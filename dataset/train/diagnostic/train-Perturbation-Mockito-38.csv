[REPLACE]  private  final  Stubber  mockitoStubber; 	[BUGGY] private Stubber mockitoStubber ; [NO-ERROR]  [CONTEXT]    [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  	None^158^^^^^^^
[REPLACE]  this  .  mockitoOngoingStubbing  =  ongoingStubbing; 	[BUGGY] this . mockitoOngoingStubbing =  null ; [FE] NullPointerException assertEquals(  "foo  " , mock.simpleMethod(  "foo  "))   [METHOD]  <init> [TYPE] OngoingStubbing) [PARAMETER] OngoingStubbing<T> ongoingStubbing [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDOngoingStubbingImpl ( OngoingStubbing<T> ongoingStubbing ) { [ATTENTION] this . mockitoOngoingStubbing = null ; }  	None^83^^^^^82^84^
[REPLACE]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] this . mockitoStubber =  null ; [FE] NullPointerException assertEquals(null , mock.simpleMethod(  "boooo  "))   [METHOD]  <init> [TYPE] Stubber) [PARAMETER] Stubber mockitoStubber [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubberImpl ( Stubber mockitoStubber ) { [ATTENTION] this . mockitoStubber = null ; }  	None^161^^^^^160^162^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenAnswer  (  answer  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( answer ) ) ; [CE] no suitable method found for thenReturn(Answer<CAP#1>)  [METHOD]  willAnswer [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] Answer answer [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDMyOngoingStubbing<T> willAnswer ( Answer<?> answer ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( answer ) )  ; }  	None^90^^^^^89^91^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenReturn  (  value  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenThrow ( value ) ) ; [CE] method thenThrow in interface OngoingStubbing<T#2> cannot be applied to given types ;  [METHOD]  willReturn [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] T value [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] T value [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDMyOngoingStubbing<T> willReturn ( T value ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenThrow ( value ) )  ; }  	None^97^^^^^96^98^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenReturn  (  value,  values  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  ) ; [CE] ' ; ' expected  [METHOD]  willReturn [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] T value values [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] T value [TYPE] Stubber mockitoStubber [TYPE] T[] values  [CONTEXT]  public BDDMyOngoingStubbing<T> willReturn ( T value , T . . . values ) { [ATTENTION] returnnew BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  )  ; }  	None^104^^^^^103^105^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenThrow  (  throwables  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( value , values ) ) ; [CE] cannot find symbol value  [METHOD]  willThrow [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] throwables [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Throwable[] throwables [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDMyOngoingStubbing<T> willThrow ( Throwable . . . throwables ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( value , values ) )  ; }  	None^111^^^^^110^112^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenCallRealMethod  (  )  )  ; 	[BUGGY] return new BDDStubberImpl ( doCallRealMethod ( ) )  ) ; [CE] ' ; ' expected  [METHOD]  willCallRealMethod [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDMyOngoingStubbing<T> willCallRealMethod ( ) { [ATTENTION] returnnew BDDStubberImpl ( doCallRealMethod ( ) ) )  ; }  	None^115^^^^^114^116^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  Mockito  .  when  (  methodCall  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( Mockito . doReturn ( methodCall ) ) ; [CE] constructor BDDOngoingStubbingImpl in class BDDOngoingStubbingImpl<T#2> cannot be applied to given types ;  [METHOD]  given [TYPE] <T> [PARAMETER] T methodCall [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] T methodCall [TYPE] Stubber mockitoStubber  [CONTEXT]  public static <T> BDDMyOngoingStubbing<T> given ( T methodCall ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( Mockito . doReturn ( methodCall ) )  ; }  	None^123^^^^^122^124^
[REPLACE]  return  mockitoStubber  .  when  (  mock  )  ; 	[BUGGY] return mockitoStubber . doReturn ( mock ) ; [CE] incompatible types  [METHOD]  given [TYPE] <T> [PARAMETER] T mock [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] T mock [TYPE] Stubber mockitoStubber  [CONTEXT]  public <T> T given ( T mock ) { [ATTENTION] return mockitoStubber . doReturn ( mock )  ; }  	None^168^^^^^167^169^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doAnswer  (  answer  )  )  ; 	[BUGGY] return new BDDStubberImpl ( doThrow ( toBeThrown ) )  ) ; [CE] ' ; ' expected  [METHOD]  willAnswer [TYPE] BDDMockito$BDDStubber [PARAMETER] Answer answer [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] Answer answer [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDStubber willAnswer ( Answer answer ) { [ATTENTION] returnnew BDDStubberImpl ( doThrow ( toBeThrown ) )  )  ; }  	None^175^^^^^174^176^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doNothing  (  )  )  ; 	[BUGGY] return new BDDStubberImpl ( doThrow ( toBeThrown ) )  ) ; [CE] ' ; ' expected  [METHOD]  willNothing [TYPE] BDDMockito$BDDStubber [PARAMETER] [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubber willNothing ( ) { [ATTENTION] returnnew BDDStubberImpl ( doThrow ( toBeThrown ) )  )  ; }  	None^182^^^^^181^183^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doReturn  (  toBeReturned  )  )  ; 	[BUGGY] return new BDDStubberImpl ( doThrow ( toBeThrown ) )  ) ; [CE] ' ; ' expected  [METHOD]  willReturn [TYPE] BDDMockito$BDDStubber [PARAMETER] Object toBeReturned [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Object toBeReturned [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDStubber willReturn ( Object toBeReturned ) { [ATTENTION] returnnew BDDStubberImpl ( doThrow ( toBeThrown ) )  )  ; }  	None^189^^^^^188^190^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doThrow  (  toBeThrown  )  )  ; 	[BUGGY] return new BDDStubberImpl ( mockitoStubber . doReturn ( toBeThrown ) ) ; [FE] AssertionFailedError [METHOD]  willThrow [TYPE] BDDMockito$BDDStubber [PARAMETER] Throwable toBeThrown [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] Throwable toBeThrown [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public BDDStubber willThrow ( Throwable toBeThrown ) { [ATTENTION] return new BDDStubberImpl ( mockitoStubber . doReturn ( toBeThrown ) )  ; }  	None^196^^^^^195^197^
[REPLACE]  return  new  BDDStubberImpl  (  Mockito  .  doThrow  (  toBeThrown  )  )  ; 	[BUGGY] return new BDDStubberImpl ( Mockito . doNothing ( )  ) ; [FE] AssertionFailedError [METHOD]  willThrow [TYPE] BDDMockito$BDDStubber [PARAMETER] Throwable toBeThrown [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] Throwable toBeThrown [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public static BDDStubber willThrow ( Throwable toBeThrown ) { [ATTENTION] return new BDDStubberImpl ( Mockito . doNothing ( )  )  ; }  	None^204^^^^^203^205^
[REPLACE]  return  new  BDDStubberImpl  (  Mockito  .  doAnswer  (  answer  )  )  ; 	[BUGGY] return new BDDStubberImpl ( Mockito . doReturn ( answer ) ) ; [FE]   assertEquals(  "foo  " , mock.simpleMethod(  "foo  "))   [METHOD]  willAnswer [TYPE] BDDMockito$BDDStubber [PARAMETER] Answer answer [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] Answer answer [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public static BDDStubber willAnswer ( Answer answer ) { [ATTENTION] return new BDDStubberImpl ( Mockito . doReturn ( answer ) )  ; }  	None^211^^^^^210^212^
[REPLACE]  return  new  BDDStubberImpl  (  Mockito  .  doNothing  (  )  )  ; 	[BUGGY] return new BDDStubberImpl ( doThrow ( toBeThrown ) )  ) ; [CE] ' ; ' expected  [METHOD]  willDoNothing [TYPE] BDDMockito$BDDStubber [PARAMETER] [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public static BDDStubber willDoNothing ( ) { [ATTENTION] returnnew BDDStubberImpl ( doThrow ( toBeThrown ) ) )  ; }  	None^218^^^^^217^219^
[REPLACE]  return  new  BDDStubberImpl  (  Mockito  .  doReturn  (  toBeReturned  )  )  ; 	[BUGGY] return new BDDStubberImpl ( Mockito . doNothing ( )  ) ; [FE]   assertEquals(null , mock.simpleMethod(  "boooo  "))   [METHOD]  willReturn [TYPE] BDDMockito$BDDStubber [PARAMETER] Object toBeReturned [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Object toBeReturned [TYPE] boolean false true [TYPE] Stubber mockitoStubber  [CONTEXT]  public static BDDStubber willReturn ( Object toBeReturned ) { [ATTENTION] return new BDDStubberImpl ( Mockito . doNothing ( )  )  ; }  	None^225^^^^^224^226^
[REPLACE]  return  new  BDDStubberImpl  (  Mockito  .  doCallRealMethod  (  )  )  ; 	[BUGGY] return new BDDStubberImpl ( Mockito . doReturn ( null )  ) ; [FE]  AssertionFailedError  expected:<woof> but was:<null> assertEquals(  "woof  " , dog.bark())   [METHOD]  willCallRealMethod [TYPE] BDDMockito$BDDStubber [PARAMETER] [CLASS] BDDMockito BDDOngoingStubbingImpl BDDStubberImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public static BDDStubber willCallRealMethod ( ) { [ATTENTION] return new BDDStubberImpl ( Mockito . doReturn ( null )  )  ; }  	None^232^^^^^231^233^
[REPLACE]  this  .  mockitoOngoingStubbing  =  ongoingStubbing; 	[BUGGY] this . mockitoOngoingStubbing =  false ; [CE] incompatible types  [METHOD]  <init> [TYPE] OngoingStubbing) [PARAMETER] OngoingStubbing<T> ongoingStubbing [CLASS] BDDOngoingStubbingImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true  [CONTEXT]  public BDDOngoingStubbingImpl ( OngoingStubbing<T> ongoingStubbing ) { [ATTENTION] this . mockitoOngoingStubbing = false ; }  	None^83^^^^^82^84^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenAnswer  (  answer  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( answer ) ) ; [CE] no suitable method found for thenReturn(Answer<CAP#1>)  [METHOD]  willAnswer [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] BDDOngoingStubbingImpl  [TYPE] Answer answer [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true  [CONTEXT]  public BDDMyOngoingStubbing<T> willAnswer ( Answer<?> answer ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( answer ) )  ; }  	None^90^^^^^89^91^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenReturn  (  value  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenThrow ( value ) ) ; [CE] method thenThrow in interface OngoingStubbing<T#2> cannot be applied to given types ;  [METHOD]  willReturn [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] T value [CLASS] BDDOngoingStubbingImpl  [TYPE] T value [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true  [CONTEXT]  public BDDMyOngoingStubbing<T> willReturn ( T value ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenThrow ( value ) )  ; }  	None^97^^^^^96^98^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenReturn  (  value,  values  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  ) ; [CE] ' ; ' expected  [METHOD]  willReturn [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] T value values [CLASS] BDDOngoingStubbingImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true [TYPE] T value [TYPE] T[] values  [CONTEXT]  public BDDMyOngoingStubbing<T> willReturn ( T value , T . . . values ) { [ATTENTION] returnnew BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  )  ; }  	None^104^^^^^103^105^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenThrow  (  throwables  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  ) ; [CE] ' ; ' expected  [METHOD]  willThrow [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] throwables [CLASS] BDDOngoingStubbingImpl  [TYPE] Throwable[] throwables [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true  [CONTEXT]  public BDDMyOngoingStubbing<T> willThrow ( Throwable . . . throwables ) { [ATTENTION] returnnew BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenAnswer ( answer ) )  )  ; }  	None^111^^^^^110^112^
[REPLACE]  return  new  BDDOngoingStubbingImpl<T>  (  mockitoOngoingStubbing  .  thenCallRealMethod  (  )  )  ; 	[BUGGY] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( this )  ) ; [CE] no suitable method found for thenReturn(BDDOngoingStubbingImpl<T>)  [METHOD]  willCallRealMethod [TYPE] BDDMockito$BDDMyOngoingStubbing [PARAMETER] [CLASS] BDDOngoingStubbingImpl  [TYPE] OngoingStubbing mockitoOngoingStubbing ongoingStubbing [TYPE] boolean false true  [CONTEXT]  public BDDMyOngoingStubbing<T> willCallRealMethod ( ) { [ATTENTION] return new BDDOngoingStubbingImpl<T> ( mockitoOngoingStubbing . thenReturn ( this )  )  ; }  	None^115^^^^^114^116^
[REPLACE]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] this . mockitoStubber =  null ; [FE] NullPointerException assertEquals(null , mock.simpleMethod(  "boooo  "))   [METHOD]  <init> [TYPE] Stubber) [PARAMETER] Stubber mockitoStubber [CLASS] BDDStubberImpl  [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubberImpl ( Stubber mockitoStubber ) { [ATTENTION] this . mockitoStubber = null ; }  	None^161^^^^^160^162^
[REPLACE]  return  mockitoStubber  .  when  (  mock  )  ; 	[BUGGY] return mockitoStubber . doReturn ( null )  ; [CE] incompatible types  [METHOD]  given [TYPE] <T> [PARAMETER] T mock [CLASS] BDDStubberImpl  [TYPE] T mock [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public <T> T given ( T mock ) { [ATTENTION] return mockitoStubber . doReturn ( null ) ; }  	None^168^^^^^167^169^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doAnswer  (  answer  )  )  ; 	[BUGGY] return new BDDStubberImpl ( mockitoStubber . doReturn ( answer ) ) ; [NO-ERROR]  [METHOD]  willAnswer [TYPE] BDDMockito$BDDStubber [PARAMETER] Answer answer [CLASS] BDDStubberImpl  [TYPE] Answer answer [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubber willAnswer ( Answer answer ) { [ATTENTION] return new BDDStubberImpl ( mockitoStubber . doReturn ( answer ) )  ; }  	None^175^^^^^174^176^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doNothing  (  )  )  ; 	[BUGGY] return new BDDStubberImpl ( mockitoStubber . doThrow ( toBeThrown ) )  ) ; [CE] ' ; ' expected  [METHOD]  willNothing [TYPE] BDDMockito$BDDStubber [PARAMETER] [CLASS] BDDStubberImpl  [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubber willNothing ( ) { [ATTENTION] returnnew BDDStubberImpl ( mockitoStubber . doThrow ( toBeThrown ) )  )  ; }  	None^182^^^^^181^183^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doReturn  (  toBeReturned  )  )  ; 	[BUGGY] return new BDDStubberImpl ( mockitoStubber . doThrow ( toBeReturned ) ) ; [CE] method doThrow in interface Stubber cannot be applied to given types ;  [METHOD]  willReturn [TYPE] BDDMockito$BDDStubber [PARAMETER] Object toBeReturned [CLASS] BDDStubberImpl  [TYPE] Object toBeReturned [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubber willReturn ( Object toBeReturned ) { [ATTENTION] return new BDDStubberImpl ( mockitoStubber . doThrow ( toBeReturned ) )  ; }  	None^189^^^^^188^190^
[REPLACE]  return  new  BDDStubberImpl  (  mockitoStubber  .  doThrow  (  toBeThrown  )  )  ; 	[BUGGY] return new BDDStubberImpl ( mockitoStubber . doReturn ( toBeReturned ) ) ; [CE] cannot find symbol toBeReturned  [METHOD]  willThrow [TYPE] BDDMockito$BDDStubber [PARAMETER] Throwable toBeThrown [CLASS] BDDStubberImpl  [TYPE] Throwable toBeThrown [TYPE] Stubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public BDDStubber willThrow ( Throwable toBeThrown ) { [ATTENTION] return new BDDStubberImpl ( mockitoStubber . doReturn ( toBeReturned ) )  ; }  	None^196^^^^^195^197^
[REPLACE]  private  final  RegisteredInvocations  registeredInvocations; 	[BUGGY] private RegisteredInvocations registeredInvocations ; [NO-ERROR]  [CONTEXT]    [CLASS] MockHandler  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^37^^^^^^^
[REPLACE]  private  final  MockitoStubber  mockitoStubber; 	[BUGGY] private MockitoStubber mockitoStubber ; [NO-ERROR]  [CONTEXT]    [CLASS] MockHandler  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^38^^^^^^^
[REPLACE]  private  final  MatchersBinder  matchersBinder; 	[BUGGY] private MatchersBinder matchersBinder ; [NO-ERROR]  [CONTEXT]    [CLASS] MockHandler  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^39^^^^^^^
[REPLACE]  private  final  MockSettingsImpl  mockSettings; 	[BUGGY] private MockSettingsImpl mockSettings ; [NO-ERROR]  [CONTEXT]    [CLASS] MockHandler  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^42^^^^^^^
[REPLACE]  this  .  mockName  =  mockName; 	[BUGGY] this . mockName =  null ; [FE]  AssertionFailedError  expected:<[iMethods].simpleMethod()   [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { [ATTENTION] this . mockName = null ; this . mockingProgress = mockingProgress ; this . matchersBinder = matchersBinder ; this . mockSettings = mockSettings ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^45^^^^^44^51^
[REPLACE]  this  .  mockingProgress  =  mockingProgress; 	[BUGGY] this . mockingProgress =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; [ATTENTION] this . mockingProgress = null ; this . matchersBinder = matchersBinder ; this . mockSettings = mockSettings ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^46^^^^^44^51^
[ADD]  this  .  mockingProgress  =  mockingProgress;  this  .  matchersBinder  =  matchersBinder; 	[BUGGY] [CE] variable matchersBinder might not have been initialized  [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; [ATTENTION]  this . mockSettings = mockSettings ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^46^47^^^^44^51^
[REPLACE]  this  .  matchersBinder  =  matchersBinder; 	[BUGGY] this . matchersBinder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; this . mockingProgress = mockingProgress ; [ATTENTION] this . matchersBinder = null ; this . mockSettings = mockSettings ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^47^^^^^44^51^
[REPLACE]  this  .  mockSettings  =  mockSettings; 	[BUGGY] this . mockSettings =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; this . mockingProgress = mockingProgress ; this . matchersBinder = matchersBinder ; [ATTENTION] this . mockSettings = null ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^48^^^^^44^51^
[REPLACE]  this  .  mockitoStubber  =  new  MockitoStubber  (  mockingProgress  )  ; 	[BUGGY] this . mockitoStubber =  new MockitoStubber ( null ) ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; this . mockingProgress = mockingProgress ; this . matchersBinder = matchersBinder ; this . mockSettings = mockSettings ; [ATTENTION] this . mockitoStubber = new MockitoStubber ( null )  ; this . registeredInvocations = new RegisteredInvocations ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^49^^^^^44^51^
[REPLACE]  this  .  registeredInvocations  =  new  RegisteredInvocations  (  )  ; 	[BUGGY] this . registeredInvocations  =  this . registeredInvocations ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockSettingsImpl) [PARAMETER] MockName mockName MockingProgress mockingProgress MatchersBinder matchersBinder MockSettingsImpl mockSettings [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockName mockName , MockingProgress mockingProgress , MatchersBinder matchersBinder , MockSettingsImpl mockSettings ) { this . mockName = mockName ; this . mockingProgress = mockingProgress ; this . matchersBinder = matchersBinder ; this . mockSettings = mockSettings ; this . mockitoStubber = new MockitoStubber ( mockingProgress ) ; [ATTENTION] this . registeredInvocations = this . registeredInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^50^^^^^44^51^
[REPLACE]  this  (  oldMockHandler  .  mockName,  oldMockHandler  .  mockingProgress,  oldMockHandler  .  matchersBinder,  oldMockHandler  .  mockSettings  )  ; 	[BUGGY] this ( 0 . mockName , oldMockHandler . mockingProgress , oldMockHandler . matchersBinder , oldMockHandler . mockSettings ) ; [CE] ')' expected  [METHOD]  <init> [TYPE] MockHandler) [PARAMETER] MockHandler<T> oldMockHandler [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockHandler oldMockHandler [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockHandler ( MockHandler<T> oldMockHandler ) { [ATTENTION] this ( 0 . mockName , oldMockHandler . mockingProgress , oldMockHandler . matchersBinder , oldMockHandler . mockSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^54^^^^^53^55^
[REPLACE]  if  (  mockitoStubber  .  hasAnswersForStubbing  (  )  )  { 	[BUGGY] if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {[CE] cannot find symbol invocation  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { [ATTENTION] if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^58^^^^^57^101^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; [ATTENTION] return true ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^63^^^^^57^101^
[REPLACE]  Invocation  invocation  =  new  Invocation  (  proxy,  method,  args,  SequenceNumber  .  next  (  )  ,  new  FilteredCGLIBProxyRealMethod  (  methodProxy  )  )  ; 	[BUGGY] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [CE] cannot find symbol invocation  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  [ATTENTION] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation )  ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^60^^^^^57^101^
[REPLACE]  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ; 	[BUGGY] InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . validateState ( )  , invocation ) ; [CE] 'void' type not allowed here  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; [ATTENTION] InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . validateState ( ) , invocation )  ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^61^^^^^57^101^
[REPLACE]  Invocation  invocation  =  new  Invocation  (  proxy,  method,  args,  SequenceNumber  .  next  (  )  ,  new  FilteredCGLIBProxyRealMethod  (  methodProxy  )  )  ; 	[BUGGY] Invocation invocation = new Invocation ( ret , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; [CE] cannot find symbol ret  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  [ATTENTION] Invocation invocation = new Invocation ( ret , method , args , SequenceNumber . next ( )  , new FilteredCGLIBProxyRealMethod ( methodProxy ) )  ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^60^^^^^57^101^
[ADD]  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  mockitoStubber  .  setMethodForStubbing  (  invocationMatcher  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; [ATTENTION]  return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^61^62^^^^57^101^
[REPLACE]  VerificationMode  verificationMode  =  mockingProgress  .  pullVerificationMode  (  )  ; 	[BUGGY] VerificationMode verificationMode = mockingProgress . validateState ( )  ; [CE] incompatible types  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } [ATTENTION] VerificationMode verificationMode = mockingProgress . validateState ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^65^^^^^57^101^
[REPLACE]  Invocation  invocation  =  new  Invocation  (  proxy,  method,  args,  SequenceNumber  .  next  (  )  ,  new  FilteredCGLIBProxyRealMethod  (  methodProxy  )  )  ; 	[BUGGY] Invocation invocation = new Invocation ( ret , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; [CE] cannot find symbol ret  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  [ATTENTION] Invocation invocation = new Invocation ( ret , method , args , SequenceNumber . next ( )  , new FilteredCGLIBProxyRealMethod ( methodProxy ) )  ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^67^^^^^57^101^
[REPLACE]  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ; 	[BUGGY] InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . validateState ( )  , invocation ) ; [CE] 'void' type not allowed here  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; [ATTENTION] InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . validateState ( ) , invocation )  ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^68^^^^^57^101^
[REPLACE]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] mockingProgress . pullVerificationMode ( ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  [ATTENTION] mockingProgress . pullVerificationMode ( )  ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^70^^^^^57^101^
[ADD]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  [ATTENTION]  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^70^^^^^57^101^
[REPLACE]  if  (  verificationMode  !=  null  )  { 	[BUGGY] if ( verificationMode = = this ) {[FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  [ATTENTION] if ( verificationMode = = this ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^72^^^^^57^101^
[REPLACE]  return  null; 	[BUGGY] return this ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; [ATTENTION] return this ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^75^^^^^57^101^
[REPLACE]  VerificationDataImpl  data  =  new  VerificationDataImpl  (  registeredInvocations  .  getAll  (  )  ,  invocationMatcher  )  ; 	[BUGGY] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . add ( ) , invocationMatcher ) ; [CE] method add in class RegisteredInvocations cannot be applied to given types ;  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { [ATTENTION] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . add ( )  , invocationMatcher )  ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^73^^^^^57^101^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; [ATTENTION] return false ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^75^^^^^57^101^
[REPLACE]  registeredInvocations  .  add  (  invocationMatcher  .  getInvocation  (  )  )  ; 	[BUGGY] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } [ATTENTION] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( )  , invocationMatcher )  ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^78^^^^^57^101^
[ADD]  registeredInvocations  .  add  (  invocationMatcher  .  getInvocation  (  )  )  ;  mockitoStubber  .  setInvocationForPotentialStubbing  (  invocationMatcher  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } [ATTENTION]  OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^78^79^^^^57^101^
[REPLACE]  mockitoStubber  .  setInvocationForPotentialStubbing  (  invocationMatcher  )  ; 	[BUGGY] mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; [NO-ERROR]  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; [ATTENTION] mockitoStubber . setMethodForStubbing ( invocationMatcher )  ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^79^^^^^57^101^
[REPLACE]  OngoingStubbingImpl<T>  ongoingStubbing  =  new  OngoingStubbingImpl<T>  (  mockitoStubber,  registeredInvocations  )  ; 	[BUGGY] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [CE] cannot find symbol ongoingStubbing  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; [ATTENTION] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation )  ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^80^^^^^57^101^
[REPLACE]  mockingProgress  .  reportOngoingStubbing  (  ongoingStubbing  )  ; 	[BUGGY] mockingProgress . reportOngoingStubbing ( null ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; [ATTENTION] mockingProgress . reportOngoingStubbing ( null )  ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^81^^^^^57^101^
[REPLACE]  Answer<?>  stubbedAnswer  =  mockitoStubber  .  findAnswerFor  (  invocation  )  ; 	[BUGGY] Answer<?> stubbedAnswer = mockitoStubber . setMethodForStubbing ( invocation ) ; [CE] method setMethodForStubbing in class MockitoStubber cannot be applied to given types ;  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  [ATTENTION] Answer<?> stubbedAnswer = mockitoStubber . setMethodForStubbing ( invocation )  ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^83^^^^^57^101^
[REPLACE]  if  (  !invocation  .  isVoid  (  )  &&  stubbedAnswer  ==  null  )  { 	[BUGGY] if ( !invocation . isVoid ( ) ) {[FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [ATTENTION] if ( !invocation . isVoid ( ) ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^84^^^^^57^101^
[ADD]  if  (  !invocation  .  isVoid  (  )  &&  stubbedAnswer  ==  null  )  {  mockingProgress  .  getDebuggingInfo  (  )    .  addPotentiallyUnstubbed  (  invocationMatcher  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [ATTENTION]   if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^84^85^86^87^^57^101^
[REPLACE]  mockingProgress  .  getDebuggingInfo  (  )    .  addPotentiallyUnstubbed  (  invocationMatcher  )  ; 	[BUGGY] mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  [ATTENTION] mockingProgress . getDebuggingInfo ( )  . reportUsedStub ( invocationMatcher )  ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^86^^^^^57^101^
[REPLACE]  mockingProgress  .  getDebuggingInfo  (  )    .  addPotentiallyUnstubbed  (  invocationMatcher  )  ; 	[BUGGY] mockingProgress . reportOngoingStubbing ( this )  . addPotentiallyUnstubbed ( invocationMatcher ) ; [CE] method reportOngoingStubbing in interface MockingProgress cannot be applied to given types ;  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  [ATTENTION] mockingProgress . reportOngoingStubbing ( this ) . addPotentiallyUnstubbed ( invocationMatcher )  ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^86^^^^^57^101^
[REPLACE]  if  (  stubbedAnswer  !=  null  )  { 	[BUGGY] if ( stubbedAnswer = = true ) {[CE] incomparable types: Answer<CAP#1> and boolean  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } [ATTENTION] if ( stubbedAnswer = = true ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^89^^^^^57^101^
[REPLACE]  return  ret; 	[BUGGY] return proxy ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; [ATTENTION] return proxy ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^99^^^^^89^100^
[REPLACE]  Object  ret  =  mockSettings  .  getDefaultAnswer  (  )    .  answer  (  invocation  )  ; 	[BUGGY] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [CE] variable stubbedAnswer is already defined in method intercept(Object , Method , Object[] , MethodProxy)  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { [ATTENTION] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation )  ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^93^^^^^89^100^
[REPLACE]  return  stubbedAnswer  .  answer  (  invocation  )  ; 	[BUGGY] return null . answer ( invocation ) ; [CE] <null> cannot be dereferenced  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; [ATTENTION] return null . answer ( invocation )  ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^91^^^^^57^101^
[REPLACE]  return  stubbedAnswer  .  answer  (  invocation  )  ; 	[BUGGY] return new VoidMethodStubbableImpl<T> ( mock , mockitoStubber ) ; [CE] cannot find symbol mock  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; [ATTENTION] return new VoidMethodStubbableImpl<T> ( mock , mockitoStubber )  ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^91^^^^^57^101^
[REPLACE]  return  ret; 	[BUGGY] return proxy ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { Object ret = mockSettings . getDefaultAnswer ( ) . answer ( invocation ) ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; [ATTENTION] return proxy ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^99^^^^^57^101^
[REPLACE]  Object  ret  =  mockSettings  .  getDefaultAnswer  (  )    .  answer  (  invocation  )  ; 	[BUGGY] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; [CE] variable stubbedAnswer is already defined in method intercept(Object , Method , Object[] , MethodProxy)  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] Invocation invocation [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] InvocationMatcher invocationMatcher [TYPE] Method method [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber [TYPE] VerificationMode verificationMode [TYPE] Answer stubbedAnswer [TYPE] MockName mockName [TYPE] boolean false true [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] MethodProxy methodProxy [TYPE] Object proxy ret [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( mockitoStubber . hasAnswersForStubbing ( ) ) {  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ; mockitoStubber . setMethodForStubbing ( invocationMatcher ) ; return null ; } VerificationMode verificationMode = mockingProgress . pullVerificationMode ( ) ;  Invocation invocation = new Invocation ( proxy , method , args , SequenceNumber . next ( ) , new FilteredCGLIBProxyRealMethod ( methodProxy ) ) ; InvocationMatcher invocationMatcher = matchersBinder . bindMatchers ( mockingProgress . getArgumentMatcherStorage ( ) , invocation ) ;  mockingProgress . validateState ( ) ;  if ( verificationMode ! = null ) { VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } registeredInvocations . add ( invocationMatcher . getInvocation ( ) ) ; mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T> ( mockitoStubber , registeredInvocations ) ; mockingProgress . reportOngoingStubbing ( ongoingStubbing ) ;  Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation ) ; if ( !invocation . isVoid ( ) && stubbedAnswer = = null ) {  mockingProgress . getDebuggingInfo ( ) . addPotentiallyUnstubbed ( invocationMatcher ) ; } if ( stubbedAnswer ! = null ) { mockingProgress . getDebuggingInfo ( ) . reportUsedStub ( invocationMatcher ) ; return stubbedAnswer . answer ( invocation ) ; } else { [ATTENTION] Answer<?> stubbedAnswer = mockitoStubber . findAnswerFor ( invocation )  ;     mockitoStubber . setInvocationForPotentialStubbing ( invocationMatcher ) ; return ret ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^93^^^^^57^101^
[REPLACE]  VerificationDataImpl  data  =  new  VerificationDataImpl  (  registeredInvocations  .  getAll  (  )  ,  null  )  ; 	[BUGGY] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( ) , this ) ; [CE] constructor VerificationDataImpl in class VerificationDataImpl cannot be applied to given types ;  [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] [CLASS] MockHandler  [TYPE] VerificationDataImpl data [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public void verifyNoMoreInteractions ( ) { [ATTENTION] VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll ( )  , this )  ; VerificationModeFactory . noMoreInteractions ( ) . verify ( data ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^104^^^^^103^106^
[REPLACE]  return  new  VoidMethodStubbableImpl<T>  (  mock,  mockitoStubber  )  ; 	[BUGGY] return stubbedAnswer . answer ( invocation ) ; [CE] cannot find symbol invocation  [METHOD]  voidMethodStubbable [TYPE] VoidMethodStubbable [PARAMETER] T mock [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] T mock [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public VoidMethodStubbable<T> voidMethodStubbable ( T mock ) { [ATTENTION] return stubbedAnswer . answer ( invocation )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^109^^^^^108^110^
[REPLACE]  return  registeredInvocations  .  getAll  (  )  ; 	[BUGGY] return registeredInvocations . add ( ) ; [CE] method add in class RegisteredInvocations cannot be applied to given types ;  [METHOD]  getRegisteredInvocations [TYPE] List [PARAMETER] [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public List<Invocation> getRegisteredInvocations ( ) { [ATTENTION] return registeredInvocations . add ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^113^^^^^112^114^
[REPLACE]  return  mockName; 	[BUGGY] return null ; [FE]  AssertionFailedError  expected:<[iMethods].simpleMethod()   [METHOD]  getMockName [TYPE] MockName [PARAMETER] [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public MockName getMockName ( ) { [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^117^^^^^116^118^
[REPLACE]  mockitoStubber  .  setAnswersForStubbing  (  answers  )  ; 	[BUGGY] mockitoStubber . setAnswersForStubbing ( this ) ; [CE] method setAnswersForStubbing in class MockitoStubber cannot be applied to given types ;  [METHOD]  setAnswersForStubbing [TYPE] void [PARAMETER] Answer> answers [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] List answers [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public void setAnswersForStubbing ( List<Answer> answers ) { [ATTENTION] mockitoStubber . setAnswersForStubbing ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^122^^^^^121^123^
[ADD]  mockitoStubber  .  setAnswersForStubbing  (  answers  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  setAnswersForStubbing [TYPE] void [PARAMETER] Answer> answers [CLASS] MockHandler  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockName mockName [TYPE] boolean false true [TYPE] MatchersBinder matchersBinder [TYPE] MockSettingsImpl mockSettings [TYPE] List answers [TYPE] MockingProgress mockingProgress [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public void setAnswersForStubbing ( List<Answer> answers ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockHandler.java^122^^^^^121^123^
[ADD]  PrintSettings  printSettings  =  new  PrintSettings  (  )  ;  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ; 	[BUGGY] [CE] cannot find symbol printSettings  [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { [ATTENTION]  printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^20^21^^^^19^26^
[REPLACE]  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ; 	[BUGGY] printSettings . setMultiline ( wanted . toString ( ) . contains (   "\n  " )  ; [CE]  [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; [ATTENTION] printSettings . setMultiline ( wanted . toString ( )  . contains (   "\n  " ) ; printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^21^^^^^19^26^
[REPLACE]  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ; 	[BUGGY] printSettings . setMultiline ( actual . toString ( ) . contains (   "\n  " ) || actual . toString ( ) . contains (   "\n  " ) ) ; [FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; [ATTENTION] printSettings . setMultiline ( actual . toString ( )  . contains (   "\n  " ) || actual . toString ( )  . contains (   "\n  " ) )  ; printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^21^^^^^19^26^
[ADD]  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ;  printSettings  .  setMatchersToBeDescribedWithExtraTypeInfo  (  indexesOfMatchersToBeDescribedWithExtraTypeInfo  )  ; 	[BUGGY] printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ; [FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; [ATTENTION] printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo )  ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^21^22^^^^19^26^
[REPLACE]  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ; 	[BUGGY] printSettings . setMultiline ( wanted . toString ( ) . contains (   "\n  " ) || wanted . toString ( ) . contains (   "\n  " ) ) ; [FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; [ATTENTION] printSettings . setMultiline ( wanted . toString ( )  . contains (   "\n  " ) || wanted . toString ( )  . contains (   "\n  " ) )  ; printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^21^^^^^19^26^
[ADD]  printSettings  .  setMultiline  (  wanted  .  toString  (  )    .  contains  (    "\n  "  )  ||  actual  .  toString  (  )    .  contains  (    "\n  "  )  )  ;  printSettings  .  setMatchersToBeDescribedWithExtraTypeInfo  (  indexesOfMatchersToBeDescribedWithExtraTypeInfo  )  ; 	[BUGGY] [FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; [ATTENTION]  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^21^22^^^^19^26^
[REPLACE]  printSettings  .  setMatchersToBeDescribedWithExtraTypeInfo  (  indexesOfMatchersToBeDescribedWithExtraTypeInfo  )  ; 	[BUGGY] printSettings . PrintSettings ( )  ; [CE] cannot find symbol  [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; printSettings . setMultiline ( wanted . toString ( ) . contains (   "\n  " ) || actual . toString ( ) . contains (   "\n  " ) ) ; [ATTENTION] printSettings . PrintSettings ( ) ;  this . wanted = wanted . toString ( printSettings ) ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^22^^^^^19^26^
[REPLACE]  this  .  wanted  =  wanted  .  toString  (  printSettings  )  ; 	[BUGGY] this . actual = actual . toString ( printSettings ) ;  ; [CE] variable actual might already have been assigned  [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; printSettings . setMultiline ( wanted . toString ( ) . contains (   "\n  " ) || actual . toString ( ) . contains (   "\n  " ) ) ; printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  [ATTENTION] this . actual = actual . toString ( printSettings )  ;  ; this . actual = actual . toString ( printSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^24^^^^^19^26^
[REPLACE]  this  .  actual  =  actual  .  toString  (  printSettings  )  ; 	[BUGGY] this . wanted = wanted . toString ( printSettings ) ;  ; [CE] variable wanted might already have been assigned  [METHOD]  <init> [TYPE] Integer[]) [PARAMETER] PrintingFriendlyInvocation wanted PrintingFriendlyInvocation actual indexesOfMatchersToBeDescribedWithExtraTypeInfo [CLASS] SmartPrinter  [TYPE] PrintSettings printSettings [TYPE] String actual wanted [TYPE] PrintingFriendlyInvocation actual wanted [TYPE] boolean false true [TYPE] Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo  [CONTEXT]  public SmartPrinter ( PrintingFriendlyInvocation wanted , PrintingFriendlyInvocation actual , Integer . . . indexesOfMatchersToBeDescribedWithExtraTypeInfo ) { PrintSettings printSettings = new PrintSettings ( ) ; printSettings . setMultiline ( wanted . toString ( ) . contains (   "\n  " ) || actual . toString ( ) . contains (   "\n  " ) ) ; printSettings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchersToBeDescribedWithExtraTypeInfo ) ;  this . wanted = wanted . toString ( printSettings ) ; [ATTENTION] this . wanted = wanted . toString ( printSettings )  ;  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^25^^^^^19^26^
[REPLACE]  return  wanted; 	[BUGGY] return actual ; [FE]   assertContains(  "<custom argument matcher>  " , e.getMessage())   [METHOD]  getWanted [TYPE] String [PARAMETER] [CLASS] SmartPrinter  [TYPE] String actual wanted [TYPE] boolean false true  [CONTEXT]  public String getWanted ( ) { [ATTENTION] return actual ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^29^^^^^28^30^
[REPLACE]  return  actual; 	[BUGGY] return wanted ; [FE]   assertContains(  "<custom argument matcher>  " , e.getMessage())   [METHOD]  getActual [TYPE] String [PARAMETER] [CLASS] SmartPrinter  [TYPE] String actual wanted [TYPE] boolean false true  [CONTEXT]  public String getActual ( ) { [ATTENTION] return wanted ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/SmartPrinter.java^33^^^^^32^34^
[REPLACE]  private  List<Integer>  withTypeInfo  =  new  LinkedList<Integer>  (  )  ; 	[BUGGY] private List<Integer> withTypeInfo  = null ; [FE] NullPointerException assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [CONTEXT]    [CLASS] PrintSettings  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^15^^^^^^^
[REPLACE]  this  .  multiline  =  multiline; 	[BUGGY] this . multiline =  true ; [FE]   assertNotContains(  "\n  " , printer.getWanted().toString())   [METHOD]  setMultiline [TYPE] void [PARAMETER] boolean multiline [CLASS] PrintSettings  [TYPE] List withTypeInfo [TYPE] boolean false multiline true  [CONTEXT]  public void setMultiline ( boolean multiline ) { [ATTENTION] this . multiline = true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^18^^^^^17^19^
[REPLACE]  return  multiline; 	[BUGGY] return settings ; [CE] cannot find symbol settings  [METHOD]  isMultiline [TYPE] boolean [PARAMETER] [CLASS] PrintSettings  [TYPE] List withTypeInfo [TYPE] boolean false multiline true  [CONTEXT]  public boolean isMultiline ( ) { [ATTENTION] return settings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^22^^^^^21^23^
[ADD]  PrintSettings  settings  =  new  PrintSettings  (  )  ; 	[BUGGY] [CE] cannot find symbol settings  [METHOD]  verboseMatchers [TYPE] PrintSettings [PARAMETER] indexesOfMatchers [CLASS] PrintSettings  [TYPE] PrintSettings settings [TYPE] List withTypeInfo [TYPE] boolean false multiline true [TYPE] Integer[] indexesOfMatchers  [CONTEXT]  public static PrintSettings verboseMatchers ( Integer . . . indexesOfMatchers ) { [ATTENTION] settings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchers ) ; return settings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^26^^^^^25^29^
[REPLACE]  settings  .  setMatchersToBeDescribedWithExtraTypeInfo  (  indexesOfMatchers  )  ; 	[BUGGY] settings . verboseMatchers ( indexesOfMatchers ) ; [FE] NullPointerException assertEquals(  "(1 , (Integer) 2)   [METHOD]  verboseMatchers [TYPE] PrintSettings [PARAMETER] indexesOfMatchers [CLASS] PrintSettings  [TYPE] PrintSettings settings [TYPE] List withTypeInfo [TYPE] boolean false multiline true [TYPE] Integer[] indexesOfMatchers  [CONTEXT]  public static PrintSettings verboseMatchers ( Integer . . . indexesOfMatchers ) { PrintSettings settings = new PrintSettings ( ) ; [ATTENTION] settings . verboseMatchers ( indexesOfMatchers )  ; return settings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^27^^^^^25^29^
[REMOVE]   	[BUGGY] this . withTypeInfo = Arrays . asList ( indexesOfMatchers ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  verboseMatchers [TYPE] PrintSettings [PARAMETER] indexesOfMatchers [CLASS] PrintSettings  [TYPE] PrintSettings settings [TYPE] List withTypeInfo [TYPE] boolean false multiline true [TYPE] Integer[] indexesOfMatchers  [CONTEXT]  public static PrintSettings verboseMatchers ( Integer . . . indexesOfMatchers ) { PrintSettings settings = new PrintSettings ( ) ; [ATTENTION] settings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchers ) ;  this . withTypeInfo = Arrays . asList ( indexesOfMatchers )  ; return settings ;   	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^27^^^^^25^29^
[REPLACE]  return  settings; 	[BUGGY] return multiline ; [CE] non-static variable multiline cannot be referenced from a static context  [METHOD]  verboseMatchers [TYPE] PrintSettings [PARAMETER] indexesOfMatchers [CLASS] PrintSettings  [TYPE] PrintSettings settings [TYPE] List withTypeInfo [TYPE] boolean false multiline true [TYPE] Integer[] indexesOfMatchers  [CONTEXT]  public static PrintSettings verboseMatchers ( Integer . . . indexesOfMatchers ) { PrintSettings settings = new PrintSettings ( ) ; settings . setMatchersToBeDescribedWithExtraTypeInfo ( indexesOfMatchers ) ; [ATTENTION] return multiline ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^28^^^^^25^29^
[REPLACE]  this  .  withTypeInfo  =  Arrays  .  asList  (  indexesOfMatchers  )  ; 	[BUGGY] this . withTypeInfo =  Arrays . asList ( null ) ; [FE] NullPointerException assertEquals(  "(1 , (Integer) 2)   [METHOD]  setMatchersToBeDescribedWithExtraTypeInfo [TYPE] void [PARAMETER] Integer[] indexesOfMatchers [CLASS] PrintSettings  [TYPE] Integer[] indexesOfMatchers [TYPE] List withTypeInfo [TYPE] boolean false multiline true  [CONTEXT]  public void setMatchersToBeDescribedWithExtraTypeInfo ( Integer[] indexesOfMatchers ) { [ATTENTION] this . withTypeInfo = Arrays . asList ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/reporting/PrintSettings.java^36^^^^^35^37^
[REPLACE]  this  .  prefix  =  prefix; 	[BUGGY] this . prefix =  null ; [FE]  AssertionFailedError  expected:<startsWith(  "[AB]  ")> but was:<startsWith(  "[null]  ")> assertEquals(  "startsWith(\  "AB\  ")  " , describe(new StartsWith(  "AB  ")))   [METHOD]  <init> [TYPE] String) [PARAMETER] String prefix [CLASS] StartsWith  [TYPE] String prefix [TYPE] boolean false true  [CONTEXT]  public StartsWith ( String prefix ) { [ATTENTION] this . prefix = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/StartsWith.java^16^^^^^15^17^
[REPLACE]  return  actual  !=  null  &&  (  (  String  )  actual  )    .  startsWith  (  prefix  )  ; 	[BUGGY] return  ( ( String ) actual ) . startsWith ( prefix ) ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] StartsWith  [TYPE] Object actual [TYPE] String prefix [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return ( ( String ) actual )  . startsWith ( prefix )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/StartsWith.java^20^^^^^19^21^
[REPLACE]  Description  result  =  new  StringDescription  (  )  ; 	[BUGGY] List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; [CE] cannot find symbol result  [METHOD]  getArgumentsLine [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsLine ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( )  ; result . appendList (   " (   " ,   " ,   " ,   " ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^20^^^^^19^23^
[REPLACE]  result  .  appendList  (    "  (    ",    ",    ",    "  )  ;  ",  applyPrintSettings  (  matchers,  printSettings  )  )  ; 	[BUGGY] result . appendList (   " ( \n    " ,   " , \n    " ,   "\n ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; [FE]   assertContains(  "was not stubbed  " , logger.getLoggedInfo())   [METHOD]  getArgumentsLine [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsLine ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] result . appendList (   " ( \n  " ,   " , \n  " ,   "\n )  ;   " , applyPrintSettings ( matchers , printSettings ) )  ; return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^21^^^^^19^23^
[REMOVE]   	[BUGGY] withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; [CE] cannot find symbol matcher  [METHOD]  getArgumentsLine [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsLine ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] result . appendList (   " (   " ,   " ,   " ,   " ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ;  withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher )  . withExtraTypeInfo ( ) )  ; return result . toString ( ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^21^^^^^19^23^
[REPLACE]  return  result  .  toString  (  )  ; 	[BUGGY] return withPrintSettings ; [CE] cannot find symbol withPrintSettings  [METHOD]  getArgumentsLine [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsLine ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; result . appendList (   " (   " ,   " ,   " ,   " ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; [ATTENTION] return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^22^^^^^19^23^
[REPLACE]  Description  result  =  new  StringDescription  (  )  ; 	[BUGGY] List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; [CE] cannot find symbol result  [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( )  ; result . appendList (   " ( \n  " ,   " , \n  " ,   "\n ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^26^^^^^25^29^
[ADD]  Description  result  =  new  StringDescription  (  )  ;  result  .  appendList  (    "  (  \n      ",    ",\n      ",    "\n  )  ;  ",  applyPrintSettings  (  matchers,  printSettings  )  )  ; 	[BUGGY] result . appendList (   " ( \n    " ,   " , \n    " ,   "\n ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; [CE] cannot find symbol result  [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] result . appendList (   " ( \n  " ,   " , \n  " ,   "\n )  ;   " , applyPrintSettings ( matchers , printSettings ) )  ;  return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^26^27^^^^25^29^
[REPLACE]  result  .  appendList  (    "  (  \n      ",    ",\n      ",    "\n  )  ;  ",  applyPrintSettings  (  matchers,  printSettings  )  )  ; 	[BUGGY] result . appendList (   " (   " ,   " ,   " ,   " ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; [FE] AssertionFailedError [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] result . appendList (   " (   " ,   " ,   " ,   " )  ;   " , applyPrintSettings ( matchers , printSettings ) )  ; return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^27^^^^^25^29^
[REMOVE]   	[BUGGY] withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; [CE] cannot find symbol matcher  [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] result . appendList (   " ( \n  " ,   " , \n  " ,   "\n ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ;  withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher )  . withExtraTypeInfo ( ) )  ; return result . toString ( ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^27^^^^^25^29^
[REPLACE]  result  .  appendList  (    "  (  \n      ",    ",\n      ",    "\n  )  ;  ",  applyPrintSettings  (  matchers,  printSettings  )  )  ; 	[BUGGY] result . appendList (   " ( \n    " ,   " , \n    " ,   "\n ) ;   " , applyPrintSettings ( false , printSettings ) ) ; [CE] method applyPrintSettings in class MatchersPrinter cannot be applied to given types ;  [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] result . appendList (   " ( \n  " ,   " , \n  " ,   "\n )  ;   " , applyPrintSettings ( false , printSettings ) )  ; return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^27^^^^^25^29^
[ADD]  result  .  appendList  (    "  (  \n      ",    ",\n      ",    "\n  )  ;  ",  applyPrintSettings  (  matchers,  printSettings  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; [ATTENTION] return result . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^27^^^^^25^29^
[REPLACE]  return  result  .  toString  (  )  ; 	[BUGGY] return result . appendList ( this , 1 , true )  ; [CE] method appendList in interface Description cannot be applied to given types ;  [METHOD]  getArgumentsBlock [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] Description result [TYPE] boolean false true [TYPE] PrintSettings printSettings [TYPE] List matchers  [CONTEXT]  public String getArgumentsBlock ( List<Matcher> matchers , PrintSettings printSettings ) { Description result = new StringDescription ( ) ; result . appendList (   " ( \n  " ,   " , \n  " ,   "\n ) ;   " , applyPrintSettings ( matchers , printSettings ) ) ; [ATTENTION] return result . appendList ( this , 1 , true ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^28^^^^^25^29^
[REPLACE]  List<SelfDescribing>  withPrintSettings  =  new  LinkedList<SelfDescribing>  (  )  ; 	[BUGGY] Description result = new StringDescription ( ) ; [CE] cannot find symbol withPrintSettings  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] Description result = new StringDescription ( )  ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^32^^^^^31^43^
[ADD]  List<SelfDescribing>  withPrintSettings  =  new  LinkedList<SelfDescribing>  (  )  ; 	[BUGGY] [CE] cannot find symbol withPrintSettings  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^32^^^^^31^43^
[REPLACE]  int  i  =  0; 	[BUGGY] int i = 0 * 1 ; [NO-ERROR]  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; [ATTENTION] int i = 0 * 1 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^33^^^^^31^43^
[REPLACE]  if  (  matcher  instanceof  ContainsExtraTypeInformation  &&  printSettings  .  extraTypeInfoFor  (  i  )  )  { 	[BUGGY] if ( ! matcher instanceof ContainsExtraTypeInformation ) {[CE] bad operand type Matcher for unary operator '!'  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { [ATTENTION] if ( ! matcher instanceof ContainsExtraTypeInformation ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^35^^^^^31^43^
[REPLACE]  withPrintSettings  .  add  (  matcher  )  ; 	[BUGGY] withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { [ATTENTION] withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher )  . withExtraTypeInfo ( ) )  ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^38^^^^^31^43^
[REPLACE]  withPrintSettings  .  add  (  (  (  ContainsExtraTypeInformation  )  matcher  )    .  withExtraTypeInfo  (  )  )  ; 	[BUGGY] withPrintSettings . add ( )  . withExtraTypeInfo ( ) ) ; [CE] ' ; ' expected  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { [ATTENTION] withPrintSettings . add ( ) . withExtraTypeInfo ( ) )  ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^36^^^^^31^43^
[ADD]  withPrintSettings  .  add  (  (  (  ContainsExtraTypeInformation  )  matcher  )    .  withExtraTypeInfo  (  )  )  ;  }  else  {  withPrintSettings  .  add  (  matcher  )  ;  } 	[BUGGY] [CE] reached end of file while parsing  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { [ATTENTION]   i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^36^37^38^39^^31^43^
[REPLACE]  withPrintSettings  .  add  (  (  (  ContainsExtraTypeInformation  )  matcher  )    .  withExtraTypeInfo  (  )  )  ; 	[BUGGY] if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; [CE] reached end of file while parsing  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { [ATTENTION] if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher )  . withExtraTypeInfo ( ) )  ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^36^^^^^31^43^
[REPLACE]  for  (  final  Matcher  matcher  :  matchers  )  { 	[BUGGY] for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) {[CE] reached end of file while parsing  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; [ATTENTION] for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } return withPrintSettings ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^34^^^^^31^43^
[REPLACE]  return  withPrintSettings; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  applyPrintSettings [TYPE] List [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] MatchersPrinter  [TYPE] boolean false true [TYPE] Matcher matcher [TYPE] PrintSettings printSettings [TYPE] List matchers withPrintSettings [TYPE] int i  [CONTEXT]  private List<SelfDescribing> applyPrintSettings ( List<Matcher> matchers , PrintSettings printSettings ) { List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing> ( ) ; int i = 0 ; for ( final Matcher matcher : matchers ) { if ( matcher instanceof ContainsExtraTypeInformation && printSettings . extraTypeInfoFor ( i ) ) { withPrintSettings . add ( ( ( ContainsExtraTypeInformation ) matcher ) . withExtraTypeInfo ( ) ) ; } else { withPrintSettings . add ( matcher ) ; } i++ ; } [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/MatchersPrinter.java^42^^^^^31^43^
[REPLACE]  this  .  actualMatcher  =  actualMatcher; 	[BUGGY] this . actualMatcher =  null ; [FE] NullPointerException assertEquals(  "(Integer) 10  " , describe(m.withExtraTypeInfo()))   [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher actualMatcher [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public LocalizedMatcher ( Matcher actualMatcher ) { [ATTENTION] this . actualMatcher = null ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^19^^^^^18^21^
[ADD]  this  .  actualMatcher  =  actualMatcher; 	[BUGGY] [CE] variable actualMatcher might not have been initialized  [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher actualMatcher [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public LocalizedMatcher ( Matcher actualMatcher ) { [ATTENTION] this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^19^^^^^18^21^
[REPLACE]  this  .  location  =  new  Location  (  )  ; 	[BUGGY] this . location  = null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher actualMatcher [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public LocalizedMatcher ( Matcher actualMatcher ) { this . actualMatcher = actualMatcher ; [ATTENTION] this . location = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^20^^^^^18^21^
[ADD]  this  .  location  =  new  Location  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher actualMatcher [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public LocalizedMatcher ( Matcher actualMatcher ) { this . actualMatcher = actualMatcher ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^20^^^^^18^21^
[REPLACE]  return  actualMatcher  .  matches  (  item  )  ; 	[BUGGY] return actualMatcher . describeTo ( false )  ; [CE] method describeTo in interface SelfDescribing cannot be applied to given types ;  [METHOD]  matches [TYPE] boolean [PARAMETER] Object item [CLASS] LocalizedMatcher  [TYPE] Object item [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public boolean matches ( Object item ) { [ATTENTION] return actualMatcher . describeTo ( false ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^28^^^^^27^29^
[REPLACE]  actualMatcher  .  describeTo  (  description  )  ; 	[BUGGY] actualMatcher . matches ( description ) ; [FE]   assertContains(  "<Capturing argument>  " , e.getMessage())   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] LocalizedMatcher  [TYPE] Description description [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] actualMatcher . matches ( description )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^32^^^^^31^33^
[REMOVE]   	[BUGGY] return actualMatcher . matches ( item ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] LocalizedMatcher  [TYPE] Description description [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] actualMatcher . describeTo ( description ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^32^^^^^31^33^
[REPLACE]  return  location; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  getLocation [TYPE] Location [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public Location getLocation ( ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^36^^^^^35^37^
[REPLACE]  return    "Localized:    "  +  this  .  actualMatcher; 	[BUGGY] return null + actualMatcher ; [CE] bad operand types for binary operator '+'  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return null + actualMatcher ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^41^^^^^40^42^
[REPLACE]  if  (  actualMatcher  instanceof  ContainsExtraTypeInformation  )  { 	[BUGGY] if ( ! actualMatcher instanceof ContainsExtraTypeInformation ) {[CE] bad operand type Matcher for unary operator '!'  [METHOD]  withExtraTypeInfo [TYPE] SelfDescribing [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public SelfDescribing withExtraTypeInfo ( ) { [ATTENTION] if ( ! actualMatcher instanceof ContainsExtraTypeInformation ) { return ( ( ContainsExtraTypeInformation ) actualMatcher ) . withExtraTypeInfo ( ) ; } else { return this ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^45^^^^^44^50^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE]  expected same:<Localized: <any>> was not:<null> assertSame(m , m.withExtraTypeInfo())   [METHOD]  withExtraTypeInfo [TYPE] SelfDescribing [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public SelfDescribing withExtraTypeInfo ( ) { if ( actualMatcher instanceof ContainsExtraTypeInformation ) { return ( ( ContainsExtraTypeInformation ) actualMatcher ) . withExtraTypeInfo ( ) ; } else { [ATTENTION] return null ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^48^^^^^44^50^
[REPLACE]  return  (  (  ContainsExtraTypeInformation  )  actualMatcher  )    .  withExtraTypeInfo  (  )  ; 	[BUGGY] return ( ( ContainsExtraTypeInformation ) actualMatcher ) . typeMatches ( object ) ; [CE] cannot find symbol object  [METHOD]  withExtraTypeInfo [TYPE] SelfDescribing [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public SelfDescribing withExtraTypeInfo ( ) { if ( actualMatcher instanceof ContainsExtraTypeInformation ) { [ATTENTION] return ( ( ContainsExtraTypeInformation ) actualMatcher )  . typeMatches ( object )  ; } else { return this ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^46^^^^^44^50^
[REPLACE]  return  (  (  ContainsExtraTypeInformation  )  actualMatcher  )    .  withExtraTypeInfo  (  )  ; 	[BUGGY] return ( ( ContainsExtraTypeInformation ) actualMatcher )  . typeMatches ( this )  ; [CE] incompatible types  [METHOD]  withExtraTypeInfo [TYPE] SelfDescribing [PARAMETER] [CLASS] LocalizedMatcher  [TYPE] Matcher actualMatcher [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public SelfDescribing withExtraTypeInfo ( ) { if ( actualMatcher instanceof ContainsExtraTypeInformation ) { [ATTENTION] return ( ( ContainsExtraTypeInformation ) actualMatcher ) . typeMatches ( this ) ; } else { return this ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^46^^^^^44^50^
[REPLACE]  if  (  actualMatcher  instanceof  ContainsExtraTypeInformation  )  { 	[BUGGY] if ( ! actualMatcher instanceof ContainsExtraTypeInformation ) {[CE] bad operand type Matcher for unary operator '!'  [METHOD]  typeMatches [TYPE] boolean [PARAMETER] Object object [CLASS] LocalizedMatcher  [TYPE] Object object [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public boolean typeMatches ( Object object ) { [ATTENTION] if ( ! actualMatcher instanceof ContainsExtraTypeInformation ) { return ( ( ContainsExtraTypeInformation ) actualMatcher ) . typeMatches ( object ) ; } else { return false ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^53^^^^^52^58^
[ADD]  if  (  actualMatcher  instanceof  ContainsExtraTypeInformation  )  {  return  (  (  ContainsExtraTypeInformation  )  actualMatcher  )    .  typeMatches  (  object  )  ;  }  else  {  return  false;  } 	[BUGGY] [CE] missing return statement  [METHOD]  typeMatches [TYPE] boolean [PARAMETER] Object object [CLASS] LocalizedMatcher  [TYPE] Object object [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public boolean typeMatches ( Object object ) { [ATTENTION]   }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^53^54^55^56^57^52^58^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertFalse(m.typeMatches(10))   [METHOD]  typeMatches [TYPE] boolean [PARAMETER] Object object [CLASS] LocalizedMatcher  [TYPE] Object object [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public boolean typeMatches ( Object object ) { if ( actualMatcher instanceof ContainsExtraTypeInformation ) { return ( ( ContainsExtraTypeInformation ) actualMatcher ) . typeMatches ( object ) ; } else { [ATTENTION] return true ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^56^^^^^52^58^
[REPLACE]  return  (  (  ContainsExtraTypeInformation  )  actualMatcher  )    .  typeMatches  (  object  )  ; 	[BUGGY] return ( ( ContainsExtraTypeInformation ) actualMatcher ) . withExtraTypeInfo ( object ) ; [CE] method withExtraTypeInfo in interface ContainsExtraTypeInformation cannot be applied to given types ;  [METHOD]  typeMatches [TYPE] boolean [PARAMETER] Object object [CLASS] LocalizedMatcher  [TYPE] Object object [TYPE] boolean false true [TYPE] Matcher actualMatcher [TYPE] Location location  [CONTEXT]  public boolean typeMatches ( Object object ) { if ( actualMatcher instanceof ContainsExtraTypeInformation ) { [ATTENTION] return ( ( ContainsExtraTypeInformation ) actualMatcher )  . withExtraTypeInfo ( object )  ; } else { return false ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LocalizedMatcher.java^54^^^^^52^58^
[REPLACE]  public  static  final  Any  ANY  =  new  Any  (  )  ; 	[BUGGY] public static final Any ANY ; [CE] variable ANY might not have been initialized  [CONTEXT]    [CLASS] Any  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Any.java^13^^^^^^^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Any  [TYPE] Any ANY [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Any.java^18^^^^^17^19^
[REPLACE]  super  (  value  )  ; 	[BUGGY] super ( false ) ; [CE] constructor CompareTo in class CompareTo<T#2> cannot be applied to given types ;  [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] GreaterThan  [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public GreaterThan ( Comparable<T> value ) { [ATTENTION] super ( false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterThan.java^10^^^^^9^11^
[REPLACE]  return    "gt  "; 	[BUGGY] return result > 0 ; [CE] cannot find symbol result  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] GreaterThan  [TYPE] boolean false true  [CONTEXT]  protected String getName ( ) { [ATTENTION] return result > 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterThan.java^15^^^^^14^16^
[REPLACE]  return  result  >  0; 	[BUGGY] return result  ; [CE] incompatible types  [METHOD]  matchResult [TYPE] boolean [PARAMETER] int result [CLASS] GreaterThan  [TYPE] boolean false true [TYPE] int result  [CONTEXT]  protected boolean matchResult ( int result ) { [ATTENTION] return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterThan.java^20^^^^^19^21^
[REPLACE]  public  static  final  Null  NULL  =  new  Null  (  )  ; 	[BUGGY] public static final Null NULL  = null ; [FE] NullPointerException assertEquals(  "isNull()  " , describe(Null.NULL))   [CONTEXT]    [CLASS] Null  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Null.java^13^^^^^^^
[REPLACE]  return  actual  ==  null; 	[BUGGY] return actual ! = null ; ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Null  [TYPE] Null NULL [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return actual ! = null ; ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Null.java^19^^^^^18^20^
[ADD]  description  .  appendText  (    "isNull  (  )    "  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[isNull()]> but was:<[]> assertEquals(  "isNull()  " , describe(Null.NULL))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Null  [TYPE] Null NULL [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Null.java^23^^^^^22^24^
[REPLACE]  this  .  clazz  =  clazz; 	[BUGGY] this . clazz =  this ; [CE] incompatible types  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> clazz [CLASS] InstanceOf  [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public InstanceOf ( Class<?> clazz ) { [ATTENTION] this . clazz = this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/InstanceOf.java^16^^^^^15^17^
[REPLACE]  return  (  actual  !=  null  )  &&  clazz  .  isAssignableFrom  (  actual  .  getClass  (  )  )  ; 	[BUGGY] return  clazz . isAssignableFrom ( actual . getClass ( ) ) ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] InstanceOf  [TYPE] Class clazz [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return clazz . isAssignableFrom ( actual . getClass ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/InstanceOf.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "isA  (    "  +  clazz  .  getName  (  )  +    "  )    "  )  ; 	[BUGGY] description . appendText (   "isA (   " | clazz . getName ( )  |   " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] InstanceOf  [TYPE] Class clazz [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "isA (   "|clazz . getName ( ) |  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/InstanceOf.java^24^^^^^23^25^
[ADD]  description  .  appendText  (    "isA  (    "  +  clazz  .  getName  (  )  +    "  )    "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] InstanceOf  [TYPE] Class clazz [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/InstanceOf.java^24^^^^^23^25^
[REPLACE]  description  .  appendText  (    "isA  (    "  +  clazz  .  getName  (  )  +    "  )    "  )  ; 	[BUGGY] description . appendText (   "isA (   " + clazz . isAssignableFrom ( this )  +   " )   " ) ; [CE] method isAssignableFrom in class Class<T> cannot be applied to given types ;  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] InstanceOf  [TYPE] Class clazz [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "isA (   " + clazz . isAssignableFrom ( this ) +   " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/InstanceOf.java^24^^^^^23^25^
[REPLACE]  private  final  String  suffix; 	[BUGGY] private final double suffix ; [CE] incompatible types  [CONTEXT]    [CLASS] EndsWith  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EndsWith.java^13^^^^^^^
[REPLACE]  this  .  suffix  =  suffix; 	[BUGGY] this . suffix =  null ; [FE]  AssertionFailedError  expected:<endsWith(  "[AB]  ")> but was:<endsWith(  "[null]  ")> assertEquals(  "endsWith(\  "AB\  ")  " , describe(new EndsWith(  "AB  ")))   [METHOD]  <init> [TYPE] String) [PARAMETER] String suffix [CLASS] EndsWith  [TYPE] String suffix [TYPE] boolean false true  [CONTEXT]  public EndsWith ( String suffix ) { [ATTENTION] this . suffix = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EndsWith.java^16^^^^^15^17^
[REPLACE]  return  actual  !=  null  &&  (  (  String  )  actual  )    .  endsWith  (  suffix  )  ; 	[BUGGY] return  ( ( String ) actual ) . endsWith ( suffix ) ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] EndsWith  [TYPE] Object actual [TYPE] String suffix [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return ( ( String ) actual )  . endsWith ( suffix )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EndsWith.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "endsWith  (  \  "  "  +  suffix  +    "\  "  )    "  )  ; 	[BUGGY] description . appendText (   "endsWith ( \  "  "  = =  suffix  = =    "\  " )   " ) ; [CE] incomparable types: boolean and String  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] EndsWith  [TYPE] String suffix [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "endsWith ( \  "  " = = suffix = =   "\  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EndsWith.java^24^^^^^23^25^
[REPLACE]  private  final  String  regex; 	[BUGGY] private String regex ; [NO-ERROR]  [CONTEXT]    [CLASS] Find  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Find.java^14^^^^^^^
[REPLACE]  this  .  regex  =  regex; 	[BUGGY] this . regex =  null ; [FE] NullPointerException assertEquals(  "find(\  "\\\\s+\  ")  " , describe(new Find(  "\\s+  ")))   [METHOD]  <init> [TYPE] String) [PARAMETER] String regex [CLASS] Find  [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public Find ( String regex ) { [ATTENTION] this . regex = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Find.java^17^^^^^16^18^
[REPLACE]  return  actual  !=  null  &&  Pattern  .  compile  (  regex  )    .  matcher  (  (  String  )  actual  )    .  find  (  )  ; 	[BUGGY] return actual ! = this && Pattern . compile ( regex ) . compile ( ( String ) actual ) . find ( ) ; [CE] cannot find symbol  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Find  [TYPE] Object actual [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return actual ! = this && Pattern . compile ( regex )  . compile ( ( String ) actual )  . find ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Find.java^21^^^^^20^22^
[REPLACE]  description  .  appendText  (    "find  (  \  "  "  +  regex  .  replaceAll  (    "\\\\  ",    "\\\\\\\\  "  )  +    "\  "  )    "  )  ; 	[BUGGY] description . appendText (   "find ( \  "  " & regex . replaceAll (   "\\\\  " ,   "\\\\\\\\  " )  &   "\  " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Find  [TYPE] String regex [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "find ( \  "  "&regex . replaceAll (   "\\\\  " ,   "\\\\\\\\  " ) &  "\  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Find.java^25^^^^^24^26^
[REPLACE]  description  .  appendText  (    "find  (  \  "  "  +  regex  .  replaceAll  (    "\\\\  ",    "\\\\\\\\  "  )  +    "\  "  )    "  )  ; 	[BUGGY] return actual ! = null && Pattern . compile ( regex ) . matcher ( ( String ) actual ) . find ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Find  [TYPE] String regex [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] return actual ! = null && Pattern . compile ( regex )  . matcher ( ( String ) actual )  . find ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Find.java^25^^^^^24^26^
[REPLACE]  private  final  String  substring; 	[BUGGY] private String substring ; [NO-ERROR]  [CONTEXT]    [CLASS] Contains  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Contains.java^13^^^^^^^
[REPLACE]  this  .  substring  =  substring; 	[BUGGY] this . substring =  null ; [FE]  AssertionFailedError  expected:<contains(  "[AB]  ")> but was:<contains(  "[null]  ")> assertEquals(  "contains(\  "AB\  ")  " , describe(new Contains(  "AB  ")))   [METHOD]  <init> [TYPE] String) [PARAMETER] String substring [CLASS] Contains  [TYPE] String substring [TYPE] boolean false true  [CONTEXT]  public Contains ( String substring ) { [ATTENTION] this . substring = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Contains.java^16^^^^^15^17^
[REPLACE]  return  actual  !=  null  &&  (  (  String  )  actual  )    .  contains  (  substring  )  ; 	[BUGGY] return actual ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Contains  [TYPE] Object actual [TYPE] String substring [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return actual ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Contains.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "contains  (  \  "  "  +  substring  +    "\  "  )    "  )  ; 	[BUGGY] description . appendText (   "contains ( \  "  " < =  substring < =    "\  " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Contains  [TYPE] String substring [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "contains ( \  "  "< = substring< =   "\  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Contains.java^24^^^^^23^25^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Object) [PARAMETER] Object wanted [CLASS] Equals 1  [TYPE] Object wanted [TYPE] boolean false true  [CONTEXT]  public Equals ( Object wanted ) { [ATTENTION] this . wanted = null ; }  	None^16^^^^^15^17^
[REPLACE]  if  (  this  .  wanted  ==  null  )  { 	[BUGGY] if ( this . wanted ! = null ) {[FE] AssertionFailedError [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] if ( this . wanted ! = null ) { return actual = = null ; } return wanted . equals ( actual ) ; }  	None^20^^^^^19^24^
[ADD]  if  (  this  .  wanted  ==  null  )  {  return  actual  ==  null;  } 	[BUGGY] return actual = = null ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return actual = = null ;  return wanted . equals ( actual ) ; }  	None^20^21^22^^^19^24^
[REPLACE]  return  actual  ==  null; 	[BUGGY] return actual ! = null ; ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { if ( this . wanted = = null ) { [ATTENTION] return actual ! = null ; ; } return wanted . equals ( actual ) ; }  	None^21^^^^^19^24^
[REPLACE]  return  actual  ==  null; 	[BUGGY] return wanted ! = true ; ; [CE] incomparable types: Object and boolean  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { if ( this . wanted = = null ) { [ATTENTION] return wanted ! = true ; ; } return wanted . equals ( actual ) ; }  	None^21^^^^^19^24^
[REPLACE]  return  wanted  .  equals  (  actual  )  ; 	[BUGGY] return wanted . equals ( wanted ) ; [FE] NullPointerException assertTrue(invocation.hasSimilarMethod(overloadedInvocation))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { if ( this . wanted = = null ) { return actual = = null ; } [ATTENTION] return wanted . equals ( wanted )  ; }  	None^23^^^^^19^24^
[REPLACE]  description  .  appendText  (  describe  (  wanted  )  )  ; 	[BUGGY] String text = quoting ( ) ; [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] String text = quoting ( )  ; }  	None^27^^^^^26^28^
[ADD]  description  .  appendText  (  describe  (  wanted  )  )  ; 	[BUGGY] [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] }  	None^27^^^^^26^28^
[REPLACE]  String  text  =  quoting  (  )  ; 	[BUGGY] Equals other =  ( Equals ) o ; [CE] cannot find symbol o  [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { [ATTENTION] Equals other = ( Equals ) o ; if ( object = = null ) { text+ =   "null  " ; } else { text+ = object . toString ( ) ; } text+ = quoting ( ) ; return text ; }  	None^31^^^^^30^39^
[REPLACE]  if  (  object  ==  null  )  { 	[BUGGY] if ( object ! = this ) {[FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; [ATTENTION] if ( object ! = this ) { text+ =   "null  " ; } else { text+ = object . toString ( ) ; } text+ = quoting ( ) ; return text ; }  	None^32^^^^^30^39^
[ADD]  if  (  object  ==  null  )  {  text+=  "null  ";  }  else  {  text+=object  .  toString  (  )  ;  } 	[BUGGY] [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; [ATTENTION]   text+ = quoting ( ) ; return text ; }  	None^32^33^34^35^36^30^39^
[REPLACE]  text+=object  .  toString  (  )  ; 	[BUGGY] text+ = null . toString ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; if ( object = = null ) { text+ =   "null  " ; } else { [ATTENTION] text+ = null . toString ( )  ; } text+ = quoting ( ) ; return text ; }  	None^35^^^^^30^39^
[REPLACE]  text+=  "null  "; 	[BUGGY] text+ =   "this  " ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray(null)   [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; if ( object = = null ) { [ATTENTION] text+ =   "this  " ; } else { text+ = object . toString ( ) ; } text+ = quoting ( ) ; return text ; }  	None^33^^^^^30^39^
[ADD]  text+=object  .  toString  (  )  ; 	[BUGGY] [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; if ( object = = null ) { text+ =   "null  " ; } else { [ATTENTION] } text+ = quoting ( ) ; return text ; }  	None^35^^^^^30^39^
[REPLACE]  text+=  quoting  (  )  ; 	[BUGGY] text+ = null ; [CE] illegal start of expression  [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; if ( object = = null ) { text+ =   "null  " ; } else { text+ = object . toString ( ) ; } [ATTENTION] text+ = null ; return text ; }  	None^37^^^^^30^39^
[REPLACE]  return  text; 	[BUGGY] return actual = = null ; [CE] cannot find symbol actual  [METHOD]  describe [TYPE] String [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public String describe ( Object object ) { String text = quoting ( ) ; if ( object = = null ) { text+ =   "null  " ; } else { text+ = object . toString ( ) ; } text+ = quoting ( ) ; [ATTENTION] return actual = = null ; }  	None^38^^^^^30^39^
[REPLACE]  if  (  wanted  instanceof  String  )  { 	[BUGGY] if ( ! wanted instanceof String ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { [ATTENTION] if ( ! wanted instanceof String ) { return   "\  "  " ; } else if ( wanted instanceof Character ) { return   "'  " ; } else { return   "  " ; } }  	None^42^^^^^41^49^
[ADD]  if  (  wanted  instanceof  String  )  {  return    "\  "  ";  }  else  if  (  wanted  instanceof  Character  )  {  return    "'  "; 	[BUGGY] return   "\  "  " ; return   "'  " ; [CE] illegal start of type  [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { [ATTENTION] return   "\  "  " ; return   "'  " ;   } else { return   "  " ; } }  	None^42^43^44^45^^41^49^
[REPLACE]  }  else  if  (  wanted  instanceof  Character  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { return   "\  "  " ; [ATTENTION] }else { return   "'  " ; } else { return   "  " ; } }  	None^44^^^^^41^49^
[REPLACE]  return    "  "; 	[BUGGY] return   "'  " ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray(null)   [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { return   "\  "  " ; } else if ( wanted instanceof Character ) { return   "'  " ; } else { [ATTENTION] return   "'  " ; } }  	None^47^^^^^41^49^
[REPLACE]  return    "'  "; 	[BUGGY] return   "  " ; [FE]   assertContains(  "simpleMethod(notNull())  " , notNull.toString())   [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { return   "\  "  " ; } else if ( wanted instanceof Character ) { [ATTENTION] return   "  " ; } else { return   "  " ; } }  	None^45^^^^^41^49^
[REPLACE]  return    "\  "  "; 	[BUGGY] return   "  " ; [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { [ATTENTION] return   "  " ; } else if ( wanted instanceof Character ) { return   "'  " ; } else { return   "  " ; } }  	None^43^^^^^41^49^
[REPLACE]  }  else  if  (  wanted  instanceof  Character  )  { 	[BUGGY]  if ( ! wanted instanceof Character ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { return   "\  "  " ; [ATTENTION] }if ( ! wanted instanceof Character ) { return   "'  " ; } else { return   "  " ; } }  	None^44^^^^^41^49^
[ADD]  else  if  (  wanted  instanceof  Character  )  {  return    "'  ";  }  else  {  return    "  ";  } 	[BUGGY]  return   "  " ; [FE]   assertContains(  "simpleMethod(notNull())  " , notNull.toString())   [METHOD]  quoting [TYPE] String [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  private String quoting ( ) { if ( wanted instanceof String ) { return   "\  "  " ; [ATTENTION] } return   "  " ;   }  	None^44^45^46^47^48^41^49^
[REPLACE]  return  wanted; 	[BUGGY] return actual = = null ; [CE] cannot find symbol actual  [METHOD]  getWanted [TYPE] Object [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual object wanted [TYPE] boolean false true  [CONTEXT]  protected final Object getWanted ( ) { [ATTENTION] return actual = = null ; }  	None^52^^^^^51^53^
[REPLACE]  if  (  o  ==  null  ||  !this  .  getClass  (  )    .  equals  (  o  .  getClass  (  )  )  )  { 	[BUGGY] if ( o ! = null || !this . toString ( ) . equals ( o . getClass ( ) ) ) {[NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Equals other [TYPE] boolean false true  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( o ! = null || !this . toString ( )  . equals ( o . getClass ( ) ) ) { return false ; } Equals other =  ( Equals ) o ; return this . wanted = = null && other . wanted = = null || this . wanted ! = null && this . wanted . equals ( other . wanted ) ; }  	None^57^^^^^56^62^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Equals other [TYPE] boolean false true  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !this . getClass ( ) . equals ( o . getClass ( ) ) ) { [ATTENTION] return true ; } Equals other =  ( Equals ) o ; return this . wanted = = null && other . wanted = = null || this . wanted ! = null && this . wanted . equals ( other . wanted ) ; }  	None^58^^^^^56^62^
[REPLACE]  Equals  other  =  (  Equals  )  o; 	[BUGGY] String text = quoting ( ) ; [CE] cannot find symbol other  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Equals other [TYPE] boolean false true  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !this . getClass ( ) . equals ( o . getClass ( ) ) ) { return false ; } [ATTENTION] String text = quoting ( )  ; return this . wanted = = null && other . wanted = = null || this . wanted ! = null && this . wanted . equals ( other . wanted ) ; }  	None^60^^^^^56^62^
[REPLACE]  return  this  .  wanted  ==  null  &&  other  .  wanted  ==  null  ||  this  .  wanted  !=  null  &&  this  .  wanted  .  equals  (  other  .  wanted  )  ; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Equals other [TYPE] boolean false true  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !this . getClass ( ) . equals ( o . getClass ( ) ) ) { return false ; } Equals other =  ( Equals ) o ; [ATTENTION] return true ; }  	None^61^^^^^56^62^
[REPLACE]  throw  new  UnsupportedOperationException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { [ATTENTION] return ; }  	None^66^^^^^65^67^
[REPLACE]  return  new  SelfDescribing  (  )  { 	[BUGGY] return wanted . equals ( actual ) ; [CE] illegal start of expression  [METHOD]  withExtraTypeInfo [TYPE] SelfDescribing [PARAMETER] [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public SelfDescribing withExtraTypeInfo ( ) { [ATTENTION] return wanted . equals ( actual )  ; public void describeTo ( Description description ) { description . appendText ( describe (   " (   "+ wanted . getClass ( ) . getSimpleName ( ) +  " )   " + wanted ) ) ; }} ; }  	None^70^^^^^69^74^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   " & wanted . getClass ( ) . getSimpleName ( )  &   " )   " & wanted ) ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   " &wanted . getClass ( )  . getSimpleName ( ) &   " )   "&wanted ) )  ; }} ;   	None^72^^^^^71^73^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   " = =  wanted . getClass ( ) . getSimpleName ( )  = =   " )   "  = =  wanted ) ) ; [CE] incomparable types: boolean and String  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   " = = wanted . getClass ( )  . getSimpleName ( )  = =   " )   " = = wanted ) )  ; }} ;   	None^72^^^^^71^73^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   "+ wanted . equals ( o )  . getSimpleName ( ) +  " )   " + wanted ) ) ; [CE] cannot find symbol o  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   "+ wanted . equals ( o ) . getSimpleName ( ) +  " )   " + wanted ) )  ; }} ;   	None^72^^^^^71^73^
[REMOVE]   	[BUGGY] if ( o = = null || !this . getClass ( ) . equals ( o . getClass ( ) ) ) { return false ; [CE] ' ; ' expected  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   "+ wanted . getClass ( ) . getSimpleName ( ) +  " )   " + wanted ) ) ;   	None^72^^^^^71^73^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   "+ wanted . toString ( ) . getSimpleName ( ) +  " )   " + wanted ) ) ; [CE] cannot find symbol  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   "+ wanted . toString ( )  . getSimpleName ( ) +  " )   " + wanted ) )  ; }} ;   	None^72^^^^^71^73^
[ADD]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ;  }}; 	[BUGGY] [CE] reached end of file while parsing  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION]   	None^72^73^^^^71^73^
[REPLACE]  return  wanted  !=  null  &&  object  !=  null  &&  object  .  getClass  (  )  ==  wanted  .  getClass  (  )  ; 	[BUGGY] return wanted ! = null && o ! = null && object . equals ( )  = = wanted . getClass ( ) ; [CE] cannot find symbol o  [METHOD]  typeMatches [TYPE] boolean [PARAMETER] Object object [CLASS] Equals 1  [TYPE] Object actual o object wanted [TYPE] boolean false true  [CONTEXT]  public boolean typeMatches ( Object object ) { [ATTENTION] return wanted ! = null && o ! = null && object . equals ( ) = = wanted . getClass ( )  ; }  	None^77^^^^^76^78^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   "+true . getClass ( ) . getSimpleName ( ) +  " )   " +true ) ) ; [CE] boolean cannot be dereferenced  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] 1  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   "+true . getClass ( )  . getSimpleName ( ) +  " )   " +true ) )  ; }} ;   	None^72^^^^^71^73^
[ADD]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[(Long) 100]> but was:<[]> assertEquals(  "(Long) 100  " , descStr)   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] 1  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] }} ;   	None^72^^^^^71^73^
[REPLACE]  description  .  appendText  (  describe  (    "  (    "+  wanted  .  getClass  (  )    .  getSimpleName  (  )  +  "  )    "  +  wanted  )  )  ; 	[BUGGY] description . appendText ( describe (   " (   " & wanted . getClass ( ) . getSimpleName ( )  &   " )   " & wanted ) ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] 1  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( describe (   " (   " &wanted . getClass ( )  . getSimpleName ( ) &   " )   "&wanted ) )  ; }} ;   	None^72^^^^^71^73^
[REPLACE]  public  static  final  NotNull  NOT_NULL  =  new  NotNull  (  )  ; 	[BUGGY] public static NotNull NOT_NULL = new NotNull ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] NotNull  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/NotNull.java^13^^^^^^^
[REPLACE]  return  actual  !=  null; 	[BUGGY] return actual ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] NotNull  [TYPE] NotNull NOT_NULL [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return actual ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/NotNull.java^20^^^^^19^21^
[REPLACE]  super  (  value  )  ; 	[BUGGY] super ( null ) ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] LessThan  [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public LessThan ( Comparable<T> value ) { [ATTENTION] super ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessThan.java^10^^^^^9^11^
[REPLACE]  return    "lt  "; 	[BUGGY] return result < 0 ; [CE] cannot find symbol result  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] LessThan  [TYPE] boolean false true  [CONTEXT]  protected String getName ( ) { [ATTENTION] return result < 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessThan.java^15^^^^^14^16^
[REPLACE]  return  result  <  0; 	[BUGGY] return result  ; [CE] incompatible types  [METHOD]  matchResult [TYPE] boolean [PARAMETER] int result [CLASS] LessThan  [TYPE] boolean false true [TYPE] int result  [CONTEXT]  protected boolean matchResult ( int result ) { [ATTENTION] return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessThan.java^20^^^^^19^21^
[REPLACE]  private  final  Object  wanted; 	[BUGGY] private Object wanted ; [NO-ERROR]  [CONTEXT]    [CLASS] ReflectionEquals  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java^11^^^^^^^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] String[]) [PARAMETER] Object wanted excludeFields [CLASS] ReflectionEquals  [TYPE] Object wanted [TYPE] String[] excludeFields [TYPE] boolean false true  [CONTEXT]  public ReflectionEquals ( Object wanted , String . . . excludeFields ) { [ATTENTION] this . wanted = null ; this . excludeFields = excludeFields ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java^15^^^^^14^17^
[REPLACE]  this  .  excludeFields  =  excludeFields; 	[BUGGY] this . excludeFields =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] String[]) [PARAMETER] Object wanted excludeFields [CLASS] ReflectionEquals  [TYPE] Object wanted [TYPE] String[] excludeFields [TYPE] boolean false true  [CONTEXT]  public ReflectionEquals ( Object wanted , String . . . excludeFields ) { this . wanted = wanted ; [ATTENTION] this . excludeFields = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java^16^^^^^14^17^
[REPLACE]  return  EqualsBuilder  .  reflectionEquals  (  wanted,  actual,  excludeFields  )  ; 	[BUGGY] return EqualsBuilder . reflectionEquals ( wanted , wanted , excludeFields ) ; [FE] AssertionFailedError [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ReflectionEquals  [TYPE] Object actual wanted [TYPE] String[] excludeFields [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return EqualsBuilder . reflectionEquals ( wanted , wanted , excludeFields )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "refEq  (    "  +  wanted  +    "  )    "  )  ; 	[BUGGY] description . appendText (   "refEq (   " || wanted ||   " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ReflectionEquals  [TYPE] Object actual wanted [TYPE] String[] excludeFields [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "refEq (   "||wanted||  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java^24^^^^^23^25^
[REPLACE]  private  boolean  isEquals  =  true; 	[BUGGY] private boolean isEquals ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [CONTEXT]    [CLASS] EqualsBuilder  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^99^^^^^^^
[REPLACE]  return  reflectionEquals  (  lhs,  rhs,  false,  null,  null  )  ; 	[BUGGY] return reflectionEquals ( lhs , rhs , true , null , null ) ; [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] boolean false isEquals true  [CONTEXT]  public static boolean reflectionEquals ( Object lhs , Object rhs ) { [ATTENTION] return reflectionEquals ( lhs , rhs , true , null , null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^132^^^^^131^133^
[REPLACE]  return  reflectionEquals  (  lhs,  rhs,  false,  null,  excludeFields  )  ; 	[BUGGY] return reflectionEquals ( lhs , rhs , true , null , excludeFields ) ; [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] boolean false isEquals true [TYPE] String[] excludeFields  [CONTEXT]  public static boolean reflectionEquals ( Object lhs , Object rhs , String[] excludeFields ) { [ATTENTION] return reflectionEquals ( lhs , rhs , true , null , excludeFields )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^155^^^^^154^156^
[REPLACE]  return  reflectionEquals  (  lhs,  rhs,  testTransients,  null,  null  )  ; 	[BUGGY] return reflectionEquals ( lhs , rhs , testTransients , true , true ) ; [CE] no suitable method found for reflectionEquals(Object , Object , boolean , boolean , boolean)  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] boolean false isEquals testTransients true  [CONTEXT]  public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients ) { [ATTENTION] return reflectionEquals ( lhs , rhs , testTransients , true , true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^179^^^^^178^180^
[REPLACE]  return  reflectionEquals  (  lhs,  rhs,  testTransients,  reflectUpToClass,  null  )  ; 	[BUGGY] return reflectionEquals ( lhs , rhs , testTransients , reflectUpToClass , true ) ; [CE] no suitable method found for reflectionEquals(Object , Object , boolean , Class , boolean)  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class reflectUpToClass [TYPE] boolean false isEquals testTransients true  [CONTEXT]  public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients , Class reflectUpToClass ) { [ATTENTION] return reflectionEquals ( lhs , rhs , testTransients , reflectUpToClass , true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^208^^^^^207^209^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs ! =  rhs ) {[FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { [ATTENTION] if ( lhs! = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^239^^^^^238^284^
[ADD]  if  (  lhs  ==  rhs  )  {  return  true;  } 	[BUGGY] return true ; [CE] unreachable statement  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { [ATTENTION] return true ;  if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^239^240^241^^^238^284^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { [ATTENTION] return false ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^240^^^^^238^284^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( rhs = = null ) {[FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } [ATTENTION] if ( rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^242^^^^^238^284^
[ADD]  if  (  lhs  ==  null  ||  rhs  ==  null  )  {  return  false;  } 	[BUGGY] [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } [ATTENTION]      Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^242^243^244^^^238^284^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { [ATTENTION] return true ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^243^^^^^238^284^
[REPLACE]  Class  lhsClass  =  lhs  .  getClass  (  )  ; 	[BUGGY] Class rhsClass = lhs . getClass ( ) ; [CE] variable rhsClass is already defined in method reflectionEquals(Object , Object , boolean , Class , String[])  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     [ATTENTION] Class rhsClass = lhs . getClass ( )  ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^249^^^^^238^284^
[REPLACE]  Class  rhsClass  =  rhs  .  getClass  (  )  ; 	[BUGGY] Class lhsClass = rhs . getClass ( ) ; [CE] variable lhsClass is already defined in method reflectionEquals(Object , Object , boolean , Class , String[])  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; [ATTENTION] Class lhsClass = rhs . getClass ( )  ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^250^^^^^238^284^
[REPLACE]  Class  testClass; 	[BUGGY] Class lhsClass = lhs . getClass ( ) ; [CE] variable lhsClass is already defined in method reflectionEquals(Object , Object , boolean , Class , String[])  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; [ATTENTION] Class lhsClass = lhs . getClass ( )  ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^251^^^^^238^284^
[REPLACE]  if  (  lhsClass  .  isInstance  (  rhs  )  )  { 	[BUGGY] if ( lhs rhs  ) {[CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; [ATTENTION] if ( lhsrhs ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^252^^^^^238^284^
[REPLACE]  }  else  if  (  rhsClass  .  isInstance  (  lhs  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } [ATTENTION] }else { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^258^^^^^238^284^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^266^^^^^258^267^
[REPLACE]  if  (  !lhsClass  .  isInstance  (  rhs  )  )  { 	[BUGGY] if ( !lhs rhs  ) {[CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; [ATTENTION] if ( !lhsrhs ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^260^^^^^238^284^
[REPLACE]  testClass  =  lhsClass; 	[BUGGY] testClass = rhsClass ;  ; [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  [ATTENTION] testClass = rhsClass ;  ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^262^^^^^238^284^
[ADD]  testClass  =  lhsClass; 	[BUGGY] [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  [ATTENTION] } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^262^^^^^238^284^
[REPLACE]  testClass  =  rhsClass; 	[BUGGY] testClass = lhsClass ;  ; [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { [ATTENTION] testClass = lhsClass ;  ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^259^^^^^238^284^
[REPLACE]  if  (  !lhsClass  .  isInstance  (  rhs  )  )  { 	[BUGGY] if ( !lhs lhs  ) {[CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; [ATTENTION] if ( !lhslhs ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^260^^^^^238^284^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  [ATTENTION] return true ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^266^^^^^238^284^
[REPLACE]  if  (  !rhsClass  .  isInstance  (  lhs  )  )  { 	[BUGGY] if ( !rhs lhs  ) {[CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; [ATTENTION] if ( !rhslhs ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^254^^^^^238^284^
[ADD]  if  (  !rhsClass  .  isInstance  (  lhs  )  )  {  testClass  =  rhsClass;  } 	[BUGGY] [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1 , 2 , 3 , 4) , new TestTTLeafObject(1 , 2 , 3 , 4) , true))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; [ATTENTION]   } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^254^255^256^257^^238^284^
[REPLACE]  testClass  =  rhsClass; 	[BUGGY] testClass = lhsClass ;  ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1 , 2 , 3 , 4) , new TestTTLeafObject(1 , 2 , 3 , 4) , true))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  [ATTENTION] testClass = lhsClass ;  ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^256^^^^^238^284^
[REPLACE]  testClass  =  lhsClass; 	[BUGGY] testClass = rhsClass ;  ; [NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { [ATTENTION] testClass = rhsClass ;  ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^253^^^^^238^284^
[ADD]  else  if  (  rhsClass  .  isInstance  (  lhs  )  )  {  testClass  =  rhsClass;  if  (  !lhsClass  .  isInstance  (  rhs  )  )  {  testClass  =  lhsClass; 	[BUGGY]  testClass = rhsClass ; testClass = lhsClass ; [CE] class , interface , or enum expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } [ATTENTION] } testClass = rhsClass ; testClass = lhsClass ;    } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^258^259^260^^262^238^284^
[REPLACE]  if  (  !lhsClass  .  isInstance  (  rhs  )  )  { 	[BUGGY] if ( !lhsClass . isArray ( )  ) {[NO-ERROR]  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; [ATTENTION] if ( !lhsClass . isArray ( )  ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^260^^^^^238^284^
[ADD]  testClass  =  lhsClass; 	[BUGGY] [CE] variable testClass might not have been initialized  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { [ATTENTION] if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^253^^^^^238^284^
[ADD]  testClass  =  rhsClass; 	[BUGGY] [CE] variable testClass might not have been initialized  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { [ATTENTION] if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^259^^^^^238^284^
[REPLACE]  EqualsBuilder  equalsBuilder  =  new  EqualsBuilder  (  )  ; 	[BUGGY] List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; [CE] cannot find symbol equalsBuilder  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } [ATTENTION] List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^268^^^^^238^284^
[REPLACE]  while  (  testClass  .  getSuperclass  (  )  !=  null  &&  testClass  !=  reflectUpToClass  )  { 	[BUGGY] while ( testClass . getSuperclass ( ) ! = null ; [CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; [ATTENTION] while ( testClass . getSuperclass ( ) ! = null ; testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^271^^^^^238^284^
[REPLACE]  testClass  =  testClass  .  getSuperclass  (  )  ; 	[BUGGY] testClass =  rhsClass . getSuperclass ( ) ; [FE] AssertionFailedError [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { [ATTENTION] testClass = rhsClass . getSuperclass ( )  ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^272^^^^^238^284^
[ADD]  try  {  reflectionAppend  (  lhs,  rhs,  testClass,  equalsBuilder,  testTransients,  excludeFields  )  ;  while  (  testClass  .  getSuperclass  (  )  !=  null  &&  testClass  !=  reflectUpToClass  )  {  testClass  =  testClass  .  getSuperclass  (  )  ;  reflectionAppend  (  lhs,  rhs,  testClass,  equalsBuilder,  testTransients,  excludeFields  )  ; 	[BUGGY] reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; [CE] class , interface , or enum expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; [ATTENTION] reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields )  ; testClass = testClass . getSuperclass ( )  ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields )  ;   } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^269^270^271^272^273^238^284^
[REPLACE]  while  (  testClass  .  getSuperclass  (  )  !=  null  &&  testClass  !=  reflectUpToClass  )  { 	[BUGGY] while ( testClass . isArray ( ) ! = false ; [CE] ')' expected  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; [ATTENTION] while ( testClass . isArray ( ) ! = false ; testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^271^^^^^238^284^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1 , 2 , 3 , 4) , new TestTTLeafObject(1 , 2 , 3 , 4) , true))   [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      [ATTENTION] return true ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^281^^^^^238^284^
[ADD]  catch  (  IllegalArgumentException  e  )  { 	[BUGGY] [CE] 'try' without 'catch' or 'finally'  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } [ATTENTION]     return false ; } return equalsBuilder . isEquals ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^275^276^277^^^238^284^
[REPLACE]  return  equalsBuilder  .  isEquals  (  )  ; 	[BUGGY] return equalsBuilder . EqualsBuilder ( ) ; [CE] cannot find symbol  [METHOD]  reflectionEquals [TYPE] boolean [PARAMETER] Object lhs Object rhs boolean testTransients Class reflectUpToClass String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass reflectUpToClass rhsClass testClass [TYPE] EqualsBuilder equalsBuilder [TYPE] boolean false isEquals testTransients true [TYPE] String[] excludeFields [TYPE] IllegalArgumentException e  [CONTEXT]  String[] excludeFields ) { if ( lhs = = rhs ) { return true ; } if ( lhs = = null || rhs = = null ) { return false ; }     Class lhsClass = lhs . getClass ( ) ; Class rhsClass = rhs . getClass ( ) ; Class testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( !rhsClass . isInstance ( lhs ) ) {  testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( !lhsClass . isInstance ( rhs ) ) {  testClass = lhsClass ; } } else {  return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) ! = null && testClass ! = reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) {      return false ; } [ATTENTION] return equalsBuilder . EqualsBuilder ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^283^^^^^238^284^
[REPLACE]  Field[]  fields  =  clazz  .  getDeclaredFields  (  )  ; 	[BUGGY] Field[] fields = clazz . getSuperclass ( )  ; [CE] incompatible types  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { [ATTENTION] Field[] fields = clazz . getSuperclass ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^304^^^^^297^322^
[ADD]  Field[]  fields  =  clazz  .  getDeclaredFields  (  )  ;  List  excludedFieldList  =  excludeFields  !=  null  ?  Arrays  .  asList  (  excludeFields  )  :  Collections  .  EMPTY_LIST; 	[BUGGY] [CE] cannot find symbol fields  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { [ATTENTION]  AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^304^305^^^^297^322^
[REPLACE]  List  excludedFieldList  =  excludeFields  !=  null  ?  Arrays  .  asList  (  excludeFields  )  :  Collections  .  EMPTY_LIST; 	[BUGGY] List excludedFieldList  =  Collections . EMPTY_LIST ; [FE] NullPointerException assertTrue(!EqualsBuilder.reflectionEquals(x1 , x2))   [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; [ATTENTION] List excludedFieldList = Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^305^^^^^297^322^
[REPLACE]  AccessibleObject  .  setAccessible  (  fields,  true  )  ; 	[BUGGY] AccessibleObject . setAccessible ( fields , false ) ; [FE]  Unexpected IllegalAccessException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; [ATTENTION] AccessibleObject . setAccessible ( fields , false )  ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^306^^^^^297^322^
[REPLACE]  if  (  !excludedFieldList  .  contains  (  f  .  getName  (  )  )  &&  (  f  .  getName  (  )    .  indexOf  (  '$'  )  ==  -1  )  &&  (  useTransients  ||  !Modifier  .  isTransient  (  f  .  getModifiers  (  )  )  )  &&  (  !Modifier  .  isStatic  (  f  .  getModifiers  (  )  )  )  )  { 	[BUGGY] if ( excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( true ) {[CE] ')' expected  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; [ATTENTION] if ( excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( )  . indexOf ( '$' ) = = -1 ) && ( true ) {  try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^309^310^311^312^^297^322^
[ADD]  if  (  !excludedFieldList  .  contains  (  f  .  getName  (  )  )  &&  (  f  .  getName  (  )    .  indexOf  (  '$'  )  ==  -1  )  &&  (  useTransients  ||  !Modifier  .  isTransient  (  f  .  getModifiers  (  )  )  )  &&  (  !Modifier  .  isStatic  (  f  .  getModifiers  (  )  )  )  )  { 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; [ATTENTION]   try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^309^310^311^312^^297^322^
[ADD]  try  {  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ;  }  catch  (  IllegalAccessException  e  )  { 	[BUGGY] builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; [CE] class , interface , or enum expected  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { [ATTENTION] builder . append ( f . get ( lhs )  , f . get ( rhs ) )  ;    throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^313^314^315^^317^297^322^
[REPLACE]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; [CE] non-static method append(Object[] , Object[]) cannot be referenced from a static context  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] append ( ( Object[] ) lhs , ( Object[] ) rhs )  ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] non-static method append(boolean[] , boolean[]) cannot be referenced from a static context  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ;  append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REPLACE]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] builder . append ( f . get ( rhs ) , f . get ( rhs ) ) ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] builder . append ( f . get ( rhs )  , f . get ( rhs ) )  ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[ADD]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] [CE] exception IllegalAccessException is never thrown in body of corresponding try statement  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REPLACE]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] builder . append ( f . getName ( )  , f[CE] ')' expected  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] builder . append ( f . getName ( ) , f } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REPLACE]  throw  new  InternalError  (    "Unexpected  IllegalAccessException  "  )  ; 	[BUGGY] return ; [NO-ERROR]  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   [ATTENTION] return ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^318^^^^^297^322^
[REPLACE]  for  (  int  i  =  0;  i  <  fields  .  length  &&  builder  .  isEquals;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < fields . length - 3 && builder . isEquals ; i++ ) {[FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; [ATTENTION] for ( int i = 0 ; i < fields . length - 3 && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^307^^^^^297^322^
[ADD]  for  (  int  i  =  0;  i  <  fields  .  length  &&  builder  .  isEquals;  i++  )  {  Field  f  =  fields[i];  if  (  !excludedFieldList  .  contains  (  f  .  getName  (  )  )  &&  (  f  .  getName  (  )    .  indexOf  (  '$'  )  ==  -1  )  &&  (  useTransients  ||  !Modifier  .  isTransient  (  f  .  getModifiers  (  )  )  ) 	[BUGGY] [CE] illegal start of expression  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; [ATTENTION]   && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^307^308^309^310^311^297^322^
[REPLACE]  if  (  !excludedFieldList  .  contains  (  f  .  getName  (  )  )  &&  (  f  .  getName  (  )    .  indexOf  (  '$'  )  ==  -1  )  &&  (  useTransients  ||  !Modifier  .  isTransient  (  f  .  getModifiers  (  )  )  )  &&  (  !Modifier  .  isStatic  (  f  .  getModifiers  (  )  )  )  )  { 	[BUGGY] if ( excludedFieldList . contains ( f . getName ( ) && ( f[CE] ')' expected  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; [ATTENTION] if ( excludedFieldList . contains ( f . getName ( ) && ( f  try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^309^310^311^312^^297^322^
[REPLACE]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] builder . append ( f . get ( lhs ) , f . get ( lhs ) ) ; [FE] NullPointerException assertTrue(EqualsBuilder.reflectionEquals(o1 , o1))   [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] builder . append ( f . get ( lhs )  , f . get ( lhs ) )  ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REPLACE]  Field  f  =  fields[i]; 	[BUGGY] Field[] fields = clazz . getDeclaredFields ( ) ; [CE] variable fields is already defined in method reflectionAppend(Object , Object , Class , EqualsBuilder , boolean , String[])  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { [ATTENTION] Field[] fields = clazz . getDeclaredFields ( )  ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^308^^^^^297^322^
[ADD]  catch  (  IllegalAccessException  e  )  { 	[BUGGY] [CE] 'try' without 'catch' or 'finally'  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; [ATTENTION]  throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^315^316^317^^^297^322^
[REPLACE]  builder  .  append  (  f  .  get  (  lhs  )  ,  f  .  get  (  rhs  )  )  ; 	[BUGGY] builder . appendSuper ( f . get ( lhs ) , f . get ( rhs ) ) ; [CE] method appendSuper in class EqualsBuilder cannot be applied to given types ;  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { [ATTENTION] builder . appendSuper ( f . get ( lhs )  , f . get ( rhs ) )  ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^314^^^^^297^322^
[REPLACE]  for  (  int  i  =  0;  i  <  fields  .  length  &&  builder  .  isEquals;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) {[NO-ERROR]  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; [ATTENTION] for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { Field f = fields[i] ; if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^307^^^^^297^322^
[ADD]  Field  f  =  fields[i]; 	[BUGGY] [CE] cannot find symbol f  [METHOD]  reflectionAppend [TYPE] void [PARAMETER] Object lhs Object rhs Class clazz EqualsBuilder builder boolean useTransients String[] excludeFields [CLASS] EqualsBuilder  [TYPE] Field f [TYPE] boolean false isEquals testTransients true useTransients [TYPE] Object lhs rhs [TYPE] Class clazz [TYPE] EqualsBuilder builder [TYPE] List excludedFieldList [TYPE] String[] excludeFields [TYPE] Field[] fields [TYPE] int i [TYPE] IllegalAccessException e  [CONTEXT]  private static void reflectionAppend ( Object lhs , Object rhs , Class clazz , EqualsBuilder builder , boolean useTransients , String[] excludeFields ) { Field[] fields = clazz . getDeclaredFields ( ) ; List excludedFieldList = excludeFields ! = null ? Arrays . asList ( excludeFields ) : Collections . EMPTY_LIST ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isEquals ; i++ ) { [ATTENTION] if ( !excludedFieldList . contains ( f . getName ( ) ) && ( f . getName ( ) . indexOf ( '$' )  = = -1 ) && ( useTransients || !Modifier . isTransient ( f . getModifiers ( ) ) ) && ( !Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) {   throw new InternalError (   "Unexpected IllegalAccessException  " ) ; } } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^308^^^^^297^322^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && false ) {[NO-ERROR]  [METHOD]  appendSuper [TYPE] EqualsBuilder [PARAMETER] boolean superEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder appendSuper ( boolean superEquals ) { [ATTENTION] if ( isEquals&&false ) { return this ; } isEquals = superEquals ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^334^^^^^333^339^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  appendSuper [TYPE] EqualsBuilder [PARAMETER] boolean superEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals = superEquals ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^335^^^^^333^339^
[REPLACE]  isEquals  =  superEquals; 	[BUGGY] isEquals =  useTransients ; [CE] cannot find symbol useTransients  [METHOD]  appendSuper [TYPE] EqualsBuilder [PARAMETER] boolean superEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = useTransients ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^337^^^^^333^339^
[ADD]  isEquals  =  superEquals;  return  this; 	[BUGGY] [CE] missing return statement  [METHOD]  appendSuper [TYPE] EqualsBuilder [PARAMETER] boolean superEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals = = false ) { return this ; } [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^337^338^^^^333^339^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(true , new EqualsBuilder().appendSuper(true).append(o1 , o1).isEquals())   [METHOD]  appendSuper [TYPE] EqualsBuilder [PARAMETER] boolean superEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals = = false ) { return this ; } isEquals = superEquals ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^338^^^^^333^339^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || true ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { [ATTENTION] if ( isEquals||true ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^352^^^^^351^397^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(true , new EqualsBuilder().appendSuper(true).append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^353^^^^^351^397^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs || rhs ) {[CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs||rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^355^^^^^351^397^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^356^^^^^351^397^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = null ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^358^^^^^351^397^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^360^^^^^351^397^
[REPLACE]  Class  lhsClass  =  lhs  .  getClass  (  )  ; 	[BUGGY] Class rhsClass = lhs . getClass ( ) ; [CE] cannot find symbol lhsClass  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] Class rhsClass = lhs . getClass ( )  ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^362^^^^^351^397^
[REPLACE]  if  (  !lhsClass  .  isArray  (  )  )  { 	[BUGGY] if ( lhsClass . isArray ( ) ) {[FE]   assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; [ATTENTION] if ( lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^363^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  .  getClass  (  )  !=  rhs  .  getClass  (  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } [ATTENTION] }else {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^370^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  long[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    [ATTENTION] }else { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^376^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  int[]  )  { 	[BUGGY]  if ( ! rhs instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [ATTENTION] }if ( ! rhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^378^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  short[]  )  { 	[BUGGY]  if ( ! lhs instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^380^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  char[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] }else { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  byte[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] }else { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  double[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] }else { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  float[]  )  { 	[BUGGY]  if ( ! lhs instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  boolean[]  )  { 	[BUGGY]  if ( ! lhs instanceof boolean[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  boolean[]  )  {  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ;  }  else  {  append  (  (  Object[]  )  lhs,  (  Object[]  )  rhs  )  ; 	[BUGGY]  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] } append ( ( Object[] ) lhs , ( Object[] ) rhs )  ;    } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^391^392^^394^351^397^
[REPLACE]  append  (  (  Object[]  )  lhs,  (  Object[]  )  rhs  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [L assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^394^^^^^390^395^
[REPLACE]  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ; 	[BUGGY] append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; [FE]  [Z cannot be cast to [Ljava.lang.Object   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { [ATTENTION] append ( ( Object[] ) lhs , ( Object[] ) rhs )  ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^391^^^^^351^397^
[REPLACE]  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ; 	[BUGGY] append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [FE]  [F cannot be cast to [S assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { [ATTENTION] append ( ( short[] ) lhs , ( short[] ) rhs )  ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^389^^^^^351^397^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [F cannot be cast to [Z assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { [ATTENTION] append ( ( float[] ) lhs ,  ( float[] ) rhs ) ;  append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^389^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  boolean[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] }else { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^^^^^351^397^
[ADD]  append  (  (  Object[]  )  lhs,  (  Object[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^394^^^^^390^395^
[ADD]  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { [ATTENTION] } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^391^^^^^351^397^
[REPLACE]  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [D cannot be cast to [Z assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^387^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  float[]  )  {  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  boolean[]  )  {  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ; 	[BUGGY]  append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] } append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ;   } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^389^390^391^^351^397^
[ADD]  else  if  (  lhs  instanceof  boolean[]  )  {  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ;  }  else  {  append  (  (  Object[]  )  lhs,  (  Object[]  )  rhs  )  ; 	[BUGGY]  append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] } append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; append ( ( Object[] ) lhs , ( Object[] ) rhs )  ;    } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^391^392^^394^351^397^
[ADD]  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { [ATTENTION] } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^389^^^^^351^397^
[REPLACE]  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ; 	[BUGGY] append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [FE]  [B cannot be cast to [I assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { [ATTENTION] append ( ( int[] ) lhs , ( int[] ) rhs )  ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^385^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  float[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] }else { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  boolean[]  )  { 	[BUGGY] else if ( ! lhs instanceof boolean[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  float[]  )  {  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  boolean[]  )  {  append  (  (  boolean[]  )  lhs,  (  boolean[]  )  rhs  )  ; 	[BUGGY]  append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] } append ( ( float[] ) lhs , ( float[] ) rhs )  ; append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ;   } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^389^390^391^^351^397^
[REPLACE]  append  (  (  char[]  )  lhs,  (  char[]  )  rhs  )  ; 	[BUGGY] append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [FE]  [C cannot be cast to [S assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { [ATTENTION] append ( ( short[] ) lhs , ( short[] ) rhs )  ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^383^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  byte[]  )  { 	[BUGGY] else if ( ! lhs instanceof byte[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  byte[]  )  {  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  double[]  )  {  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ; 	[BUGGY]  append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] } append ( ( double[] ) lhs , ( double[] ) rhs )  ;   } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^385^386^387^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  double[]  )  { 	[BUGGY] else if ( ! lhs instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^^^^^351^397^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [D cannot be cast to [Z assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { [ATTENTION] append ( ( double[] ) lhs ,  ( double[] ) rhs ) ;  append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^387^^^^^351^397^
[REPLACE]  append  (  (  short[]  )  lhs,  (  short[]  )  rhs  )  ; 	[BUGGY] append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [FE]  [S cannot be cast to [F assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { [ATTENTION] append ( ( float[] ) lhs , ( float[] ) rhs )  ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^381^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  double[]  )  { 	[BUGGY]  if ( ! rhs instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] }if ( ! rhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  double[]  )  {  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  float[]  )  {  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ; 	[BUGGY]  append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] } append ( ( float[] ) lhs , ( float[] ) rhs )  ;   } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^387^388^389^^351^397^
[ADD]  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { [ATTENTION] } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^387^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  byte[]  )  {  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  double[]  )  {  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ; 	[BUGGY]  append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] } append ( ( byte[] ) lhs , ( byte[] ) rhs )  ; append ( ( double[] ) lhs , ( double[] ) rhs )  ;   } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^385^386^387^^351^397^
[ADD]  else  if  (  lhs  instanceof  double[]  )  {  append  (  (  double[]  )  lhs,  (  double[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  float[]  )  {  append  (  (  float[]  )  lhs,  (  float[]  )  rhs  )  ; 	[BUGGY]  append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] } append ( ( double[] ) lhs , ( double[] ) rhs )  ; append ( ( float[] ) lhs , ( float[] ) rhs )  ;   } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^387^388^389^^351^397^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [L assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  [ATTENTION] append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^394^^^^^390^395^
[REPLACE]  }  else  if  (  lhs  instanceof  double[]  )  { 	[BUGGY]  if ( ! lhs instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^386^^^^^351^397^
[REMOVE]   	[BUGGY] append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; [FE]  [Z cannot be cast to [Ljava.lang.Object   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { [ATTENTION] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ;  append ( ( Object[] ) lhs , ( Object[] ) rhs )  ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^391^^^^^351^397^
[REPLACE]  append  (  (  int[]  )  lhs,  (  int[]  )  rhs  )  ; 	[BUGGY] append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [FE]  [I cannot be cast to [J assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { [ATTENTION] append ( ( long[] ) lhs , ( long[] ) rhs )  ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^379^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  short[]  )  { 	[BUGGY] else if ( ! lhs instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^380^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  short[]  )  {  append  (  (  short[]  )  lhs,  (  short[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  char[]  )  {  append  (  (  char[]  )  lhs,  (  char[]  )  rhs  )  ; 	[BUGGY]  append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [ATTENTION] } append ( ( short[] ) lhs , ( short[] ) rhs )  ; append ( ( char[] ) lhs , ( char[] ) rhs )  ;   } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^380^381^382^383^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  byte[]  )  { 	[BUGGY]  if ( ! lhs instanceof byte[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  boolean[]  )  { 	[BUGGY]  if ( ! rhs instanceof boolean[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] }if ( ! rhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  char[]  )  { 	[BUGGY]  if ( ! lhs instanceof char[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  float[]  )  { 	[BUGGY] else if ( ! lhs instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^^^^^351^397^
[ADD]  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { [ATTENTION] } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^385^^^^^351^397^
[REPLACE]  append  (  (  long[]  )  lhs,  (  long[]  )  rhs  )  ; 	[BUGGY] append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [FE]  [J cannot be cast to [F assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { [ATTENTION] append ( ( float[] ) lhs , ( float[] ) rhs )  ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^377^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  int[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [ATTENTION] }else { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^378^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  char[]  )  {  append  (  (  char[]  )  lhs,  (  char[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  byte[]  )  {  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ; 	[BUGGY]  append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] } append ( ( char[] ) lhs , ( char[] ) rhs )  ; append ( ( byte[] ) lhs , ( byte[] ) rhs )  ;   } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^383^384^385^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  boolean[]  )  { 	[BUGGY] else if ( ! rhs instanceof boolean[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; [ATTENTION] } else if ( ! rhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^390^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  float[]  )  { 	[BUGGY]  if ( ! rhs instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] }if ( ! rhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  float[]  )  { 	[BUGGY] else if ( ! rhs instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; [ATTENTION] } else if ( ! rhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^388^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  byte[]  )  { 	[BUGGY]  if ( ! rhs instanceof byte[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] }if ( ! rhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  short[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [ATTENTION] }else { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^380^^^^^351^397^
[REPLACE]  this  .  setEquals  (  false  )  ; 	[BUGGY] this . isEquals ( )  ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  [ATTENTION] this . isEquals ( ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^372^^^^^351^397^
[ADD]  this  .  setEquals  (  false  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  [ATTENTION]    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^372^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  long[]  )  { 	[BUGGY] else if ( ! lhs instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    [ATTENTION] } else if ( ! lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^376^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  long[]  )  {  append  (  (  long[]  )  lhs,  (  long[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  int[]  )  {  append  (  (  int[]  )  lhs,  (  int[]  )  rhs  )  ; 	[BUGGY]  append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    [ATTENTION] } append ( ( int[] ) lhs , ( int[] ) rhs )  ;   } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^376^377^378^379^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  int[]  )  { 	[BUGGY] else if ( ! lhs instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^378^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  int[]  )  {  append  (  (  int[]  )  lhs,  (  int[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  short[]  )  {  append  (  (  short[]  )  lhs,  (  short[]  )  rhs  )  ; 	[BUGGY]  append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [ATTENTION] } append ( ( int[] ) lhs , ( int[] ) rhs )  ; append ( ( short[] ) lhs , ( short[] ) rhs )  ;   } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^378^379^380^381^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  char[]  )  { 	[BUGGY] else if ( ! lhs instanceof char[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] } else if ( ! lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^^^^^351^397^
[ADD]  append  (  (  short[]  )  lhs,  (  short[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { [ATTENTION] } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^381^^^^^351^397^
[ADD]  else  if  (  lhs  instanceof  char[]  )  {  append  (  (  char[]  )  lhs,  (  char[]  )  rhs  )  ;  }  else  if  (  lhs  instanceof  byte[]  )  {  append  (  (  byte[]  )  lhs,  (  byte[]  )  rhs  )  ; 	[BUGGY]  append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] } append ( ( byte[] ) lhs , ( byte[] ) rhs )  ;   } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^383^384^385^^351^397^
[ADD]  append  (  (  char[]  )  lhs,  (  char[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { [ATTENTION] } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^383^^^^^351^397^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [B cannot be cast to [Z assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { [ATTENTION] append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ;  append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^385^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  int[]  )  { 	[BUGGY]  if ( ! lhs instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; [ATTENTION] }if ( ! lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^378^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  byte[]  )  { 	[BUGGY] else if ( ! rhs instanceof byte[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; [ATTENTION] } else if ( ! rhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^384^^^^^351^397^
[REMOVE]   	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [FE]  [S cannot be cast to [Z assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { [ATTENTION] append ( ( short[] ) lhs ,  ( short[] ) rhs ) ;  append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^381^^^^^351^397^
[REPLACE]  if  (  lhs  instanceof  java  .  math  .  BigDecimal  &&  rhs  instanceof  java  .  math  .  BigDecimal  )  { 	[BUGGY] if ( ! rhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { [ATTENTION] if ( ! rhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^364^^^^^351^397^
[REPLACE]  isEquals  =  lhs  .  equals  (  rhs  )  ; 	[BUGGY] isEquals =  rhs . equals ( rhs ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  [ATTENTION] isEquals = rhs . equals ( rhs )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^368^^^^^364^369^
[REPLACE]  isEquals  =  (  (  (  java  .  math  .  BigDecimal  )  lhs  )    .  compareTo  (  (  java  .  math  .  BigDecimal  )  rhs  )  ==  0  )  ; 	[BUGGY] isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  && 3 ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { [ATTENTION] isEquals = ( ( ( java . math . BigDecimal ) lhs )  . compareTo ( ( java . math . BigDecimal ) rhs ) &&3 )  ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^365^^^^^351^397^
[REPLACE]  isEquals  =  (  (  (  java  .  math  .  BigDecimal  )  lhs  )    .  compareTo  (  (  java  .  math  .  BigDecimal  )  rhs  )  ==  0  )  ; 	[BUGGY] isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  || 4 ) ; [CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { [ATTENTION] isEquals = ( ( ( java . math . BigDecimal ) lhs )  . compareTo ( ( java . math . BigDecimal ) rhs ) ||4 )  ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^365^^^^^351^397^
[REPLACE]  isEquals  =  lhs  .  equals  (  rhs  )  ; 	[BUGGY] isEquals =  null . equals ( rhs ) ; [CE] <null> cannot be dereferenced  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  [ATTENTION] isEquals = null . equals ( rhs )  ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^368^^^^^351^397^
[REPLACE]  if  (  lhs  instanceof  java  .  math  .  BigDecimal  &&  rhs  instanceof  java  .  math  .  BigDecimal  )  { 	[BUGGY] if ( ! lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { [ATTENTION] if ( ! lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^364^^^^^351^397^
[ADD]  if  (  lhs  instanceof  java  .  math  .  BigDecimal  &&  rhs  instanceof  java  .  math  .  BigDecimal  )  {  isEquals  =  (  (  (  java  .  math  .  BigDecimal  )  lhs  )    .  compareTo  (  (  java  .  math  .  BigDecimal  )  rhs  )  ==  0  )  ;  }  else  {  isEquals  =  lhs  .  equals  (  rhs  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { [ATTENTION]    } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^364^365^366^^368^351^397^
[ADD]  else  if  (  lhs  .  getClass  (  )  !=  rhs  .  getClass  (  )  )  {  this  .  setEquals  (  false  )  ; 	[BUGGY]  this . setEquals ( false ) ; [CE] illegal start of type  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } [ATTENTION] } this . setEquals ( false )  ;     } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^370^371^372^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  long[]  )  { 	[BUGGY]  if ( ! lhs instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    [ATTENTION] }if ( ! lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^376^^^^^351^397^
[ADD]  append  (  (  int[]  )  lhs,  (  int[]  )  rhs  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { [ATTENTION] } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^379^^^^^351^397^
[REPLACE]  }  else  if  (  lhs  instanceof  char[]  )  { 	[BUGGY] else if ( ! rhs instanceof char[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; [ATTENTION] } else if ( ! rhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^382^^^^^351^397^
[REPLACE]  this  .  setEquals  (  false  )  ; 	[BUGGY] this . setEquals ( true ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  [ATTENTION] this . setEquals ( true )  ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^372^^^^^351^397^
[REPLACE]  isEquals  =  (  (  (  java  .  math  .  BigDecimal  )  lhs  )    .  compareTo  (  (  java  .  math  .  BigDecimal  )  rhs  )  ==  0  )  ; 	[BUGGY] isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  ! =  0 ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { [ATTENTION] isEquals = ( ( ( java . math . BigDecimal ) lhs )  . compareTo ( ( java . math . BigDecimal ) rhs ) ! = 0 )  ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^365^^^^^351^397^
[ADD]  isEquals  =  (  (  (  java  .  math  .  BigDecimal  )  lhs  )    .  compareTo  (  (  java  .  math  .  BigDecimal  )  rhs  )  ==  0  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { [ATTENTION] } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^365^^^^^351^397^
[REPLACE]  isEquals  =  lhs  .  equals  (  rhs  )  ; 	[BUGGY] isEquals =  rhs . equals ( rhs ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  [ATTENTION] isEquals = rhs . equals ( rhs )  ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^368^^^^^351^397^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object lhs Object rhs [CLASS] EqualsBuilder  [TYPE] Object lhs rhs [TYPE] Class lhsClass [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } Class lhsClass = lhs . getClass ( ) ; if ( !lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal && rhs instanceof java . math . BigDecimal ) { isEquals =  ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( ( java . math . BigDecimal ) rhs )  = = 0 ) ; } else {  isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) {  this . setEquals ( false ) ;    } else if ( lhs instanceof long[] ) { append ( ( long[] ) lhs ,  ( long[] ) rhs ) ; } else if ( lhs instanceof int[] ) { append ( ( int[] ) lhs ,  ( int[] ) rhs ) ; } else if ( lhs instanceof short[] ) { append ( ( short[] ) lhs ,  ( short[] ) rhs ) ; } else if ( lhs instanceof char[] ) { append ( ( char[] ) lhs ,  ( char[] ) rhs ) ; } else if ( lhs instanceof byte[] ) { append ( ( byte[] ) lhs ,  ( byte[] ) rhs ) ; } else if ( lhs instanceof double[] ) { append ( ( double[] ) lhs ,  ( double[] ) rhs ) ; } else if ( lhs instanceof float[] ) { append ( ( float[] ) lhs ,  ( float[] ) rhs ) ; } else if ( lhs instanceof boolean[] ) { append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; } else {  append ( ( Object[] ) lhs ,  ( Object[] ) rhs ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^396^^^^^351^397^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals ! =  false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long lhs long rhs [CLASS] EqualsBuilder  [TYPE] long lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long lhs , long rhs ) { [ATTENTION] if ( isEquals! = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^411^^^^^410^416^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long lhs long rhs [CLASS] EqualsBuilder  [TYPE] long lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long lhs , long rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^412^^^^^410^416^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs || rhs ) ; [CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long lhs long rhs [CLASS] EqualsBuilder  [TYPE] long lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long lhs , long rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs||rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^414^^^^^410^416^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long lhs long rhs [CLASS] EqualsBuilder  [TYPE] long lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long lhs , long rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^415^^^^^410^416^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int lhs int rhs [CLASS] EqualsBuilder  [TYPE] int lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int lhs , int rhs ) { [ATTENTION] if ( isEquals|| useTransients ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^426^^^^^425^431^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int lhs int rhs [CLASS] EqualsBuilder  [TYPE] int lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int lhs , int rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^427^^^^^425^431^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs && rhs ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int lhs int rhs [CLASS] EqualsBuilder  [TYPE] int lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int lhs , int rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs&&rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^429^^^^^425^431^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int lhs int rhs [CLASS] EqualsBuilder  [TYPE] int lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int lhs , int rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^430^^^^^425^431^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short lhs short rhs [CLASS] EqualsBuilder  [TYPE] short lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short lhs , short rhs ) { [ATTENTION] if ( isEquals|| useTransients ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^441^^^^^440^446^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short lhs short rhs [CLASS] EqualsBuilder  [TYPE] short lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short lhs , short rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^442^^^^^440^446^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs ! =  rhs ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short lhs short rhs [CLASS] EqualsBuilder  [TYPE] short lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short lhs , short rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs! = rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^444^^^^^440^446^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short lhs short rhs [CLASS] EqualsBuilder  [TYPE] short lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short lhs , short rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^445^^^^^440^446^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( useTransients && useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char lhs char rhs [CLASS] EqualsBuilder  [TYPE] char lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( char lhs , char rhs ) { [ATTENTION] if ( useTransients&&useTransients ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^456^^^^^455^461^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char lhs char rhs [CLASS] EqualsBuilder  [TYPE] char lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^457^^^^^455^461^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs ! =  rhs ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char lhs char rhs [CLASS] EqualsBuilder  [TYPE] char lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs! = rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^459^^^^^455^461^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char lhs char rhs [CLASS] EqualsBuilder  [TYPE] char lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^460^^^^^455^461^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && false ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte lhs byte rhs [CLASS] EqualsBuilder  [TYPE] byte lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte lhs , byte rhs ) { [ATTENTION] if ( isEquals&&false ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^471^^^^^470^476^
[ADD]  if  (  isEquals  ==  false  )  {  return  this;  } 	[BUGGY] [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte lhs byte rhs [CLASS] EqualsBuilder  [TYPE] byte lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte lhs , byte rhs ) { [ATTENTION]  isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^471^472^473^^^470^476^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte lhs byte rhs [CLASS] EqualsBuilder  [TYPE] byte lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte lhs , byte rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^472^^^^^470^476^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs || rhs ) ; [CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte lhs byte rhs [CLASS] EqualsBuilder  [TYPE] byte lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte lhs , byte rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs||rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^474^^^^^470^476^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte lhs byte rhs [CLASS] EqualsBuilder  [TYPE] byte lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte lhs , byte rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^475^^^^^470^476^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals ! =  useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double lhs double rhs [CLASS] EqualsBuilder  [TYPE] double lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double lhs , double rhs ) { [ATTENTION] if ( isEquals! = useTransients ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^492^^^^^491^496^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double lhs double rhs [CLASS] EqualsBuilder  [TYPE] double lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double lhs , double rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^493^^^^^491^496^
[REPLACE]  return  append  (  Double  .  doubleToLongBits  (  lhs  )  ,  Double  .  doubleToLongBits  (  rhs  )  )  ; 	[BUGGY] return append (  lhs  , Double . [CE] <identifier> expected  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double lhs double rhs [CLASS] EqualsBuilder  [TYPE] double lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double lhs , double rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] return append ( lhs , Double . }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^495^^^^^491^496^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float lhs float rhs [CLASS] EqualsBuilder  [TYPE] float lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( float lhs , float rhs ) { [ATTENTION] if ( isEquals|| useTransients ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^512^^^^^511^516^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float lhs float rhs [CLASS] EqualsBuilder  [TYPE] float lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( float lhs , float rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^513^^^^^511^516^
[REPLACE]  return  append  (  Float  .  floatToIntBits  (  lhs  )  ,  Float  .  floatToIntBits  (  rhs  )  )  ; 	[BUGGY] return append (  lhs  , Float . [CE] <identifier> expected  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float lhs float rhs [CLASS] EqualsBuilder  [TYPE] float lhs rhs [TYPE] boolean false isEquals superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( float lhs , float rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] return append ( lhs , Float . }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^515^^^^^511^516^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals ! =  false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean lhs boolean rhs [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( boolean lhs , boolean rhs ) { [ATTENTION] if ( isEquals! = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^526^^^^^525^531^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean lhs boolean rhs [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } isEquals =  ( lhs = = rhs ) ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^527^^^^^525^531^
[REPLACE]  isEquals  =  (  lhs  ==  rhs  )  ; 	[BUGGY] isEquals =  ( lhs && rhs ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean lhs boolean rhs [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] isEquals = ( lhs&&rhs )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^529^^^^^525^531^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(o1 , o1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean lhs boolean rhs [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals = = false ) { return this ; } isEquals =  ( lhs = = rhs ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^530^^^^^525^531^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals ! =  false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { [ATTENTION] if ( isEquals! = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^544^^^^^543^562^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^545^^^^^543^562^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs || rhs ) {[CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs||rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^547^^^^^543^562^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^548^^^^^543^562^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = false ) {[CE] incomparable types: Object[] and boolean  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = false ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^550^^^^^543^562^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^552^^^^^543^562^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length ( ) ! = rhs . length ( ) ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length ( ) ! = rhs . length ( ) ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^554^^^^^543^562^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^556^^^^^543^562^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length + 1 && isEquals ; ++i ) {[FE]  3 assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length + 1 && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^558^^^^^543^562^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] inconvertible types  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^559^^^^^543^562^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^558^^^^^543^562^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] Object[] lhs Object[] rhs [CLASS] EqualsBuilder  [TYPE] Object[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( Object[] lhs , Object[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^561^^^^^543^562^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { [ATTENTION] if ( isEquals||false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^575^^^^^574^593^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^576^^^^^574^593^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs && rhs ) {[CE] bad operand types for binary operator '&&'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs&&rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^578^^^^^574^593^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^579^^^^^574^593^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = null ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^581^^^^^574^593^
[ADD]  if  (  lhs  ==  null  ||  rhs  ==  null  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^581^582^583^584^^574^593^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^583^^^^^574^593^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length + 4 ! = rhs . length + 4 ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length + 4 ! = rhs . length + 4 ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^585^^^^^574^593^
[ADD]  if  (  lhs  .  length  !=  rhs  .  length  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^585^586^587^588^^574^593^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^587^^^^^574^593^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length / 0 . 5 && isEquals ; ++i ) {[FE]  2 assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length /0 . 5&& isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^589^^^^^574^593^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^589^590^591^^^574^593^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( lhs[i] , lhs[i] ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( lhs[i] , lhs[i] )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^590^^^^^574^593^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^589^^^^^574^593^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] long[] lhs long[] rhs [CLASS] EqualsBuilder  [TYPE] long[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( long[] lhs , long[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^592^^^^^574^593^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if (useTransients ! =  true ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { [ATTENTION] if ( useTransients! = true ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^606^^^^^605^624^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^607^^^^^605^624^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs || rhs ) {[CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs||rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^609^^^^^605^624^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^610^^^^^605^624^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = true ) {[CE] incomparable types: int[] and boolean  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = true ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^612^^^^^605^624^
[REMOVE]   	[BUGGY] if ( lhs = = rhs ) {   return this ; }[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs = = null || rhs = = null ) { if ( lhs = = rhs ) { return this ; }this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^612^^^^^605^624^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^614^^^^^605^624^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length ( ) ! = rhs . length ( ) ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length ( ) ! = rhs . length ( ) ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^616^^^^^605^624^
[ADD]  if  (  lhs  .  length  !=  rhs  .  length  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^616^617^618^619^^605^624^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^618^^^^^605^624^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^620^^^^^605^624^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] inconvertible types  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^621^^^^^605^624^
[ADD]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^621^^^^^605^624^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^620^^^^^605^624^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^620^621^622^^^605^624^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] int[] lhs int[] rhs [CLASS] EqualsBuilder  [TYPE] int[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( int[] lhs , int[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^623^^^^^605^624^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && true ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { [ATTENTION] if ( isEquals&&true ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^637^^^^^636^655^
[ADD]  if  (  isEquals  ==  false  )  {  return  this;  } 	[BUGGY] return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { [ATTENTION] return this ;  if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^637^638^639^^^636^655^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^638^^^^^636^655^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs ! =  rhs ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs! = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^640^^^^^636^655^
[ADD]  if  (  lhs  ==  rhs  )  {  return  this;  } 	[BUGGY] return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] return this ;  if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^640^641^642^^^636^655^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^641^^^^^636^655^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = this ) {[CE] incomparable types: short[] and EqualsBuilder  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = this ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^643^^^^^636^655^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^645^^^^^636^655^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length + 3 ! = rhs . length + 3 ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length + 3 ! = rhs . length + 3 ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^647^^^^^636^655^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^649^^^^^636^655^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length - 4 && isEquals ; ++i ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length - 4 && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^651^^^^^636^655^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( rhs[i] , rhs[i] ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( rhs[i] , rhs[i] )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^652^^^^^636^655^
[ADD]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^652^^^^^636^655^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^651^^^^^636^655^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] short[] lhs short[] rhs [CLASS] EqualsBuilder  [TYPE] short[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( short[] lhs , short[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^654^^^^^636^655^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals || false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { [ATTENTION] if ( isEquals||false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^668^^^^^667^686^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^669^^^^^667^686^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs || rhs ) {[CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs||rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^671^^^^^667^686^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^672^^^^^667^686^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( useTransients ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^674^^^^^667^686^
[REMOVE]   	[BUGGY] if ( lhs = = rhs ) {   return this ; }[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs = = null || rhs = = null ) { if ( lhs = = rhs ) { return this ; }this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^674^^^^^667^686^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^676^^^^^667^686^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length + 2 ! = rhs . length + 2 ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length + 2 ! = rhs . length + 2 ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^678^^^^^667^686^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^680^^^^^667^686^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length / 2 && isEquals ; ++i ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length /2 && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^682^^^^^667^686^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^682^683^684^^^667^686^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] inconvertible types  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^683^^^^^667^686^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^682^^^^^667^686^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] char[] lhs char[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] char[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( char[] lhs , char[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^685^^^^^667^686^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { [ATTENTION] if ( isEquals&& useTransients ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^699^^^^^698^717^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^700^^^^^698^717^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs || rhs ) {[CE] bad operand types for binary operator '||'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs||rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^702^^^^^698^717^
[ADD]  if  (  lhs  ==  rhs  )  {  return  this;  } 	[BUGGY] return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] return this ;  if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^702^703^704^^^698^717^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^703^^^^^698^717^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( rhs = = null ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^705^^^^^698^717^
[ADD]  if  (  lhs  ==  null  ||  rhs  ==  null  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION]   if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^705^706^707^708^^698^717^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^707^^^^^698^717^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length + 5 ! = rhs . length + 5 ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length + 5 ! = rhs . length + 5 ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^709^^^^^698^717^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^711^^^^^698^717^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^713^^^^^698^717^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^713^714^715^^^698^717^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( lhs[i] , lhs[i] ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( lhs[i] , lhs[i] )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^714^^^^^698^717^
[ADD]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^714^^^^^698^717^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^713^^^^^698^717^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] byte[] lhs byte[] rhs [CLASS] EqualsBuilder  [TYPE] byte[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( byte[] lhs , byte[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^716^^^^^698^717^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { [ATTENTION] if ( isEquals&&useTransients ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^730^^^^^729^748^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^731^^^^^729^748^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs ! =  rhs ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs! = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^733^^^^^729^748^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^734^^^^^729^748^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = null ||useTransients ) {[CE] cannot find symbol useTransients  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = null ||useTransients ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^736^^^^^729^748^
[ADD]  if  (  lhs  ==  null  ||  rhs  ==  null  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^736^737^738^739^^729^748^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^738^^^^^729^748^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length - 4 ! = rhs . length - 4 ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length - 4 ! = rhs . length - 4 ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^740^^^^^729^748^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^742^^^^^729^748^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length * 0 . 5 && isEquals ; ++i ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length *0 . 5&& isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^744^^^^^729^748^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( ( boolean[] ) lhs ,  ( boolean[] ) rhs ) ; [CE] inconvertible types  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( ( boolean[] ) lhs , ( boolean[] ) rhs )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^745^^^^^729^748^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^744^^^^^729^748^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] double[] lhs double[] rhs [CLASS] EqualsBuilder  [TYPE] double[] lhs rhs [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public EqualsBuilder append ( double[] lhs , double[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^747^^^^^729^748^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals ! =  false ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { [ATTENTION] if ( isEquals! = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^761^^^^^760^779^
[ADD]  if  (  isEquals  ==  false  )  {  return  this;  } 	[BUGGY] [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { [ATTENTION]  if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^761^762^763^^^760^779^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^762^^^^^760^779^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs && rhs ) {[CE] bad operand types for binary operator '&&'  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs&&rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^764^^^^^760^779^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^765^^^^^760^779^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( lhs ! = null ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs ! = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^767^^^^^760^779^
[ADD]  if  (  lhs  ==  null  ||  rhs  ==  null  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^767^768^769^770^^760^779^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^769^^^^^760^779^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length ( ) ! = rhs . length ( ) ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length ( ) ! = rhs . length ( ) ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^771^^^^^760^779^
[ADD]  if  (  lhs  .  length  !=  rhs  .  length  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^771^772^773^774^^760^779^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^773^^^^^760^779^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length / 2 && isEquals ; ++i ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length /2 && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^775^^^^^760^779^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( lhs[i] , lhs[i] ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( lhs[i] , lhs[i] )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^776^^^^^760^779^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^775^^^^^760^779^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^775^776^777^^^760^779^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] float[] lhs float[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] float[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( float[] lhs , float[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^778^^^^^760^779^
[REPLACE]  if  (  isEquals  ==  false  )  { 	[BUGGY] if ( isEquals && false ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { [ATTENTION] if ( isEquals&&false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^792^^^^^791^810^
[ADD]  if  (  isEquals  ==  false  )  {  return  this;  } 	[BUGGY] [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { [ATTENTION]  if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^792^793^794^^^791^810^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { [ATTENTION] return null ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^793^^^^^791^810^
[REPLACE]  if  (  lhs  ==  rhs  )  { 	[BUGGY] if ( lhs ! =  rhs ) {[FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION] if ( lhs! = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^795^^^^^791^810^
[ADD]  if  (  lhs  ==  rhs  )  {  return  this;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } [ATTENTION]  if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^795^796^797^^^791^810^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { [ATTENTION] return null ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^796^^^^^791^810^
[REPLACE]  if  (  lhs  ==  null  ||  rhs  ==  null  )  { 	[BUGGY] if ( rhs = = null ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^798^^^^^791^810^
[REMOVE]   	[BUGGY] if ( lhs = = rhs ) {   return this ; }[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } [ATTENTION] if ( lhs = = null || rhs = = null ) { if ( lhs = = rhs ) { return this ; }this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^798^^^^^791^810^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; [ATTENTION] return null ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^800^^^^^791^810^
[REPLACE]  if  (  lhs  .  length  !=  rhs  .  length  )  { 	[BUGGY] if ( lhs . length ( ) ! = rhs . length ( ) ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] if ( lhs . length ( ) ! = rhs . length ( ) ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^802^^^^^791^810^
[ADD]  if  (  lhs  .  length  !=  rhs  .  length  )  {  this  .  setEquals  (  false  )  ;  return  this;  } 	[BUGGY] this . setEquals ( false ) ; return this ; [CE] unreachable statement  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } [ATTENTION] this . setEquals ( false )  ; return this ;   for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^802^803^804^805^^791^810^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; [ATTENTION] return null ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^804^^^^^791^810^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) {[CE] cannot find symbol  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length ( ) && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^806^^^^^791^810^
[ADD]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  {  append  (  lhs[i],  rhs[i]  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION]  return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^806^807^808^^^791^810^
[REPLACE]  append  (  lhs[i],  rhs[i]  )  ; 	[BUGGY] append ( rhs[i] , rhs[i] ) ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(array1 , array1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { [ATTENTION] append ( rhs[i] , rhs[i] )  ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^807^^^^^791^810^
[REPLACE]  for  (  int  i  =  0;  i  <  lhs  .  length  &&  isEquals;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) {[NO-ERROR]  [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } [ATTENTION] for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^806^^^^^791^810^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  append [TYPE] EqualsBuilder [PARAMETER] boolean[] lhs boolean[] rhs [CLASS] EqualsBuilder  [TYPE] int i [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients [TYPE] boolean[] lhs rhs  [CONTEXT]  public EqualsBuilder append ( boolean[] lhs , boolean[] rhs ) { if ( isEquals = = false ) { return this ; } if ( lhs = = rhs ) { return this ; } if ( lhs = = null || rhs = = null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length ! = rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = 0 ; i < lhs . length && isEquals ; ++i ) { append ( lhs[i] , rhs[i] ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^809^^^^^791^810^
[REPLACE]  return  this  .  isEquals; 	[BUGGY] return false ; [FE] NullPointerException assertTrue(new EqualsBuilder().append(obj1 , obj1).isEquals())   [METHOD]  isEquals [TYPE] boolean [PARAMETER] [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  public boolean isEquals ( ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^819^^^^^818^820^
[REPLACE]  this  .  isEquals  =  isEquals; 	[BUGGY] this . isEquals =  useTransients ; [CE] cannot find symbol useTransients  [METHOD]  setEquals [TYPE] void [PARAMETER] boolean isEquals [CLASS] EqualsBuilder  [TYPE] boolean false isEquals lhs rhs superEquals testTransients true useTransients  [CONTEXT]  protected void setEquals ( boolean isEquals ) { [ATTENTION] this . isEquals = useTransients ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java^829^^^^^828^830^
[REPLACE]  super  (  value  )  ; 	[BUGGY] super ( null ) ; [FE] NullPointerException assertTrue(cmpEq.matches(new BigDecimal(  "5  ")))   [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] CompareEqual  [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public CompareEqual ( Comparable<T> value ) { [ATTENTION] super ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareEqual.java^10^^^^^9^11^
[REPLACE]  return    "cmpEq  "; 	[BUGGY] return result = = 0 ; [CE] cannot find symbol result  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] CompareEqual  [TYPE] boolean false true  [CONTEXT]  protected String getName ( ) { [ATTENTION] return result = = 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareEqual.java^15^^^^^14^16^
[REPLACE]  return  result  ==  0; 	[BUGGY] return result || 0 ; [CE] bad operand types for binary operator '||'  [METHOD]  matchResult [TYPE] boolean [PARAMETER] int result [CLASS] CompareEqual  [TYPE] boolean false true [TYPE] int result  [CONTEXT]  protected boolean matchResult ( int result ) { [ATTENTION] return result||0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareEqual.java^20^^^^^19^21^
[REPLACE]  private  LinkedList<Object>  arguments  =  new  LinkedList<Object>  (  )  ; 	[BUGGY] private LinkedList<Object> arguments ; [FE] NullPointerException assertEquals(11 , allValues.get(0).getAge())   [CONTEXT]    [CLASS] CapturingMatcher  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^17^^^^^^^
[REPLACE]  this  .  arguments  .  add  (  argument  )  ; 	[BUGGY] this . arguments . getLast ( )  ; [FE] NullPointerException assertEquals(11 , allValues.get(0).getAge())   [METHOD]  matches [TYPE] boolean [PARAMETER] Object argument [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] Object argument [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object argument ) { [ATTENTION] this . arguments . getLast ( ) ; return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^23^^^^^22^25^
[ADD]  this  .  arguments  .  add  (  argument  )  ; 	[BUGGY] [FE]  IndexOutOfBoundsException Index: 0 , Size: 0 assertEquals(11 , allValues.get(0).getAge())   [METHOD]  matches [TYPE] boolean [PARAMETER] Object argument [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] Object argument [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object argument ) { [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^23^^^^^22^25^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]   assertEquals(11 , allValues.get(0).getAge())   [METHOD]  matches [TYPE] boolean [PARAMETER] Object argument [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] Object argument [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object argument ) { this . arguments . add ( argument ) ; [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^24^^^^^22^25^
[REPLACE]  description  .  appendText  (    "<Capturing  argument>  "  )  ; 	[BUGGY] this . arguments . add ( argument ) ; [CE] cannot find symbol argument  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] this . arguments . add ( argument )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^31^^^^^30^32^
[REPLACE]  return  (  T  )  arguments  .  getLast  (  )  ; 	[BUGGY] return ( T ) arguments . LinkedList ( ) ; [CE] cannot find symbol  [METHOD]  getLastValue [TYPE] T [PARAMETER] [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] boolean false true  [CONTEXT]  public T getLastValue ( ) { if ( arguments . isEmpty ( ) ) { new Reporter ( ) . noArgumentValueWasCaptured ( ) ; } else { [ATTENTION] return ( T ) arguments . LinkedList ( )  ; } return ( T ) arguments ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^38^^^^^34^41^
[REPLACE]  new  Reporter  (  )    .  noArgumentValueWasCaptured  (  )  ; 	[BUGGY] new Reporter ( )  . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  getLastValue [TYPE] T [PARAMETER] [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] boolean false true  [CONTEXT]  public T getLastValue ( ) { if ( arguments . isEmpty ( ) ) { [ATTENTION] new Reporter ( ) . Reporter ( ) ; } else { return ( T ) arguments . getLast ( ) ; } return ( T ) arguments ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^36^^^^^34^41^
[REPLACE]  return  (  T  )  arguments; 	[BUGGY] return ( List ) arguments ; [CE] incompatible types  [METHOD]  getLastValue [TYPE] T [PARAMETER] [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] boolean false true  [CONTEXT]  public T getLastValue ( ) { if ( arguments . isEmpty ( ) ) { new Reporter ( ) . noArgumentValueWasCaptured ( ) ; } else { return ( T ) arguments . getLast ( ) ; } [ATTENTION] return ( List ) arguments ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^40^^^^^34^41^
[REPLACE]  return  (  List  )  arguments; 	[BUGGY] return ( T ) arguments ; [CE] incompatible types  [METHOD]  getAllValues [TYPE] List [PARAMETER] [CLASS] CapturingMatcher  [TYPE] LinkedList arguments [TYPE] boolean false true  [CONTEXT]  public List<T> getAllValues ( ) { [ATTENTION] return ( T ) arguments ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CapturingMatcher.java^44^^^^^43^45^
[REPLACE]  super  (  value  )  ; 	[BUGGY] super ( 0 ) ; [CE] constructor CompareTo in class CompareTo<T#2> cannot be applied to given types ;  [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] LessOrEqual  [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public LessOrEqual ( Comparable<T> value ) { [ATTENTION] super ( 0 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessOrEqual.java^10^^^^^9^11^
[REPLACE]  return    "leq  "; 	[BUGGY] return result < = 0 ; [CE] cannot find symbol result  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] LessOrEqual  [TYPE] boolean false true  [CONTEXT]  protected String getName ( ) { [ATTENTION] return result < = 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessOrEqual.java^15^^^^^14^16^
[REPLACE]  return  result  <=  0; 	[BUGGY] return result  ; [CE] incompatible types  [METHOD]  matchResult [TYPE] boolean [PARAMETER] int result [CLASS] LessOrEqual  [TYPE] boolean false true [TYPE] int result  [CONTEXT]  protected boolean matchResult ( int result ) { [ATTENTION] return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/LessOrEqual.java^20^^^^^19^21^
[REPLACE]  this  .  first  =  first; 	[BUGGY] this . first =  null ; [FE] NullPointerException assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher first [CLASS] Not  [TYPE] Matcher first [TYPE] boolean false true  [CONTEXT]  public Not ( Matcher first ) { [ATTENTION] this . first = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^17^^^^^16^18^
[ADD]  this  .  first  =  first; 	[BUGGY] [CE] variable first might not have been initialized  [METHOD]  <init> [TYPE] Matcher) [PARAMETER] Matcher first [CLASS] Not  [TYPE] Matcher first [TYPE] boolean false true  [CONTEXT]  public Not ( Matcher first ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^17^^^^^16^18^
[REPLACE]  return  !first  .  matches  (  actual  )  ; 	[BUGGY] return !first . describeTo ( actual ) ; [CE] method describeTo in interface SelfDescribing cannot be applied to given types ;  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Not  [TYPE] Matcher first [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return !first . describeTo ( actual )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^21^^^^^20^22^
[REPLACE]  description  .  appendText  (    "not  (    "  )  ; 	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<[not(]1)> but was:<[ ) ]1)> assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Not  [TYPE] Matcher first [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   " )   " )  ; first . describeTo ( description ) ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^25^^^^^24^28^
[ADD]  description  .  appendText  (    "not  (    "  )  ;  first  .  describeTo  (  description  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[not(1])> but was:<[])> assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Not  [TYPE] Matcher first [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION]  description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^25^26^^^^24^28^
[REPLACE]  first  .  describeTo  (  description  )  ; 	[BUGGY] first . matches ( description ) ; [FE]  AssertionFailedError  expected:<not([1])> but was:<not([])> assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Not  [TYPE] Matcher first [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "not (   " ) ; [ATTENTION] first . matches ( description )  ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^26^^^^^24^28^
[REPLACE]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] description . appendText (   "not (   " ) ; [FE]  AssertionFailedError  expected:<not(1[)]> but was:<not(1[not ( ]> assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Not  [TYPE] Matcher first [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "not (   " ) ; first . describeTo ( description ) ; [ATTENTION] description . appendText (   "not (   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^27^^^^^24^28^
[ADD]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<not(1[)]> but was:<not(1[]> assertEquals(  "not(1)  " , describe(new Not(new Equals(1))))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Not  [TYPE] Matcher first [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "not (   " ) ; first . describeTo ( description ) ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Not.java^27^^^^^24^28^
[REPLACE]  private  final  List<Matcher>  matchers; 	[BUGGY] private List<Matcher> matchers ; [NO-ERROR]  [CONTEXT]    [CLASS] And  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^17^^^^^^^
[REPLACE]  this  .  matchers  =  matchers; 	[BUGGY] this . matchers =  null ; [FE] NullPointerException assertEquals(  "and(1 , 2)  " , describe(new And(matchers)))   [METHOD]  <init> [TYPE] List) [PARAMETER] Matcher> matchers [CLASS] And  [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public And ( List<Matcher> matchers ) { [ATTENTION] this . matchers = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^20^^^^^19^21^
[ADD]  this  .  matchers  =  matchers; 	[BUGGY] [CE] variable matchers might not have been initialized  [METHOD]  <init> [TYPE] List) [PARAMETER] Matcher> matchers [CLASS] And  [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public And ( List<Matcher> matchers ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^20^^^^^19^21^
[REPLACE]  if  (  !matcher  .  matches  (  actual  )  )  { 	[BUGGY] if ( matcher . matches ( actual ) ) {[FE]  AssertionFailedError  expected:<0> but was:<null> assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] And  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { [ATTENTION] if ( matcher . matches ( actual ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^25^^^^^23^30^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<null> but was:<0> assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] And  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) { [ATTENTION] return true ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^26^^^^^23^30^
[REPLACE]  for  (  Matcher  matcher  :  matchers  )  { 	[BUGGY] for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) {[CE] illegal start of expression  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] And  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) { if ( !matcher . matches ( actual ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^24^^^^^23^30^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<0> but was:<null> assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] And  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) { return false ; } } [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^29^^^^^23^30^
[REPLACE]  description  .  appendText  (    "and  (    "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  AssertionFailedError  expected:<[and(]1 , 2)> but was:<[ , ]1 , 2)> assertEquals(  "and(1 , 2)  " , describe(new And(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   " ,   " )  ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^33^^^^^32^41^
[REPLACE]  if  (  it  .  hasNext  (  )  )  { 	[BUGGY] if ( it . next ( ) ) {[CE] incompatible types  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION] if ( it . next ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^36^^^^^32^41^
[REPLACE]  description  .  appendText  (    ",    "  )  ; 	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<and(1[ , ] 2)> but was:<and(1[ )] 2)> assertEquals(  "and(1 , 2)  " , describe(new And(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { [ATTENTION] description . appendText (   " )   " )  ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^37^^^^^32^41^
[REPLACE]  for  (  Iterator<Matcher>  it  =  matchers  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator<Matcher> null = matchers . iterator ( ) ; it . hasNext ( ) ; ) {[CE] not a statement  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; [ATTENTION] for ( Iterator<Matcher> null = matchers . iterator ( )  ; it . hasNext ( )  ;  ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^34^^^^^32^41^
[ADD]  for  (  Iterator<Matcher>  it  =  matchers  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  {  it  .  next  (  )    .  describeTo  (  description  )  ;  if  (  it  .  hasNext  (  )  )  {  description  .  appendText  (    ",    "  )  ;  } 	[BUGGY] [CE] <identifier> expected  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; [ATTENTION]   } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^34^35^36^37^38^32^41^
[REPLACE]  if  (  it  .  hasNext  (  )  )  { 	[BUGGY] if ( 0 . hasNext ( ) ) {[CE] ')' expected  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION] if ( 0 . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^36^^^^^32^41^
[REPLACE]  for  (  Iterator<Matcher>  it  =  matchers  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) {[CE] reached end of file while parsing  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; [ATTENTION] for ( Matcher matcher : matchers ) { if ( !matcher . matches ( actual ) ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^34^^^^^32^41^
[REPLACE]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  AssertionFailedError  expected:<and(1 , 2[)]> but was:<and(1 , 2[ , ]> assertEquals(  "and(1 , 2)  " , describe(new And(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] And  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "and (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } [ATTENTION] description . appendText (   " ,   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/And.java^40^^^^^32^41^
[REPLACE]  private  final  String  regex; 	[BUGGY] private final boolean regex ; [CE] incompatible types  [CONTEXT]    [CLASS] Matches  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Matches.java^13^^^^^^^
[REPLACE]  this  .  regex  =  regex; 	[BUGGY] this . regex =  null ; [FE] NullPointerException assertEquals(  "matches(\  "\\\\s+\  ")  " , describe(new Matches(  "\\s+  ")))   [METHOD]  <init> [TYPE] String) [PARAMETER] String regex [CLASS] Matches  [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public Matches ( String regex ) { [ATTENTION] this . regex = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Matches.java^16^^^^^15^17^
[REPLACE]  return  (  actual  instanceof  String  )  &&  (  (  String  )  actual  )    .  matches  (  regex  )  ; 	[BUGGY] return ( actual instanceof String ) || ( ( String ) actual ) . matches ( regex ) ; [FE]  AssertionFailedError  expected:<[1]> but was:<[2]> assertEquals(  "1  " , mock.oneArg(  "a12  "))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Matches  [TYPE] Object actual [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return ( actual instanceof String ) || ( ( String ) actual )  . matches ( regex )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Matches.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "matches  (  \  "  "  +  regex  .  replaceAll  (    "\\\\  ",    "\\\\\\\\  "  )  +    "\  "  )    "  )  ; 	[BUGGY] description . appendText (   "matches ( \  "  " > =  regex . replaceAll (   "\\\\  " ,   "\\\\\\\\  " ) > =    "\  " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Matches  [TYPE] String regex [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "matches ( \  "  "> = regex . replaceAll (   "\\\\  " ,   "\\\\\\\\  " ) > =   "\  " )   " )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Matches.java^24^25^^^^23^26^
[REPLACE]  description  .  appendText  (    "matches  (  \  "  "  +  regex  .  replaceAll  (    "\\\\  ",    "\\\\\\\\  "  )  +    "\  "  )    "  )  ; 	[BUGGY] description . appendText (   "matches ( \  "  " + regex . matches ( this ) +   "\  " )   " ) ; [CE] method matches in class String cannot be applied to given types ;  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Matches  [TYPE] String regex [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "matches ( \  "  " + regex . matches ( this ) +   "\  " )   " )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Matches.java^24^25^^^^23^26^
[REPLACE]  this  .  wanted  =  value; 	[BUGGY] this . wanted =  wanted ; [CE] variable wanted might not have been initialized  [METHOD]  <init> [TYPE] Number) [PARAMETER] Number value Number delta [CLASS] EqualsWithDelta  [TYPE] Number delta value wanted [TYPE] boolean false true  [CONTEXT]  public EqualsWithDelta ( Number value , Number delta ) { [ATTENTION] this . wanted = wanted ; this . delta = delta ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EqualsWithDelta.java^17^^^^^16^19^
[ADD]  this  .  wanted  =  value; 	[BUGGY] [CE] variable wanted might not have been initialized  [METHOD]  <init> [TYPE] Number) [PARAMETER] Number value Number delta [CLASS] EqualsWithDelta  [TYPE] Number delta value wanted [TYPE] boolean false true  [CONTEXT]  public EqualsWithDelta ( Number value , Number delta ) { [ATTENTION] this . delta = delta ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EqualsWithDelta.java^17^^^^^16^19^
[REPLACE]  this  .  delta  =  delta; 	[BUGGY] this . delta =  null ; [FE]   assertContains(  "eq(1.0 , 0.1)  " , e.getMessage())   [METHOD]  <init> [TYPE] Number) [PARAMETER] Number value Number delta [CLASS] EqualsWithDelta  [TYPE] Number delta value wanted [TYPE] boolean false true  [CONTEXT]  public EqualsWithDelta ( Number value , Number delta ) { this . wanted = value ; [ATTENTION] this . delta = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EqualsWithDelta.java^18^^^^^16^19^
[REPLACE]  return  wanted  .  doubleValue  (  )  -  delta  .  doubleValue  (  )  <=  actualNumber  .  doubleValue  (  )  &&  actualNumber  .  doubleValue  (  )  <=  wanted  .  doubleValue  (  )  +  delta  .  doubleValue  (  )  ; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<1> but was:<null> assertEquals(  "1  " , mock.oneArg(1.0))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] EqualsWithDelta  [TYPE] Number actualNumber delta value wanted [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { Number actualNumber =  ( Number ) actual ; [ATTENTION] return false ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EqualsWithDelta.java^23^24^25^^^21^26^
[REPLACE]  description  .  appendText  (    "eq  (    "  +  wanted  +    ",    "  +  delta  +    "  )    "  )  ; 	[BUGGY] description . appendText (   "eq (   " || wanted ||   " ,   " || delta ||   " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] EqualsWithDelta  [TYPE] Number actualNumber delta value wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   "eq (   "||wanted||  " ,   "||delta||  " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/EqualsWithDelta.java^29^^^^^28^30^
[REPLACE]  super  (  value  )  ; 	[BUGGY] super ( null ) ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] GreaterOrEqual  [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public GreaterOrEqual ( Comparable<T> value ) { [ATTENTION] super ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterOrEqual.java^10^^^^^9^11^
[REPLACE]  return    "geq  "; 	[BUGGY] return result > = 0 ; [CE] cannot find symbol result  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] GreaterOrEqual  [TYPE] boolean false true  [CONTEXT]  protected String getName ( ) { [ATTENTION] return result > = 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterOrEqual.java^15^^^^^14^16^
[REPLACE]  return  result  >=  0; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  matchResult [TYPE] boolean [PARAMETER] int result [CLASS] GreaterOrEqual  [TYPE] boolean false true [TYPE] int result  [CONTEXT]  protected boolean matchResult ( int result ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/GreaterOrEqual.java^20^^^^^19^21^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] NullPointerException assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  <init> [TYPE] Object) [PARAMETER] Object wanted [CLASS] Same  [TYPE] Object wanted [TYPE] boolean false true  [CONTEXT]  public Same ( Object wanted ) { [ATTENTION] this . wanted = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^16^^^^^15^17^
[REPLACE]  return  wanted  ==  actual; 	[BUGGY] return wanted || actual ; [CE] bad operand types for binary operator '||'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Same  [TYPE] Object actual wanted [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] return wanted||actual ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^20^^^^^19^21^
[REPLACE]  description  .  appendText  (    "same  (    "  )  ; 	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<[same(]'x')> but was:<[ ) ]'x')> assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   " )   " )  ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^24^^^^^23^29^
[ADD]  description  .  appendText  (    "same  (    "  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[same(]'x')> but was:<[]'x')> assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^24^^^^^23^29^
[REPLACE]  appendQuoting  (  description  )  ; 	[BUGGY] description . appendText (   "\  "  " ) ; [FE]  expected:<same([ assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "same (   " ) ; [ATTENTION] description . appendText (   "\  "  " )  ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^25^^^^^23^29^
[REPLACE]  description  .  appendText  (  wanted  .  toString  (  )  )  ; 	[BUGGY] description . appendText (   "\  "  " ) ; [FE]  expected:<same( assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "same (   " ) ; appendQuoting ( description ) ; [ATTENTION] description . appendText (   "\  "  " )  ; appendQuoting ( description ) ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^26^^^^^23^29^
[REPLACE]  appendQuoting  (  description  )  ; 	[BUGGY] description . appendText (   "\  "  " ) ; [FE]  expected:<same( assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "same (   " ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; [ATTENTION] description . appendText (   "\  "  " )  ; description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^27^^^^^23^29^
[ADD]  appendQuoting  (  description  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<same('x['])> but was:<same('x[])> assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "same (   " ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; [ATTENTION] description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^27^^^^^23^29^
[REPLACE]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] description . appendText (   "\  "  " ) ; [FE]  expected:<same( assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "same (   " ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; [ATTENTION] description . appendText (   "\  "  " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^28^^^^^23^29^
[REPLACE]  if  (  wanted  instanceof  String  )  { 	[BUGGY] if ( ! wanted instanceof String ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  appendQuoting [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  private void appendQuoting ( Description description ) { [ATTENTION] if ( ! wanted instanceof String ) { description . appendText (   "\  "  " ) ; } else if ( wanted instanceof Character ) { description . appendText (   "'  " ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^32^^^^^31^37^
[REPLACE]  }  else  if  (  wanted  instanceof  Character  )  { 	[BUGGY]  else {[FE]  AssertionFailedError  expected:<same([X])> but was:<same(['X'])> assertEquals(  "same(X)  " , describe(new Same(o)))   [METHOD]  appendQuoting [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  private void appendQuoting ( Description description ) { if ( wanted instanceof String ) { description . appendText (   "\  "  " ) ; [ATTENTION] }else { description . appendText (   "'  " ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^34^^^^^31^37^
[REPLACE]  description  .  appendText  (    "'  "  )  ; 	[BUGGY] description . appendText (   "\  "  " ) ; [FE]  expected:<same([ assertEquals(  "same('x')  " , describe(new Same('x')))   [METHOD]  appendQuoting [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  private void appendQuoting ( Description description ) { if ( wanted instanceof String ) { description . appendText (   "\  "  " ) ; } else if ( wanted instanceof Character ) { [ATTENTION] description . appendText (   "\  "  " )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^35^^^^^31^37^
[REPLACE]  description  .  appendText  (    "\  "  "  )  ; 	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<same([  "X  "])> but was:<same([ ) X ) ])> assertEquals(  "same(\  "X\  ")  " , describe(new Same(  "X  ")))   [METHOD]  appendQuoting [TYPE] void [PARAMETER] Description description [CLASS] Same  [TYPE] Object actual wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  private void appendQuoting ( Description description ) { if ( wanted instanceof String ) { [ATTENTION] description . appendText (   " )   " )  ; } else if ( wanted instanceof Character ) { description . appendText (   "'  " ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Same.java^33^^^^^31^37^
[REPLACE]  super  (  wanted  )  ; 	[BUGGY] Object wanted = getWanted ( ) ; [CE] constructor Equals in class Equals cannot be applied to given types ;  [METHOD]  <init> [TYPE] Object) [PARAMETER] Object wanted [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object wanted  [CONTEXT]  public ArrayEquals ( Object wanted ) { [ATTENTION] Object wanted = getWanted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^15^^^^^14^16^
[ADD]  super  (  wanted  )  ; 	[BUGGY] [CE] constructor Equals in class Equals cannot be applied to given types ;  [METHOD]  <init> [TYPE] Object) [PARAMETER] Object wanted [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object wanted  [CONTEXT]  public ArrayEquals ( Object wanted ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^15^^^^^14^16^
[REPLACE]  Object  wanted  =  getWanted  (  )  ; 	[BUGGY] Object[] result = new Object[Array . getLength ( array ) ] ; [CE] cannot find symbol array  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] Object[] result = new Object[Array . getLength ( array ) ] ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^19^^^^^18^42^
[REPLACE]  if  (  wanted  ==  null  ||  actual  ==  null  )  { 	[BUGGY] if ( wanted ! = null || actual = = null ) {[FE]  AssertionFailedError  expected:<0> but was:<null> assertEquals(  "0  " , mock.oneArray(new boolean[] { true , false , false }))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; [ATTENTION] if ( wanted ! = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^20^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  boolean[]  &&  actual  instanceof  boolean[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; [ATTENTION] }else { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^22^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  byte[]  &&  actual  instanceof  byte[]  )  { 	[BUGGY]  if ( ! wanted instanceof byte[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^24^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY] else if ( actual instanceof double[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] } else if ( actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[REMOVE]   	[BUGGY] if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) {   return equals ( ( ( boolean[] )  ( wanted ) ) ,  ( ( boolean[] )  ( actual ) ) ) ; }else   if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) {     return equals ( ( ( byte[] )  ( wanted ) ) ,  ( ( byte[] )  ( actual ) ) ) ;   }else     if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) {       return equals ( ( ( char[] )  ( wanted ) ) ,  ( ( char[] )  ( actual ) ) ) ;     }else       if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) {         return equals ( ( ( double[] )  ( wanted ) ) ,  ( ( double[] )  ( actual ) ) ) ;       }else         if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) {           return equals ( ( ( float[] )  ( wanted ) ) ,  ( ( float[] )  ( actual ) ) ) ;         }else           if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) {             return equals ( ( ( int[] )  ( wanted ) ) ,  ( ( int[] )  ( actual ) ) ) ;           }else             if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) {               return equals ( ( ( long[] )  ( wanted ) ) ,  ( ( long[] )  ( actual ) ) ) ;             }else               if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) {                 return equals ( ( ( short[] )  ( wanted ) ) ,  ( ( short[] )  ( actual ) ) ) ;               }else                 if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) {                   return equals ( ( ( Object[] )  ( wanted ) ) ,  ( ( Object[] )  ( actual ) ) ) ;                 }[CE] no suitable method found for equals(boolean[] , boolean[])  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] } else if ( wanted instanceof double[] && actual instanceof double[] ) { if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) { return equals ( ( ( boolean[] )  ( wanted ) )  , ( ( boolean[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) { return equals ( ( ( byte[] )  ( wanted ) )  , ( ( byte[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) { return equals ( ( ( char[] )  ( wanted ) )  , ( ( char[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) { return equals ( ( ( double[] )  ( wanted ) )  , ( ( double[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) { return equals ( ( ( float[] )  ( wanted ) )  , ( ( float[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) { return equals ( ( ( int[] )  ( wanted ) )  , ( ( int[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) { return equals ( ( ( long[] )  ( wanted ) )  , ( ( long[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) { return equals ( ( ( short[] )  ( wanted ) )  , ( ( short[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) { return equals ( ( ( Object[] )  ( wanted ) )  , ( ( Object[] )  ( actual ) ) )  ; }return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  { 	[BUGGY]  if ( ! wanted instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY] else if ( ! wanted instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  {  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  {  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ;  } 	[BUGGY]  return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( short[] ) wanted , ( short[] ) actual )  ; return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ;   return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^37^38^39^40^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( ! wanted instanceof Object[] && actual instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [FE]  [Ljava.lang.String   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( ( float[] ) wanted , ( float[] ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [S cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  else {[CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  {  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<8> but was:<null> assertEquals(  "0  " , mock.oneArray(new boolean[] { true , false , false }))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }  return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^39^40^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [J cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( true , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 1 , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY] else if ( actual instanceof Object[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } else if ( actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  {  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ;  } 	[BUGGY]  return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ;  return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^39^40^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( true , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [I cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( actual instanceof short[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY] else if ( ! wanted instanceof Object[] && actual instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REMOVE]   	[BUGGY] if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) {   return equals ( ( ( Object[] )  ( wanted ) ) ,  ( ( Object[] )  ( actual ) ) ) ; }[CE] no suitable method found for equals(Object[] , Object[])  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } else if ( wanted instanceof short[] && actual instanceof short[] ) { if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) { return equals ( ( ( Object[] )  ( wanted ) )  , ( ( Object[] )  ( actual ) ) )  ; }return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( ! wanted instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [F cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY] else if ( actual instanceof short[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } else if ( actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( actual instanceof Object[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( false , this ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( ! wanted instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY] else if ( ! wanted instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 0 , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , false ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( 1 , null ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  {  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  {  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( long[] ) wanted , ( long[] ) actual )  ; return Arrays . equals ( ( short[] ) wanted , ( short[] ) actual )  ;   } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^35^36^37^^18^42^
[ADD]  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  {  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  {  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ;  } 	[BUGGY]  return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [CE] unreachable statement  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ;   return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^37^38^39^40^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( true , null ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( true , true ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [D cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  {  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  {  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( int[] ) wanted , ( int[] ) actual )  ; return Arrays . equals ( ( long[] ) wanted , ( long[] ) actual )  ;   } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^33^34^35^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY] else if ( ! wanted instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( null , true ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  {  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  {  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( short[] ) wanted , ( short[] ) actual )  ;   } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^35^36^37^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY] else if ( ! wanted instanceof Object[] && wanted instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof Object[] && wanted instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( ! wanted instanceof long[] && actual instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY] else if ( ! wanted instanceof long[] && actual instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [C cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^27^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  {  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  {  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( int[] ) wanted , ( int[] ) actual )  ;   } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^31^32^33^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY]  if ( ! wanted instanceof int[] && actual instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( ! actual instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( ! wanted instanceof short[] && actual instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , null ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , this ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( actual instanceof long[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( null , true ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( true , 1 ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( ! actual instanceof short[] && actual instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  { 	[BUGGY]  if ( actual instanceof float[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] }if ( actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( 1 , 1 ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , true ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( 1 , null ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( true , this ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , this ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , false ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( ! wanted instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( false , this ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { [ATTENTION] return Arrays . equals ( true , this ) actual )  ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^27^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  byte[]  )  wanted,  (  byte[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [B cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^25^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  { 	[BUGGY] else if ( ! actual instanceof char[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] } else if ( ! actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY]  if ( ! wanted instanceof double[] && actual instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( false , null ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY] else if ( ! wanted instanceof int[] && wanted instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof int[] && wanted instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( ! actual instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , false ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY] else if ( ! wanted instanceof short[] && actual instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  { 	[BUGGY]  if ( ! wanted instanceof float[] && actual instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( this , null ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY]  if ( actual instanceof double[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] }if ( actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  {  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  {  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( float[] ) wanted , ( float[] ) actual )  ; return Arrays . equals ( ( int[] ) wanted , ( int[] ) actual )  ;   } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^31^32^33^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , this ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , false ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 0 , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( false , null ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY] else if ( actual instanceof int[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } else if ( actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY] else if ( actual instanceof long[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } else if ( actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( null , true ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY]  if ( actual instanceof int[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] }if ( actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  {  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  {  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( long[] ) wanted , ( long[] ) actual )  ;   } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^33^34^35^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , null ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( true , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( null , false ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( false , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( true , this ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  boolean[]  )  wanted,  (  boolean[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [FE]  [Z cannot be cast to [Ljava.lang.Object   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^23^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  byte[]  &&  actual  instanceof  byte[]  )  { 	[BUGGY]  if ( actual instanceof byte[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; [ATTENTION] }if ( actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^24^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  byte[]  &&  actual  instanceof  byte[]  )  {  return  Arrays  .  equals  (  (  byte[]  )  wanted,  (  byte[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  {  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( byte[] ) wanted , ( byte[] ) actual )  ; return Arrays . equals ( ( char[] ) wanted , ( char[] ) actual )  ;   } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^24^25^26^27^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  { 	[BUGGY]  if ( actual instanceof char[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] }if ( actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] }else { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  {  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  {  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( float[] ) wanted , ( float[] ) actual )  ;   } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^29^30^31^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  { 	[BUGGY] else if ( ! wanted instanceof float[] && actual instanceof float[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( null , false ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , 0 ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( null , false ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( true , false ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , 1 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY]  if ( ! wanted instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( ! actual instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 1 , 0 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY] else if ( ! actual instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] } else if ( ! actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( ! wanted instanceof Object[] && wanted instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof Object[] && wanted instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( wanted instanceof Object[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( wanted instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 0 , this ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( false , false ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( 1 , false ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( true , this ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , 1 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( true , 0 ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY] else if ( ! wanted instanceof int[] && actual instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( 0 , false ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  int[]  &&  actual  instanceof  int[]  )  { 	[BUGGY] else if ( ! wanted instanceof int[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^32^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( false , false ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( null , 0 ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( this , false ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( 1 , this ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( true , false ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , 1 ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( false , false ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { [ATTENTION] return Arrays . equals ( null , null ) actual )  ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^27^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( 1 , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( true , this ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 1 , 1 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REMOVE]   	[BUGGY] if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) {   return equals ( ( ( boolean[] )  ( wanted ) ) ,  ( ( boolean[] )  ( actual ) ) ) ; }else   if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) {     return equals ( ( ( byte[] )  ( wanted ) ) ,  ( ( byte[] )  ( actual ) ) ) ;   }else     if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) {       return equals ( ( ( char[] )  ( wanted ) ) ,  ( ( char[] )  ( actual ) ) ) ;     }else       if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) {         return equals ( ( ( double[] )  ( wanted ) ) ,  ( ( double[] )  ( actual ) ) ) ;       }else         if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) {           return equals ( ( ( float[] )  ( wanted ) ) ,  ( ( float[] )  ( actual ) ) ) ;         }else           if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) {             return equals ( ( ( int[] )  ( wanted ) ) ,  ( ( int[] )  ( actual ) ) ) ;           }else             if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) {               return equals ( ( ( long[] )  ( wanted ) ) ,  ( ( long[] )  ( actual ) ) ) ;             }else               if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) {                 return equals ( ( ( short[] )  ( wanted ) ) ,  ( ( short[] )  ( actual ) ) ) ;               }else                 if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) {                   return equals ( ( ( Object[] )  ( wanted ) ) ,  ( ( Object[] )  ( actual ) ) ) ;                 }[CE] no suitable method found for equals(boolean[] , boolean[])  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; [ATTENTION] } else if ( wanted instanceof float[] && actual instanceof float[] ) { if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) { return equals ( ( ( boolean[] )  ( wanted ) )  , ( ( boolean[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) { return equals ( ( ( byte[] )  ( wanted ) )  , ( ( byte[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) { return equals ( ( ( char[] )  ( wanted ) )  , ( ( char[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) { return equals ( ( ( double[] )  ( wanted ) )  , ( ( double[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) { return equals ( ( ( float[] )  ( wanted ) )  , ( ( float[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) { return equals ( ( ( int[] )  ( wanted ) )  , ( ( int[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) { return equals ( ( ( long[] )  ( wanted ) )  , ( ( long[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) { return equals ( ( ( short[] )  ( wanted ) )  , ( ( short[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) { return equals ( ( ( Object[] )  ( wanted ) )  , ( ( Object[] )  ( actual ) ) )  ; }return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^30^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( wanted instanceof long[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( wanted instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  super  .  matches  (  actual  )  ; 	[BUGGY] return super . describeTo ( true )  ; [CE] no suitable method found for describeTo(boolean)  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { [ATTENTION] return super . describeTo ( true ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^21^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  byte[]  &&  actual  instanceof  byte[]  )  { 	[BUGGY] else if ( actual instanceof byte[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; [ATTENTION] } else if ( actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^24^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  { 	[BUGGY] else if ( ! wanted instanceof char[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( null , 0 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , true ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( this , this ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( false , false ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { [ATTENTION] return Arrays . equals ( false , true ) actual )  ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^27^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( 0 , this ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , 0 ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  Object[]  &&  actual  instanceof  Object[]  )  { 	[BUGGY]  if ( ! actual instanceof Object[] && actual instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^38^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { [ATTENTION] return Arrays . equals ( this , false ) actual )  ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^29^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( true , true ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( 0 , null ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( null , 0 ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  char[]  &&  actual  instanceof  char[]  )  { 	[BUGGY] else if ( actual instanceof char[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] } else if ( actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REMOVE]   	[BUGGY] if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) {   return equals ( ( ( boolean[] )  ( wanted ) ) ,  ( ( boolean[] )  ( actual ) ) ) ; }else   if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) {     return equals ( ( ( byte[] )  ( wanted ) ) ,  ( ( byte[] )  ( actual ) ) ) ;   }else     if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) {       return equals ( ( ( char[] )  ( wanted ) ) ,  ( ( char[] )  ( actual ) ) ) ;     }else       if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) {         return equals ( ( ( double[] )  ( wanted ) ) ,  ( ( double[] )  ( actual ) ) ) ;       }else         if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) {           return equals ( ( ( float[] )  ( wanted ) ) ,  ( ( float[] )  ( actual ) ) ) ;         }else           if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) {             return equals ( ( ( int[] )  ( wanted ) ) ,  ( ( int[] )  ( actual ) ) ) ;           }else             if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) {               return equals ( ( ( long[] )  ( wanted ) ) ,  ( ( long[] )  ( actual ) ) ) ;             }else               if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) {                 return equals ( ( ( short[] )  ( wanted ) ) ,  ( ( short[] )  ( actual ) ) ) ;               }else                 if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) {                   return equals ( ( ( Object[] )  ( wanted ) ) ,  ( ( Object[] )  ( actual ) ) ) ;                 }[CE] no suitable method found for equals(boolean[] , boolean[])  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; [ATTENTION] } else if ( wanted instanceof char[] && actual instanceof char[] ) { if ( ( wanted instanceof boolean[] ) && ( actual instanceof boolean[] ) ) { return equals ( ( ( boolean[] )  ( wanted ) )  , ( ( boolean[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof byte[] ) && ( actual instanceof byte[] ) ) { return equals ( ( ( byte[] )  ( wanted ) )  , ( ( byte[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof char[] ) && ( actual instanceof char[] ) ) { return equals ( ( ( char[] )  ( wanted ) )  , ( ( char[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof double[] ) && ( actual instanceof double[] ) ) { return equals ( ( ( double[] )  ( wanted ) )  , ( ( double[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof float[] ) && ( actual instanceof float[] ) ) { return equals ( ( ( float[] )  ( wanted ) )  , ( ( float[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof int[] ) && ( actual instanceof int[] ) ) { return equals ( ( ( int[] )  ( wanted ) )  , ( ( int[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof long[] ) && ( actual instanceof long[] ) ) { return equals ( ( ( long[] )  ( wanted ) )  , ( ( long[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof short[] ) && ( actual instanceof short[] ) ) { return equals ( ( ( short[] )  ( wanted ) )  , ( ( short[] )  ( actual ) ) )  ; }else if ( ( wanted instanceof Object[] ) && ( actual instanceof Object[] ) ) { return equals ( ( ( Object[] )  ( wanted ) )  , ( ( Object[] )  ( actual ) ) )  ; }return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^26^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( false , 0 ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 0 , 0 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , null )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( 0 , null ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[ADD]  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  {  return  Arrays  .  equals  (  (  double[]  )  wanted,  (  double[]  )  actual  )  ;  }  else  if  (  wanted  instanceof  float[]  &&  actual  instanceof  float[]  )  {  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY]  return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [CE] illegal start of type  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] } return Arrays . equals ( ( double[] ) wanted , ( double[] ) actual )  ; return Arrays . equals ( ( float[] ) wanted , ( float[] ) actual )  ;   } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^29^30^31^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY]  if ( ! actual instanceof long[] && actual instanceof long[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] }if ( ! actual instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 1 , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 1 , true ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( this , 1 ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY] else if ( ! wanted instanceof short[] && wanted instanceof short[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof short[] && wanted instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY]  if ( ! wanted instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] }if ( ! wanted instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , 0 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( true , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( true , true ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , false ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( null , true ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( false , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( false , 1 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  float[]  )  wanted,  (  float[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 1 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { [ATTENTION] return Arrays . equals ( this , 1 ) actual )  ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^31^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  int[]  )  wanted,  (  int[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { [ATTENTION] return Arrays . equals ( 0 , 0 ) actual )  ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^33^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  long[]  &&  actual  instanceof  long[]  )  { 	[BUGGY] else if ( wanted instanceof long[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; [ATTENTION] } else if ( wanted instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^34^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , false )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( 0 , false ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  double[]  &&  actual  instanceof  double[]  )  { 	[BUGGY] else if ( ! wanted instanceof double[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; [ATTENTION] } else if ( ! wanted instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^28^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  long[]  )  wanted,  (  long[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { [ATTENTION] return Arrays . equals ( this , this ) actual )  ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^35^^^^^18^42^
[REPLACE]  }  else  if  (  wanted  instanceof  short[]  &&  actual  instanceof  short[]  )  { 	[BUGGY]  if ( wanted instanceof short[] ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; [ATTENTION] }if ( wanted instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^36^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  Object[]  )  wanted,  (  Object[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( this , 0 )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { [ATTENTION] return Arrays . equals ( this , 0 ) actual )  ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^39^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  short[]  )  wanted,  (  short[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , true )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { [ATTENTION] return Arrays . equals ( 0 , true ) actual )  ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^37^^^^^18^42^
[REPLACE]  return  super  .  matches  (  actual  )  ; 	[BUGGY] return super . matches ( wanted ) ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { [ATTENTION] return super . matches ( wanted )  ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^21^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  boolean[]  )  wanted,  (  boolean[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( null , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { [ATTENTION] return Arrays . equals ( null , this ) actual )  ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^23^^^^^18^42^
[REPLACE]  return  Arrays  .  equals  (  (  char[]  )  wanted,  (  char[]  )  actual  )  ; 	[BUGGY] return Arrays . equals ( 0 , this )  actual ) ; [CE] ' ; ' expected  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { [ATTENTION] return Arrays . equals ( 0 , this ) actual )  ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^27^^^^^18^42^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object actual wanted  [CONTEXT]  public boolean matches ( Object actual ) { Object wanted = getWanted ( ) ; if ( wanted = = null || actual = = null ) { return super . matches ( actual ) ; } else if ( wanted instanceof boolean[] && actual instanceof boolean[] ) { return Arrays . equals ( ( boolean[] ) wanted ,  ( boolean[] ) actual ) ; } else if ( wanted instanceof byte[] && actual instanceof byte[] ) { return Arrays . equals ( ( byte[] ) wanted ,  ( byte[] ) actual ) ; } else if ( wanted instanceof char[] && actual instanceof char[] ) { return Arrays . equals ( ( char[] ) wanted ,  ( char[] ) actual ) ; } else if ( wanted instanceof double[] && actual instanceof double[] ) { return Arrays . equals ( ( double[] ) wanted ,  ( double[] ) actual ) ; } else if ( wanted instanceof float[] && actual instanceof float[] ) { return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; } else if ( wanted instanceof int[] && actual instanceof int[] ) { return Arrays . equals ( ( int[] ) wanted ,  ( int[] ) actual ) ; } else if ( wanted instanceof long[] && actual instanceof long[] ) { return Arrays . equals ( ( long[] ) wanted ,  ( long[] ) actual ) ; } else if ( wanted instanceof short[] && actual instanceof short[] ) { return Arrays . equals ( ( short[] ) wanted ,  ( short[] ) actual ) ; } else if ( wanted instanceof Object[] && actual instanceof Object[] ) { return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; } [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^41^^^^^18^42^
[REPLACE]  if  (  getWanted  (  )  !=  null  &&  getWanted  (  )    .  getClass  (  )    .  isArray  (  )  )  { 	[BUGGY] if ( getWanted ( )  = = null && getWanted ( ) . getClass ( ) . isArray ( ) ) {[FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] if ( getWanted ( ) = = null && getWanted ( )  . getClass ( )  . isArray ( ) ) { appendArray ( createObjectArray ( getWanted ( ) ) , description ) ; } else { super . describeTo ( description ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^45^^^^^44^50^
[ADD]  if  (  getWanted  (  )  !=  null  &&  getWanted  (  )    .  getClass  (  )    .  isArray  (  )  )  {  appendArray  (  createObjectArray  (  getWanted  (  )  )  ,  description  )  ;  }  else  {  super  .  describeTo  (  description  )  ;  } 	[BUGGY] appendArray ( createObjectArray ( getWanted ( ) ) , description ) ; super . describeTo ( description ) ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] appendArray ( createObjectArray ( getWanted ( ) )  , description )  ; super . describeTo ( description )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^45^46^47^48^49^44^50^
[REPLACE]  super  .  describeTo  (  description  )  ; 	[BUGGY] super . Equals ( description ) ; [CE] cannot find symbol  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { if ( getWanted ( ) ! = null && getWanted ( ) . getClass ( ) . isArray ( ) ) { appendArray ( createObjectArray ( getWanted ( ) ) , description ) ; } else { [ATTENTION] super . Equals ( description )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^48^^^^^44^50^
[ADD]  super  .  describeTo  (  description  )  ; 	[BUGGY] [FE]   assertEquals(  "null  " , mock.oneArray(nullArray))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { if ( getWanted ( ) ! = null && getWanted ( ) . getClass ( ) . isArray ( ) ) { appendArray ( createObjectArray ( getWanted ( ) ) , description ) ; } else { [ATTENTION] } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^48^^^^^44^50^
[REPLACE]  appendArray  (  createObjectArray  (  getWanted  (  )  )  ,  description  )  ; 	[BUGGY] if ( getWanted ( ) ! = null && getWanted ( ) . getClass ( ) . isArray ( ) ) { appendArray ( createObjectArray ( getWanted ( ) ) , description ) ; [CE] illegal start of expression  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { if ( getWanted ( ) ! = null && getWanted ( ) . getClass ( ) . isArray ( ) ) { [ATTENTION] if ( getWanted ( ) ! = null && getWanted ( )  . getClass ( )  . isArray ( ) ) { appendArray ( createObjectArray ( getWanted ( ) )  , description )  ; } else { super . describeTo ( description ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^46^^^^^44^50^
[REMOVE]   	[BUGGY] return Arrays . equals ( ( float[] ) wanted ,  ( float[] ) actual ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { if ( getWanted ( ) ! = null && getWanted ( ) . getClass ( ) . isArray ( ) ) { [ATTENTION] appendArray ( createObjectArray ( getWanted ( ) ) , description ) ;  return Arrays . equals ( ( float[] ) wanted , ( float[] ) actual )  ; } else { super . describeTo ( description ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^46^^^^^44^50^
[REPLACE]  description  .  appendText  (    "[  "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { [ATTENTION] description . appendText (   " ,   " )  ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { description . appendText (   " ,   " ) ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^53^^^^^52^61^
[REPLACE]  if  (  i  !=  array  .  length  -  1  )  { 	[BUGGY] if ( i ! = array . length - 0 - 0 ) {[FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; [ATTENTION] if ( i ! = array . length - 0- 0 ) { description . appendText (   " ,   " ) ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^56^^^^^52^61^
[REPLACE]  description  .  appendText  (    ",    "  )  ; 	[BUGGY] description . appendText (   "]  " ) ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { [ATTENTION] description . appendText (   "]  " )  ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^57^^^^^52^61^
[REPLACE]  for  (  int  i  =  0;  i  <  array  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < array . length + 4 ; i++ ) {[FE]  3 assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; [ATTENTION] for ( int i = 0 ; i < array . length + 4 ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { description . appendText (   " ,   " ) ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^54^^^^^52^61^
[REPLACE]  if  (  i  !=  array  .  length  -  1  )  { 	[BUGGY] if ( i ! = array . length ( ) - 1 ) {[CE] cannot find symbol  [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; [ATTENTION] if ( i ! = array . length ( ) - 1 ) { description . appendText (   " ,   " ) ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^56^^^^^52^61^
[ADD]  if  (  i  !=  array  .  length  -  1  )  {  description  .  appendText  (    ",    "  )  ;  } 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; [ATTENTION] description . appendText (   " ,   " )  ;  } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^56^57^58^^^52^61^
[ADD]  description  .  appendText  (    ",    "  )  ; 	[BUGGY] [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { [ATTENTION] } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^57^^^^^52^61^
[REPLACE]  for  (  int  i  =  0;  i  <  array  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < array . length ; i++ ) {[NO-ERROR]  [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; [ATTENTION] for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { description . appendText (   " ,   " ) ; } } description . appendText (   "]  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^54^^^^^52^61^
[REPLACE]  description  .  appendText  (    "]  "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  appendArray [TYPE] void [PARAMETER] Object[] array Description description [CLASS] ArrayEquals  [TYPE] Description description [TYPE] boolean false true [TYPE] Object[] array [TYPE] int i  [CONTEXT]  private void appendArray ( Object[] array , Description description ) { description . appendText (   "[  " ) ; for ( int i = 0 ; i < array . length ; i++ ) { new Equals ( array[i] ) . describeTo ( description ) ; if ( i ! = array . length - 1 ) { description . appendText (   " ,   " ) ; } } [ATTENTION] description . appendText (   " ,   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^60^^^^^52^61^
[REPLACE]  if  (  array  instanceof  Object[]  )  { 	[BUGGY] if ( ! array instanceof Object[] ) {[CE] bad operand type Object for unary operator '!'  [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { [ATTENTION] if ( ! array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { result[i] = Array . get ( array , i ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^64^^^^^63^72^
[REPLACE]  return  (  Object[]  )  array; 	[BUGGY] return Arrays . equals ( ( Object[] ) wanted ,  ( Object[] ) actual ) ; [CE] wanted has private access in Equals  [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { [ATTENTION] return Arrays . equals ( ( Object[] ) wanted , ( Object[] ) actual )  ; } Object[] result = new Object[Array . getLength ( array ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { result[i] = Array . get ( array , i ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^65^^^^^63^72^
[REPLACE]  Object[]  result  =  new  Object[Array  .  getLength  (  array  )  ]; 	[BUGGY] Object[] result = new Object[Array . get ( array , i ) ] ; [CE] cannot find symbol i  [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } [ATTENTION] Object[] result = new Object[Array . get ( array , i ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { result[i] = Array . get ( array , i ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^67^^^^^63^72^
[REPLACE]  for  (  int  i  =  0;  i  <  Array  .  getLength  (  array  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < =  Array . getLength ( array ) ; i++ ) {[FE] NullPointerException assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; [ATTENTION] for ( int i = 0 ; i< = Array . getLength ( array )  ; i++ ) { result[i] = Array . get ( array , i ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^68^^^^^63^72^
[REPLACE]  result[i]  =  Array  .  get  (  array,  i  )  ; 	[BUGGY] result[i]  = null ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { [ATTENTION] result[i] = null ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^69^^^^^63^72^
[REPLACE]  result[i]  =  Array  .  get  (  array,  i  )  ; 	[BUGGY] result[i]  =  result[i] ; [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { [ATTENTION] result[i] = result[i] ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^69^^^^^63^72^
[REPLACE]  for  (  int  i  =  0;  i  <  Array  .  getLength  (  array  )  ;  i++  )  { 	[BUGGY] for ( int i = 2 ; i < Array . getLength ( array ) ; i++ ) {[FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; [ATTENTION] for ( int i = 2 ; i < Array . getLength ( array )  ; i++ ) { result[i] = Array . get ( array , i ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^68^^^^^63^72^
[ADD]  for  (  int  i  =  0;  i  <  Array  .  getLength  (  array  )  ;  i++  )  {  result[i]  =  Array  .  get  (  array,  i  )  ;  } 	[BUGGY] [FE]  This substring: assertThat(invocation.toString() , endsWith(  "oneArray([1 , 2 , 3])   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; [ATTENTION]  return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^68^69^70^^^63^72^
[REPLACE]  return  result; 	[BUGGY] return ( Object[] ) array ; [FE]  [I cannot be cast to [Ljava.lang.Object   [METHOD]  createObjectArray [TYPE] Object[] [PARAMETER] Object array [CLASS] ArrayEquals  [TYPE] boolean false true [TYPE] Object array [TYPE] Object[] result [TYPE] int i  [CONTEXT]  public static Object[] createObjectArray ( Object array ) { if ( array instanceof Object[] ) { return ( Object[] ) array ; } Object[] result = new Object[Array . getLength ( array ) ] ; for ( int i = 0 ; i < Array . getLength ( array ) ; i++ ) { result[i] = Array . get ( array , i ) ; } [ATTENTION] return ( Object[] ) array ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/ArrayEquals.java^71^^^^^63^72^
[REPLACE]  private  final  Comparable<T>  wanted; 	[BUGGY] private Comparable<T> wanted ; [NO-ERROR]  [CONTEXT]    [CLASS] CompareTo  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^12^^^^^^^
[REPLACE]  this  .  wanted  =  value; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Comparable) [PARAMETER] Comparable<T> value [CLASS] CompareTo  [TYPE] Comparable value wanted [TYPE] boolean false true  [CONTEXT]  public CompareTo ( Comparable<T> value ) { [ATTENTION] this . wanted = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^15^^^^^14^16^
[REPLACE]  if  (  !  (  actual  instanceof  Comparable  )  )  { 	[BUGGY] if ( ! ! ( actual instanceof Comparable ) ) {[FE] AssertionFailedError [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] CompareTo  [TYPE] Comparable value wanted [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] if ( ! ! ( actual instanceof Comparable ) ) { return false ; } return matchResult ( ( ( Comparable ) actual ) . compareTo ( wanted ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^21^^^^^19^26^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] CompareTo  [TYPE] Comparable value wanted [TYPE] Object actual [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Object actual ) { if ( ! ( actual instanceof Comparable ) ) { [ATTENTION] return true ; } return matchResult ( ( ( Comparable ) actual ) . compareTo ( wanted ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^22^^^^^19^26^
[REPLACE]  description  .  appendText  (  getName  (  )  +    "  (    "  +  wanted  +    "  )    "  )  ; 	[BUGGY] description . appendText ( getName ( )  < =    " (   " < =  wanted < =    " )   " ) ; [CE] bad operand types for binary operator  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] CompareTo  [TYPE] Comparable value wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText ( getName ( ) < =   " (   "< = wanted< =   " )   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^29^^^^^28^30^
[REPLACE]  description  .  appendText  (  getName  (  )  +    "  (    "  +  wanted  +    "  )    "  )  ; 	[BUGGY] return matchResult ( ( ( Comparable ) actual ) . compareTo ( wanted ) ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] CompareTo  [TYPE] Comparable value wanted [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] return matchResult ( ( ( Comparable ) actual )  . compareTo ( wanted ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/CompareTo.java^29^^^^^28^30^
[REPLACE]  this  .  matchers  =  matchers; 	[BUGGY] this . matchers =  this ; [CE] incompatible types  [METHOD]  <init> [TYPE] List) [PARAMETER] Matcher> matchers [CLASS] Or  [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public Or ( List<Matcher> matchers ) { [ATTENTION] this . matchers = this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^20^^^^^19^21^
[REPLACE]  if  (  matcher  .  matches  (  actual  )  )  { 	[BUGGY] if ( matcher . matches ( actual )  ) {[NO-ERROR]  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Or  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { [ATTENTION] if ( matcher . matches ( actual )  ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^25^^^^^23^30^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<0> but was:<null> assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Or  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { [ATTENTION] return false ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^26^^^^^23^30^
[REPLACE]  for  (  Matcher  matcher  :  matchers  )  { 	[BUGGY] for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) {[CE] illegal start of expression  [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Or  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { [ATTENTION] for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^24^^^^^23^30^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<null> but was:<8> assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  matches [TYPE] boolean [PARAMETER] Object actual [CLASS] Or  [TYPE] List matchers [TYPE] Object actual [TYPE] boolean false true [TYPE] Matcher matcher  [CONTEXT]  public boolean matches ( Object actual ) { for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^29^^^^^23^30^
[REPLACE]  description  .  appendText  (    "or  (    "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  AssertionFailedError  expected:<[or(]1 , 2)> but was:<[ , ]1 , 2)> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { [ATTENTION] description . appendText (   " ,   " )  ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^33^^^^^32^41^
[REPLACE]  if  (  it  .  hasNext  (  )  )  { 	[BUGGY] if ( it . next ( )  ) {[CE] incompatible types  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION] if ( it . next ( )  ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^36^^^^^32^41^
[ADD]  if  (  it  .  hasNext  (  )  )  {  description  .  appendText  (    ",    "  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<or(1[ , ]2)> but was:<or(1[]2)> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION]  } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^36^37^38^^^32^41^
[REPLACE]  description  .  appendText  (    ",    "  )  ; 	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<or(1[ , ] 2)> but was:<or(1[ )] 2)> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { [ATTENTION] description . appendText (   " )   " )  ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^37^^^^^32^41^
[REPLACE]  for  (  Iterator<Matcher>  it  =  matchers  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator<Matcher> null = matchers . iterator ( ) ; it . hasNext ( ) ; ) {[CE] not a statement  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; [ATTENTION] for ( Iterator<Matcher> null = matchers . iterator ( )  ; it . hasNext ( )  ;  ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^34^^^^^32^41^
[REPLACE]  if  (  it  .  hasNext  (  )  )  { 	[BUGGY] if ( true . hasNext ( ) ) {[CE] boolean cannot be dereferenced  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION] if ( true . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^36^^^^^32^41^
[ADD]  if  (  it  .  hasNext  (  )  )  {  description  .  appendText  (    ",    "  )  ;  } 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  AssertionFailedError  expected:<or(1 , 2[])> but was:<or(1 , 2[ , ])> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; [ATTENTION] description . appendText (   " ,   " )  ;  } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^36^37^38^^^32^41^
[REMOVE]   	[BUGGY] description . appendText (   " )   " ) ; [FE]  AssertionFailedError  expected:<or(1 , []2)> but was:<or(1 , [ ) ]2)> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { [ATTENTION] description . appendText (   " ,   " ) ;  description . appendText (   " )   " )  ; } } description . appendText (   " )   " ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^37^^^^^32^41^
[REPLACE]  for  (  Iterator<Matcher>  it  =  matchers  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) {[CE] reached end of file while parsing  [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; [ATTENTION] for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } description . appendText (   " )   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^34^^^^^32^41^
[REPLACE]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] description . appendText (   " ,   " ) ; [FE]  AssertionFailedError  expected:<or(1 , 2[)]> but was:<or(1 , 2[ , ]> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } [ATTENTION] description . appendText (   " ,   " )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^40^^^^^32^41^
[ADD]  description  .  appendText  (    "  )    "  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<or(1 , 2[)]> but was:<or(1 , 2[]> assertEquals(  "or(1 , 2)  " , describe(new Or(matchers)))   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] Or  [TYPE] Iterator it [TYPE] List matchers [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void describeTo ( Description description ) { description . appendText (   "or (   " ) ; for ( Iterator<Matcher> it = matchers . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . describeTo ( description ) ; if ( it . hasNext ( ) ) { description . appendText (   " ,   " ) ; } } [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/matchers/Or.java^40^^^^^32^41^
[REPLACE]  private  final  MockitoCore  mockitoCore  =  new  MockitoCore  (  )  ; 	[BUGGY] private final MockitoCore mockitoCore  = null ; [FE] [CONTEXT]    [CLASS] InOrderImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^23^^^^^^^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter ; [CE] variable reporter might not have been initialized  [CONTEXT]    [CLASS] InOrderImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^24^^^^^^^
[REPLACE]  private  final  List<Object>  mocksToBeVerifiedInOrder  =  new  LinkedList<Object>  (  )  ; 	[BUGGY] private final List<Object> mocksToBeVerifiedInOrder  = null ; [FE] [CONTEXT]    [CLASS] InOrderImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^25^^^^^^^
[REPLACE]  this  .  mocksToBeVerifiedInOrder  .  addAll  (  mocksToBeVerifiedInOrder  )  ; 	[BUGGY] this . mocksToBeVerifiedInOrder . addAll ( this ) ; [CE] no suitable method found for addAll(InOrderImpl)  [METHOD]  <init> [TYPE] List) [PARAMETER] Object> mocksToBeVerifiedInOrder [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public InOrderImpl ( List<Object> mocksToBeVerifiedInOrder ) { [ATTENTION] this . mocksToBeVerifiedInOrder . addAll ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^28^^^^^27^29^
[REPLACE]  return  this  .  verify  (  mock,  VerificationModeFactory  .  times  (  1  )  )  ; 	[BUGGY] return this . verify ( mock )  ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock ) { [ATTENTION] return this . verify ( mock ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^32^^^^^31^33^
[REPLACE]  if  (  !mocksToBeVerifiedInOrder  .  contains  (  mock  )  )  { 	[BUGGY] if ( mocksToBeVerifiedInOrder . contains ( mock ) ) {[FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { [ATTENTION] if ( mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass ( ) . getSimpleName ( ) +   " is not implemented to work with InOrder  " ) ; } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^36^^^^^35^42^
[REPLACE]  }  else  if  (  !  (  mode  instanceof  VerificationInOrderMode  )  )  { 	[BUGGY]  else {[FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; [ATTENTION] }else { throw new MockitoException ( mode . getClass ( ) . getSimpleName ( ) +   " is not implemented to work with InOrder  " ) ; } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^38^^^^^35^42^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { [ATTENTION] return ; } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^39^^^^^35^42^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] reporter . inOrderRequiresFamiliarMock ( ) ; [FE]  AssertionFailedError  expected:<[AtMost is not implemented to work with InOrder]> but was:<[ assertEquals(  "AtMost is not implemented to work with InOrder  " , e.getMessage())   [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { [ATTENTION] reporter . inOrderRequiresFamiliarMock ( )  ; } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^39^^^^^35^42^
[ADD]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] [FE]  org.mockito.internal.verification.AtMost cannot be cast to org.mockito.internal.verification.api.VerificationInOrderMode assertEquals(  "AtMost is not implemented to work with InOrder  " , e.getMessage())   [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { [ATTENTION] } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^39^^^^^35^42^
[REPLACE]  reporter  .  inOrderRequiresFamiliarMock  (  )  ; 	[BUGGY] reporter . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { [ATTENTION] reporter . Reporter ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass ( ) . getSimpleName ( ) +   " is not implemented to work with InOrder  " ) ; } return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^37^^^^^35^42^
[ADD]  else  if  (  !  (  mode  instanceof  VerificationInOrderMode  )  )  {  throw  new  MockitoException  (  "    ")  ;  } 	[BUGGY] [FE]  org.mockito.internal.verification.AtMost cannot be cast to org.mockito.internal.verification.api.VerificationInOrderMode assertEquals(  "AtMost is not implemented to work with InOrder  " , e.getMessage())   [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; [ATTENTION] }  return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^38^39^40^^^35^42^
[REPLACE]  return  mockitoCore  .  verify  (  mock,  new  InOrderWrapper  (  (  VerificationInOrderMode  )  mode,  mocksToBeVerifiedInOrder  )  )  ; 	[BUGGY] return mockitoCore . verify ( mock )  ) ; [CE] ' ; ' expected  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] InOrderImpl  [TYPE] MockitoCore mockitoCore [TYPE] List mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( !mocksToBeVerifiedInOrder . contains ( mock ) ) { reporter . inOrderRequiresFamiliarMock ( ) ; } else if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass ( ) . getSimpleName ( ) +   " is not implemented to work with InOrder  " ) ; } [ATTENTION] return mockitoCore . verify ( mock )  )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/InOrderImpl.java^41^^^^^35^42^
[REPLACE]  private  String  name; 	[BUGGY] private char name ; [CE] incompatible types  [CONTEXT]    [CLASS] MockSettingsImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^14^^^^^^^
[REPLACE]  if  (  extraInterfaces  ==  null  ||  extraInterfaces  .  length  ==  0  )  { 	[BUGGY] if ( null = = this ) {[FE] AssertionFailedError [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { [ATTENTION] if ( null = = this ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^19^^^^^18^32^
[ADD]  if  (  extraInterfaces  ==  null  ||  extraInterfaces  .  length  ==  0  )  {  new  Reporter  (  )    .  extraInterfacesRequiresAtLeastOneInterface  (  )  ;  } 	[BUGGY] new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; [FE]   assertEquals(List.class , mockSettingsImpl.getExtraInterfaces()[0])   [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { [ATTENTION] new Reporter ( )  . extraInterfacesRequiresAtLeastOneInterface ( )  ;   for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^19^20^21^^^18^32^
[REPLACE]  new  Reporter  (  )    .  extraInterfacesRequiresAtLeastOneInterface  (  )  ; 	[BUGGY] new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( ) ; [CE] method extraInterfacesAcceptsOnlyInterfaces in class Reporter cannot be applied to given types ;  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { [ATTENTION] new Reporter ( )  . extraInterfacesAcceptsOnlyInterfaces ( )  ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^20^^^^^18^32^
[REPLACE]  if  (  i  ==  null  )  { 	[BUGGY] if ( true ! = true ) {[FE] AssertionFailedError [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { [ATTENTION] if ( true ! = true ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^24^^^^^18^32^
[REPLACE]  }  else  if  (  !i  .  isInterface  (  )  )  { 	[BUGGY]  truef ( !i . isInterface ( ) ) {[CE] ' ; ' expected  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; [ATTENTION] }truef ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^26^^^^^18^32^
[ADD]  else  if  (  !i  .  isInterface  (  )  )  {  new  Reporter  (  )    .  extraInterfacesAcceptsOnlyInterfaces  (  i  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; [ATTENTION] }  } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^26^27^28^^^18^32^
[REPLACE]  new  Reporter  (  )    .  extraInterfacesAcceptsOnlyInterfaces  (  i  )  ; 	[BUGGY] new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( this ) ; [CE] method extraInterfacesAcceptsOnlyInterfaces in class Reporter cannot be applied to given types ;  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { [ATTENTION] new Reporter ( )  . extraInterfacesAcceptsOnlyInterfaces ( this )  ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^27^^^^^18^32^
[REPLACE]  new  Reporter  (  )    .  extraInterfacesDoesNotAcceptNullParameters  (  )  ; 	[BUGGY] new Reporter ( )  . extraInterfacesAcceptsOnlyInterfaces ( this )  ; [CE] method extraInterfacesAcceptsOnlyInterfaces in class Reporter cannot be applied to given types ;  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { [ATTENTION] new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( this ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^25^^^^^18^32^
[REPLACE]  }  else  if  (  !i  .  isInterface  (  )  )  { 	[BUGGY]  else {[FE]   assertEquals(List.class , mockSettingsImpl.getExtraInterfaces()[0])   [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; [ATTENTION] }else { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^26^^^^^18^32^
[REPLACE]  new  Reporter  (  )    .  extraInterfacesAcceptsOnlyInterfaces  (  i  )  ; 	[BUGGY] new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( null ) ; [FE] AssertionFailedError [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { [ATTENTION] new Reporter ( )  . extraInterfacesAcceptsOnlyInterfaces ( null )  ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^27^^^^^18^32^
[ADD]  new  Reporter  (  )    .  extraInterfacesAcceptsOnlyInterfaces  (  i  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { [ATTENTION] } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^27^^^^^18^32^
[REPLACE]  for  (  Class<?>  i  :  extraInterfaces  )  { 	[BUGGY] for ( Class<?> i : extraInterfaces ) { if ( i = = null ) {[CE] illegal start of expression  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } [ATTENTION] for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^23^^^^^18^32^
[REPLACE]  this  .  extraInterfaces  =  extraInterfaces; 	[BUGGY] this . extraInterfaces =  this ; [CE] incompatible types  [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } [ATTENTION] this . extraInterfaces = this ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^30^^^^^18^32^
[ADD]  this  .  extraInterfaces  =  extraInterfaces; 	[BUGGY] [FE] NullPointerException assertEquals(List.class , mockSettingsImpl.getExtraInterfaces()[0])   [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^30^^^^^18^32^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertContains(  "You mocked following type: IMethods  " , e.getMessage())   [METHOD]  extraInterfaces [TYPE] MockSettings [PARAMETER] extraInterfaces [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class i [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings extraInterfaces ( Class<?> . . . extraInterfaces ) { if ( extraInterfaces = = null || extraInterfaces . length = = 0 ) { new Reporter ( ) . extraInterfacesRequiresAtLeastOneInterface ( ) ; } for ( Class<?> i : extraInterfaces ) { if ( i = = null ) { new Reporter ( ) . extraInterfacesDoesNotAcceptNullParameters ( ) ; } else if ( !i . isInterface ( ) ) { new Reporter ( ) . extraInterfacesAcceptsOnlyInterfaces ( i ) ; } } this . extraInterfaces = extraInterfaces ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^31^^^^^18^32^
[REPLACE]  return  name; 	[BUGGY] return extraInterfaces ; [CE] incompatible types  [METHOD]  getMockName [TYPE] String [PARAMETER] [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public String getMockName ( ) { [ATTENTION] return extraInterfaces ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^35^^^^^34^36^
[REPLACE]  return  extraInterfaces; 	[BUGGY] return defaultAnswer ; [CE] incompatible types  [METHOD]  getExtraInterfaces [TYPE] Class[] [PARAMETER] [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public Class<?>[] getExtraInterfaces ( ) { [ATTENTION] return defaultAnswer ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^39^^^^^38^40^
[REPLACE]  return  spiedInstance; 	[BUGGY] return extraInterfaces ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  getSpiedInstance [TYPE] Object [PARAMETER] [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public Object getSpiedInstance ( ) { [ATTENTION] return extraInterfaces ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^43^^^^^42^44^
[REPLACE]  this  .  name  =  name; 	[BUGGY] this . name =  null ; [FE] AssertionFailedError [METHOD]  name [TYPE] MockSettings [PARAMETER] String name [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings name ( String name ) { [ATTENTION] this . name = null ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^47^^^^^46^49^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  name [TYPE] MockSettings [PARAMETER] String name [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings name ( String name ) { this . name = name ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^48^^^^^46^49^
[REPLACE]  this  .  spiedInstance  =  spiedInstance; 	[BUGGY] this . spiedInstance =  null ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  spiedInstance [TYPE] MockSettings [PARAMETER] Object spiedInstance [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings spiedInstance ( Object spiedInstance ) { [ATTENTION] this . spiedInstance = null ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^52^^^^^51^54^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  spiedInstance [TYPE] MockSettings [PARAMETER] Object spiedInstance [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings spiedInstance ( Object spiedInstance ) { this . spiedInstance = spiedInstance ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^53^^^^^51^54^
[REPLACE]  this  .  defaultAnswer  =  defaultAnswer; 	[BUGGY] this . defaultAnswer =  null ; [FE] AssertionFailedError [METHOD]  defaultAnswer [TYPE] MockSettings [PARAMETER] Answer defaultAnswer [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings defaultAnswer ( Answer defaultAnswer ) { [ATTENTION] this . defaultAnswer = null ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^58^^^^^57^60^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  defaultAnswer [TYPE] MockSettings [PARAMETER] Answer defaultAnswer [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public MockSettings defaultAnswer ( Answer defaultAnswer ) { this . defaultAnswer = defaultAnswer ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^59^^^^^57^60^
[REPLACE]  return  defaultAnswer; 	[BUGGY] return extraInterfaces ; [CE] incompatible types  [METHOD]  getDefaultAnswer [TYPE] Answer [PARAMETER] [CLASS] MockSettingsImpl  [TYPE] Answer defaultAnswer [TYPE] Object spiedInstance [TYPE] Class[] extraInterfaces [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public Answer<Object> getDefaultAnswer ( ) { [ATTENTION] return extraInterfaces ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MockSettingsImpl.java^63^^^^^62^64^
[REPLACE]  private  final  Method  hashCodeMethod; 	[BUGGY] private Method hashCodeMethod ; [NO-ERROR]  [CONTEXT]    [CLASS] MethodInterceptorFilter  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^17^^^^^^^
[REPLACE]  if  (  toMock  .  isInterface  (  )  )  { 	[BUGGY] if ( toMock . getMethod ( null , 1 )  ) {[CE] method getMethod in class Class<T> cannot be applied to given types ;  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { [ATTENTION] if ( toMock . getMethod ( null , 1 )  ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^24^^^^^22^34^
[ADD]  if  (  toMock  .  isInterface  (  )  )  {  toMock  =  Object  .  class;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { [ATTENTION]  equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^24^25^26^^^22^34^
[REPLACE]  toMock  =  Object  .  class; 	[BUGGY] toMock ; [CE] not a statement  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { [ATTENTION] toMock ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^25^^^^^22^34^
[ADD]  try  {  if  (  toMock  .  isInterface  (  )  )  {  toMock  =  Object  .  class;  } 	[BUGGY] toMock = Object . class ; [CE] illegal start of type  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { [ATTENTION] toMock = Object . class ;   equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^23^24^25^26^^22^34^
[REPLACE]  if  (  toMock  .  isInterface  (  )  )  { 	[BUGGY] if ( equalsMethod . equals ( method ) ) {[CE] cannot find symbol method  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { [ATTENTION] if ( equalsMethod . equals ( method ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^24^^^^^22^34^
[ADD]  toMock  =  Object  .  class; 	[BUGGY] [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { [ATTENTION] } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^25^^^^^22^34^
[REPLACE]  equalsMethod  =  toMock  .  getMethod  (    "equals  ",  new  Class[]  {  Object  .  class  }  )  ; 	[BUGGY] equalsMethod =  null . getMethod (   "equals  " , new Class[] { Object . class } ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } [ATTENTION] equalsMethod = null . getMethod (   "equals  " , new Class[] { Object . class } )  ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^27^^^^^22^34^
[REPLACE]  hashCodeMethod  =  toMock  .  getMethod  (    "hashCode  ",  (  Class[]  )  null  )  ; 	[BUGGY] hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) true ) ; [CE] inconvertible types  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; [ATTENTION] hashCodeMethod = toMock . getMethod (   "hashCode  " , ( Class[] ) true )  ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^28^^^^^22^34^
[ADD]  hashCodeMethod  =  toMock  .  getMethod  (    "hashCode  ",  (  Class[]  )  null  )  ; 	[BUGGY] [CE] variable hashCodeMethod might not have been initialized  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; [ATTENTION] } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^28^^^^^22^34^
[REPLACE]  throw  new  RuntimeException  (    "\nSomething  went  really  wrong  .    Object  method  could  not  be  found!  "  +    "\n  please  report  it  to  the  mocking  mailing  list  at  http:  } 	[BUGGY] throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http: ; [CE] unclosed string literal  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { [ATTENTION] throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http: ;  this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^30^31^32^^^22^34^
[ADD]  throw  new  RuntimeException  (    "\nSomething  went  really  wrong  .    Object  method  could  not  be  found!  "  +    "\n  please  report  it  to  the  mocking  mailing  list  at  http:  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { [ATTENTION]  this . delegate = delegate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^30^31^32^^^22^34^
[REPLACE]  this  .  delegate  =  delegate; 	[BUGGY] this . delegate =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class , T [PARAMETER] Class toMock T delegate [CLASS] MethodInterceptorFilter  [TYPE] Class toMock [TYPE] Method equalsMethod hashCodeMethod [TYPE] boolean false true [TYPE] T delegate [TYPE] NoSuchMethodException e  [CONTEXT]  public MethodInterceptorFilter ( Class toMock , T delegate ) { try { if ( toMock . isInterface ( ) ) { toMock = Object . class ; } equalsMethod = toMock . getMethod (   "equals  " , new Class[] { Object . class } ) ; hashCodeMethod = toMock . getMethod (   "hashCode  " ,  ( Class[] ) null ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException (   "\nSomething went really wrong . Object method could not be found!  " +   "\n please report it to the mocking mailing list at http://mockito . org  " ) ; } [ATTENTION] this . delegate = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^33^^^^^22^34^
[REPLACE]  if  (  equalsMethod  .  equals  (  method  )  )  { 	[BUGGY] if ( toMock . isInterface ( ) ) {[CE] cannot find symbol toMock  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { [ATTENTION] if ( toMock . isInterface ( ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; } else if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^38^^^^^36^47^
[ADD]  if  (  equalsMethod  .  equals  (  method  )  )  {  return  Boolean  .  valueOf  (  proxy  ==  args[0]  )  ;  }  else  if  (  hashCodeMethod  .  equals  (  method  )  )  {  return  hashCodeForMock  (  proxy  )  ;  } 	[BUGGY] return Boolean . valueOf ( proxy = = args[0] ) ; return hashCodeForMock ( proxy ) ; [CE] unreachable statement  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { [ATTENTION] return Boolean . valueOf ( proxy = = args[0] )  ; return hashCodeForMock ( proxy )  ;    new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^38^39^40^41^42^36^47^
[REPLACE]  }  else  if  (  hashCodeMethod  .  equals  (  method  )  )  { 	[BUGGY]  if ( hashCodeMethod . equals ( hashCodeMethod ) ) {[FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; [ATTENTION] }if ( hashCodeMethod . equals ( hashCodeMethod ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^40^^^^^36^47^
[ADD]  else  if  (  hashCodeMethod  .  equals  (  method  )  )  {  return  hashCodeForMock  (  proxy  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; [ATTENTION] }  new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^40^41^42^^^36^47^
[REPLACE]  return  hashCodeForMock  (  proxy  )  ; 	[BUGGY] return delegate . intercept ( proxy , method , args , methodProxy ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; } else if ( hashCodeMethod . equals ( method ) ) { [ATTENTION] return delegate . intercept ( proxy , method , args , methodProxy )  ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^41^^^^^36^47^
[REPLACE]  return  Boolean  .  valueOf  (  proxy  ==  args[0]  )  ; 	[BUGGY] return Boolean . valueOf ( proxy || args[0] ) ; [CE] bad operand types for binary operator '||'  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { [ATTENTION] return Boolean . valueOf ( proxy||args[0] )  ; } else if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^39^^^^^36^47^
[REPLACE]  }  else  if  (  hashCodeMethod  .  equals  (  method  )  )  { 	[BUGGY]  if ( hashCodeMethod . equals ( method ) ) {[NO-ERROR]  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; [ATTENTION] }if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^40^^^^^36^47^
[REPLACE]  return  Boolean  .  valueOf  (  proxy  ==  args[0]  )  ; 	[BUGGY] return Boolean . valueOf ( proxy && args[0] ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { [ATTENTION] return Boolean . valueOf ( proxy&&args[0] )  ; } else if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^39^^^^^36^47^
[REPLACE]  new  CGLIBHacker  (  )    .  setMockitoNamingPolicy  (  methodProxy  )  ; 	[BUGGY] new CGLIBHacker ( )  . CGLIBHacker ( )  ; [CE] cannot find symbol  [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; } else if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } [ATTENTION] new CGLIBHacker ( ) . CGLIBHacker ( ) ;  return delegate . intercept ( proxy , method , args , methodProxy ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^44^^^^^36^47^
[REPLACE]  return  delegate  .  intercept  (  proxy,  method,  args,  methodProxy  )  ; 	[BUGGY] return delegate . intercept ( proxy , hashCodeMethod , args , methodProxy ) ; [FE] AssertionFailedError [METHOD]  intercept [TYPE] Object [PARAMETER] Object proxy Method method Object[] args MethodProxy methodProxy [CLASS] MethodInterceptorFilter  [TYPE] MethodProxy methodProxy [TYPE] Object proxy [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate [TYPE] Object[] args  [CONTEXT]  public Object intercept ( Object proxy , Method method , Object[] args , MethodProxy methodProxy ) throws Throwable { if ( equalsMethod . equals ( method ) ) { return Boolean . valueOf ( proxy = = args[0] ) ; } else if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; } new CGLIBHacker ( ) . setMockitoNamingPolicy ( methodProxy ) ;  [ATTENTION] return delegate . intercept ( proxy , hashCodeMethod , args , methodProxy )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^46^^^^^36^47^
[REPLACE]  return  new  Integer  (  System  .  identityHashCode  (  mock  )  )  ; 	[BUGGY] return new Integer (  mock  ) ; [CE] no suitable constructor found for Integer(Object)  [METHOD]  hashCodeForMock [TYPE] int [PARAMETER] Object mock [CLASS] MethodInterceptorFilter  [TYPE] Object mock [TYPE] Method equalsMethod hashCodeMethod method [TYPE] boolean false true [TYPE] T delegate  [CONTEXT]  private int hashCodeForMock ( Object mock ) { [ATTENTION] return new Integer ( mock )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/MethodInterceptorFilter.java^50^^^^^49^51^
[REPLACE]  public  static  final  ClassImposterizer  INSTANCE  =  new  ClassImposterizer  (  )  ; 	[BUGGY] public static ClassImposterizer INSTANCE = new ClassImposterizer ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  	None^30^^^^^^^
[REPLACE]  private  ObjenesisStd  objenesis  =  new  ObjenesisStd  (  )  ; 	[BUGGY] private ObjenesisStd objenesis  = null ; [FE] [CONTEXT]    [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  	None^37^^^^^^^
[REPLACE]  private  static  final  NamingPolicy  NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  =  new  MockitoNamingPolicy  (  )  { 	[BUGGY] private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  = null ; [CE] class , interface , or enum expected  [CONTEXT]  [ATTENTION] private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = null ; @Override public String getClassName ( String prefix , String source , Object key , Predicate names ) { return   "codegen .   " + super . getClassName ( prefix , source , key , names ) ; } } ;   [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  	None^39^^^^^39^44^
[REPLACE]  private  static  final  CallbackFilter  IGNORE_BRIDGE_METHODS  =  new  CallbackFilter  (  )  { 	[BUGGY] private static final CallbackFilter IGNORE_BRIDGE_METHODS ; [CE] class , interface , or enum expected  [CONTEXT]  [ATTENTION] private static final CallbackFilter IGNORE_BRIDGE_METHODS ; public int accept ( Method method ) { return method . isBridge ( ) ? 1 : 0 ; } } ;   [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  	None^46^^^^^46^50^
[REPLACE]  return    "codegen  .    "  +  super  .  getClassName  (  prefix,  source,  key,  names  )  ; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  getClassName [TYPE] String [PARAMETER] String prefix String source Object key Predicate names [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Object key [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] String prefix source [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES [TYPE] Predicate names  [CONTEXT]  public String getClassName ( String prefix , String source , Object key , Predicate names ) { [ATTENTION] return true ; }  	None^42^^^^^41^43^
[REPLACE]  return  method  .  isBridge  (  )  ?  1  :  0; 	[BUGGY] return method . isBridge ( ) ? 4 : 0 ; [FE] AssertionFailedError [METHOD]  accept [TYPE] int [PARAMETER] Method method [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] Method method [TYPE] boolean false true [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES [TYPE] ClassImposterizer INSTANCE  [CONTEXT]  public int accept ( Method method ) { [ATTENTION] return method . isBridge ( ) ? 4 : 0 ; }  	None^48^^^^^47^49^
[REPLACE]  return  !type  .  isPrimitive  (  )  &&  !Modifier  .  isFinal  (  type  .  getModifiers  (  )  )  &&  !type  .  isAnonymousClass  (  )  ; 	[BUGGY] return type . isPrimitive ( ) && !Modifier . isPrivate ( type . getModifiers ( ) ) && true ( ) ; [CE] ' ; ' expected  [METHOD]  canImposterise [TYPE] boolean [PARAMETER] Class<?> type [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] Class type [TYPE] ObjenesisStd objenesis [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] boolean false true [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES [TYPE] ClassImposterizer INSTANCE  [CONTEXT]  public boolean canImposterise ( Class<?> type ) { [ATTENTION] return type . isPrimitive ( ) && !Modifier . isPrivate ( type . getModifiers ( ) ) && true ( )  ; }  	None^53^^^^^52^54^
[ADD]  try  {  setConstructorsAccessible  (  mockedType,  true  )  ;  Class<?>  proxyClass  =  createProxyClass  (  mockedType,  ancillaryTypes  )  ;  return  mockedType  .  cast  (  createProxy  (  proxyClass,  interceptor  )  )  ;  }  finally  { 	[BUGGY] setConstructorsAccessible ( mockedType , true ) ; Class<?> proxyClass = createProxyClass ( mockedType , ancillaryTypes ) ; return mockedType . cast ( createProxy ( proxyClass , interceptor ) ) ; [CE] class , interface , or enum expected  [METHOD]  imposterise [TYPE] <T> [PARAMETER] MethodInterceptor interceptor Class<T> mockedType ancillaryTypes [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] Class[] ancillaryTypes [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  public <T> T imposterise ( final MethodInterceptor interceptor , Class<T> mockedType , Class<?> . . . ancillaryTypes ) { [ATTENTION] setConstructorsAccessible ( mockedType , true )  ; Class<?> proxyClass = createProxyClass ( mockedType , ancillaryTypes )  ; return mockedType . cast ( createProxy ( proxyClass , interceptor ) )  ;   setConstructorsAccessible ( mockedType , false ) ; } }  	None^57^58^59^60^61^56^64^
[REPLACE]  return  mockedType  .  cast  (  createProxy  (  proxyClass,  interceptor  )  )  ; 	[BUGGY] return 0 . cast ( createProxy ( proxyClass , interceptor ) ) ; [CE] ' ; ' expected  [METHOD]  imposterise [TYPE] <T> [PARAMETER] MethodInterceptor interceptor Class<T> mockedType ancillaryTypes [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] Class[] ancillaryTypes [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  public <T> T imposterise ( final MethodInterceptor interceptor , Class<T> mockedType , Class<?> . . . ancillaryTypes ) { try { setConstructorsAccessible ( mockedType , true ) ; Class<?> proxyClass = createProxyClass ( mockedType , ancillaryTypes ) ; [ATTENTION] return 0 . cast ( createProxy ( proxyClass , interceptor ) )  ; } finally { setConstructorsAccessible ( mockedType , false ) ; } }  	None^60^^^^^56^64^
[REPLACE]  Class<?>  proxyClass  =  createProxyClass  (  mockedType,  ancillaryTypes  )  ; 	[BUGGY] Class<?> proxyClass = createProxyClass ( mockedType , null ) ; [FE] AssertionFailedError [METHOD]  imposterise [TYPE] <T> [PARAMETER] MethodInterceptor interceptor Class<T> mockedType ancillaryTypes [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] Class[] ancillaryTypes [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  public <T> T imposterise ( final MethodInterceptor interceptor , Class<T> mockedType , Class<?> . . . ancillaryTypes ) { try { setConstructorsAccessible ( mockedType , true ) ; [ATTENTION] Class<?> proxyClass = createProxyClass ( mockedType , null )  ; return mockedType . cast ( createProxy ( proxyClass , interceptor ) ) ; } finally { setConstructorsAccessible ( mockedType , false ) ; } }  	None^59^^^^^56^64^
[REPLACE]  for  (  Constructor<?>  constructor  :  mockedType  .  getDeclaredConstructors  (  )  )  { 	[BUGGY] for ( Constructor<?> constructor : mockedType . getDeclaredConstructors ( ) ) { constructor . setAccessible ( accessible ) ; [NO-ERROR]  [METHOD]  setConstructorsAccessible [TYPE] void [PARAMETER] Class<?> mockedType boolean accessible [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] boolean accessible false true [TYPE] Constructor constructor [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private void setConstructorsAccessible ( Class<?> mockedType , boolean accessible ) { [ATTENTION] for ( Constructor<?> constructor : mockedType . getDeclaredConstructors ( ) ) { constructor . setAccessible ( accessible )  ; constructor . setAccessible ( accessible ) ; } }  	None^67^^^^^66^70^
[REPLACE]  if  (  mockedType  ==  Object  .  class  )  { 	[BUGGY] if ( false && Object . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { [ATTENTION] if ( false&&Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^73^^^^^72^115^
[ADD]  if  (  mockedType  ==  Object  .  class  )  {  mockedType  =  ClassWithSuperclassToWorkAroundCglibBug  .  class;  } 	[BUGGY] mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; [FE] AssertionFailedError [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { [ATTENTION] mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ;   Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^73^74^75^^^72^115^
[REPLACE]  mockedType  =  ClassWithSuperclassToWorkAroundCglibBug  .  class; 	[BUGGY] mockedType ; [CE] not a statement  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { [ATTENTION] mockedType ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^74^^^^^72^115^
[REPLACE]  Enhancer  enhancer  =  new  Enhancer  (  )  { 	[BUGGY] Enhancer enhancer = new Enhancer ( ) { @Override[CE] duplicate annotation  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } [ATTENTION] Enhancer enhancer = new Enhancer ( ) { @Override @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^77^^^^^72^115^
[REPLACE]  enhancer  .  setClassLoader  (  SearchingClassLoader  .  combineLoadersOf  (  mockedType  )  )  ; 	[BUGGY] enhancer . setClassLoader (  mockedType  ) ; [CE] method setClassLoader in class AbstractClassGenerator cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; [ATTENTION] enhancer . setClassLoader ( mockedType )  ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^84^^^^^72^115^
[REPLACE]  enhancer  .  setClassLoader  (  SearchingClassLoader  .  combineLoadersOf  (  mockedType  )  )  ; 	[BUGGY] enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( this ) ) ; [CE] no suitable method found for combineLoadersOf(ClassImposterizer)  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; [ATTENTION] enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( this ) )  ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^84^^^^^72^115^
[ADD]  enhancer  .  setClassLoader  (  SearchingClassLoader  .  combineLoadersOf  (  mockedType  )  )  ;  enhancer  .  setUseFactory  (  true  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; [ATTENTION]  if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^84^85^^^^72^115^
[REPLACE]  enhancer  .  setUseFactory  (  true  )  ; 	[BUGGY] enhancer . setUseFactory ( false ) ; [FE] AssertionFailedError [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; [ATTENTION] enhancer . setUseFactory ( false )  ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^85^^^^^72^115^
[REMOVE]   	[BUGGY] enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; [ATTENTION] enhancer . setUseFactory ( true ) ;  enhancer . setInterfaces ( prepend ( mockedType , interfaces ) )  ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; }  	None^85^^^^^72^115^
[REPLACE]  if  (  mockedType  .  isInterface  (  )  )  { 	[BUGGY] if ( null . isInterface ( ) ) {[CE] <null> cannot be dereferenced  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; [ATTENTION] if ( null . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^86^^^^^72^115^
[REPLACE]  enhancer  .  setSuperclass  (  mockedType  )  ; 	[BUGGY] enhancer . setInterfaces ( mockedType ) ; [CE] method setInterfaces in class Enhancer cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { [ATTENTION] enhancer . setInterfaces ( mockedType )  ; enhancer . setInterfaces ( interfaces ) ; }  	None^90^^^^^86^92^
[REPLACE]  enhancer  .  setInterfaces  (  interfaces  )  ; 	[BUGGY] enhancer . setInterfaces ( null ) ; [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; [ATTENTION] enhancer . setInterfaces ( null )  ; }  	None^91^^^^^86^92^
[REPLACE]  enhancer  .  setSuperclass  (  Object  .  class  )  ; 	[BUGGY] enhancer . setInterfaces ( null )  ; [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { [ATTENTION] enhancer . setInterfaces ( null ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^87^^^^^72^115^
[ADD]  enhancer  .  setSuperclass  (  Object  .  class  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { [ATTENTION] enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^87^^^^^72^115^
[REPLACE]  enhancer  .  setInterfaces  (  prepend  (  mockedType,  interfaces  )  )  ; 	[BUGGY] enhancer . setSuperclass ( prepend ( mockedType , interfaces ) ) ; [CE] method setSuperclass in class Enhancer cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; [ATTENTION] enhancer . setSuperclass ( prepend ( mockedType , interfaces ) )  ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^88^^^^^72^115^
[REPLACE]  enhancer  .  setInterfaces  (  prepend  (  mockedType,  interfaces  )  )  ; 	[BUGGY] enhancer . setInterfaces ( prepend ( this , interfaces ) ) ; [CE] method prepend in class ClassImposterizer cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; [ATTENTION] enhancer . setInterfaces ( prepend ( this , interfaces ) )  ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^88^^^^^72^115^
[REPLACE]  enhancer  .  setCallbackTypes  (  new  Class[]{MethodInterceptor  .  class,  NoOp  .  class}  )  ; 	[BUGGY] enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; [FE] AssertionFailedError [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } [ATTENTION] enhancer . setInterfaces ( prepend ( mockedType , interfaces ) )  ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^93^^^^^72^115^
[REPLACE]  enhancer  .  setCallbackFilter  (  IGNORE_BRIDGE_METHODS  )  ; 	[BUGGY] enhancer . setNamingPolicy ( IGNORE_BRIDGE_METHODS ) ; [CE] method setNamingPolicy in class AbstractClassGenerator cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; [ATTENTION] enhancer . setNamingPolicy ( IGNORE_BRIDGE_METHODS )  ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^94^^^^^72^115^
[REPLACE]  if  (  mockedType  .  getSigners  (  )  !=  null  )  { 	[BUGGY] if ( null . cast ( )  = = null ) {[CE] <null> cannot be dereferenced  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; [ATTENTION] if ( null . cast ( ) = = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^95^^^^^72^115^
[REPLACE]  enhancer  .  setNamingPolicy  (  MockitoNamingPolicy  .  INSTANCE  )  ; 	[BUGGY] enhancer . setUseFactory ( true )  ; [FE] AssertionFailedError [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { [ATTENTION] enhancer . setUseFactory ( true ) ; }  	None^98^^^^^95^99^
[REPLACE]  enhancer  .  setNamingPolicy  (  NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  )  ; 	[BUGGY] enhancer . setCallbackFilter ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; [CE] method setCallbackFilter in class Enhancer cannot be applied to given types ;  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { [ATTENTION] enhancer . setCallbackFilter ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES )  ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^96^^^^^72^115^
[REMOVE]   	[BUGGY] enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; [NO-ERROR]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { [ATTENTION] enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ;  enhancer . setInterfaces ( prepend ( mockedType , interfaces ) )  ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; }  	None^96^^^^^72^115^
[REPLACE]  if  (  Modifier  .  isPrivate  (  mockedType  .  getModifiers  (  )  )  )  { 	[BUGGY] if ( Modifier . isFinal ( null . getModifiers ( ) ) ) {[CE] <null> cannot be dereferenced  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { [ATTENTION] if ( Modifier . isFinal ( null . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^104^^^^^72^115^
[REPLACE]  throw  new  MockitoException  (    "\n  "  +    "Mockito  cannot  mock  this  class:    "  +  mockedType  +    "  .  \n  "  +    "Most  likely  it  is  a  private  class  that  is  not  visible  by  Mockito  "  )  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { [ATTENTION] return ;   } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^105^106^107^108^^72^115^
[ADD]  try  {  return  enhancer  .  createClass  (  )  ;  }  catch  (  CodeGenerationException  e  )  {  if  (  Modifier  .  isPrivate  (  mockedType  .  getModifiers  (  )  )  )  {  throw  new  MockitoException  (    "\n  " 	[BUGGY] return enhancer . createClass ( ) ; [CE] not a statement  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } [ATTENTION] return enhancer . createClass ( )  ;   +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^101^102^103^104^105^72^115^
[REPLACE]  return  enhancer  .  createClass  (  )  ; 	[BUGGY] return enhancer . Enhancer ( ) ; [CE] cannot find symbol  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { [ATTENTION] return enhancer . Enhancer ( )  ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^102^^^^^72^115^
[REPLACE]  throw  new  MockitoException  (    "\n  "  +    "Mockito  cannot  mock  this  class:    "  +  mockedType  +    "  .  \n  "  +    "Most  likely  it  is  a  private  class  that  is  not  visible  by  Mockito  "  )  ; 	[BUGGY] throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType ; [CE]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { [ATTENTION] throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType ;   } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^105^106^107^108^^72^115^
[REPLACE]  throw  new  MockitoException  (    "\n  "  +    "Mockito  cannot  mock  this  class:    "  +  mockedType  +    "  .  \n  "  +    "Mockito  can  only  mock  visible  &  non-final  classes  "  )  ; 	[BUGGY] throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType ; [CE]  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } [ATTENTION] throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType ;   } }  	None^110^111^112^113^^72^115^
[ADD]  throw  new  MockitoException  (    "\n  "  +    "Mockito  cannot  mock  this  class:    "  +  mockedType  +    "  .  \n  " 	[BUGGY] [CE] not a statement  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; } catch ( CodeGenerationException e ) { if ( Modifier . isPrivate ( mockedType . getModifiers ( ) ) ) { throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } [ATTENTION]  +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^110^111^112^^^72^115^
[ADD]  catch  (  CodeGenerationException  e  )  {  if  (  Modifier  .  isPrivate  (  mockedType  .  getModifiers  (  )  )  )  {  throw  new  MockitoException  (    "\n  " 	[BUGGY] [CE] not a statement  [METHOD]  createProxyClass [TYPE] <T> [PARAMETER] Class<?> mockedType interfaces [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] interfaces [TYPE] boolean false true [TYPE] Enhancer enhancer [TYPE] CodeGenerationException e [TYPE] ClassImposterizer INSTANCE [TYPE] Class mockedType sc [TYPE] List constructors [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private <T> Class<?> createProxyClass ( Class<?> mockedType , Class<?> . . . interfaces ) { if ( mockedType = = Object . class ) { mockedType = ClassWithSuperclassToWorkAroundCglibBug . class ; } Enhancer enhancer = new Enhancer ( ) { @Override @SuppressWarnings (   "unchecked  " ) protected void filterConstructors ( Class sc , List constructors ) {  } } ; enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( mockedType ) ) ; enhancer . setUseFactory ( true ) ; if ( mockedType . isInterface ( ) ) { enhancer . setSuperclass ( Object . class ) ; enhancer . setInterfaces ( prepend ( mockedType , interfaces ) ) ; } else { enhancer . setSuperclass ( mockedType ) ; enhancer . setInterfaces ( interfaces ) ; } enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; enhancer . setCallbackFilter ( IGNORE_BRIDGE_METHODS ) ; if ( mockedType . getSigners ( ) ! = null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy . INSTANCE ) ; } try { return enhancer . createClass ( ) ; [ATTENTION]  +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Most likely it is a private class that is not visible by Mockito  " ) ; } throw new MockitoException (   "\n  " +   "Mockito cannot mock this class:   " + mockedType +   " . \n  " +   "Mockito can only mock visible & non-final classes  " ) ; } }  	None^103^104^105^^^72^115^
[REPLACE]  Factory  proxy  =  (  Factory  )  objenesis  .  newInstance  (  proxyClass  )  ; 	[BUGGY] Factory proxy =  ( Factory ) objenesis . ObjenesisStd ( proxyClass ) ; [CE] cannot find symbol  [METHOD]  createProxy [TYPE] Object [PARAMETER] Class<?> proxyClass MethodInterceptor interceptor [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Factory proxy [TYPE] Class proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Object createProxy ( Class<?> proxyClass , final MethodInterceptor interceptor ) { [ATTENTION] Factory proxy = ( Factory ) objenesis . ObjenesisStd ( proxyClass )  ; proxy . setCallbacks ( new Callback[] {interceptor , NoOp . INSTANCE} ) ; return proxy ; }  	None^118^^^^^117^121^
[REPLACE]  proxy  .  setCallbacks  (  new  Callback[]  {interceptor,  NoOp  .  INSTANCE}  )  ; 	[BUGGY] enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} ) ; [CE] cannot find symbol enhancer  [METHOD]  createProxy [TYPE] Object [PARAMETER] Class<?> proxyClass MethodInterceptor interceptor [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Factory proxy [TYPE] Class proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Object createProxy ( Class<?> proxyClass , final MethodInterceptor interceptor ) { Factory proxy =  ( Factory ) objenesis . newInstance ( proxyClass ) ; [ATTENTION] enhancer . setCallbackTypes ( new Class[]{MethodInterceptor . class , NoOp . class} )  ; return proxy ; }  	None^119^^^^^117^121^
[REPLACE]  return  proxy; 	[BUGGY] return all ; [CE] cannot find symbol all  [METHOD]  createProxy [TYPE] Object [PARAMETER] Class<?> proxyClass MethodInterceptor interceptor [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] MethodInterceptor interceptor [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Factory proxy [TYPE] Class proxyClass [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Object createProxy ( Class<?> proxyClass , final MethodInterceptor interceptor ) { Factory proxy =  ( Factory ) objenesis . newInstance ( proxyClass ) ; proxy . setCallbacks ( new Callback[] {interceptor , NoOp . INSTANCE} ) ; [ATTENTION] return all ; }  	None^120^^^^^117^121^
[REPLACE]  Class<?>[]  all  =  new  Class<?>[rest  .  length+1]; 	[BUGGY] Class<?>[] all = new Class<?>[rest . length ( ) +1] ; [CE] cannot find symbol  [METHOD]  prepend [TYPE] Class[] [PARAMETER] Class<?> first rest [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] all rest [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class first [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Class<?>[] prepend ( Class<?> first , Class<?> . . . rest ) { [ATTENTION] Class<?>[] all = new Class<?>[rest . length ( ) +1] ; all[0] = first ; System . arraycopy ( rest , 0 , all , 1 , rest . length ) ; return all ; }  	None^124^^^^^123^128^
[REPLACE]  all[0]  =  first; 	[BUGGY] all[4] = first ; [FE] AssertionFailedError [METHOD]  prepend [TYPE] Class[] [PARAMETER] Class<?> first rest [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] all rest [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class first [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Class<?>[] prepend ( Class<?> first , Class<?> . . . rest ) { Class<?>[] all = new Class<?>[rest . length+1] ; [ATTENTION] all[4] = first ; System . arraycopy ( rest , 0 , all , 1 , rest . length ) ; return all ; }  	None^125^^^^^123^128^
[REPLACE]  System  .  arraycopy  (  rest,  0,  all,  1,  rest  .  length  )  ; 	[BUGGY] System . arraycopy ( rest , 0 , all , 1 , rest . length ) ; [NO-ERROR]  [METHOD]  prepend [TYPE] Class[] [PARAMETER] Class<?> first rest [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] all rest [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class first [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Class<?>[] prepend ( Class<?> first , Class<?> . . . rest ) { Class<?>[] all = new Class<?>[rest . length+1] ; all[0] = first ; [ATTENTION] System . arraycopy ( rest , 0 , all , 1 , rest . length )  ; return all ; }  	None^126^^^^^123^128^
[ADD]  System  .  arraycopy  (  rest,  0,  all,  1,  rest  .  length  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  prepend [TYPE] Class[] [PARAMETER] Class<?> first rest [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] all rest [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class first [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Class<?>[] prepend ( Class<?> first , Class<?> . . . rest ) { Class<?>[] all = new Class<?>[rest . length+1] ; all[0] = first ; [ATTENTION] return all ; }  	None^126^^^^^123^128^
[REPLACE]  return  all; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  prepend [TYPE] Class[] [PARAMETER] Class<?> first rest [CLASS] ClassImposterizer 1 2 3 ClassWithSuperclassToWorkAroundCglibBug  [TYPE] ObjenesisStd objenesis [TYPE] Class[] all rest [TYPE] boolean false true [TYPE] ClassImposterizer INSTANCE [TYPE] Class first [TYPE] CallbackFilter IGNORE_BRIDGE_METHODS [TYPE] NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES  [CONTEXT]  private Class<?>[] prepend ( Class<?> first , Class<?> . . . rest ) { Class<?>[] all = new Class<?>[rest . length+1] ; all[0] = first ; System . arraycopy ( rest , 0 , all , 1 , rest . length ) ; [ATTENTION] return null ; }  	None^127^^^^^123^128^
[REPLACE]  return  method  .  isBridge  (  )  ?  1  :  0; 	[BUGGY] return method . isBridge ( ) ? 4 : 0 ; [FE] AssertionFailedError [METHOD]  accept [TYPE] int [PARAMETER] Method method [CLASS] 2  [TYPE] boolean false true [TYPE] Method method  [CONTEXT]  public int accept ( Method method ) { [ATTENTION] return method . isBridge ( ) ? 4 : 0 ; }  	None^48^^^^^47^49^
[REPLACE]  super  (  parent  )  ; 	[BUGGY] super ( nextToSearch ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] ClassLoader) [PARAMETER] ClassLoader parent ClassLoader nextToSearch [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] boolean false true  [CONTEXT]  public SearchingClassLoader ( ClassLoader parent , ClassLoader nextToSearch ) { [ATTENTION] super ( nextToSearch )  ; this . nextToSearch = nextToSearch ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^19^^^^^18^21^
[REPLACE]  this  .  nextToSearch  =  nextToSearch; 	[BUGGY] this . nextToSearch =  parent ; [NO-ERROR]  [METHOD]  <init> [TYPE] ClassLoader) [PARAMETER] ClassLoader parent ClassLoader nextToSearch [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] boolean false true  [CONTEXT]  public SearchingClassLoader ( ClassLoader parent , ClassLoader nextToSearch ) { super ( parent ) ; [ATTENTION] this . nextToSearch = parent ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^20^^^^^18^21^
[ADD]  this  .  nextToSearch  =  nextToSearch; 	[BUGGY] [CE] variable nextToSearch might not have been initialized  [METHOD]  <init> [TYPE] ClassLoader) [PARAMETER] ClassLoader parent ClassLoader nextToSearch [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] boolean false true  [CONTEXT]  public SearchingClassLoader ( ClassLoader parent , ClassLoader nextToSearch ) { super ( parent ) ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^20^^^^^18^21^
[REPLACE]  return  combineLoadersOf  (  classes[0],  classes  )  ; 	[BUGGY] return combineLoadersOf ( classes[1] , classes ) ; [FE] AssertionFailedError [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] classes [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class[] classes [TYPE] boolean false true  [CONTEXT]  public static ClassLoader combineLoadersOf ( Class<?> . . . classes ) { [ATTENTION] return combineLoadersOf ( classes[1] , classes )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^24^^^^^23^25^
[REPLACE]  List<ClassLoader>  loaders  =  new  ArrayList<ClassLoader>  (  )  ; 	[BUGGY] ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ; [CE] cannot find symbol parentLoaders  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { [ATTENTION] ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 )  ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^28^^^^^27^50^
[REPLACE]  addIfNewElement  (  loaders,  first  .  getClassLoader  (  )  )  ; 	[BUGGY] addIfNewElement ( loaders , null . getClassLoader ( ) ) ; [CE] <null> cannot be dereferenced  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  [ATTENTION] addIfNewElement ( loaders , null . getClassLoader ( ) )  ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^30^^^^^27^50^
[REPLACE]  for  (  Class<?>  c  :  others  )  { 	[BUGGY] for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; [NO-ERROR]  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; [ATTENTION] for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) )  ; addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^31^^^^^27^50^
[REPLACE]  addIfNewElement  (  loaders,  SearchingClassLoader  .  class  .  getClassLoader  (  )  )  ; 	[BUGGY] addIfNewElement ( this , SearchingClassLoader . class . getClassLoader ( ) ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      [ATTENTION] addIfNewElement ( this , SearchingClassLoader . class . getClassLoader ( ) )  ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^40^^^^^27^50^
[ADD]  addIfNewElement  (  loaders,  SearchingClassLoader  .  class  .  getClassLoader  (  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      [ATTENTION]    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^40^^^^^27^50^
[REPLACE]  addIfNewElement  (  loaders,  SearchingClassLoader  .  class  .  getClassLoader  (  )  )  ; 	[BUGGY] loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; [CE] cannot find symbol loader  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      [ATTENTION] loader = new SearchingClassLoader ( parentLoaders . get ( i )  , loader )  ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^40^^^^^27^50^
[REPLACE]  addIfNewElement  (  loaders,  currentThread  (  )    .  getContextClassLoader  (  )  )  ; 	[BUGGY] addIfNewElement ( true , currentThread ( ) . getContextClassLoader ( ) ) ; [CE] method addIfNewElement in class SearchingClassLoader cannot be applied to given types ;  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    [ATTENTION] addIfNewElement ( true , currentThread ( )  . getContextClassLoader ( ) )  ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^44^^^^^27^50^
[REMOVE]   	[BUGGY] loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; [CE] cannot find symbol loader  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    [ATTENTION] addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;  loader = new SearchingClassLoader ( parentLoaders . get ( i )  , loader )  ;    return combine ( loaders ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^44^^^^^27^50^
[REPLACE]  addIfNewElement  (  loaders,  currentThread  (  )    .  getContextClassLoader  (  )  )  ; 	[BUGGY] addIfNewElement ( loaders , c . getClassLoader ( ) ) ; [CE] cannot find symbol c  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    [ATTENTION] addIfNewElement ( loaders , c . getClassLoader ( ) )  ;    return combine ( loaders ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^44^^^^^27^50^
[REPLACE]  return  combine  (  loaders  )  ; 	[BUGGY] return loader ; [CE] cannot find symbol loader  [METHOD]  combineLoadersOf [TYPE] ClassLoader [PARAMETER] Class<?> first others [CLASS] SearchingClassLoader  [TYPE] ClassLoader nextToSearch parent [TYPE] Class c first [TYPE] List loaders [TYPE] Class[] others [TYPE] boolean false true  [CONTEXT]  private static ClassLoader combineLoadersOf ( Class<?> first , Class<?> . . . others ) { List<ClassLoader> loaders = new ArrayList<ClassLoader> ( ) ;  addIfNewElement ( loaders , first . getClassLoader ( ) ) ; for ( Class<?> c : others ) { addIfNewElement ( loaders , c . getClassLoader ( ) ) ; }      addIfNewElement ( loaders , SearchingClassLoader . class . getClassLoader ( ) ) ;    addIfNewElement ( loaders , currentThread ( ) . getContextClassLoader ( ) ) ;    [ATTENTION] return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^49^^^^^27^50^
[REPLACE]  ClassLoader  loader  =  parentLoaders  .  get  (  parentLoaders  .  size  (  )  -1  )  ; 	[BUGGY] ClassLoader loader = null . get ( parentLoaders . length ( ) -1 ) ; [CE] cannot find symbol  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { [ATTENTION] ClassLoader loader = null . get ( parentLoaders . length ( ) -1 )  ;  for ( int i = parentLoaders . size ( ) -2 ; i > = 0 ; i-- ) { loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^53^^^^^52^60^
[REPLACE]  for  (  int  i  =  parentLoaders  .  size  (  )  -2;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = parentLoaders . size ( ) * 0 -0 ; i > = 0 ; i-- ) {[FE] AssertionFailedError [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  [ATTENTION] for ( int i = parentLoaders . size ( ) *0 -0 ; i > = 0 ; i-- ) { loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^55^^^^^52^60^
[ADD]  for  (  int  i  =  parentLoaders  .  size  (  )  -2;  i  >=  0;  i--  )  {  loader  =  new  SearchingClassLoader  (  parentLoaders  .  get  (  i  )  ,  loader  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  [ATTENTION]   return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^55^56^57^^^52^60^
[REPLACE]  loader  =  new  SearchingClassLoader  (  parentLoaders  .  get  (  i  )  ,  loader  )  ; 	[BUGGY] loader =  new SearchingClassLoader ( true . get ( i ) , loader ) ; [CE] boolean cannot be dereferenced  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  for ( int i = parentLoaders . size ( ) -2 ; i > = 0 ; i-- ) { [ATTENTION] loader = new SearchingClassLoader ( true . get ( i )  , loader )  ; } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^56^^^^^52^60^
[REPLACE]  loader  =  new  SearchingClassLoader  (  parentLoaders  .  get  (  i  )  ,  loader  )  ; 	[BUGGY] loader =  new SearchingClassLoader ( null . get ( i ) , loader ) ; [CE] <null> cannot be dereferenced  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  for ( int i = parentLoaders . size ( ) -2 ; i > = 0 ; i-- ) { [ATTENTION] loader = new SearchingClassLoader ( null . get ( i )  , loader )  ; } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^56^^^^^52^60^
[ADD]  loader  =  new  SearchingClassLoader  (  parentLoaders  .  get  (  i  )  ,  loader  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  for ( int i = parentLoaders . size ( ) -2 ; i > = 0 ; i-- ) { [ATTENTION] } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^56^^^^^52^60^
[REPLACE]  for  (  int  i  =  parentLoaders  .  size  (  )  -2;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = parentLoaders . size ( ) * 0 . 5 -2 ; i > = 0 ; i-- ) {[CE] possible loss of precision  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  [ATTENTION] for ( int i = parentLoaders . size ( ) *0 . 5 -2 ; i > = 0 ; i-- ) { loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; } return loader ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^55^^^^^52^60^
[REPLACE]  return  loader; 	[BUGGY] return parent ; [CE] parent has private access in ClassLoader  [METHOD]  combine [TYPE] ClassLoader [PARAMETER] ClassLoader> parentLoaders [CLASS] SearchingClassLoader  [TYPE] ClassLoader loader nextToSearch parent [TYPE] List parentLoaders [TYPE] boolean false true [TYPE] int i  [CONTEXT]  private static ClassLoader combine ( List<ClassLoader> parentLoaders ) { ClassLoader loader = parentLoaders . get ( parentLoaders . size ( ) -1 ) ;  for ( int i = parentLoaders . size ( ) -2 ; i > = 0 ; i-- ) { loader = new SearchingClassLoader ( parentLoaders . get ( i ) , loader ) ; } [ATTENTION] return parent ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^59^^^^^52^60^
[REPLACE]  if  (  c  !=  null  &&  !loaders  .  contains  (  c  )  )  { 	[BUGGY] if ( c = = null ) {[FE] AssertionFailedError [METHOD]  addIfNewElement [TYPE] void [PARAMETER] ClassLoader> loaders ClassLoader c [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] List loaders [TYPE] boolean false true  [CONTEXT]  private static void addIfNewElement ( List<ClassLoader> loaders , ClassLoader c ) { [ATTENTION] if ( c = = null ) { loaders . add ( c ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^63^^^^^62^66^
[ADD]  if  (  c  !=  null  &&  !loaders  .  contains  (  c  )  )  {  loaders  .  add  (  c  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  addIfNewElement [TYPE] void [PARAMETER] ClassLoader> loaders ClassLoader c [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] List loaders [TYPE] boolean false true  [CONTEXT]  private static void addIfNewElement ( List<ClassLoader> loaders , ClassLoader c ) { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^63^64^65^^^62^66^
[REPLACE]  loaders  .  add  (  c  )  ; 	[BUGGY] loaders . contains ( null )  ; [FE] AssertionFailedError [METHOD]  addIfNewElement [TYPE] void [PARAMETER] ClassLoader> loaders ClassLoader c [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] List loaders [TYPE] boolean false true  [CONTEXT]  private static void addIfNewElement ( List<ClassLoader> loaders , ClassLoader c ) { if ( c ! = null && !loaders . contains ( c ) ) { [ATTENTION] loaders . contains ( null ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^64^^^^^62^66^
[REMOVE]   	[BUGGY] addIfNewElement ( loaders , c . getClassLoader ( ) ) ; [CE] method getClassLoader in class ClassLoader cannot be applied to given types ;  [METHOD]  addIfNewElement [TYPE] void [PARAMETER] ClassLoader> loaders ClassLoader c [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] List loaders [TYPE] boolean false true  [CONTEXT]  private static void addIfNewElement ( List<ClassLoader> loaders , ClassLoader c ) { if ( c ! = null && !loaders . contains ( c ) ) { [ATTENTION] loaders . add ( c ) ;  addIfNewElement ( loaders , c . getClassLoader ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^64^^^^^62^66^
[REPLACE]  if  (  nextToSearch  !=  null  )  { 	[BUGGY] if ( nextToSearch = = null ) {[NO-ERROR]  [METHOD]  findClass [TYPE] Class [PARAMETER] String name [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] String name [TYPE] boolean false true  [CONTEXT]  protected Class<?> findClass ( String name ) throws ClassNotFoundException { [ATTENTION] if ( nextToSearch = = null ) { return nextToSearch . loadClass ( name ) ; } else { return super . findClass ( name ) ; // will throw ClassNotFoundException } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^70^^^^^69^75^
[REPLACE]  return  super  .  findClass  (  name  )  ; 	[BUGGY] return super . loadClass ( name ) ; [NO-ERROR]  [METHOD]  findClass [TYPE] Class [PARAMETER] String name [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] String name [TYPE] boolean false true  [CONTEXT]  protected Class<?> findClass ( String name ) throws ClassNotFoundException { if ( nextToSearch ! = null ) { return nextToSearch . loadClass ( name ) ; } else { [ATTENTION] return super . loadClass ( name )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^73^^^^^69^75^
[REPLACE]  return  nextToSearch  .  loadClass  (  name  )  ; 	[BUGGY] return nextToSearch . findClass ( name )  ; [CE] findClass(String) has protected access in ClassLoader  [METHOD]  findClass [TYPE] Class [PARAMETER] String name [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] String name [TYPE] boolean false true  [CONTEXT]  protected Class<?> findClass ( String name ) throws ClassNotFoundException { if ( nextToSearch ! = null ) { [ATTENTION] return nextToSearch . findClass ( name ) ; } else { return super . findClass ( name ) ; // will throw ClassNotFoundException } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^71^^^^^69^75^
[REPLACE]  return  nextToSearch  .  loadClass  (  name  )  ; 	[BUGGY] return nextToSearch . findClass ( name ) ; [CE] findClass(String) has protected access in ClassLoader  [METHOD]  findClass [TYPE] Class [PARAMETER] String name [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] String name [TYPE] boolean false true  [CONTEXT]  protected Class<?> findClass ( String name ) throws ClassNotFoundException { if ( nextToSearch ! = null ) { [ATTENTION] return nextToSearch . findClass ( name )  ; } else { return super . findClass ( name ) ; // will throw ClassNotFoundException } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^71^^^^^69^75^
[REPLACE]  return  super  .  findClass  (  name  )  ; 	[BUGGY] return super . SearchingClassLoader ( loader , c )  ; [CE] cannot find symbol loader  [METHOD]  findClass [TYPE] Class [PARAMETER] String name [CLASS] SearchingClassLoader  [TYPE] ClassLoader c loader nextToSearch parent [TYPE] String name [TYPE] boolean false true  [CONTEXT]  protected Class<?> findClass ( String name ) throws ClassNotFoundException { if ( nextToSearch ! = null ) { return nextToSearch . loadClass ( name ) ; } else { [ATTENTION] return super . SearchingClassLoader ( loader , c ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java^73^^^^^69^75^
[REPLACE]  if  (  mock  .  getClass  (  )    .  getInterfaces  (  )    .  length  ==  2  )  { 	[BUGGY] if ( mock . getClass ( ) . getInterfaces ( ) . length - 3 = = 2 ) {[FE]  AssertionFailedError  expected:<Mock for [DummyInterface] , hashCode: 37098814...> but was:<Mock for [Object] , hashCode: 37098814...> assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  classNameForMock [TYPE] String [PARAMETER] Object mock [CLASS] ClassNameFinder  [TYPE] boolean false true [TYPE] Object mock  [CONTEXT]  public static String classNameForMock ( Object mock ) { [ATTENTION] if ( mock . getClass ( )  . getInterfaces ( )  . length - 3 = = 2 ) { return mock . getClass ( ) . getInterfaces ( ) [0] . getSimpleName ( ) ; } else { return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/ClassNameFinder.java^10^^^^^9^15^
[REPLACE]  return  mock  .  getClass  (  )    .  getSuperclass  (  )    .  getSimpleName  (  )  ; 	[BUGGY] return mock . getClass ( ) . getInterfaces ( ) [0] . getSimpleName ( ) ; [FE]  AssertionFailedError  expected:<Mock for [DummyClass] , hashCode: 10237140...> but was:<Mock for [Factory] , hashCode: 10237140...> assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  classNameForMock [TYPE] String [PARAMETER] Object mock [CLASS] ClassNameFinder  [TYPE] boolean false true [TYPE] Object mock  [CONTEXT]  public static String classNameForMock ( Object mock ) { if ( mock . getClass ( ) . getInterfaces ( ) . length = = 2 ) { return mock . getClass ( ) . getInterfaces ( ) [0] . getSimpleName ( ) ; } else { [ATTENTION] return mock . getClass ( )  . getInterfaces ( ) [0] . getSimpleName ( )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/ClassNameFinder.java^13^^^^^9^15^
[REPLACE]  return  mock  .  getClass  (  )    .  getInterfaces  (  )  [0]  .  getSimpleName  (  )  ; 	[BUGGY] return mock . getClass ( ) . getInterfaces ( ) [0] . getInterfaces ( )  ; [CE] incompatible types  [METHOD]  classNameForMock [TYPE] String [PARAMETER] Object mock [CLASS] ClassNameFinder  [TYPE] boolean false true [TYPE] Object mock  [CONTEXT]  public static String classNameForMock ( Object mock ) { if ( mock . getClass ( ) . getInterfaces ( ) . length = = 2 ) { [ATTENTION] return mock . getClass ( )  . getInterfaces ( ) [0] . getInterfaces ( ) ; } else { return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/ClassNameFinder.java^11^^^^^9^15^
[REPLACE]  return  mock  .  getClass  (  )    .  getInterfaces  (  )  [0]  .  getSimpleName  (  )  ; 	[BUGGY] return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; [FE]  AssertionFailedError  expected:<Mock for [DummyInterface] , hashCode: 37098814...> but was:<Mock for [Object] , hashCode: 37098814...> assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  classNameForMock [TYPE] String [PARAMETER] Object mock [CLASS] ClassNameFinder  [TYPE] boolean false true [TYPE] Object mock  [CONTEXT]  public static String classNameForMock ( Object mock ) { if ( mock . getClass ( ) . getInterfaces ( ) . length = = 2 ) { [ATTENTION] return mock . getClass ( )  . getSuperclass ( )  . getSimpleName ( )  ; } else { return mock . getClass ( ) . getSuperclass ( ) . getSimpleName ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/ClassNameFinder.java^11^^^^^9^15^
[REPLACE]  public  static  final  MockitoNamingPolicy  INSTANCE  =  new  MockitoNamingPolicy  (  )  ; 	[BUGGY] public static final MockitoNamingPolicy INSTANCE  = null ; [FE] [CONTEXT]    [CLASS] MockitoNamingPolicy  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java^11^^^^^^^
[REPLACE]  if  (  namingPolicyField  .  get  (  createInfo  )  ==  null  )  { 	[BUGGY] if ( namingPolicyField . get ( createInfo ) ! = createInfo ) {[NO-ERROR]  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; [ATTENTION] if ( namingPolicyField . get ( createInfo ) ! = createInfo ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^20^^^^^13^26^
[ADD]  if  (  namingPolicyField  .  get  (  createInfo  )  ==  null  )  {  namingPolicyField  .  set  (  createInfo,  MockitoNamingPolicy  .  INSTANCE  )  ;  } 	[BUGGY] namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; [NO-ERROR]  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; [ATTENTION] namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE )  ;  } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^20^21^22^^^13^26^
[REPLACE]  namingPolicyField  .  set  (  createInfo,  MockitoNamingPolicy  .  INSTANCE  )  ; 	[BUGGY] namingPolicyField . setAccessible ( true ) ; [FE]  AssertionFailedError  expected:<null> but was:<org.mockito.internal.creation.cglib.MockitoNamingPolicy@6c629d6e> assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { [ATTENTION] namingPolicyField . setAccessible ( true )  ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^21^^^^^13^26^
[ADD]  try  {  Field  createInfoField  =  reflectOnCreateInfo  (  methodProxy  )  ;  createInfoField  .  setAccessible  (  true  )  ;  Object  createInfo  =  createInfoField  .  get  (  methodProxy  )  ;  Field  namingPolicyField  =  createInfo  .  getClass  (  )    .  getDeclaredField  (    "namingPolicy  "  )  ; 	[BUGGY] Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; [CE] illegal start of type  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { [ATTENTION] Field createInfoField = reflectOnCreateInfo ( methodProxy )  ; createInfoField . setAccessible ( true )  ; Object createInfo = createInfoField . get ( methodProxy )  ; Field namingPolicyField = createInfo . getClass ( )  . getDeclaredField (   "namingPolicy  " )  ;   namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^14^15^16^17^18^13^26^
[REPLACE]  if  (  namingPolicyField  .  get  (  createInfo  )  ==  null  )  { 	[BUGGY] if ( namingPolicyField . get ( createInfo ) ! = null ) {[FE]  AssertionFailedError  expected:<null> but was:<org.mockito.internal.creation.cglib.MockitoNamingPolicy@6c629d6e> assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; [ATTENTION] if ( namingPolicyField . get ( createInfo ) ! = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^20^^^^^13^26^
[ADD]  if  (  namingPolicyField  .  get  (  createInfo  )  ==  null  )  {  namingPolicyField  .  set  (  createInfo,  MockitoNamingPolicy  .  INSTANCE  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<null> but was:<org.mockito.internal.creation.cglib.MockitoNamingPolicy@6c629d6e> assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; [ATTENTION]  } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^20^21^22^^^13^26^
[REPLACE]  Field  createInfoField  =  reflectOnCreateInfo  (  methodProxy  )  ; 	[BUGGY] Object createInfo = createInfoField . get ( methodProxy ) ; [CE] cannot find symbol createInfoField  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { [ATTENTION] Object createInfo = createInfoField . get ( methodProxy )  ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^15^^^^^13^26^
[REPLACE]  Object  createInfo  =  createInfoField  .  get  (  methodProxy  )  ; 	[BUGGY] Object createInfo = namingPolicy methodProxy  ; [CE] ' ; ' expected  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; [ATTENTION] Object createInfo = namingPolicymethodProxy ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^17^^^^^13^26^
[ADD]  Object  createInfo  =  createInfoField  .  get  (  methodProxy  )  ; 	[BUGGY] [CE] cannot find symbol createInfo  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; [ATTENTION] Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^17^^^^^13^26^
[REPLACE]  Field  namingPolicyField  =  createInfo  .  getClass  (  )    .  getDeclaredField  (    "namingPolicy  "  )  ; 	[BUGGY] Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; [CE] variable createInfoField is already defined in method setMockitoNamingPolicy(MethodProxy)  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; [ATTENTION] Field createInfoField = reflectOnCreateInfo ( methodProxy )  ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^18^^^^^13^26^
[REPLACE]  Object  createInfo  =  createInfoField  .  get  (  methodProxy  )  ; 	[BUGGY] Object createInfo = createInfo methodProxy  ; [CE] ' ; ' expected  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; [ATTENTION] Object createInfo = createInfomethodProxy ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^17^^^^^13^26^
[ADD]  Field  namingPolicyField  =  createInfo  .  getClass  (  )    .  getDeclaredField  (    "namingPolicy  "  )  ;  namingPolicyField  .  setAccessible  (  true  )  ; 	[BUGGY] namingPolicyField . setAccessible ( true ) ; [CE] cannot find symbol namingPolicyField  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; [ATTENTION] namingPolicyField . setAccessible ( true )  ;  if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { throw new RuntimeException (   "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^18^19^^^^13^26^
[REPLACE]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] return ; [NO-ERROR]  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } } catch ( Exception e ) { [ATTENTION] return ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^24^^^^^13^26^
[ADD]  catch  (  Exception  e  )  {  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] [CE] 'try' without 'catch' or 'finally'  [METHOD]  setMockitoNamingPolicy [TYPE] void [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] Field createInfoField namingPolicyField [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Object createInfo [TYPE] Exception e  [CONTEXT]  public void setMockitoNamingPolicy ( MethodProxy methodProxy ) { try { Field createInfoField = reflectOnCreateInfo ( methodProxy ) ; createInfoField . setAccessible ( true ) ; Object createInfo = createInfoField . get ( methodProxy ) ; Field namingPolicyField = createInfo . getClass ( ) . getDeclaredField (   "namingPolicy  " ) ; namingPolicyField . setAccessible ( true ) ; if ( namingPolicyField . get ( createInfo )  = = null ) { namingPolicyField . set ( createInfo , MockitoNamingPolicy . INSTANCE ) ; } [ATTENTION]  } }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^23^24^^^^13^26^
[REPLACE]  Class  cglibMethodProxyClass  =  methodProxy  .  getClass  (  )  ; 	[BUGGY] Object createInfo = createInfoField . get ( methodProxy ) ; [CE] cannot find symbol createInfoField  [METHOD]  reflectOnCreateInfo [TYPE] Field [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Class cglibMethodProxyClass  [CONTEXT]  private Field reflectOnCreateInfo ( MethodProxy methodProxy ) throws NoSuchFieldException { [ATTENTION] Object createInfo = createInfoField . get ( methodProxy )  ;   while ( cglibMethodProxyClass ! = MethodProxy . class ) { cglibMethodProxyClass = methodProxy . getClass ( ) . getSuperclass ( ) ; } return cglibMethodProxyClass . getDeclaredField (   "createInfo  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^30^^^^^29^37^
[REPLACE]  while  (  cglibMethodProxyClass  !=  MethodProxy  .  class  )  { 	[BUGGY] while ( cglibMethodProxyClass  = =  MethodProxy . class ) {[FE] AssertionFailedError [METHOD]  reflectOnCreateInfo [TYPE] Field [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Class cglibMethodProxyClass  [CONTEXT]  private Field reflectOnCreateInfo ( MethodProxy methodProxy ) throws NoSuchFieldException { Class cglibMethodProxyClass = methodProxy . getClass ( ) ;   [ATTENTION] while ( cglibMethodProxyClass = = MethodProxy . class ) { cglibMethodProxyClass = methodProxy . getClass ( ) . getSuperclass ( ) ; } return cglibMethodProxyClass . getDeclaredField (   "createInfo  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^33^^^^^29^37^
[ADD]  while  (  cglibMethodProxyClass  !=  MethodProxy  .  class  )  {  cglibMethodProxyClass  =  methodProxy  .  getClass  (  )    .  getSuperclass  (  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  reflectOnCreateInfo [TYPE] Field [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Class cglibMethodProxyClass  [CONTEXT]  private Field reflectOnCreateInfo ( MethodProxy methodProxy ) throws NoSuchFieldException { Class cglibMethodProxyClass = methodProxy . getClass ( ) ;   [ATTENTION]  } return cglibMethodProxyClass . getDeclaredField (   "createInfo  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^33^34^^^^29^37^
[REPLACE]  cglibMethodProxyClass  =  methodProxy  .  getClass  (  )    .  getSuperclass  (  )  ; 	[BUGGY] cglibMethodProxyClass =  null . getClass ( ) . getSuperclass ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  reflectOnCreateInfo [TYPE] Field [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Class cglibMethodProxyClass  [CONTEXT]  private Field reflectOnCreateInfo ( MethodProxy methodProxy ) throws NoSuchFieldException { Class cglibMethodProxyClass = methodProxy . getClass ( ) ;   while ( cglibMethodProxyClass ! = MethodProxy . class ) { [ATTENTION] cglibMethodProxyClass = null . getClass ( )  . getSuperclass ( )  ; } return cglibMethodProxyClass . getDeclaredField (   "createInfo  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^34^^^^^29^37^
[REPLACE]  return  cglibMethodProxyClass  .  getDeclaredField  (    "createInfo  "  )  ; 	[BUGGY] return cglibMethodProxy   "createInfo  "  ; [CE]  [METHOD]  reflectOnCreateInfo [TYPE] Field [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBHacker  [TYPE] boolean false true [TYPE] MethodProxy methodProxy [TYPE] Class cglibMethodProxyClass  [CONTEXT]  private Field reflectOnCreateInfo ( MethodProxy methodProxy ) throws NoSuchFieldException { Class cglibMethodProxyClass = methodProxy . getClass ( ) ;   while ( cglibMethodProxyClass ! = MethodProxy . class ) { cglibMethodProxyClass = methodProxy . getClass ( ) . getSuperclass ( ) ; } [ATTENTION] return cglibMethodProxy  "createInfo  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/creation/cglib/CGLIBHacker.java^36^^^^^29^37^
[REPLACE]  private  final  InvocationOnMock  invocation; 	[BUGGY] private InvocationOnMock invocation ; [NO-ERROR]  [CONTEXT]    [CLASS] ReturnsSmartNulls ThrowingInterceptor  	None^40^^^^^^^
[REPLACE]  private  final  Location  location  =  new  Location  (  )  ; 	[BUGGY] private Location location = new Location ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] ReturnsSmartNulls ThrowingInterceptor  	None^41^^^^^^^
[REPLACE]  private  final  Answer<Object>  delegate  =  new  ReturnsMoreEmptyValues  (  )  ; 	[BUGGY] private final Answer<Object> delegate  = null ; [FE] NullPointerException assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [CONTEXT]    [CLASS] ReturnsSmartNulls ThrowingInterceptor  	None^57^^^^^^^
[REPLACE]  this  .  invocation  =  invocation; 	[BUGGY] this . invocation =  null ; [FE] NullPointerException assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  <init> [TYPE] InvocationOnMock) [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  private ThrowingInterceptor ( InvocationOnMock invocation ) { [ATTENTION] this . invocation = null ; }  	None^44^^^^^43^45^
[ADD]  this  .  invocation  =  invocation; 	[BUGGY] [CE] variable invocation might not have been initialized  [METHOD]  <init> [TYPE] InvocationOnMock) [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  private ThrowingInterceptor ( InvocationOnMock invocation ) { [ATTENTION] }  	None^44^^^^^43^45^
[REPLACE]  if  (  Invocation  .  isToString  (  method  )  )  { 	[BUGGY] if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) {[CE] cannot find symbol type  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { [ATTENTION] if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }  	None^48^^^^^47^54^
[REPLACE]  return    "SmartNull  returned  by  unstubbed    "  +  invocation  .  getMethod  (  )    .  getName  (  )  +    "  (  )  method  on  mock  "; 	[BUGGY] return   "SmartNull returned by unstubbed   " | invocation . getMethod ( ) . getName ( )  |   " ( ) method on mock  " ; [CE] bad operand types for binary operator  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { [ATTENTION] return   "SmartNull returned by unstubbed   "|invocation . getMethod ( )  . getName ( ) |  " ( ) method on mock  " ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }  	None^49^^^^^47^54^
[REPLACE]  new  Reporter  (  )    .  smartNullPointerException  (  location  )  ; 	[BUGGY] new Reporter ( )  . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; } [ATTENTION] new Reporter ( ) . Reporter ( ) ; return null ; }  	None^52^^^^^47^54^
[REPLACE]  return  null; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; } new Reporter ( ) . smartNullPointerException ( location ) ; [ATTENTION] return false ; }  	None^53^^^^^47^54^
[REPLACE]  Object  defaultReturnValue  =  delegate  .  answer  (  invocation  )  ; 	[BUGGY] Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; [CE] cannot find symbol defaultReturnValue  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { [ATTENTION] Class<?> type = invocation . getMethod ( )  . getReturnType ( )  ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^60^^^^^59^69^
[REPLACE]  if  (  defaultReturnValue  !=  null  )  { 	[BUGGY] if ( defaultReturnValue = = null ) {[FE]  AssertionFailedError  expected:<[SmartNull returned by unstubbed get() method on mock]> but was:<[null]> assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; [ATTENTION] if ( defaultReturnValue = = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^61^^^^^59^69^
[ADD]  if  (  defaultReturnValue  !=  null  )  {  return  defaultReturnValue;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<false> but was:<null> assertEquals(false  ,  answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; [ATTENTION]  Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^61^62^63^^^59^69^
[REPLACE]  return  defaultReturnValue; 	[BUGGY] return null ; [FE]  AssertionFailedError  expected:<false> but was:<null> assertEquals(false  ,  answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { [ATTENTION] return null ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^62^^^^^59^69^
[REPLACE]  Class<?>  type  =  invocation  .  getMethod  (  )    .  getReturnType  (  )  ; 	[BUGGY] Object defaultReturnValue = delegate . answer ( invocation ) ; [CE] variable defaultReturnValue is already defined in method answer(InvocationOnMock)  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } [ATTENTION] Object defaultReturnValue = delegate . answer ( invocation )  ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^64^^^^^59^69^
[REPLACE]  if  (  ClassImposterizer  .  INSTANCE  .  canImposterise  (  type  )  )  { 	[BUGGY] if ( ClassImposterizer . INSTANCE . imposterise ( null , true )  ) {[CE] method imposterise in class ClassImposterizer cannot be applied to given types ;  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; [ATTENTION] if ( ClassImposterizer . INSTANCE . imposterise ( null , true )  ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } return null ; }  	None^65^^^^^59^69^
[REPLACE]  return  ClassImposterizer  .  INSTANCE  .  imposterise  (  new  ThrowingInterceptor  (  invocation  )  ,  type  )  ; 	[BUGGY] return  new ThrowingInterceptor ( invocation )  ; [FE]  org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls$ThrowingInterceptor cannot be cast to assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { [ATTENTION] return new ThrowingInterceptor ( invocation ) ; } return null ; }  	None^66^^^^^59^69^
[REPLACE]  return  ClassImposterizer  .  INSTANCE  .  imposterise  (  new  ThrowingInterceptor  (  invocation  )  ,  type  )  ; 	[BUGGY] return ClassImposterizer . INSTANCE . canImposterise ( this )  ; [CE] method canImposterise in class ClassImposterizer cannot be applied to given types ;  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { [ATTENTION] return ClassImposterizer . INSTANCE . canImposterise ( this ) ; } return null ; }  	None^66^^^^^59^69^
[REPLACE]  return  null; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsSmartNulls ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]  public Object answer ( final InvocationOnMock invocation ) throws Throwable { Object defaultReturnValue = delegate . answer ( invocation ) ; if ( defaultReturnValue ! = null ) { return defaultReturnValue ; } Class<?> type = invocation . getMethod ( ) . getReturnType ( ) ; if ( ClassImposterizer . INSTANCE . canImposterise ( type ) ) { return ClassImposterizer . INSTANCE . imposterise ( new ThrowingInterceptor ( invocation ) , type ) ; } [ATTENTION] return false ; }  	None^68^^^^^59^69^
[REPLACE]  private  final  Location  location  =  new  Location  (  )  ; 	[BUGGY] private Location location = new Location ( ) ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowingInterceptor  [TYPE] Answer delegate [TYPE] Object defaultReturnValue [TYPE] Class type [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Location location  [CONTEXT]   	None^41^^^^^^^
[REPLACE]  this  .  invocation  =  invocation; 	[BUGGY] this . invocation =  null ; [FE] NullPointerException assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  <init> [TYPE] InvocationOnMock) [PARAMETER] InvocationOnMock invocation [CLASS] ThrowingInterceptor  [TYPE] InvocationOnMock invocation [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  private ThrowingInterceptor ( InvocationOnMock invocation ) { [ATTENTION] this . invocation = null ; }  	None^44^^^^^43^45^
[REPLACE]  return    "SmartNull  returned  by  unstubbed    "  +  invocation  .  getMethod  (  )    .  getName  (  )  +    "  (  )  method  on  mock  "; 	[BUGGY] return   "SmartNull returned by unstubbed   "  ; [FE]  AssertionFailedError  expected:<...turned by unstubbed [get() method on mock]> but was:<...turned by unstubbed []> assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ThrowingInterceptor  [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { [ATTENTION] return   "SmartNull returned by unstubbed   " ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }  	None^49^^^^^47^54^
[REPLACE]  return    "SmartNull  returned  by  unstubbed    "  +  invocation  .  getMethod  (  )    .  getName  (  )  +    "  (  )  method  on  mock  "; 	[BUGGY] return false ; [FE]  java.lang.Boolean cannot be cast to java.lang.String assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ThrowingInterceptor  [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { [ATTENTION] return false ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; }  	None^49^^^^^47^54^
[REPLACE]  new  Reporter  (  )    .  smartNullPointerException  (  location  )  ; 	[BUGGY] return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; [CE] unreachable statement  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ThrowingInterceptor  [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; } [ATTENTION] return   "SmartNull returned by unstubbed   " + invocation . getMethod ( )  . getName ( ) +   " ( ) method on mock  " ; return null ; }  	None^52^^^^^47^54^
[REPLACE]  return  null; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  intercept [TYPE] Object [PARAMETER] Object obj Method method Object[] args MethodProxy proxy [CLASS] ThrowingInterceptor  [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] MethodProxy proxy [TYPE] Object obj [TYPE] Method method [TYPE] Object[] args [TYPE] Location location  [CONTEXT]  public Object intercept ( Object obj , Method method , Object[] args , MethodProxy proxy ) throws Throwable { if ( Invocation . isToString ( method ) ) { return   "SmartNull returned by unstubbed   " + invocation . getMethod ( ) . getName ( ) +   " ( ) method on mock  " ; } new Reporter ( ) . smartNullPointerException ( location ) ; [ATTENTION] return true ; }  	None^53^^^^^47^54^
[REPLACE]  private  Answer<Object>  delegate  =  new  ReturnsEmptyValues  (  )  ; 	[BUGGY] private Answer<Object> delegate ; [FE] NullPointerException assertEquals(false , answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [CONTEXT]    [CLASS] ReturnsMoreEmptyValues  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^45^^^^^^^
[REPLACE]  Object  ret  =  delegate  .  answer  (  invocation  )  ; 	[BUGGY] Object ret = delegate . answer ( invocation )  ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Object ret [TYPE] Class returnType [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { return ret ; } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^51^^^^^50^58^
[REPLACE]  if  (  ret  !=  null  )  { 	[BUGGY] if ( ret = = null ) {[FE]  AssertionFailedError  expected:<false> but was:<null> assertEquals(false , answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Object ret [TYPE] Class returnType [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; [ATTENTION] if ( ret = = null ) { return ret ; } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^52^^^^^50^58^
[REPLACE]  return  ret; 	[BUGGY] return   "  " ; [FE]  AssertionFailedError  expected:<false> but was:<> assertEquals(false , answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Object ret [TYPE] Class returnType [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { [ATTENTION] return   "  " ; } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^53^^^^^50^58^
[REPLACE]  Class<?>  returnType  =  invocation  .  getMethod  (  )    .  getReturnType  (  )  ; 	[BUGGY] Class<?> componenetType = type . getComponentType ( ) ; [CE] cannot find symbol type  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Object ret [TYPE] Class returnType [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { return ret ; } [ATTENTION] Class<?> componenetType = type . getComponentType ( )  ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^56^^^^^50^58^
[REPLACE]  return  returnValueFor  (  returnType  )  ; 	[BUGGY] return returnValueFor ( null ) ; [FE] NullPointerException assertEquals(  "  " , values.answer(invocationOf(StringMethods.class ,   "stringMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Object ret [TYPE] Class returnType [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { return ret ; } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; [ATTENTION] return returnValueFor ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^57^^^^^50^58^
[REPLACE]  if  (  type  ==  String  .  class  )  { 	[BUGGY] if ( type || String . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { [ATTENTION] if ( type||String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^61^^^^^60^68^
[REPLACE]  }  else  if  (  type  .  isArray  (  )  )  { 	[BUGGY]  else {[CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; [ATTENTION] } else { Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^63^^^^^60^68^
[ADD]  else  if  (  type  .  isArray  (  )  )  {  Class<?>  componenetType  =  type  .  getComponentType  (  )  ;  return  Array  .  newInstance  (  componenetType,  0  )  ;  } 	[BUGGY]  Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; [CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; [ATTENTION] } Class<?> componenetType = type . getComponentType ( )  ; return Array . newInstance ( componenetType , 0 )  ;   return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^63^64^65^66^^60^68^
[REPLACE]  return  Array  .  newInstance  (  componenetType,  0  )  ; 	[BUGGY] return Array . newInstance ( false , 1 ) ; [CE] no suitable method found for newInstance(boolean , int)  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; [ATTENTION] return Array . newInstance ( false , 1 )  ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^65^^^^^60^68^
[REPLACE]  Class<?>  componenetType  =  type  .  getComponentType  (  )  ; 	[BUGGY] Class<?> componenetType = true . getComponentType ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { [ATTENTION] Class<?> componenetType = true . getComponentType ( )  ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^64^^^^^60^68^
[REPLACE]  return  Array  .  newInstance  (  componenetType,  0  )  ; 	[BUGGY] return Array . newInstance ( null , 4 ) ; [FE] NullPointerException assertTrue(ret.getClass().isArray())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; [ATTENTION] return Array . newInstance ( null , 4 )  ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^65^^^^^60^68^
[REPLACE]  Class<?>  componenetType  =  type  .  getComponentType  (  )  ; 	[BUGGY] Class<?> componenetType = type . isArray ( ) ; [CE] incompatible types  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { [ATTENTION] Class<?> componenetType = type . isArray ( )  ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^64^^^^^60^68^
[REPLACE]  return    "  "; 	[BUGGY] return null ; [FE]  AssertionFailedError  expected:<> but was:<null> assertEquals(  "  " , values.answer(invocationOf(StringMethods.class ,   "stringMethod  ")))   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { [ATTENTION] return null ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^62^^^^^60^68^
[REPLACE]  }  else  if  (  type  .  isArray  (  )  )  { 	[BUGGY]  if ( type . isArray ( ) ) {[NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; [ATTENTION] } if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^63^^^^^60^68^
[ADD]  Class<?>  componenetType  =  type  .  getComponentType  (  )  ; 	[BUGGY] [CE] cannot find symbol componenetType  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { [ATTENTION] return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^64^^^^^60^68^
[REPLACE]  return  Array  .  newInstance  (  componenetType,  0  )  ; 	[BUGGY] return Array . newInstance ( componenetType , 0L ) ; [CE] no suitable method found for newInstance(Class<CAP#1> , long)  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; [ATTENTION] return Array . newInstance ( componenetType , 0L )  ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^65^^^^^60^68^
[REPLACE]  Class<?>  componenetType  =  type  .  getComponentType  (  )  ; 	[BUGGY] Class<?> componenetType = null . isArray ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { [ATTENTION] Class<?> componenetType = null . isArray ( )  ; return Array . newInstance ( componenetType , 0 ) ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^64^^^^^60^68^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE]  java.lang.Boolean cannot be cast to assertEquals(  "SmartNull returned by unstubbed get() method on mock  " , smartNull +   "  ")   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsMoreEmptyValues  [TYPE] Answer delegate [TYPE] Class componenetType type [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type = = String . class ) { return   "  " ; }else if ( type . isArray ( ) ) { Class<?> componenetType = type . getComponentType ( ) ; return Array . newInstance ( componenetType , 0 ) ; } [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java^67^^^^^60^68^
[REPLACE]  private  MockitoCore  mockitoCore  =  new  MockitoCore  (  )  ; 	[BUGGY] private MockitoCore mockitoCore ; [FE] NullPointerException assertTrue(new MockUtil().isMock(interfaceMock))   [CONTEXT]    [CLASS] ReturnsMocks  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^15^^^^^^^
[REPLACE]  private  Answer<Object>  delegate  =  new  ReturnsMoreEmptyValues  (  )  ; 	[BUGGY] private Answer<Object> delegate ; [FE] NullPointerException assertEquals(false , answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [CONTEXT]    [CLASS] ReturnsMocks  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^16^^^^^^^
[REPLACE]  Object  ret  =  delegate  .  answer  (  invocation  )  ; 	[BUGGY] Object ret = delegate . answer ( invocation )  ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Object ret [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { return ret ; } return returnValueFor ( invocation . getMethod ( ) . getReturnType ( ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^19^^^^^18^25^
[REPLACE]  if  (  ret  !=  null  )  { 	[BUGGY] if ( ret = = false ) {[CE] incomparable types: Object and boolean  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Object ret [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; [ATTENTION] if ( ret = = false ) { return ret ; } return returnValueFor ( invocation . getMethod ( ) . getReturnType ( ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^20^^^^^18^25^
[REPLACE]  return  ret; 	[BUGGY] return null ; [FE]  AssertionFailedError  expected:<false> but was:<null> assertEquals(false , answer.answer(invocationOf(HasPrimitiveMethods.class ,   "booleanMethod  ")))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Object ret [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { [ATTENTION] return null ; } return returnValueFor ( invocation . getMethod ( ) . getReturnType ( ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^21^^^^^18^25^
[REPLACE]  return  returnValueFor  (  invocation  .  getMethod  (  )    .  getReturnType  (  )  )  ; 	[BUGGY] return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( ) . defaultAnswer ( this ) ) ; [CE] cannot find symbol clazz  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Object ret [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { Object ret = delegate . answer ( invocation ) ; if ( ret ! = null ) { return ret ; } [ATTENTION] return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( )  . defaultAnswer ( this ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^24^^^^^18^25^
[REPLACE]  if  (  !ClassImposterizer  .  INSTANCE  .  canImposterise  (  clazz  )  )  { 	[BUGGY] if ( !ClassImposterizer . INSTANCE . canImposterise ( null ) ) {[FE] NullPointerException assertNull(values.returnValueFor(Baz.class))   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> clazz [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> clazz ) { [ATTENTION] if ( !ClassImposterizer . INSTANCE . canImposterise ( null ) ) { return null ; } return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( ) . defaultAnswer ( this ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^29^^^^^28^34^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE]  Expected: <null> but was: false assertNull(values.returnValueFor(Baz.class))   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> clazz [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> clazz ) { if ( !ClassImposterizer . INSTANCE . canImposterise ( clazz ) ) { [ATTENTION] return false ; } return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( ) . defaultAnswer ( this ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^30^^^^^28^34^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE]  Expected: <null> but was: true assertNull(values.returnValueFor(Baz.class))   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> clazz [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> clazz ) { if ( !ClassImposterizer . INSTANCE . canImposterise ( clazz ) ) { [ATTENTION] return true ; } return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( ) . defaultAnswer ( this ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^30^^^^^28^34^
[REPLACE]  return  mockitoCore  .  mock  (  (  Class  )  clazz,  new  MockSettingsImpl  (  )    .  defaultAnswer  (  this  )  )  ; 	[BUGGY] return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( ) . defaultAnswer ( null ) ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> clazz [CLASS] ReturnsMocks  [TYPE] Answer delegate [TYPE] MockitoCore mockitoCore [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  Object returnValueFor ( Class<?> clazz ) { if ( !ClassImposterizer . INSTANCE . canImposterise ( clazz ) ) { return null ; } [ATTENTION] return mockitoCore . mock ( ( Class ) clazz , new MockSettingsImpl ( )  . defaultAnswer ( null ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java^33^^^^^28^34^
[REPLACE]  if  (  Invocation  .  isToString  (  invocation  )  )  { 	[BUGGY] else if ( Primitives . isPrimitiveWrapper ( type ) ) {[CE] illegal start of type  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { [ATTENTION] } else if ( Primitives . isPrimitiveWrapper ( type ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^56^^^^^55^68^
[ADD]  if  (  Invocation  .  isToString  (  invocation  )  )  {  Object  mock  =  invocation  .  getMock  (  )  ;  MockName  name  =  new  MockUtil  (  )    .  getMockName  (  mock  )  ;  if  (  name  .  isSurrogate  (  )  )  {  return    "Mock  for    "  +  ClassNameFinder  .  classNameForMock  (  mock  )  +    ",  hashCode:    "  +  mock  .  hashCode  (  )  ; 	[BUGGY] Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; [CE] illegal start of type  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { [ATTENTION] Object mock = invocation . getMock ( )  ; MockName name = new MockUtil ( )  . getMockName ( mock )  ; return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( )  ;   } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^56^57^58^59^60^55^68^
[REPLACE]  if  (  name  .  isSurrogate  (  )  )  { 	[BUGGY] else if ( type = = Collection . class ) {[CE] illegal start of type  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; [ATTENTION] } else if ( type = = Collection . class ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^59^^^^^55^68^
[ADD]  if  (  name  .  isSurrogate  (  )  )  {  return    "Mock  for    "  +  ClassNameFinder  .  classNameForMock  (  mock  )  +    ",  hashCode:    "  +  mock  .  hashCode  (  )  ;  }  else  {  return  name  .  toString  (  )  ;  } 	[BUGGY] [FE]   assertContains(  "great mockie  " , name)   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; [ATTENTION]   } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^59^60^61^62^63^55^68^
[REPLACE]  return  name  .  toString  (  )  ; 	[BUGGY] return name . isSurrogate ( )  ; [FE]  java.lang.Boolean cannot be cast to java.lang.String assertContains(  "great mockie  " , name)   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { [ATTENTION] return name . isSurrogate ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^62^^^^^55^68^
[REPLACE]  return    "Mock  for    "  +  ClassNameFinder  .  classNameForMock  (  mock  )  +    ",  hashCode:    "  +  mock  .  hashCode  (  )  ; 	[BUGGY] return   "Mock for   " +  mock  +   " , hashCode:   " + mock . hashCode ( ) ; [FE]  0 assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { [ATTENTION] return   "Mock for   " + mock+   " , hashCode:   " + mock . hashCode ( )  ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^60^^^^^55^68^
[REPLACE]  return    "Mock  for    "  +  ClassNameFinder  .  classNameForMock  (  mock  )  +    ",  hashCode:    "  +  mock  .  hashCode  (  )  ; 	[BUGGY] return   "Mock for   "  ; [FE]  AssertionFailedError  expected:<Mock for [DummyClass , hashCode: 1023714065]> but was:<Mock for []> assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { [ATTENTION] return   "Mock for   " ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^60^^^^^55^68^
[REPLACE]  Object  mock  =  invocation  .  getMock  (  )  ; 	[BUGGY] Object mock = invocation . getMethod ( ) ; [FE]  Argument should be a mock , but is: class java.lang.reflect.Method assertContains(  "great mockie  " , name)   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { [ATTENTION] Object mock = invocation . getMethod ( )  ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^57^^^^^55^68^
[REPLACE]  MockName  name  =  new  MockUtil  (  )    .  getMockName  (  mock  )  ; 	[BUGGY] MockName name = new MockUtil ( )  . MockUtil ( )  ; [CE] cannot find symbol  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; [ATTENTION] MockName name = new MockUtil ( ) . MockUtil ( ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^58^^^^^55^68^
[REPLACE]  return  name  .  toString  (  )  ; 	[BUGGY] return name . isSurrogate ( ) ; [FE]  java.lang.Boolean cannot be cast to java.lang.String assertContains(  "great mockie  " , name)   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { [ATTENTION] return name . isSurrogate ( )  ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^62^^^^^55^68^
[ADD]  Object  mock  =  invocation  .  getMock  (  )  ; 	[BUGGY] [CE] cannot find symbol mock  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { [ATTENTION] MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^57^^^^^55^68^
[REPLACE]  MockName  name  =  new  MockUtil  (  )    .  getMockName  (  mock  )  ; 	[BUGGY] Object mock = invocation . getMock ( ) ; [CE] variable mock is already defined in method answer(InvocationOnMock)  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; [ATTENTION] Object mock = invocation . getMock ( )  ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^58^^^^^55^68^
[REPLACE]  Class<?>  returnType  =  invocation  .  getMethod  (  )    .  getReturnType  (  )  ; 	[BUGGY] Class<?> returnType = invocation . getMock ( ) . getReturnType ( ) ; [CE] cannot find symbol  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } [ATTENTION] Class<?> returnType = invocation . getMock ( )  . getReturnType ( )  ; return returnValueFor ( returnType ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^66^^^^^55^68^
[REPLACE]  return  returnValueFor  (  returnType  )  ; 	[BUGGY] return returnValueFor ( this ) ; [CE] method returnValueFor in class ReturnsEmptyValues cannot be applied to given types ;  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ReturnsEmptyValues  [TYPE] MockName name [TYPE] boolean false true [TYPE] InvocationOnMock invocation [TYPE] Object mock [TYPE] Class returnType  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) { if ( Invocation . isToString ( invocation ) ) { Object mock = invocation . getMock ( ) ; MockName name = new MockUtil ( ) . getMockName ( mock ) ; if ( name . isSurrogate ( ) ) { return   "Mock for   " + ClassNameFinder . classNameForMock ( mock ) +   " , hashCode:   " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } Class<?> returnType = invocation . getMethod ( ) . getReturnType ( ) ; [ATTENTION] return returnValueFor ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^67^^^^^55^68^
[REPLACE]  if  (  type  .  isPrimitive  (  )  )  { 	[BUGGY] if (0 . isPrimitive ( ) ) {[CE] ')' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { [ATTENTION] if ( 0 . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^71^^^^^70^108^
[REPLACE]  }  else  if  (  Primitives  .  isPrimitiveWrapper  (  type  )  )  { 	[BUGGY]  if ( Primitives . isPrimitiveWrapper (1 ) ) {[CE] method isPrimitiveWrapper in class Primitives cannot be applied to given types ;  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; [ATTENTION] }if ( Primitives . isPrimitiveWrapper ( 1 ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^73^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Collection  .  class  )  { 	[BUGGY] else if ( type && Collection . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   [ATTENTION] } else if ( type&&Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^77^^^^^70^108^
[ADD]  else  if  (  type  ==  Collection  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  Set  .  class  )  {  return  new  HashSet<Object>  (  )  ; 	[BUGGY]  return new LinkedList<Object> ( ) ; return new HashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   [ATTENTION] } return new LinkedList<Object> ( )  ; return new HashSet<Object> ( )  ;   } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^77^78^79^80^^70^108^
[REPLACE]  }  else  if  (  type  ==  Set  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }else { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }else { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[ADD]  else  if  (  type  ==  HashSet  .  class  )  {  return  new  HashSet<Object>  (  )  ;  }  else  if  (  type  ==  SortedSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ; 	[BUGGY]  return new TreeSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } return new TreeSet<Object> ( )  ;   } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^82^83^84^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }else { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( type && TreeSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type&&TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[ADD]  else  if  (  type  ==  TreeSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ;  }  else  if  (  type  ==  LinkedHashSet  .  class  )  {  return  new  LinkedHashSet<Object>  (  )  ; 	[BUGGY]  return new LinkedHashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } return new LinkedHashSet<Object> ( )  ;   } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^86^87^88^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( type ! =  LinkedHashSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedHashSet  .  class  )  {  return  new  LinkedHashSet<Object>  (  )  ;  }  else  if  (  type  ==  List  .  class  )  {  return  new  LinkedList<Object>  (  )  ; 	[BUGGY]  return new LinkedHashSet<Object> ( ) ; return new LinkedList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } return new LinkedHashSet<Object> ( )  ; return new LinkedList<Object> ( )  ;   } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^88^89^90^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( type && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( type&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( false && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }else { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[ADD]  else  if  (  type  ==  ArrayList  .  class  )  {  return  new  ArrayList<Object>  (  )  ;  }  else  if  (  type  ==  Map  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY]  return new HashMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new HashMap<Object , Object> ( )  ;   } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^94^95^96^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (this ! =  Map . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }else { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[ADD]  else  if  (  type  ==  HashMap  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  SortedMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY]  return new HashMap<Object , Object> ( ) ; return new TreeMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } return new HashMap<Object , Object> ( )  ; return new TreeMap<Object , Object> ( )  ;   } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^98^99^100^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( this || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( type ! =  TreeMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[ADD]  else  if  (  type  ==  TreeMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  LinkedHashMap  .  class  )  {  return  new  LinkedHashMap<Object,  Object>  (  )  ;  } 	[BUGGY]  return new LinkedHashMap<Object , Object> ( ) ; [CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } return new LinkedHashMap<Object , Object> ( )  ;    return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^102^103^104^105^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( type ! =  LinkedHashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  LinkedHashMap<Object,  Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { [ATTENTION] returnnew Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^104^^^^^70^108^
[REPLACE]  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^102^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( type && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^100^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (false || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[ADD]  else  if  (  type  ==  TreeMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  LinkedHashMap  .  class  )  {  return  new  LinkedHashMap<Object,  Object>  (  )  ;  } 	[BUGGY]  return new TreeMap<Object , Object> ( ) ; return new LinkedHashMap<Object , Object> ( ) ; [CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } return new TreeMap<Object , Object> ( )  ; return new LinkedHashMap<Object , Object> ( )  ;    return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^102^103^104^105^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (true || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( type || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY] return new LinkedHashMap<Object , Object> ( ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { [ATTENTION] return new LinkedHashMap<Object , Object> ( )  ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^98^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (this && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }else { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  else {[CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }else { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( true && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedHashMap  .  class  )  {  return  new  LinkedHashMap<Object,  Object>  (  )  ;  } 	[BUGGY]  return new LinkedHashMap<Object , Object> ( ) ; [CE] unreachable statement  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } return new LinkedHashMap<Object , Object> ( )  ;   return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^104^105^^^70^108^
[REPLACE]  return  new  LinkedHashMap<Object,  Object>  (  )  ; 	[BUGGY] return new HashMap<Object , Object> ( ) ; [FE]  java.util.HashMap cannot be cast to java.util.LinkedHashMap assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { [ATTENTION] return new HashMap<Object , Object> ( )  ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^104^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( type ! =  TreeMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^98^^^^^70^108^
[REPLACE]  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY] return new HashMap<Object , Object> ( ) ; [FE]  java.util.HashMap cannot be cast to java.util.SortedMap assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { [ATTENTION] return new HashMap<Object , Object> ( )  ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^100^^^^^70^108^
[REPLACE]  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^96^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (this || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }else { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( type && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedHashMap  .  class  )  {  return  new  LinkedHashMap<Object,  Object>  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }   return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^104^105^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( type && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[ADD]  else  if  (  type  ==  SortedMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  TreeMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY]  return new TreeMap<Object , Object> ( ) ; return new TreeMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } return new TreeMap<Object , Object> ( )  ; return new TreeMap<Object , Object> ( )  ;   } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^100^101^102^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (this ! =  TreeMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object , Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object , Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object , Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object , Object> ( ) ;       }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type = = TreeMap . class ) { if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object , Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object , Object> ( ) ;   }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type = = LinkedHashMap . class ) { if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( null || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  ArrayList<Object>  (  )  ; 	[BUGGY] return new LinkedList<Object> ( ) ; [FE]  java.util.LinkedList cannot be cast to java.util.ArrayList assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { [ATTENTION] return new LinkedList<Object> ( )  ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^94^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }else { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( type && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( type || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( type ! =  LinkedHashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY] return new HashMap<Object , Object> ( ) ; [FE]  java.util.HashMap cannot be cast to java.util.TreeMap assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { [ATTENTION] return new HashMap<Object , Object> ( )  ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^102^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object , Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object , Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object , Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object , Object> ( ) ;       }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type = = SortedMap . class ) { if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( this || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( false || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY] return new LinkedHashMap<Object , Object> ( ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { [ATTENTION] return new LinkedHashMap<Object , Object> ( )  ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^96^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( type || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object , Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object , Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object , Object> ( ) ;     }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type = = HashMap . class ) { if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( type || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (0 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( type || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (1 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 1 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^92^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( false || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[ADD]  else  if  (  type  ==  SortedMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  TreeMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY]  return new TreeMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } return new TreeMap<Object , Object> ( )  ;   } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^100^101^102^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( true || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 1 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( null && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( type ! =  SortedMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( type || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( type||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( null || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( false && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  ArrayList<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^94^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( null ! =  Map . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( null! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( this && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( null && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( null || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( type && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 1 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( true ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^90^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( type ! =  LinkedList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (true && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( type ! =  HashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (this && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (false && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( null ! =  LinkedHashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( this ! =  LinkedHashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( type ! =  Map . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( type! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object , Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object , Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object , Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object , Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object , Object> ( ) ;                 }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( type = = Map . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( type ! =  HashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[ADD]  else  if  (  type  ==  HashMap  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  SortedMap  .  class  )  {  return  new  TreeMap<Object,  Object>  (  )  ; 	[BUGGY]  return new TreeMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } return new TreeMap<Object , Object> ( )  ;   } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^98^99^100^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( type && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (0 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( this || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( this ! =  TreeMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( null ! =  LinkedHashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( null && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( true ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( null && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( type ! =  ArrayList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object , Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object , Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object , Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type = = ArrayList . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( null && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( type && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( type&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( type || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( type||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( null || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (1 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (this ! =  LinkedHashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (false ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 0 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (this ! =  LinkedHashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [FE]  java.util.LinkedHashSet cannot be cast to java.util.List assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^90^^^^^70^108^
[REPLACE]  return  new  LinkedHashSet<Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^88^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( type && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( type&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[ADD]  else  if  (  type  ==  List  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  LinkedList  .  class  )  {  return  new  LinkedList<Object>  (  )  ; 	[BUGGY]  return new LinkedList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } return new LinkedList<Object> ( )  ;   } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^90^91^92^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }else { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( type && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( type && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( type&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( null || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( false ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( type ! =  SortedMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( null && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (this || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( this && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (true ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (1 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (false || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (this ! =  ArrayList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( type || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( type||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[ADD]  else  if  (  type  ==  Map  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  HashMap  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY]  return new HashMap<Object , Object> ( ) ; return new HashMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } return new HashMap<Object , Object> ( )  ; return new HashMap<Object , Object> ( )  ;   } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^96^97^98^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( null && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( null ! =  TreeMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( null! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (true ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( true && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (true && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( this || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 1 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[ADD]  else  if  (  type  ==  Map  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ;  }  else  if  (  type  ==  HashMap  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY]  return new HashMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } return new HashMap<Object , Object> ( )  ;   } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^96^97^98^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( type || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (false ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (1 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (true || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( this && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( this && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (true || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedList  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  ArrayList  .  class  )  {  return  new  ArrayList<Object>  (  )  ; 	[BUGGY]  return new ArrayList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new ArrayList<Object> ( )  ;   } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^92^93^94^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (false && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 0 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 0 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (this ! =  SortedMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 0 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (false && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[ADD]  else  if  (  type  ==  ArrayList  .  class  )  {  return  new  ArrayList<Object>  (  )  ;  }  else  if  (  type  ==  Map  .  class  )  {  return  new  HashMap<Object,  Object>  (  )  ; 	[BUGGY]  return new ArrayList<Object> ( ) ; return new HashMap<Object , Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new ArrayList<Object> ( )  ; return new HashMap<Object , Object> ( )  ;   } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^94^95^96^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( type ! =  Map . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( type! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( false || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (true && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( this || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (1 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (false && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 1 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( this || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [FE]  java.util.LinkedHashSet cannot be cast to java.util.LinkedList assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^92^^^^^70^108^
[REPLACE]  return  new  TreeSet<Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^86^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( type || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( this && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( this&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedList  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  ArrayList  .  class  )  {  return  new  ArrayList<Object>  (  )  ; 	[BUGGY]  return new LinkedList<Object> ( ) ; return new ArrayList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new LinkedList<Object> ( )  ; return new ArrayList<Object> ( )  ;   } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^92^93^94^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( true || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (true ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( true ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (false ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (true && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( null ! =  ArrayList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (this || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (false || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (this && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( true ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (false && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( null && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( this ! =  SortedMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( true && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( false || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (true || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( false && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( true || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }else { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( type || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( this && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( this && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (0 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 1 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( false ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( false ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( null ! =  SortedMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (true && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (0 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( null ! =  TreeMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( null! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( true && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (0 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( type || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( type||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 0 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 1 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( false ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( null && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( null&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( true ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (false || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (false && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( false && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (true || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (this && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  return  new  TreeSet<Object>  (  )  ; 	[BUGGY] return new Object , Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { [ATTENTION] returnnew Object , Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^84^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if (false || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( false||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }else { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (1 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( false || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( this ! =  LinkedHashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (true ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (this || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( true && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( null || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( null||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( null ! =  ArrayList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( null! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( type && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( type&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( this && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 1 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (0 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( null || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( this || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (0 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( null || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 1 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (false && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( true || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( type ! =  List . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( type! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( null && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (0 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( this ! =  SortedMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( type && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( type&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( true && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 0 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( type ! =  ArrayList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (this || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( false && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 1 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( false && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object , Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object , Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object , Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type = = LinkedList . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( this ! =  ArrayList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (this && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( this || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( true || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (this && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 0 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( this && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (1 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (this && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if (true && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( true&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if (true || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( true||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( null ! =  LinkedList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( type && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 0 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 0 || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( true || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if ( 1 || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (true && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (0 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( true && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( type || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( null || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (0 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( true ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (false ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 0 ! =  LinkedHashMap . class ) {[CE] incomparable types: int and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( this && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( false && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (false || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( this ! =  TreeMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( false ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (this ! =  TreeMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (this ! =  SortedMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (1 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( true || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( true||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( true && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( true || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( false ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (false ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (this || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( false && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (0 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 0 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  return  new  HashSet<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^82^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( this && SortedSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( this&&SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( null && TreeSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( null&&TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[ADD]  else  if  (  type  ==  LinkedHashSet  .  class  )  {  return  new  LinkedHashSet<Object>  (  )  ;  }  else  if  (  type  ==  List  .  class  )  {  return  new  LinkedList<Object>  (  )  ; 	[BUGGY]  return new LinkedList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } return new LinkedList<Object> ( )  ;   } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^88^89^90^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( type && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (1 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 0 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (true ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 1 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (this || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( null ! =  SortedMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 0 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 0&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( 0 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( true || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (1 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 0 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( this || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( this ! =  Map . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( this || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (this && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 1 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (this && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( true ! =  LinkedHashMap . class ) {[CE] incomparable types: boolean and Class<LinkedHashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 1 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( null && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( null&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (this ! =  HashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY]  if (this && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( true || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( null || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( null||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (1 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (0 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (0 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( false || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[ADD]  else  if  (  type  ==  List  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  LinkedList  .  class  )  {  return  new  LinkedList<Object>  (  )  ; 	[BUGGY]  return new LinkedList<Object> ( ) ; return new LinkedList<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } return new LinkedList<Object> ( )  ; return new LinkedList<Object> ( )  ;   } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^90^91^92^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( true ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( this && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (1 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( null ! =  HashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( null! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( this && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( type ! =  LinkedList . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (true || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (false || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (0 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (true ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  return  new  LinkedHashSet<Object>  (  )  ; 	[BUGGY] return new LinkedList<Object> ( ) ; [FE]  java.util.LinkedList cannot be cast to java.util.LinkedHashSet assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { [ATTENTION] return new LinkedList<Object> ( )  ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^88^^^^^70^108^
[REPLACE]  return  new  TreeSet<Object>  (  )  ; 	[BUGGY] return new HashSet<Object> ( ) ; [FE]  java.util.HashSet cannot be cast to java.util.SortedSet assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { [ATTENTION] return new HashSet<Object> ( )  ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^84^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( type ! =  TreeSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type! = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( type || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( type||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (1 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( false || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 1 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( true && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (1 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( false ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 1 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( false || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 0 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (true && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( this && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( false || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( true && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 1 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (true && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (1 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 0 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 0 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if ( 0 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( true || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( true||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( true || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( true||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 1 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (this || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (this || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (false || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( 1 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 0 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 0! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( type || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( type || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (true ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (true || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( true||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (false && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( false ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  return  new  HashSet<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^80^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if ( type ! =  HashSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type! = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[ADD]  else  if  (  type  ==  SortedSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ;  }  else  if  (  type  ==  TreeSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ; 	[BUGGY]  return new TreeSet<Object> ( ) ; return new TreeSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } return new TreeSet<Object> ( )  ; return new TreeSet<Object> ( )  ;   } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^84^85^86^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( type && TreeSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type&&TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( type || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( type||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (this && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( null && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( null&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if ( 0 && LinkedHashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( false ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (this || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( null || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( this ! =  HashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( false && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 1 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (false ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (true || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (true || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( this || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (1 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (this || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( null ! =  LinkedHashSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( null! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( this || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 1 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 1 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (0 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (false && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( this && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (1 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( null ! =  HashMap . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( null! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 0 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 0||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (true ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 1 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashMap  .  class  )  { 	[BUGGY] else if (false || LinkedHashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^103^^^^^70^108^
[ADD]  else  if  (  type  ==  TreeSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ;  }  else  if  (  type  ==  LinkedHashSet  .  class  )  {  return  new  LinkedHashSet<Object>  (  )  ; 	[BUGGY]  return new TreeSet<Object> ( ) ; return new LinkedHashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } return new TreeSet<Object> ( )  ; return new LinkedHashSet<Object> ( )  ;   } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^86^87^88^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if (this && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( null ! =  Map . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( null! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (0 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (false && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (true || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if (false ! =  List . class ) {[CE] incomparable types: boolean and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( false! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( false ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (this ! =  Map . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( this! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }else                       if ( type = =  ( class ) ) {                         return new Object , Object> ( ) ;                       }else                         if ( type = =  ( class ) ) {                           return new Object , Object> ( ) ;                         }else                           if ( type = =  ( class ) ) {                             return new Object , Object> ( ) ;                           }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( type = = List . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 1 ! =  TreeMap . class ) {[CE] incomparable types: int and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (1 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( type ! =  List . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( type! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (false ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( false! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( false && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY] else if ( 1 || SortedSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( 1||SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }else                       if ( type = =  ( class ) ) {                         return new Object , Object> ( ) ;                       }else                         if ( type = =  ( class ) ) {                           return new Object , Object> ( ) ;                         }else                           if ( type = =  ( class ) ) {                             return new Object , Object> ( ) ;                           }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( type = = SortedSet . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( type || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( 1 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if ( 0 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (false || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (true ! =  TreeMap . class ) {[CE] incomparable types: boolean and Class<TreeMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( true ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (this ! =  HashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (this || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( this||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( null ! =  List . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( null! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (0 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 1 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( null || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( null||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  return  new  TreeSet<Object>  (  )  ; 	[BUGGY] return new HashSet<Object> ( ) ; [FE]  java.util.HashSet cannot be cast to java.util.TreeSet assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { [ATTENTION] return new HashSet<Object> ( )  ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^86^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( false || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( null || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( null||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 1 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( this ! =  List . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( this! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( 0 || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( null && TreeSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( null&&TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }else                       if ( type = =  ( class ) ) {                         return new Object , Object> ( ) ;                       }else                         if ( type = =  ( class ) ) {                           return new Object , Object> ( ) ;                         }else                           if ( type = =  ( class ) ) {                             return new Object , Object> ( ) ;                           }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type = = TreeSet . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( type ! =  LinkedHashSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }else                       if ( type = =  ( class ) ) {                         return new Object , Object> ( ) ;                       }else                         if ( type = =  ( class ) ) {                           return new Object , Object> ( ) ;                         }else                           if ( type = =  ( class ) ) {                             return new Object , Object> ( ) ;                           }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type = = LinkedHashSet . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( true ! =  SortedMap . class ) {[CE] incomparable types: boolean and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (false ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (1 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( false || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (true && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if ( 0 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( type && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( type && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (1 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( null && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( this ! =  HashMap . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( false && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new Object> ( )  ; [CE] '(' or '[' expected  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { [ATTENTION] returnnew Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^78^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Set  .  class  )  { 	[BUGGY]  if ( type || Set . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type||Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REMOVE]   	[BUGGY] if ( type = =  ( class ) ) {   return new Object> ( ) ; }else   if ( type = =  ( class ) ) {     return new Object> ( ) ;   }else     if ( type = =  ( class ) ) {       return new Object> ( ) ;     }else       if ( type = =  ( class ) ) {         return new Object> ( ) ;       }else         if ( type = =  ( class ) ) {           return new Object> ( ) ;         }else           if ( type = =  ( class ) ) {             return new Object> ( ) ;           }else             if ( type = =  ( class ) ) {               return new Object> ( ) ;             }else               if ( type = =  ( class ) ) {                 return new Object> ( ) ;               }else                 if ( type = =  ( class ) ) {                   return new Object> ( ) ;                 }else                   if ( type = =  ( class ) ) {                     return new Object , Object> ( ) ;                   }else                     if ( type = =  ( class ) ) {                       return new Object , Object> ( ) ;                     }else                       if ( type = =  ( class ) ) {                         return new Object , Object> ( ) ;                       }else                         if ( type = =  ( class ) ) {                           return new Object , Object> ( ) ;                         }else                           if ( type = =  ( class ) ) {                             return new Object , Object> ( ) ;                           }[CE] illegal start of expression  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type = = Set . class ) { if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }else if ( type = = ( class ) ) { return new Object , Object> ( )  ; }return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if (this ! =  HashSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( this! = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[ADD]  else  if  (  type  ==  SortedSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ;  }  else  if  (  type  ==  TreeSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ; 	[BUGGY]  return new TreeSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } return new TreeSet<Object> ( )  ;   } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^84^85^86^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( type || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( true ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (false || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( null && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( null&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (true && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( true || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (1 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( false ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }else { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (1 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (0 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (false ! =  HashMap . class ) {[CE] incomparable types: boolean and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( false! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( true && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( true&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if ( 0 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( type && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( false || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (false ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (this && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( null || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( null||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  return  new  HashSet<Object>  (  )  ; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^82^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( this && TreeSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this&&TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( this && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (this ! =  LinkedList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if ( 0 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 0! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( true && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 0 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (this && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (1 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (0 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (0 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( false ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 0 ! =  ArrayList . class ) {[CE] incomparable types: int and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if (this || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( this||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( this || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( this||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if ( type && HashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type&&HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[ADD]  else  if  (  type  ==  HashSet  .  class  )  {  return  new  HashSet<Object>  (  )  ;  }  else  if  (  type  ==  SortedSet  .  class  )  {  return  new  TreeSet<Object>  (  )  ; 	[BUGGY]  return new HashSet<Object> ( ) ; return new TreeSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } return new HashSet<Object> ( )  ; return new TreeSet<Object> ( )  ;   } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^82^83^84^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( type ! =  SortedSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type! = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if (1 && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( 1&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( null && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( null&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( this || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( this||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (this && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( this&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (1 ! =  SortedMap . class ) {[CE] incomparable types: int and Class<SortedMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1! = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (true && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (1 || TreeMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY] else if (0 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeMap  .  class  )  { 	[BUGGY]  if (0 && TreeMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; [ATTENTION] }if ( 0&&TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^101^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( this ! =  Map . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( this! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (0 && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( 1 && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (false ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( false! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (true && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY]  if (1 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (0 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 0! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( type || SortedSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type||SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( null || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( null||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (true ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( true! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( true ! =  List . class ) {[CE] incomparable types: boolean and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( true! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( type || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( type||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( false && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( false&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (false ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( null || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( null||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( true || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  return  new  HashSet<Object>  (  )  ; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^80^^^^^70^108^
[REPLACE]  return  Primitives  .  primitiveWrapperOf  (  type  )  ; 	[BUGGY] return Primitives . isPrimitiveWrapper ( null ) ; [FE]  java.lang.Boolean cannot be cast to java.lang.Byte assertEquals(new Byte((byte) 0) , mock.byteObjectReturningMethod())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { [ATTENTION] return Primitives . isPrimitiveWrapper ( null )  ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^74^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Collection  .  class  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   [ATTENTION] }else { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^77^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY] else if (0 || SortedMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( this ! =  List . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( this! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( this ! =  LinkedHashSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( null || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( null||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 1 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (true || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( false ! =  List . class ) {[CE] incomparable types: boolean and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( false! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if ( 1 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 1! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (false ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (1 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (0 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( true ! =  Map . class ) {[CE] incomparable types: boolean and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY] else if ( type ! =  SortedSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( type! = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( this ! =  TreeSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<TreeSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( this! = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( 1 || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( 1||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (true ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (true ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( this && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( this&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( this ! =  LinkedList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if (false || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( false||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( true || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (0 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedMap  .  class  )  { 	[BUGGY]  if (1 && SortedMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] }if ( 1&&SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^99^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 1 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 1! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if (false && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( false&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( this || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY]  if (0 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] }if ( 0&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( false ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( 1 || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( true ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (0 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 0||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( false ! =  SortedSet . class ) {[CE] incomparable types: boolean and Class<SortedSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( false! = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( null ! =  TreeSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( null! = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (false && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 1 || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( 1 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (false && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Set  .  class  )  { 	[BUGGY]  if ( type && Set . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( type&&Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( type && SortedSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type&&SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (true ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 0 ! =  HashMap . class ) {[CE] incomparable types: int and Class<HashMap>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0! = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( null || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( null||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( 1 || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( 1||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if (true || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( true||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( false ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (true && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( 1 || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (1 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (this || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if ( null || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( null||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( this ! =  LinkedList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if ( type || HashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( type||HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if ( 0 || HashMap . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0||HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (0 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 0&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( this || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( this||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if (this && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( this&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (1 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (1 || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( true && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( true&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( false || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( false||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  return  Primitives  .  primitiveWrapperOf  (  type  )  ; 	[BUGGY] return Primitives . isPrimitiveWrapper ( null )  ; [FE]  java.lang.Boolean cannot be cast to java.lang.Byte assertEquals(new Byte((byte) 0) , mock.byteObjectReturningMethod())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { [ATTENTION] return Primitives . isPrimitiveWrapper ( null ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^74^^^^^70^108^
[REPLACE]  return  primitiveOf  (  type  )  ; 	[BUGGY] return primitiveOf ( null ) ; [FE]  java.lang.Integer cannot be cast to java.lang.Boolean assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { [ATTENTION] return primitiveOf ( null )  ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^72^^^^^70^108^
[REPLACE]  }  else  if  (  Primitives  .  isPrimitiveWrapper  (  type  )  )  { 	[BUGGY] else if ( Primitives . isPrimitiveWrapper (true ) ) {[CE] method isPrimitiveWrapper in class Primitives cannot be applied to given types ;  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; [ATTENTION] } else if ( Primitives . isPrimitiveWrapper ( true ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^73^^^^^70^108^
[ADD]  else  if  (  type  ==  Set  .  class  )  {  return  new  HashSet<Object>  (  )  ;  }  else  if  (  type  ==  HashSet  .  class  )  {  return  new  HashSet<Object>  (  )  ; 	[BUGGY]  return new HashSet<Object> ( ) ; return new HashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new HashSet<Object> ( )  ; return new HashSet<Object> ( )  ;   } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^80^81^82^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY] else if ( type ! =  HashSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( type! = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( this ! =  ArrayList . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( null && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( null&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (1 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( false && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( false&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( false || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( null && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( null&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (false && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (false ! =  ArrayList . class ) {[CE] incomparable types: boolean and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (0 || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY]  if ( null && SortedSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( null&&SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( true && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if (this ! =  LinkedHashSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( this! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if (this ! =  List . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( this! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (false && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  return  new  LinkedList<Object>  (  )  ; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [NO-ERROR]  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^78^^^^^70^108^
[ADD]  else  if  (  type  ==  Set  .  class  )  {  return  new  HashSet<Object>  (  )  ;  }  else  if  (  type  ==  HashSet  .  class  )  {  return  new  HashSet<Object>  (  )  ; 	[BUGGY]  return new HashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } return new HashSet<Object> ( )  ;   } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^80^81^82^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( this && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( this&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashMap  .  class  )  { 	[BUGGY] else if (0 && HashMap . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; [ATTENTION] } else if ( 0&&HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^97^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if (true ! =  LinkedHashSet . class ) {[CE] incomparable types: boolean and Class<LinkedHashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( true! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY] else if ( type && SortedSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( type&&SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if ( true ! =  LinkedList . class ) {[CE] incomparable types: boolean and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (0 ! =  ArrayList . class ) {[CE] incomparable types: int and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( 0 || Map . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 0||Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( false && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if (1 ! =  HashSet . class ) {[CE] incomparable types: int and Class<HashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( 1! = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if ( type ! =  TreeSet . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( type! = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( 1 && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( 1&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( 0 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( 1 && Map . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1&&Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY]  if (this || TreeSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this||TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( false && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( false&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( 0 && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (0 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if (0 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 0! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( false || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( false||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  return  Primitives  .  primitiveWrapperOf  (  type  )  ; 	[BUGGY] return Primitives . isPrimitiveWrapper ( type ) ; [FE]  java.lang.Boolean cannot be cast to java.lang.Byte assertEquals(new Byte((byte) 0) , mock.byteObjectReturningMethod())   [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { [ATTENTION] return Primitives . isPrimitiveWrapper ( type )  ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^74^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Collection  .  class  )  { 	[BUGGY]  if ( false && Collection . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   [ATTENTION] }if ( false&&Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^77^^^^^70^108^
[ADD]  else  if  (  type  ==  Collection  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  ==  Set  .  class  )  {  return  new  HashSet<Object>  (  )  ; 	[BUGGY]  return new HashSet<Object> ( ) ; [CE] illegal start of type  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   [ATTENTION] } return new HashSet<Object> ( )  ;   } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^77^78^79^80^^70^108^
[REPLACE]  }  else  if  (  type  ==  Set  .  class  )  { 	[BUGGY] else if ( type && Set . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( type&&Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( 0 ! =  LinkedList . class ) {[CE] incomparable types: int and Class<LinkedList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 0! = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if (true ! =  List . class ) {[CE] incomparable types: boolean and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( true! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if (true || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( true||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( false || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( 0 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 0! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if ( true && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( true&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY] else if ( true || SortedSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( true||SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( this || LinkedHashSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this||LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if (true ! =  List . class ) {[CE] incomparable types: boolean and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( true! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY] else if ( null && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( null&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( false && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( false&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( true || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( true||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (true || ArrayList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true||ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if (this || List . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( this||List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if (1 ! =  ArrayList . class ) {[CE] incomparable types: int and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  TreeSet  .  class  )  { 	[BUGGY] else if (0 ! =  TreeSet . class ) {[CE] incomparable types: int and Class<TreeSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] } else if ( 0! = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^85^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 0 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( 1 && List . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( 1&&List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( 1 ! =  ArrayList . class ) {[CE] incomparable types: int and Class<ArrayList>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 1! = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Set  .  class  )  { 	[BUGGY]  if ( this && Set . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this&&Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^79^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  HashSet  .  class  )  { 	[BUGGY]  if ( this ! =  HashSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<HashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; [ATTENTION] }if ( this! = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^81^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY]  if (this ! =  List . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<List>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] }if ( this! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if ( false && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if ( 1 && LinkedHashSet . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( 1&&LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  SortedSet  .  class  )  { 	[BUGGY] else if (this || SortedSet . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; [ATTENTION] } else if ( this||SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^83^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY]  if ( 1 && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( 1&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if ( true || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( true||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  ArrayList  .  class  )  { 	[BUGGY] else if (true && ArrayList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( true&&ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^93^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedHashSet  .  class  )  { 	[BUGGY]  if (this ! =  LinkedHashSet . class ) {[CE] incomparable types: ReturnsEmptyValues and Class<LinkedHashSet>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; [ATTENTION] }if ( this! = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^87^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (false || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( false||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY] else if (0 && LinkedList . class ) {[CE] bad operand types for binary operator '&&'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] } else if ( 0&&LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (false || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( false||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  LinkedList  .  class  )  { 	[BUGGY]  if (this || LinkedList . class ) {[CE] bad operand types for binary operator '||'  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; [ATTENTION] }if ( this||LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^91^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  Map  .  class  )  { 	[BUGGY] else if ( 1 ! =  Map . class ) {[CE] incomparable types: int and Class<Map>  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; [ATTENTION] } else if ( 1! = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^95^^^^^70^108^
[REPLACE]  }  else  if  (  type  ==  List  .  class  )  { 	[BUGGY] else if ( null ! =  List . class ) {[FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; [ATTENTION] } else if ( null! = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^89^^^^^70^108^
[REPLACE]  return  primitiveOf  (  type  )  ; 	[BUGGY] return primitiveOf ( 1 ) ; [CE] method primitiveOf in class ReturnsEmptyValues cannot be applied to given types ;  [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { [ATTENTION] return primitiveOf ( 1 )  ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^72^^^^^70^108^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  returnValueFor [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  Object returnValueFor ( Class<?> type ) { if ( type . isPrimitive ( ) ) { return primitiveOf ( type ) ; } else if ( Primitives . isPrimitiveWrapper ( type ) ) { return Primitives . primitiveWrapperOf ( type ) ;   } else if ( type = = Collection . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = Set . class ) { return new HashSet<Object> ( ) ; } else if ( type = = HashSet . class ) { return new HashSet<Object> ( ) ; } else if ( type = = SortedSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = TreeSet . class ) { return new TreeSet<Object> ( ) ; } else if ( type = = LinkedHashSet . class ) { return new LinkedHashSet<Object> ( ) ; } else if ( type = = List . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = LinkedList . class ) { return new LinkedList<Object> ( ) ; } else if ( type = = ArrayList . class ) { return new ArrayList<Object> ( ) ; } else if ( type = = Map . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = HashMap . class ) { return new HashMap<Object , Object> ( ) ; } else if ( type = = SortedMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = TreeMap . class ) { return new TreeMap<Object , Object> ( ) ; } else if ( type = = LinkedHashMap . class ) { return new LinkedHashMap<Object , Object> ( ) ; }  [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^107^^^^^70^108^
[REPLACE]  if  (  type  ==  Boolean  .  TYPE  )  { 	[BUGGY] if ( type || Boolean . TYPE ) {[CE] bad operand types for binary operator '||'  [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { [ATTENTION] if ( type||Boolean . TYPE ) { return false ; } else if ( type = = Character . TYPE ) { return ( char ) 0 ; } else { return 0 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^111^^^^^110^118^
[REPLACE]  }  else  if  (  type  ==  Character  .  TYPE  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; [ATTENTION] }else { return ( char ) 0 ; } else { return 0 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^113^^^^^110^118^
[REPLACE]  return  0; 	[BUGGY] return 4 ; [FE]  AssertionFailedError  expected:<0> but was:<4> assertEquals(false , values.returnValueFor(Boolean.TYPE))   [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; } else if ( type = = Character . TYPE ) { return ( char ) 0 ; } else { [ATTENTION] return 4 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^116^^^^^110^118^
[REPLACE]  return  (  char  )  0; 	[BUGGY] return new LinkedHashSet<Object> ( ) ; [FE]  expected:< assertEquals(false , values.returnValueFor(Boolean.TYPE))   [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; } else if ( type = = Character . TYPE ) { [ATTENTION] return new LinkedHashSet<Object> ( )  ; } else { return 0 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^114^^^^^110^118^
[REPLACE]  return  0; 	[BUGGY] return 2 ; [FE]  AssertionFailedError  expected:<0> but was:<2> assertEquals(false , values.returnValueFor(Boolean.TYPE))   [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; } else if ( type = = Character . TYPE ) { return ( char ) 0 ; } else { [ATTENTION] return 2 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^116^^^^^110^118^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<false> but was:<true> assertEquals(false , values.returnValueFor(Boolean.TYPE))   [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { [ATTENTION] return true ; } else if ( type = = Character . TYPE ) { return ( char ) 0 ; } else { return 0 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^112^^^^^110^118^
[ADD]  else  if  (  type  ==  Character  .  TYPE  )  {  return  (  char  )  0;  }  else  {  return  0;  } 	[BUGGY]  return ( char ) 0 ; return 0 ; [CE] unreachable statement  [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; [ATTENTION] } return ( char ) 0 ; return 0 ;   }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^113^114^115^116^117^110^118^
[REPLACE]  return  0; 	[BUGGY] return 3 ; [FE]  AssertionFailedError  expected:<0> but was:<3> assertEquals(false , values.returnValueFor(Boolean.TYPE))   [METHOD]  primitiveOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] ReturnsEmptyValues  [TYPE] boolean false true [TYPE] Class type  [CONTEXT]  private Object primitiveOf ( Class<?> type ) { if ( type = = Boolean . TYPE ) { return false ; } else if ( type = = Character . TYPE ) { return ( char ) 0 ; } else { [ATTENTION] return 3 ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java^116^^^^^110^118^
[REPLACE]  return  new  GlobalConfiguration  (  )    .  getDefaultAnswer  (  )    .  answer  (  invocation  )  ; 	[BUGGY] return new GlobalConfiguration ( )  . GlobalConfiguration ( )  . answer ( invocation ) ; [CE] cannot find symbol  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] GloballyConfiguredAnswer  [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] return new GlobalConfiguration ( ) . GlobalConfiguration ( ) . answer ( invocation )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java^20^^^^^19^21^
[REPLACE]  private  final  Queue<Answer>  answers  =  new  ConcurrentLinkedQueue<Answer>  (  )  ; 	[BUGGY] private final Queue<Answer> answers ; [CE] variable answers might not have been initialized  [CONTEXT]    [CLASS] StubbedInvocationMatcher  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^17^^^^^^^
[REPLACE]  super  (  invocation  .  getInvocation  (  )  ,  invocation  .  getMatchers  (  )  )  ; 	[BUGGY] super ( invocation . getMatchers ( ) , invocation . getMatchers ( ) ) ; [CE] no suitable constructor found for InvocationMatcher(List<Matcher> , List<Matcher>)  [METHOD]  <init> [TYPE] Answer) [PARAMETER] InvocationMatcher invocation Answer answer [CLASS] StubbedInvocationMatcher  [TYPE] InvocationMatcher invocation [TYPE] Answer answer [TYPE] boolean false true [TYPE] Queue answers  [CONTEXT]  public StubbedInvocationMatcher ( InvocationMatcher invocation , Answer answer ) { [ATTENTION] super ( invocation . getMatchers ( )  , invocation . getMatchers ( ) )  ; this . answers . add ( answer ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^20^^^^^19^22^
[REPLACE]  super  (  invocation  .  getInvocation  (  )  ,  invocation  .  getMatchers  (  )  )  ; 	[BUGGY] super ( invocation . getMatchers ( )  , invocation . getMatchers ( ) ) ; [CE] no suitable constructor found for InvocationMatcher(List<Matcher> , List<Matcher>)  [METHOD]  <init> [TYPE] Answer) [PARAMETER] InvocationMatcher invocation Answer answer [CLASS] StubbedInvocationMatcher  [TYPE] InvocationMatcher invocation [TYPE] Answer answer [TYPE] boolean false true [TYPE] Queue answers  [CONTEXT]  public StubbedInvocationMatcher ( InvocationMatcher invocation , Answer answer ) { [ATTENTION] super ( invocation . getMatchers ( ) , invocation . getMatchers ( ) )  ; this . answers . add ( answer ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^20^^^^^19^22^
[REPLACE]  super  (  invocation  .  getInvocation  (  )  ,  invocation  .  getMatchers  (  )  )  ; 	[BUGGY] super ( invocation . getInvocation ( ) , invocation . getInvocation ( )  ) ; [CE] no suitable constructor found for InvocationMatcher(Invocation , Invocation)  [METHOD]  <init> [TYPE] Answer) [PARAMETER] InvocationMatcher invocation Answer answer [CLASS] StubbedInvocationMatcher  [TYPE] InvocationMatcher invocation [TYPE] Answer answer [TYPE] boolean false true [TYPE] Queue answers  [CONTEXT]  public StubbedInvocationMatcher ( InvocationMatcher invocation , Answer answer ) { [ATTENTION] super ( invocation . getInvocation ( )  , invocation . getInvocation ( )  )  ; this . answers . add ( answer ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^20^^^^^19^22^
[REPLACE]  this  .  answers  .  add  (  answer  )  ; 	[BUGGY] answers . add ( answer ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Answer) [PARAMETER] InvocationMatcher invocation Answer answer [CLASS] StubbedInvocationMatcher  [TYPE] InvocationMatcher invocation [TYPE] Answer answer [TYPE] boolean false true [TYPE] Queue answers  [CONTEXT]  public StubbedInvocationMatcher ( InvocationMatcher invocation , Answer answer ) { super ( invocation . getInvocation ( ) , invocation . getMatchers ( ) ) ; [ATTENTION] answers . add ( answer )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^21^^^^^19^22^
[REPLACE]  return  answers  .  size  (  )  ==  1  ?  answers  .  peek  (  )    .  answer  (  invocation  )  :  answers  .  poll  (  )    .  answer  (  invocation  )  ; 	[BUGGY] return answers . size ( ) + 5 = = 0 ? answers . peek ( ) . answer ( invocation ) : answers . poll ( ) . answer ( invocation ) ; [FE] NullPointerException assertEquals(  "foo  " , mock.oneArg('s'))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] StubbedInvocationMatcher  [TYPE] Queue answers [TYPE] InvocationOnMock invocation [TYPE] boolean false true  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable {  synchronized ( answers ) { [ATTENTION] return answers . size ( ) + 5 = = 0? answers . peek ( )  . answer ( invocation ) : answers . poll ( )  . answer ( invocation )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^27^^^^^24^29^
[REPLACE]  answers  .  add  (  answer  )  ; 	[BUGGY] this . answers . add ( answer ) ; [NO-ERROR]  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer [CLASS] StubbedInvocationMatcher  [TYPE] Queue answers [TYPE] Answer answer [TYPE] boolean false true  [CONTEXT]  public void addAnswer ( Answer answer ) { [ATTENTION] this . answers . add ( answer )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^32^^^^^31^33^
[REPLACE]  return  super  .  toString  (  )  +    "  stubbed  with:    "  +  answers; 	[BUGGY] return super . toString ( ) +   " stubbed with:   " +false ; [NO-ERROR]  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] StubbedInvocationMatcher  [TYPE] Queue answers [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return super . toString ( ) +   " stubbed with:   " +false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java^37^^^^^36^38^
[REPLACE]  this  .  mock  =  mock; 	[BUGGY] this . mock =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockitoStubber) [PARAMETER] T mock MockitoStubber mockitoStubber [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbableImpl ( T mock , MockitoStubber mockitoStubber ) { [ATTENTION] this . mock = null ; this . mockitoStubber = mockitoStubber ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^17^^^^^16^19^
[REPLACE]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] this . mockitoStubber =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockitoStubber) [PARAMETER] T mock MockitoStubber mockitoStubber [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbableImpl ( T mock , MockitoStubber mockitoStubber ) { this . mock = mock ; [ATTENTION] this . mockitoStubber = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^18^^^^^16^19^
[ADD]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockitoStubber) [PARAMETER] T mock MockitoStubber mockitoStubber [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbableImpl ( T mock , MockitoStubber mockitoStubber ) { this . mock = mock ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^18^^^^^16^19^
[REPLACE]  mockitoStubber  .  addAnswerForVoidMethod  (  "    ")  ; 	[BUGGY] mockitoStubber . addAnswerForVoidMethod ( answer ) ; [CE] cannot find symbol answer  [METHOD]  toThrow [TYPE] VoidMethodStubbable [PARAMETER] Throwable throwable [CLASS] VoidMethodStubbableImpl  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] T mock [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public VoidMethodStubbable<T> toThrow ( Throwable throwable ) { [ATTENTION] mockitoStubber . addAnswerForVoidMethod ( answer )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^22^^^^^21^24^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  toThrow [TYPE] VoidMethodStubbable [PARAMETER] Throwable throwable [CLASS] VoidMethodStubbableImpl  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] T mock [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public VoidMethodStubbable<T> toThrow ( Throwable throwable ) { mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^23^^^^^21^24^
[REPLACE]  mockitoStubber  .  addAnswerForVoidMethod  (  new  DoesNothing  (  )  )  ; 	[BUGGY] mockitoStubber . addAnswerForVoidMethod ( answer ) ; [CE] cannot find symbol answer  [METHOD]  toReturn [TYPE] VoidMethodStubbable [PARAMETER] [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbable<T> toReturn ( ) { [ATTENTION] mockitoStubber . addAnswerForVoidMethod ( answer )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^27^^^^^26^29^
[ADD]  mockitoStubber  .  addAnswerForVoidMethod  (  new  DoesNothing  (  )  )  ;  return  this; 	[BUGGY] [CE] missing return statement  [METHOD]  toReturn [TYPE] VoidMethodStubbable [PARAMETER] [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbable<T> toReturn ( ) { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^27^28^^^^26^29^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(1 , spy.size())   [METHOD]  toReturn [TYPE] VoidMethodStubbable [PARAMETER] [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public VoidMethodStubbable<T> toReturn ( ) { mockitoStubber . addAnswerForVoidMethod ( new DoesNothing ( ) ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^28^^^^^26^29^
[REPLACE]  mockitoStubber  .  addAnswerForVoidMethod  (  answer  )  ; 	[BUGGY] mockitoStubber . addAnswerForVoidMethod ( false ) ; [CE] method addAnswerForVoidMethod in class MockitoStubber cannot be applied to given types ;  [METHOD]  toAnswer [TYPE] VoidMethodStubbable [PARAMETER] Answer<?> answer [CLASS] VoidMethodStubbableImpl  [TYPE] Answer answer [TYPE] boolean false true [TYPE] T mock [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public VoidMethodStubbable<T> toAnswer ( Answer<?> answer ) { [ATTENTION] mockitoStubber . addAnswerForVoidMethod ( false )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^32^^^^^31^34^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertTrue(call1.isCalled())   [METHOD]  toAnswer [TYPE] VoidMethodStubbable [PARAMETER] Answer<?> answer [CLASS] VoidMethodStubbableImpl  [TYPE] Answer answer [TYPE] boolean false true [TYPE] T mock [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public VoidMethodStubbable<T> toAnswer ( Answer<?> answer ) { mockitoStubber . addAnswerForVoidMethod ( answer ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^33^^^^^31^34^
[REPLACE]  return  mock; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  on [TYPE] T [PARAMETER] [CLASS] VoidMethodStubbableImpl  [TYPE] T mock [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public T on ( ) { [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java^37^^^^^36^38^
[REPLACE]  private  final  MockitoStubber  mockitoStubber; 	[BUGGY] private MockitoStubber mockitoStubber ; [NO-ERROR]  [CONTEXT]    [CLASS] OngoingStubbingImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^14^^^^^^^
[REPLACE]  private  final  RegisteredInvocations  registeredInvocations; 	[BUGGY] private RegisteredInvocations registeredInvocations ; [NO-ERROR]  [CONTEXT]    [CLASS] OngoingStubbingImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^15^^^^^^^
[REPLACE]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] this . mockitoStubber =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RegisteredInvocations) [PARAMETER] MockitoStubber mockitoStubber RegisteredInvocations registeredInvocations [CLASS] OngoingStubbingImpl  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public OngoingStubbingImpl ( MockitoStubber mockitoStubber , RegisteredInvocations registeredInvocations ) { [ATTENTION] this . mockitoStubber = null ; this . registeredInvocations = registeredInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^19^^^^^17^21^
[REPLACE]  this  .  registeredInvocations  =  registeredInvocations; 	[BUGGY] this . registeredInvocations =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RegisteredInvocations) [PARAMETER] MockitoStubber mockitoStubber RegisteredInvocations registeredInvocations [CLASS] OngoingStubbingImpl  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public OngoingStubbingImpl ( MockitoStubber mockitoStubber , RegisteredInvocations registeredInvocations ) { this . mockitoStubber = mockitoStubber ; [ATTENTION] this . registeredInvocations = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^20^^^^^17^21^
[ADD]  this  .  registeredInvocations  =  registeredInvocations; 	[BUGGY] [CE] variable registeredInvocations might not have been initialized  [METHOD]  <init> [TYPE] RegisteredInvocations) [PARAMETER] MockitoStubber mockitoStubber RegisteredInvocations registeredInvocations [CLASS] OngoingStubbingImpl  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public OngoingStubbingImpl ( MockitoStubber mockitoStubber , RegisteredInvocations registeredInvocations ) { this . mockitoStubber = mockitoStubber ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^20^^^^^17^21^
[REPLACE]  registeredInvocations  .  removeLast  (  )  ; 	[BUGGY] mockitoStubber . addAnswer ( answer ) ; [FE]   assertEquals(  "hello  " , result)   [METHOD]  thenAnswer [TYPE] OngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public OngoingStubbing<T> thenAnswer ( Answer<?> answer ) { [ATTENTION] mockitoStubber . addAnswer ( answer )  ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing<T> ( mockitoStubber ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^24^^^^^23^27^
[REPLACE]  mockitoStubber  .  addAnswer  (  answer  )  ; 	[BUGGY] mockitoStubber . addAnswer ( null ) ; [FE] AssertionFailedError [METHOD]  thenAnswer [TYPE] OngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public OngoingStubbing<T> thenAnswer ( Answer<?> answer ) { registeredInvocations . removeLast ( ) ; [ATTENTION] mockitoStubber . addAnswer ( null )  ; return new ConsecutiveStubbing<T> ( mockitoStubber ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^25^^^^^23^27^
[REPLACE]  return  new  ConsecutiveStubbing<T>  (  mockitoStubber  )  ; 	[BUGGY] return registeredInvocations ; [CE] incompatible types  [METHOD]  thenAnswer [TYPE] OngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public OngoingStubbing<T> thenAnswer ( Answer<?> answer ) { registeredInvocations . removeLast ( ) ; mockitoStubber . addAnswer ( answer ) ; [ATTENTION] return registeredInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^26^^^^^23^27^
[REPLACE]  registeredInvocations  .  removeLast  (  )  ; 	[BUGGY] mockitoStubber . addAnswer ( answer ) ; [FE] AssertionFailedError [METHOD]  toAnswer [TYPE] DeprecatedOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public DeprecatedOngoingStubbing<T> toAnswer ( Answer<?> answer ) { [ATTENTION] mockitoStubber . addAnswer ( answer )  ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing<T> ( mockitoStubber ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^30^^^^^29^33^
[REPLACE]  mockitoStubber  .  addAnswer  (  answer  )  ; 	[BUGGY] mockitoStubber . addAnswer ( null ) ; [FE] AssertionFailedError [METHOD]  toAnswer [TYPE] DeprecatedOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public DeprecatedOngoingStubbing<T> toAnswer ( Answer<?> answer ) { registeredInvocations . removeLast ( ) ; [ATTENTION] mockitoStubber . addAnswer ( null )  ; return new ConsecutiveStubbing<T> ( mockitoStubber ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^31^^^^^29^33^
[REPLACE]  return  new  ConsecutiveStubbing<T>  (  mockitoStubber  )  ; 	[BUGGY] return registeredInvocations ; [CE] incompatible types  [METHOD]  toAnswer [TYPE] DeprecatedOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] OngoingStubbingImpl  [TYPE] Answer answer [TYPE] RegisteredInvocations registeredInvocations [TYPE] boolean false true [TYPE] MockitoStubber mockitoStubber  [CONTEXT]  public DeprecatedOngoingStubbing<T> toAnswer ( Answer<?> answer ) { registeredInvocations . removeLast ( ) ; mockitoStubber . addAnswer ( answer ) ; [ATTENTION] return registeredInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^32^^^^^29^33^
[REPLACE]  return  registeredInvocations; 	[BUGGY] return new ConsecutiveStubbing<T> ( mockitoStubber ) ; [CE] incompatible types  [METHOD]  getRegisteredInvocations [TYPE] RegisteredInvocations [PARAMETER] [CLASS] OngoingStubbingImpl  [TYPE] RegisteredInvocations registeredInvocations [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public RegisteredInvocations getRegisteredInvocations ( ) { [ATTENTION] return new ConsecutiveStubbing<T> ( mockitoStubber )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java^36^^^^^35^37^
[REPLACE]  private  final  ConditionalStackTraceFilter  filter  =  new  ConditionalStackTraceFilter  (  )  ; 	[BUGGY] private ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] ThrowsException  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^15^^^^^^^
[REPLACE]  this  .  throwable  =  throwable; 	[BUGGY] this . throwable =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Throwable) [PARAMETER] Throwable throwable [CLASS] ThrowsException  [TYPE] ConditionalStackTraceFilter filter [TYPE] Throwable throwable [TYPE] boolean false true  [CONTEXT]  public ThrowsException ( Throwable throwable ) { [ATTENTION] this . throwable = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^18^^^^^17^19^
[REPLACE]  if  (  new  MockUtil  (  )    .  isMock  (  throwable  )  )  { 	[BUGGY] if ( new MockUtil ( )  . MockUtil ( )  ) {[CE] cannot find symbol  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] if ( new MockUtil ( ) . MockUtil ( )  ) { throw throwable ; } Throwable t = throwable . fillInStackTrace ( ) ; filter . filter ( t ) ; throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^22^^^^^21^28^
[ADD]  if  (  new  MockUtil  (  )    .  isMock  (  throwable  )  )  {  throw  throwable;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION]  Throwable t = throwable . fillInStackTrace ( ) ; filter . filter ( t ) ; throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^22^23^24^^^21^28^
[REPLACE]  throw  throwable; 	[BUGGY] return ; [CE] missing return value  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( new MockUtil ( ) . isMock ( throwable ) ) { [ATTENTION] return ; } Throwable t = throwable . fillInStackTrace ( ) ; filter . filter ( t ) ; throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^23^^^^^21^28^
[ADD]  throw  throwable; 	[BUGGY] [FE] AssertionFailedError [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( new MockUtil ( ) . isMock ( throwable ) ) { [ATTENTION] } Throwable t = throwable . fillInStackTrace ( ) ; filter . filter ( t ) ; throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^23^^^^^21^28^
[REPLACE]  filter  .  filter  (  t  )  ; 	[BUGGY] filter . filter ( throwable ) ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( new MockUtil ( ) . isMock ( throwable ) ) { throw throwable ; } Throwable t = throwable . fillInStackTrace ( ) ; [ATTENTION] filter . filter ( throwable )  ; throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^26^^^^^21^28^
[ADD]  filter  .  filter  (  t  )  ; 	[BUGGY] [FE]  Method at index: 0 assertThat(e , hasFirstMethodInStackTrace(  "shouldShowProperExceptionStackTrace  "))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( new MockUtil ( ) . isMock ( throwable ) ) { throw throwable ; } Throwable t = throwable . fillInStackTrace ( ) ; [ATTENTION] throw t ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^26^^^^^21^28^
[REPLACE]  throw  t; 	[BUGGY] return ; [CE] missing return value  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] ThrowsException  [TYPE] Throwable t throwable [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( new MockUtil ( ) . isMock ( throwable ) ) { throw throwable ; } Throwable t = throwable . fillInStackTrace ( ) ; filter . filter ( t ) ; [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/ThrowsException.java^27^^^^^21^28^
[REPLACE]  private  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private Reporter reporter  = null ; [FE] [CONTEXT]    [CLASS] AnswersValidator  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^13^^^^^^^
[REPLACE]  if  (  answer  instanceof  ThrowsException  )  { 	[BUGGY] if ( ! answer instanceof ThrowsException ) {[CE] bad operand type Answer<CAP#1> for unary operator '!'  [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { [ATTENTION] if ( ! answer instanceof ThrowsException ) { validateException ( ( ThrowsException ) answer , invocation ) ; } if ( answer instanceof Returns ) { validateReturnValue ( ( Returns ) answer , invocation ) ; } if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^16^^^^^15^27^
[REPLACE]  validateException  (  (  ThrowsException  )  answer,  invocation  )  ; 	[BUGGY] validateDoNothing ( ( DoesNothing ) answer , invocation ) ; [FE] AssertionFailedError [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { if ( answer instanceof ThrowsException ) { [ATTENTION] validateDoNothing ( ( DoesNothing ) answer , invocation )  ; } if ( answer instanceof Returns ) { validateReturnValue ( ( Returns ) answer , invocation ) ; } if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^17^^^^^15^27^
[REPLACE]  if  (  answer  instanceof  Returns  )  { 	[BUGGY] if ( ! answer instanceof Returns ) {[CE] bad operand type Answer<CAP#1> for unary operator '!'  [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { if ( answer instanceof ThrowsException ) { validateException ( ( ThrowsException ) answer , invocation ) ; } [ATTENTION] if ( ! answer instanceof Returns ) { validateReturnValue ( ( Returns ) answer , invocation ) ; } if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^20^^^^^15^27^
[REPLACE]  validateReturnValue  (  (  Returns  )  answer,  invocation  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; [FE] AssertionFailedError [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { if ( answer instanceof ThrowsException ) { validateException ( ( ThrowsException ) answer , invocation ) ; } if ( answer instanceof Returns ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  ,   "null  " , invocation . getMethodName ( ) )  ; } if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^21^^^^^15^27^
[REPLACE]  if  (  answer  instanceof  DoesNothing  )  { 	[BUGGY] if ( ! answer instanceof DoesNothing ) {[CE] bad operand type Answer<CAP#1> for unary operator '!'  [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { if ( answer instanceof ThrowsException ) { validateException ( ( ThrowsException ) answer , invocation ) ; } if ( answer instanceof Returns ) { validateReturnValue ( ( Returns ) answer , invocation ) ; } [ATTENTION] if ( ! answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^24^^^^^15^27^
[REPLACE]  validateDoNothing  (  (  DoesNothing  )  answer,  invocation  )  ; 	[BUGGY] validateReturnValue ( ( Returns ) answer , invocation ) ; [FE] AssertionFailedError [METHOD]  validate [TYPE] void [PARAMETER] Answer<?> answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Answer answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  public void validate ( Answer<?> answer , Invocation invocation ) { if ( answer instanceof ThrowsException ) { validateException ( ( ThrowsException ) answer , invocation ) ; } if ( answer instanceof Returns ) { validateReturnValue ( ( Returns ) answer , invocation ) ; } if ( answer instanceof DoesNothing ) { [ATTENTION] validateReturnValue ( ( Returns ) answer , invocation )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^25^^^^^15^27^
[REPLACE]  if  (  !invocation  .  isVoid  (  )  )  { 	[BUGGY] if ( !invocation . isValidException ( ) ) {[CE] method isValidException in class Invocation cannot be applied to given types ;  [METHOD]  validateDoNothing [TYPE] void [PARAMETER] DoesNothing answer Invocation invocation [CLASS] AnswersValidator  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] DoesNothing answer [TYPE] Reporter reporter  [CONTEXT]  private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { [ATTENTION] if ( !invocation . isValidException ( ) ) { reporter . onlyVoidMethodsCanBeSetToDoNothing ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^30^^^^^29^33^
[REPLACE]  reporter  .  onlyVoidMethodsCanBeSetToDoNothing  (  )  ; 	[BUGGY] reporter . cannotStubVoidMethodWithAReturnValue ( ) ; [FE]   assertContains(  "Only void methods can doNothing()  " , e.getMessage())   [METHOD]  validateDoNothing [TYPE] void [PARAMETER] DoesNothing answer Invocation invocation [CLASS] AnswersValidator  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] DoesNothing answer [TYPE] Reporter reporter  [CONTEXT]  private void validateDoNothing ( DoesNothing answer , Invocation invocation ) { if ( !invocation . isVoid ( ) ) { [ATTENTION] reporter . cannotStubVoidMethodWithAReturnValue ( )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^31^^^^^29^33^
[REPLACE]  if  (  invocation  .  isVoid  (  )  )  { 	[BUGGY] if ( !invocation . isVoid ( ) ) {[FE] AssertionFailedError [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { [ATTENTION] if ( !invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^36^^^^^35^47^
[REPLACE]  reporter  .  cannotStubVoidMethodWithAReturnValue  (  )  ; 	[BUGGY] reporter . cannotStubWithNullThrowable ( ) ; [FE]   assertContains(  "Cannot stub a void method with a return value  " , e.getMessage())   [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { [ATTENTION] reporter . cannotStubWithNullThrowable ( )  ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^37^^^^^35^47^
[REPLACE]  if  (  answer  .  returnsNull  (  )  &&  invocation  .  returnsPrimitive  (  )  )  { 	[BUGGY] if ( invocation . returnsPrimitive ( ) ) {[FE]   assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing())   [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } [ATTENTION] if ( invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^40^^^^^35^47^
[ADD]  if  (  answer  .  returnsNull  (  )  &&  invocation  .  returnsPrimitive  (  )  )  {  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,    "null  ",  invocation  .  getMethodName  (  )  )  ;  } 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; [FE] AssertionFailedError [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  ,   "null  " , invocation . getMethodName ( ) )  ;   if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^40^41^42^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,    "null  ",  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "false  " , invocation . printMethodReturnType ( ) ) ; [FE]   assertContains(  "null cannot be returned by intReturningMethod  " , e.getMessage())   [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  ,   "false  " , invocation . printMethodReturnType ( ) )  ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^41^^^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,    "null  ",  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . isValidReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; [CE] method isValidReturnType in class Invocation cannot be applied to given types ;  [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . isValidReturnType ( )  ,   "null  " , invocation . getMethodName ( ) )  ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^41^^^^^35^47^
[REMOVE]   	[BUGGY] validateDoNothing ( ( DoesNothing ) answer , invocation ) ; [CE] inconvertible types  [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ;  validateDoNothing ( ( DoesNothing ) answer , invocation )  ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^41^^^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,    "null  ",  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . printMethodReturnType ( ) ) ; [FE]   assertContains(  "null cannot be returned by intReturningMethod  " , e.getMessage())   [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  ,   "null  " , invocation . printMethodReturnType ( ) )  ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^41^^^^^35^47^
[REPLACE]  if  (  !answer  .  returnsNull  (  )  &&  !invocation  .  isValidReturnType  (  answer  .  getReturnType  (  )  )  )  { 	[BUGGY] if ( !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) {[FE] AssertionFailedError [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } [ATTENTION] if ( !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^44^^^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,  answer  .  printReturnType  (  )  ,  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . printMethodReturnType ( ) ) ; [FE] AssertionFailedError [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  , answer . printReturnType ( )  , invocation . printMethodReturnType ( ) )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^45^^^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,  answer  .  printReturnType  (  )  ,  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . isValidReturnType ( )  , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ; [CE] method isValidReturnType in class Invocation cannot be applied to given types ;  [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . isValidReturnType ( ) , answer . printReturnType ( )  , invocation . getMethodName ( ) )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^45^^^^^35^47^
[REPLACE]  reporter  .  wrongTypeOfReturnValue  (  invocation  .  printMethodReturnType  (  )  ,  answer  .  printReturnType  (  )  ,  invocation  .  getMethodName  (  )  )  ; 	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . getReturnType ( ) , invocation . getMethodName ( ) ) ; [CE] method wrongTypeOfReturnValue in class Reporter cannot be applied to given types ;  [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  , answer . getReturnType ( )  , invocation . getMethodName ( ) )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^45^^^^^35^47^
[REMOVE]   	[BUGGY] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; [NO-ERROR]  [METHOD]  validateReturnValue [TYPE] void [PARAMETER] Returns answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Returns answer [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter  [CONTEXT]  private void validateReturnValue ( Returns answer , Invocation invocation ) { if ( invocation . isVoid ( ) ) { reporter . cannotStubVoidMethodWithAReturnValue ( ) ; } if ( answer . returnsNull ( ) && invocation . returnsPrimitive ( ) ) { reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) ,   "null  " , invocation . getMethodName ( ) ) ; } if ( !answer . returnsNull ( ) && !invocation . isValidReturnType ( answer . getReturnType ( ) ) ) { [ATTENTION] reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( ) , answer . printReturnType ( ) , invocation . getMethodName ( ) ) ;  reporter . wrongTypeOfReturnValue ( invocation . printMethodReturnType ( )  ,   "null  " , invocation . getMethodName ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^45^^^^^35^47^
[REPLACE]  if  (  throwable  ==  null  )  { 	[BUGGY] if ( throwable ! = null ) {[FE] AssertionFailedError [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; [ATTENTION] if ( throwable ! = null ) { reporter . cannotStubWithNullThrowable ( ) ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } if ( !invocation . isValidException ( throwable ) ) { reporter . checkedExceptionInvalid ( throwable ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^51^^^^^49^62^
[ADD]  if  (  throwable  ==  null  )  {  reporter  .  cannotStubWithNullThrowable  (  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; [ATTENTION]   if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } if ( !invocation . isValidException ( throwable ) ) { reporter . checkedExceptionInvalid ( throwable ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^51^52^53^^^49^62^
[REPLACE]  reporter  .  cannotStubWithNullThrowable  (  )  ; 	[BUGGY] reporter . cannotStubVoidMethodWithAReturnValue ( ) ; [NO-ERROR]  [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable = = null ) { [ATTENTION] reporter . cannotStubVoidMethodWithAReturnValue ( )  ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } if ( !invocation . isValidException ( throwable ) ) { reporter . checkedExceptionInvalid ( throwable ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^52^^^^^49^62^
[REPLACE]  if  (  throwable  instanceof  RuntimeException  ||  throwable  instanceof  Error  )  { 	[BUGGY] if ( throwable instanceof Error ) {[FE] AssertionFailedError [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable = = null ) { reporter . cannotStubWithNullThrowable ( ) ; } [ATTENTION] if ( throwable instanceof Error ) { return ; } if ( !invocation . isValidException ( throwable ) ) { reporter . checkedExceptionInvalid ( throwable ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^55^^^^^49^62^
[REPLACE]  if    (  "    ")    { 	[BUGGY] if ( answer instanceof Returns ) {[CE] inconvertible types  [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable = = null ) { reporter . cannotStubWithNullThrowable ( ) ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } [ATTENTION] if ( answer instanceof Returns ) { reporter . checkedExceptionInvalid ( throwable ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^59^^^^^49^62^
[REMOVE]   	[BUGGY] if ( ! ( invocation . isVoid ( ) ) ) {   reporter . onlyVoidMethodsCanBeSetToDoNothing ( ) ; }[FE]   assertContains(  "Checked exception is invalid  " , e.getMessage())   [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable = = null ) { reporter . cannotStubWithNullThrowable ( ) ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } [ATTENTION] if ( !invocation . isValidException ( throwable ) ) { if ( ! ( invocation . isVoid ( ) ) ) { reporter . onlyVoidMethodsCanBeSetToDoNothing ( )  ; }reporter . checkedExceptionInvalid ( throwable ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^59^^^^^49^62^
[REPLACE]  reporter  .  checkedExceptionInvalid  (  throwable  )  ; 	[BUGGY] reporter . onlyVoidMethodsCanBeSetToDoNothing ( )  ; [FE]   assertContains(  "Checked exception is invalid  " , e.getMessage())   [METHOD]  validateException [TYPE] void [PARAMETER] ThrowsException answer Invocation invocation [CLASS] AnswersValidator  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] ThrowsException answer [TYPE] Reporter reporter  [CONTEXT]  private void validateException ( ThrowsException answer , Invocation invocation ) { Throwable throwable = answer . getThrowable ( ) ; if ( throwable = = null ) { reporter . cannotStubWithNullThrowable ( ) ; } if ( throwable instanceof RuntimeException || throwable instanceof Error ) { return ; } if ( !invocation . isValidException ( throwable ) ) { [ATTENTION] reporter . onlyVoidMethodsCanBeSetToDoNothing ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswersValidator.java^60^^^^^49^62^
[REPLACE]  private  final  ReturnValues  returnValues; 	[BUGGY] private ReturnValues returnValues ; [NO-ERROR]  [CONTEXT]    [CLASS] AnswerReturnValuesAdapter  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java^15^^^^^^^
[REPLACE]  this  .  returnValues  =  returnValues; 	[BUGGY] this . returnValues =  null ; [NO-ERROR]  [METHOD]  <init> [TYPE] ReturnValues) [PARAMETER] ReturnValues returnValues [CLASS] AnswerReturnValuesAdapter  [TYPE] ReturnValues returnValues [TYPE] boolean false true  [CONTEXT]  public AnswerReturnValuesAdapter ( ReturnValues returnValues ) { [ATTENTION] this . returnValues = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java^18^^^^^17^19^
[ADD]  this  .  returnValues  =  returnValues; 	[BUGGY] [CE] variable returnValues might not have been initialized  [METHOD]  <init> [TYPE] ReturnValues) [PARAMETER] ReturnValues returnValues [CLASS] AnswerReturnValuesAdapter  [TYPE] ReturnValues returnValues [TYPE] boolean false true  [CONTEXT]  public AnswerReturnValuesAdapter ( ReturnValues returnValues ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java^18^^^^^17^19^
[REPLACE]  return  null; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] DoesNothing  [TYPE] boolean false true [TYPE] InvocationOnMock invocation  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/DoesNothing.java^13^^^^^12^14^
[REPLACE]  this  .  value  =  value; 	[BUGGY] this . value =  null ; [FE]   assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing())   [METHOD]  <init> [TYPE] Object) [PARAMETER] Object value [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public Returns ( Object value ) { [ATTENTION] this . value = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^15^^^^^14^16^
[ADD]  this  .  value  =  value; 	[BUGGY] [CE] variable value might not have been initialized  [METHOD]  <init> [TYPE] Object) [PARAMETER] Object value [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public Returns ( Object value ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^15^^^^^14^16^
[REPLACE]  return  value; 	[BUGGY] return   "Returns:   " + value ; [FE]  AssertionFailedError  expected:<simpleMethod> but was:<Returns: simpleMethod> assertEquals(  "simpleMethod  " , mockitoStubber.answerTo(simpleMethod))   [METHOD]  answer [TYPE] Object [PARAMETER] InvocationOnMock invocation [CLASS] Returns  [TYPE] Object value [TYPE] InvocationOnMock invocation [TYPE] boolean false true  [CONTEXT]  public Object answer ( InvocationOnMock invocation ) throws Throwable { [ATTENTION] return   "Returns:   " + value ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^19^^^^^18^20^
[REPLACE]  return  value  .  getClass  (  )    .  getSimpleName  (  )  ; 	[BUGGY] return   "Returns:   " + value ; [FE] AssertionFailedError [METHOD]  printReturnType [TYPE] String [PARAMETER] [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public String printReturnType ( ) { [ATTENTION] return   "Returns:   " + value ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^23^^^^^22^24^
[REPLACE]  return  value  .  getClass  (  )  ; 	[BUGGY] return value . getClass ( ) . getSimpleName ( ) ; [CE] incompatible types  [METHOD]  getReturnType [TYPE] Class [PARAMETER] [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public Class<?> getReturnType ( ) { [ATTENTION] return value . getClass ( )  . getSimpleName ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^27^^^^^26^28^
[REPLACE]  return  value  ==  null; 	[BUGGY] return value ! = this ; ; [CE] unreachable statement  [METHOD]  returnsNull [TYPE] boolean [PARAMETER] [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public boolean returnsNull ( ) { [ATTENTION] return value ! = this ; ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^31^^^^^30^32^
[REPLACE]  return    "Returns:    "  +  value; 	[BUGGY] return   "Returns:   " +false ; [NO-ERROR]  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Returns  [TYPE] Object value [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "Returns:   " +false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/answers/Returns.java^36^^^^^35^37^
[REPLACE]  private  final  MockitoStubber  mockitoStubber; 	[BUGGY] private MockitoStubber mockitoStubber ; [NO-ERROR]  [CONTEXT]    [CLASS] ConsecutiveStubbing  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^12^^^^^^^
[REPLACE]  this  .  mockitoStubber  =  mockitoStubber; 	[BUGGY] this . mockitoStubber =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockitoStubber) [PARAMETER] MockitoStubber mockitoStubber [CLASS] ConsecutiveStubbing  [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public ConsecutiveStubbing ( MockitoStubber mockitoStubber ) { [ATTENTION] this . mockitoStubber = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^15^^^^^14^16^
[REPLACE]  mockitoStubber  .  addConsecutiveAnswer  (  answer  )  ; 	[BUGGY] mockitoStubber . addConsecutiveAnswer ( this ) ; [CE] method addConsecutiveAnswer in class MockitoStubber cannot be applied to given types ;  [METHOD]  thenAnswer [TYPE] OngoingStubbing [PARAMETER] Answer<?> answer [CLASS] ConsecutiveStubbing  [TYPE] Answer answer [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public OngoingStubbing<T> thenAnswer ( Answer<?> answer ) { [ATTENTION] mockitoStubber . addConsecutiveAnswer ( this )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^19^^^^^18^21^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  thenAnswer [TYPE] OngoingStubbing [PARAMETER] Answer<?> answer [CLASS] ConsecutiveStubbing  [TYPE] Answer answer [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public OngoingStubbing<T> thenAnswer ( Answer<?> answer ) { mockitoStubber . addConsecutiveAnswer ( answer ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^20^^^^^18^21^
[REPLACE]  mockitoStubber  .  addConsecutiveAnswer  (  answer  )  ; 	[BUGGY] mockitoStubber . addConsecutiveAnswer ( null ) ; [FE] NullPointerException assertEquals(  "100  " , mock.simpleMethod())   [METHOD]  toAnswer [TYPE] DeprecatedOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] ConsecutiveStubbing  [TYPE] Answer answer [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public DeprecatedOngoingStubbing<T> toAnswer ( Answer<?> answer ) { [ATTENTION] mockitoStubber . addConsecutiveAnswer ( null )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^24^^^^^23^26^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  toAnswer [TYPE] DeprecatedOngoingStubbing [PARAMETER] Answer<?> answer [CLASS] ConsecutiveStubbing  [TYPE] Answer answer [TYPE] MockitoStubber mockitoStubber [TYPE] boolean false true  [CONTEXT]  public DeprecatedOngoingStubbing<T> toAnswer ( Answer<?> answer ) { mockitoStubber . addConsecutiveAnswer ( answer ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java^25^^^^^23^26^
[REPLACE]  private  final  LinkedList<StubbedInvocationMatcher>  stubbed  =  new  LinkedList<StubbedInvocationMatcher>  (  )  ; 	[BUGGY] private LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher> ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] MockitoStubber  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^20^^^^^^^
[REPLACE]  private  final  MockingProgress  mockingProgress; 	[BUGGY] private MockingProgress mockingProgress ; [NO-ERROR]  [CONTEXT]    [CLASS] MockitoStubber  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^21^^^^^^^
[REPLACE]  private  final  List<Answer>  answersForStubbing  =  new  ArrayList<Answer>  (  )  ; 	[BUGGY] private final List<Answer> answersForStubbing  = null ; [FE] [CONTEXT]    [CLASS] MockitoStubber  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^22^^^^^^^
[REPLACE]  this  .  mockingProgress  =  mockingProgress; 	[BUGGY] this . mockingProgress =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockingProgress) [PARAMETER] MockingProgress mockingProgress [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocationForStubbing [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public MockitoStubber ( MockingProgress mockingProgress ) { [ATTENTION] this . mockingProgress = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^27^^^^^26^28^
[REPLACE]  this  .  invocationForStubbing  =  invocation; 	[BUGGY] invocationForStubbing = invocation ;  ; [NO-ERROR]  [METHOD]  setInvocationForPotentialStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void setInvocationForPotentialStubbing ( InvocationMatcher invocation ) { [ATTENTION] invocationForStubbing = invocation ;  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^31^^^^^30^32^
[ADD]  this  .  invocationForStubbing  =  invocation; 	[BUGGY] [FE] AssertionFailedError [METHOD]  setInvocationForPotentialStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void setInvocationForPotentialStubbing ( InvocationMatcher invocation ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^31^^^^^30^32^
[REPLACE]  addAnswer  (  answer,  false  )  ; 	[BUGGY] addAnswer ( answer , true ) ; [FE] AssertionFailedError [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] Answer answer [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void addAnswer ( Answer answer ) { [ATTENTION] addAnswer ( answer , true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^35^^^^^34^36^
[REPLACE]  addAnswer  (  answer,  true  )  ; 	[BUGGY] addAnswer ( answer , false ) ; [FE]  AssertionFailedError  expected:<[foo]> but was:<[bar]> assertEquals(  "foo  " , mock.simpleMethod(  "whatever  "))   [METHOD]  addConsecutiveAnswer [TYPE] void [PARAMETER] Answer answer [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] Answer answer [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void addConsecutiveAnswer ( Answer answer ) { [ATTENTION] addAnswer ( answer , false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^39^^^^^38^40^
[REPLACE]  Invocation  invocation  =  invocationForStubbing  .  getInvocation  (  )  ; 	[BUGGY] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) {[CE] ' ; ' expected  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { [ATTENTION] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^43^^^^^42^53^
[REPLACE]  mockingProgress  .  stubbingCompleted  (  invocation  )  ; 	[BUGGY] return findAnswerFor ( invocation ) . answer ( invocation ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; [ATTENTION] return findAnswerFor ( invocation )  . answer ( invocation )  ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^44^^^^^42^53^
[ADD]  mockingProgress  .  stubbingCompleted  (  invocation  )  ;  AnswersValidator  answersValidator  =  new  AnswersValidator  (  )  ; 	[BUGGY] AnswersValidator answersValidator = new AnswersValidator ( ) ; [FE] AssertionFailedError [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; [ATTENTION] AnswersValidator answersValidator = new AnswersValidator ( )  ;  answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^44^45^^^^42^53^
[REPLACE]  AnswersValidator  answersValidator  =  new  AnswersValidator  (  )  ; 	[BUGGY] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) {[CE] ' ; ' expected  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; [ATTENTION] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^45^^^^^42^53^
[ADD]  AnswersValidator  answersValidator  =  new  AnswersValidator  (  )  ; 	[BUGGY] [CE] cannot find symbol answersValidator  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; [ATTENTION] answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^45^^^^^42^53^
[REPLACE]  answersValidator  .  validate  (  answer,  invocation  )  ; 	[BUGGY] answersValidator . AnswersValidator ( )  ; [CE] cannot find symbol  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; [ATTENTION] answersValidator . AnswersValidator ( ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^46^^^^^42^53^
[REPLACE]  if  (  isConsecutive  )  { 	[BUGGY] if ( s . matches ( invocation ) ) {[CE] cannot find symbol s  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  [ATTENTION] if ( s . matches ( invocation ) ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^48^^^^^42^53^
[ADD]  if  (  isConsecutive  )  {  stubbed  .  getFirst  (  )    .  addAnswer  (  answer  )  ;  }  else  {  stubbed  .  addFirst  (  new  StubbedInvocationMatcher  (  invocationForStubbing,  answer  )  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  [ATTENTION]   }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^48^49^50^51^52^42^53^
[REPLACE]  stubbed  .  addFirst  (  new  StubbedInvocationMatcher  (  invocationForStubbing,  answer  )  )  ; 	[BUGGY] stubbed . getFirst ( )  ; [FE] AssertionFailedError [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { [ATTENTION] stubbed . getFirst ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^51^^^^^42^53^
[ADD]  stubbed  .  addFirst  (  new  StubbedInvocationMatcher  (  invocationForStubbing,  answer  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { stubbed . getFirst ( ) . addAnswer ( answer ) ; } else { [ATTENTION] } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^51^^^^^42^53^
[REPLACE]  stubbed  .  getFirst  (  )    .  addAnswer  (  answer  )  ; 	[BUGGY] stubbed . getFirst ( )  . addAnswer ( answer , isConsecutive )  ; [CE] method addAnswer in class StubbedInvocationMatcher cannot be applied to given types ;  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { [ATTENTION] stubbed . getFirst ( ) . addAnswer ( answer , isConsecutive ) ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^49^^^^^42^53^
[REPLACE]  stubbed  .  getFirst  (  )    .  addAnswer  (  answer  )  ; 	[BUGGY] return findAnswerFor ( invocation ) . answer ( invocation ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { [ATTENTION] return findAnswerFor ( invocation )  . answer ( invocation )  ; } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^49^^^^^42^53^
[ADD]  stubbed  .  getFirst  (  )    .  addAnswer  (  answer  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[bar]> but was:<[foo]> assertEquals(  "foo  " , mock.simpleMethod(  "whatever  "))   [METHOD]  addAnswer [TYPE] void [PARAMETER] Answer answer boolean isConsecutive [CLASS] MockitoStubber  [TYPE] Answer answer [TYPE] boolean false isConsecutive true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] AnswersValidator answersValidator  [CONTEXT]  private void addAnswer ( Answer answer , boolean isConsecutive ) { Invocation invocation = invocationForStubbing . getInvocation ( ) ; mockingProgress . stubbingCompleted ( invocation ) ; AnswersValidator answersValidator = new AnswersValidator ( ) ; answersValidator . validate ( answer , invocation ) ;  if ( isConsecutive ) { [ATTENTION] } else { stubbed . addFirst ( new StubbedInvocationMatcher ( invocationForStubbing , answer ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^49^^^^^42^53^
[REPLACE]  return  findAnswerFor  (  invocation  )    .  answer  (  invocation  )  ; 	[BUGGY] return findAnswerFor ( invocation ) . addAnswer ( invocation ) ; [CE] cannot find symbol  [METHOD]  answerTo [TYPE] Object [PARAMETER] Invocation invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  Object answerTo ( Invocation invocation ) throws Throwable { [ATTENTION] return findAnswerFor ( invocation )  . addAnswer ( invocation )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^56^^^^^55^57^
[REPLACE]  if  (  s  .  matches  (  invocation  )  )  { 	[BUGGY] if ( isConsecutive ) {[CE] cannot find symbol isConsecutive  [METHOD]  findAnswerFor [TYPE] Answer [PARAMETER] Invocation invocation [CLASS] MockitoStubber  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] StubbedInvocationMatcher s [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public Answer<?> findAnswerFor ( Invocation invocation ) { for ( StubbedInvocationMatcher s : stubbed ) { [ATTENTION] if ( isConsecutive ) { return s ; } } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^61^^^^^59^67^
[REPLACE]  return  s; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  findAnswerFor [TYPE] Answer [PARAMETER] Invocation invocation [CLASS] MockitoStubber  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] StubbedInvocationMatcher s [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public Answer<?> findAnswerFor ( Invocation invocation ) { for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { [ATTENTION] return null ; } } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^62^^^^^59^67^
[REPLACE]  for  (  StubbedInvocationMatcher  s  :  stubbed  )  { 	[BUGGY] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) {[CE] illegal start of expression  [METHOD]  findAnswerFor [TYPE] Answer [PARAMETER] Invocation invocation [CLASS] MockitoStubber  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] StubbedInvocationMatcher s [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public Answer<?> findAnswerFor ( Invocation invocation ) { [ATTENTION] for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { if ( s . matches ( invocation ) ) { return s ; } } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^60^^^^^59^67^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  findAnswerFor [TYPE] Answer [PARAMETER] Invocation invocation [CLASS] MockitoStubber  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] StubbedInvocationMatcher s [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answersForStubbing [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public Answer<?> findAnswerFor ( Invocation invocation ) { for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s ; } } [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^66^^^^^59^67^
[REPLACE]  answersForStubbing  .  add  (  answer  )  ; 	[BUGGY] answersForStubbing . addAll ( answer ) ; [CE] no suitable method found for addAll(Answer)  [METHOD]  addAnswerForVoidMethod [TYPE] void [PARAMETER] Answer answer [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] Answer answer [TYPE] List answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void addAnswerForVoidMethod ( Answer answer ) { [ATTENTION] answersForStubbing . addAll ( answer )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^70^^^^^69^71^
[REPLACE]  answersForStubbing  .  addAll  (  answers  )  ; 	[BUGGY] answersForStubbing . addAll ( true ) ; [CE] no suitable method found for addAll(boolean)  [METHOD]  setAnswersForStubbing [TYPE] void [PARAMETER] Answer> answers [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public void setAnswersForStubbing ( List<Answer> answers ) { [ATTENTION] answersForStubbing . addAll ( true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^74^^^^^73^75^
[REPLACE]  return  !answersForStubbing  .  isEmpty  (  )  ; 	[BUGGY] return !answersForStubbing . get ( ) ; [CE] method get in interface List<E> cannot be applied to given types ;  [METHOD]  hasAnswersForStubbing [TYPE] boolean [PARAMETER] [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public boolean hasAnswersForStubbing ( ) { [ATTENTION] return !answersForStubbing . get ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^78^^^^^77^79^
[REPLACE]  invocationForStubbing  =  invocation; 	[BUGGY] this . invocationForStubbing = invocation ;  ; [NO-ERROR]  [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { [ATTENTION] this . invocationForStubbing = invocation ;  ; assert hasAnswersForStubbing ( ) ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^82^^^^^81^88^
[REPLACE]  assert  hasAnswersForStubbing  (  )  ; 	[BUGGY] return !answersForStubbing . isEmpty ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; [ATTENTION] return !answersForStubbing . isEmpty ( )  ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^83^^^^^81^88^
[REPLACE]  for  (  int  i  =  0;  i  <  answersForStubbing  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < answersForStubbing . size ( ) + 1 ; i++ ) {[FE] AssertionFailedError [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; [ATTENTION] for ( int i = 0 ; i < answersForStubbing . size ( ) + 1 ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^84^^^^^81^88^
[REPLACE]  addAnswer  (  answersForStubbing  .  get  (  i  )  ,  i  !=  0  )  ; 	[BUGGY] addAnswer ( answersForStubbing . get ( i ) , i  = =  0 ) ; [FE] AssertionFailedError [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { [ATTENTION] addAnswer ( answersForStubbing . get ( i )  , i = = 0 )  ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^85^^^^^81^88^
[REPLACE]  addAnswer  (  answersForStubbing  .  get  (  i  )  ,  i  !=  0  )  ; 	[BUGGY] addAnswer ( answersForStubbing . addAll ( i ) , i ! = 0 ) ; [CE] no suitable method found for addAll(int)  [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { [ATTENTION] addAnswer ( answersForStubbing . addAll ( i )  , i ! = 0 )  ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^85^^^^^81^88^
[REPLACE]  for  (  int  i  =  0;  i  <  answersForStubbing  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) {[NO-ERROR]  [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; [ATTENTION] for ( int i = 0 ; i < answersForStubbing . size ( )  ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^84^^^^^81^88^
[ADD]  for  (  int  i  =  0;  i  <  answersForStubbing  .  size  (  )  ;  i++  )  {  addAnswer  (  answersForStubbing  .  get  (  i  )  ,  i  !=  0  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; [ATTENTION]  answersForStubbing . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^84^85^86^^^81^88^
[REPLACE]  answersForStubbing  .  clear  (  )  ; 	[BUGGY] answersForStubbing . size ( ) ; [FE] AssertionFailedError [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } [ATTENTION] answersForStubbing . size ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^87^^^^^81^88^
[REMOVE]   	[BUGGY] answersValidator . validate ( answer , invocation ) ; [CE] cannot find symbol answer  [METHOD]  setMethodForStubbing [TYPE] void [PARAMETER] InvocationMatcher invocation [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed [TYPE] int i  [CONTEXT]  public void setMethodForStubbing ( InvocationMatcher invocation ) { invocationForStubbing = invocation ; assert hasAnswersForStubbing ( ) ; for ( int i = 0 ; i < answersForStubbing . size ( ) ; i++ ) { addAnswer ( answersForStubbing . get ( i ) , i ! = 0 ) ; } [ATTENTION] answersForStubbing . clear ( ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^87^^^^^81^88^
[REPLACE]  return    "invocationForStubbing:    "  +  invocationForStubbing; 	[BUGGY] return   "invocationForStubbing:   " || invocationForStubbing ; [CE] bad operand types for binary operator  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] MockitoStubber  [TYPE] InvocationMatcher invocation invocationForStubbing [TYPE] List answers answersForStubbing [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] LinkedList stubbed  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "invocationForStubbing:   "||invocationForStubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/MockitoStubber.java^92^^^^^91^93^
[REPLACE]  return  thenAnswer  (  new  Returns  (  value  )  )  ; 	[BUGGY] return toAnswer ( new Returns ( value ) ) ; [CE] incompatible types  [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T value  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value ) { [ATTENTION] return toAnswer ( new Returns ( value ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^15^^^^^14^16^
[REPLACE]  OngoingStubbing<T>  stubbing  =  thenReturn  (  value  )  ; 	[BUGGY] OngoingStubbing<T> stubbing = thenReturn ( v ) ; [CE] cannot find symbol v  [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { [ATTENTION] OngoingStubbing<T> stubbing = thenReturn ( v )  ; if ( values = = null ) { return stubbing . thenReturn ( null ) ; } for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^19^^^^^18^27^
[REPLACE]  if  (  values  ==  null  )  { 	[BUGGY] if ( values ! = null ) {[FE] NullPointerException assertNull(mock.simpleMethod())   [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; [ATTENTION] if ( values ! = null ) { return stubbing . thenReturn ( null ) ; } for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^20^^^^^18^27^
[REPLACE]  return  stubbing  .  thenReturn  (  null  )  ; 	[BUGGY] return thenAnswer ( new CallsRealMethods ( ) ) ; [FE]  IndexOutOfBoundsException Index: -1 , Size: 0 assertNull(mock.simpleMethod())   [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; if ( values = = null ) { [ATTENTION] return thenAnswer ( new CallsRealMethods ( ) )  ; } for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^21^^^^^18^27^
[REPLACE]  return  stubbing  .  thenReturn  (  null  )  ; 	[BUGGY] return stubbing . thenReturn ( this ) ; [CE] no suitable method found for thenReturn(BaseStubbing<T>)  [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; if ( values = = null ) { [ATTENTION] return stubbing . thenReturn ( this )  ; } for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^21^^^^^18^27^
[REPLACE]  stubbing  =  stubbing  .  thenReturn  (  v  )  ; 	[BUGGY] stubbing = stubbing . thenThrow ( t ) ;  ; [CE] cannot find symbol t  [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; if ( values = = null ) { return stubbing . thenReturn ( null ) ; } for ( T v: values ) { [ATTENTION] stubbing = stubbing . thenThrow ( t )  ;  ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^24^^^^^18^27^
[REPLACE]  for  (  T  v:  values  )  { 	[BUGGY] for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; [FE]  AssertionFailedError  expected:<t[hree]> but was:<t[wo]> assertEquals(  "one  " , mock.simpleMethod())   [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; if ( values = = null ) { return stubbing . thenReturn ( null ) ; } [ATTENTION] for ( T v: values ) { stubbing = stubbing . thenReturn ( v )  ; stubbing = stubbing . thenReturn ( v ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^23^^^^^18^27^
[REPLACE]  return  stubbing; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  thenReturn [TYPE] OngoingStubbing [PARAMETER] T value values [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T v value [TYPE] T[] values [TYPE] OngoingStubbing stubbing  [CONTEXT]  public OngoingStubbing<T> thenReturn ( T value , T . . . values ) { OngoingStubbing<T> stubbing = thenReturn ( value ) ; if ( values = = null ) { return stubbing . thenReturn ( null ) ; } for ( T v: values ) { stubbing = stubbing . thenReturn ( v ) ; } [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^26^^^^^18^27^
[REPLACE]  return  thenAnswer  (  "    ")  ; 	[BUGGY] return toAnswer (  "   ")  ; [CE] method toAnswer in interface DeprecatedOngoingStubbing<T> cannot be applied to given types ;  [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] Throwable throwable [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable throwable  [CONTEXT]  private OngoingStubbing<T> thenThrow ( Throwable throwable ) { [ATTENTION] return toAnswer (   "   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^30^^^^^29^31^
[REPLACE]  if  (  throwables  ==  null  )  { 	[BUGGY] if ( throwables ! = this ) {[CE] incomparable types: Throwable[] and BaseStubbing<T>  [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { [ATTENTION] if ( throwables ! = this ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^34^^^^^33^46^
[ADD]  if  (  throwables  ==  null  )  {  thenThrow  (  (  Throwable  )  null  )  ;  } 	[BUGGY] thenThrow ( ( Throwable ) null ) ; [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { [ATTENTION] thenThrow ( ( Throwable ) null )  ;  OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^34^35^36^^^33^46^
[REPLACE]  thenThrow  (  (  Throwable  )  null  )  ; 	[BUGGY] thenThrow ( ( Throwable ) this ) ; [CE] inconvertible types  [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { [ATTENTION] thenThrow ( ( Throwable ) this )  ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^35^^^^^33^46^
[REPLACE]  OngoingStubbing<T>  stubbing  =  null; 	[BUGGY] OngoingStubbing<T> stubbing = this ; [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } [ATTENTION] OngoingStubbing<T> stubbing = this ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^37^^^^^33^46^
[REPLACE]  if  (  stubbing  ==  null  )  { 	[BUGGY] if ( false ! = this ) {[CE] incomparable types: boolean and BaseStubbing<T>  [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { [ATTENTION] if ( false ! = this ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^39^^^^^33^46^
[REPLACE]  stubbing  =  stubbing  .  thenThrow  (  t  )  ; 	[BUGGY] stubbing = thenThrow ( t ) ;  ; [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { [ATTENTION] stubbing = thenThrow ( t )  ;  ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^42^^^^^33^46^
[REPLACE]  stubbing  =  thenThrow  (  t  )  ; 	[BUGGY] stubbing = stubbing . thenThrow ( t ) ;  ; [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { [ATTENTION] stubbing = stubbing . thenThrow ( t )  ;  ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^40^^^^^33^46^
[ADD]  stubbing  =  thenThrow  (  t  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { [ATTENTION] } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^40^^^^^33^46^
[ADD]  stubbing  =  stubbing  .  thenThrow  (  t  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { [ATTENTION] } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^42^^^^^33^46^
[REPLACE]  for  (  Throwable  t:  throwables  )  { 	[BUGGY] for ( Throwable t: throwables ) { if ( stubbing = = null ) {[CE] illegal start of expression  [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; [ATTENTION] for ( Throwable t: throwables ) { if ( stubbing = = null ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^38^^^^^33^46^
[REPLACE]  return  stubbing; 	[BUGGY] return this ; [FE]  IndexOutOfBoundsException Index: -1 , Size: 0 assertEquals(  "one  " , mock.simpleMethod())   [METHOD]  thenThrow [TYPE] OngoingStubbing [PARAMETER] throwables [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable t [TYPE] OngoingStubbing stubbing [TYPE] Throwable[] throwables  [CONTEXT]  public OngoingStubbing<T> thenThrow ( Throwable . . . throwables ) { if ( throwables = = null ) { thenThrow ( ( Throwable ) null ) ; } OngoingStubbing<T> stubbing = null ; for ( Throwable t: throwables ) { if ( stubbing = = null ) { stubbing = thenThrow ( t ) ; } else { stubbing = stubbing . thenThrow ( t ) ; } } [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^45^^^^^33^46^
[REPLACE]  return  thenAnswer  (  new  CallsRealMethods  (  )  )  ; 	[BUGGY] return thenAnswer ( new ThrowsException ( throwable )  ) ; [CE] cannot find symbol throwable  [METHOD]  thenCallRealMethod [TYPE] OngoingStubbing [PARAMETER] [CLASS] BaseStubbing  [TYPE] boolean false true  [CONTEXT]  public OngoingStubbing<T> thenCallRealMethod ( ) { [ATTENTION] return thenAnswer ( new ThrowsException ( throwable )  )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^50^^^^^49^51^
[REPLACE]  return  toAnswer  (  new  Returns  (  value  )  )  ; 	[BUGGY] return thenAnswer ( new Returns ( value ) ) ; [CE] incompatible types  [METHOD]  toReturn [TYPE] DeprecatedOngoingStubbing [PARAMETER] T value [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] T value  [CONTEXT]  public DeprecatedOngoingStubbing<T> toReturn ( T value ) { [ATTENTION] return thenAnswer ( new Returns ( value ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^54^^^^^53^55^
[REPLACE]  return  toAnswer  (  "    ")  ; 	[BUGGY] return thenAnswer (  "   ")  ; [CE] method thenAnswer in interface OngoingStubbing<T> cannot be applied to given types ;  [METHOD]  toThrow [TYPE] DeprecatedOngoingStubbing [PARAMETER] Throwable throwable [CLASS] BaseStubbing  [TYPE] boolean false true [TYPE] Throwable throwable  [CONTEXT]  public DeprecatedOngoingStubbing<T> toThrow ( Throwable throwable ) { [ATTENTION] return thenAnswer (   "   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/BaseStubbing.java^58^^^^^57^59^
[REPLACE]  final  List<Answer>  answers  =  new  LinkedList<Answer>  (  )  ; 	[BUGGY] final List<Answer> answers  = null ; [FE] [CONTEXT]    [CLASS] StubberImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^21^^^^^^^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter ; [CE] variable reporter might not have been initialized  [CONTEXT]    [CLASS] StubberImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^22^^^^^^^
[REPLACE]  if  (  mock  ==  null  )  { 	[BUGGY] if ( mock ! = true ) {[CE] incomparable types: T and boolean  [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  [ATTENTION] if ( mock ! = true ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^27^^^^^24^37^
[REPLACE]  if  (  !mockUtil  .  isMock  (  mock  )  )  { 	[BUGGY] if ( mockUtil . isMock ( mock ) ) {[FE] AssertionFailedError [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { [ATTENTION] if ( mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^30^^^^^24^37^
[REPLACE]  reporter  .  notAMockPassedToWhenMethod  (  )  ; 	[BUGGY] reporter . nullPassedToWhenMethod ( )  ; [FE]   assertContains(  "Argument passed to when() is not a mock  " , e.getMessage())   [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { [ATTENTION] reporter . nullPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^31^^^^^24^37^
[REPLACE]  reporter  .  nullPassedToWhenMethod  (  )  ; 	[BUGGY] reporter . notAMockPassedToWhenMethod ( ) ; [FE]   assertContains(  "Argument passed to when() is null  " , e.getMessage())   [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { [ATTENTION] reporter . notAMockPassedToWhenMethod ( )  ; } else { if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^28^^^^^24^37^
[REPLACE]  reporter  .  notAMockPassedToWhenMethod  (  )  ; 	[BUGGY] reporter . nullPassedToWhenMethod ( ) ; [FE]   assertContains(  "Argument passed to when() is not a mock  " , e.getMessage())   [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { [ATTENTION] reporter . nullPassedToWhenMethod ( )  ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^31^^^^^24^37^
[REPLACE]  mockUtil  .  getMockHandler  (  mock  )    .  setAnswersForStubbing  (  answers  )  ; 	[BUGGY] mockUtil . MockUtil ( )  . setAnswersForStubbing ( answers ) ; [CE] cannot find symbol  [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } [ATTENTION] mockUtil . MockUtil ( ) . setAnswersForStubbing ( answers )  ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^35^^^^^24^37^
[REPLACE]  mockUtil  .  getMockHandler  (  mock  )    .  setAnswersForStubbing  (  answers  )  ; 	[BUGGY] mockUtil . isMock ( mock ) . setAnswersForStubbing ( answers ) ; [CE] boolean cannot be dereferenced  [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } [ATTENTION] mockUtil . isMock ( mock )  . setAnswersForStubbing ( answers )  ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^35^^^^^24^37^
[REPLACE]  return  mock; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  when [TYPE] <T> [PARAMETER] T mock [CLASS] StubberImpl  [TYPE] List answers [TYPE] boolean false true [TYPE] T mock [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T when ( T mock ) { MockUtil mockUtil = new MockUtil ( ) ;  if ( mock = = null ) { reporter . nullPassedToWhenMethod ( ) ; } else { if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToWhenMethod ( ) ; } } mockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ; [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^36^^^^^24^37^
[REPLACE]  answers  .  add  (  new  Returns  (  toBeReturned  )  )  ; 	[BUGGY] answers . add ( answer ) ; [CE] cannot find symbol answer  [METHOD]  doReturn [TYPE] Stubber [PARAMETER] Object toBeReturned [CLASS] StubberImpl  [TYPE] List answers [TYPE] Object toBeReturned [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doReturn ( Object toBeReturned ) { [ATTENTION] answers . add ( answer )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^40^^^^^39^42^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "foo  " , spy.get(0))   [METHOD]  doReturn [TYPE] Stubber [PARAMETER] Object toBeReturned [CLASS] StubberImpl  [TYPE] List answers [TYPE] Object toBeReturned [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doReturn ( Object toBeReturned ) { answers . add ( new Returns ( toBeReturned ) ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^41^^^^^39^42^
[REPLACE]  answers  .  add  (  new  ThrowsException  (  toBeThrown  )  )  ; 	[BUGGY] answers . add ( answer ) ; [CE] cannot find symbol answer  [METHOD]  doThrow [TYPE] Stubber [PARAMETER] Throwable toBeThrown [CLASS] StubberImpl  [TYPE] Throwable toBeThrown [TYPE] List answers [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doThrow ( Throwable toBeThrown ) { [ATTENTION] answers . add ( answer )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^45^^^^^44^47^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  doThrow [TYPE] Stubber [PARAMETER] Throwable toBeThrown [CLASS] StubberImpl  [TYPE] Throwable toBeThrown [TYPE] List answers [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doThrow ( Throwable toBeThrown ) { answers . add ( new ThrowsException ( toBeThrown ) ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^46^^^^^44^47^
[REPLACE]  answers  .  add  (  new  DoesNothing  (  )  )  ; 	[BUGGY] answers . add ( answer ) ; [CE] cannot find symbol answer  [METHOD]  doNothing [TYPE] Stubber [PARAMETER] [CLASS] StubberImpl  [TYPE] List answers [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public Stubber doNothing ( ) { [ATTENTION] answers . add ( answer )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^50^^^^^49^52^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  doNothing [TYPE] Stubber [PARAMETER] [CLASS] StubberImpl  [TYPE] List answers [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public Stubber doNothing ( ) { answers . add ( new DoesNothing ( ) ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^51^^^^^49^52^
[REPLACE]  answers  .  add  (  answer  )  ; 	[BUGGY] reporter . nullPassedToWhenMethod ( ) ; [FE] AssertionFailedError [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] StubberImpl  [TYPE] Answer answer [TYPE] List answers [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doAnswer ( Answer answer ) { [ATTENTION] reporter . nullPassedToWhenMethod ( )  ; return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^55^^^^^54^57^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] StubberImpl  [TYPE] Answer answer [TYPE] List answers [TYPE] boolean false true [TYPE] Reporter reporter  [CONTEXT]  public Stubber doAnswer ( Answer answer ) { answers . add ( answer ) ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/stubbing/StubberImpl.java^56^^^^^54^57^
[REPLACE]  return  atLeast  (  1  )  ; 	[BUGGY] return atLeast ( 1 - 3 ) ; [FE] AssertionFailedError [METHOD]  atLeastOnce [TYPE] VerificationMode [PARAMETER] [CLASS] VerificationModeFactory  [TYPE] boolean false true  [CONTEXT]  public static VerificationMode atLeastOnce ( ) { [ATTENTION] return atLeast ( 1 - 3 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationModeFactory.java^12^^^^^11^13^
[REPLACE]  return  new  AtLeast  (  minNumberOfInvocations  )  ; 	[BUGGY] return new Times ( wantedNumberOfInvocations )  ; [CE] cannot find symbol wantedNumberOfInvocations  [METHOD]  atLeast [TYPE] VerificationMode [PARAMETER] int minNumberOfInvocations [CLASS] VerificationModeFactory  [TYPE] boolean false true [TYPE] int minNumberOfInvocations  [CONTEXT]  public static VerificationMode atLeast ( int minNumberOfInvocations ) { [ATTENTION] returnnew Times ( wantedNumberOfInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationModeFactory.java^16^^^^^15^17^
[REPLACE]  return  new  Times  (  wantedNumberOfInvocations  )  ; 	[BUGGY] return new AtLeast ( minNumberOfInvocations )  ; [CE] cannot find symbol minNumberOfInvocations  [METHOD]  times [TYPE] Times [PARAMETER] int wantedNumberOfInvocations [CLASS] VerificationModeFactory  [TYPE] boolean false true [TYPE] int wantedNumberOfInvocations  [CONTEXT]  public static Times times ( int wantedNumberOfInvocations ) { [ATTENTION] returnnew AtLeast ( minNumberOfInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationModeFactory.java^20^^^^^19^21^
[REPLACE]  return  new  NoMoreInteractions  (  )  ; 	[BUGGY] return new Times ( wantedNumberOfInvocations )  ; [CE] cannot find symbol wantedNumberOfInvocations  [METHOD]  noMoreInteractions [TYPE] NoMoreInteractions [PARAMETER] [CLASS] VerificationModeFactory  [TYPE] boolean false true  [CONTEXT]  public static NoMoreInteractions noMoreInteractions ( ) { [ATTENTION] returnnew Times ( wantedNumberOfInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationModeFactory.java^24^^^^^23^25^
[REPLACE]  return  new  AtMost  (  maxNumberOfInvocations  )  ; 	[BUGGY] return new Times ( wantedNumberOfInvocations )  ; [CE] cannot find symbol wantedNumberOfInvocations  [METHOD]  atMost [TYPE] VerificationMode [PARAMETER] int maxNumberOfInvocations [CLASS] VerificationModeFactory  [TYPE] boolean false true [TYPE] int maxNumberOfInvocations  [CONTEXT]  public static VerificationMode atMost ( int maxNumberOfInvocations ) { [ATTENTION] returnnew Times ( wantedNumberOfInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationModeFactory.java^28^^^^^27^29^
[REPLACE]  if  (  wantedNumberOfInvocations  <  0  )  { 	[BUGGY] if (wantedCount > 0 ) {[CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] Times(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] Times  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public Times ( int wantedNumberOfInvocations ) { [ATTENTION] if ( wantedCount>0 ) { throw new MockitoException (   "Negative value is not allowed here  " ) ; } this . wantedCount = wantedNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^25^^^^^24^29^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] Times(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] Times  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public Times ( int wantedNumberOfInvocations ) { if ( wantedNumberOfInvocations < 0 ) { [ATTENTION] return ; } this . wantedCount = wantedNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^26^^^^^24^29^
[ADD]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Negative value is not allowed here  " , e.getMessage())   [METHOD]  <init> [TYPE] Times(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] Times  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public Times ( int wantedNumberOfInvocations ) { if ( wantedNumberOfInvocations < 0 ) { [ATTENTION] } this . wantedCount = wantedNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^26^^^^^24^29^
[REPLACE]  this  .  wantedCount  =  wantedNumberOfInvocations; 	[BUGGY] this . wantedCount =  wantedCount ; [CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] Times(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] Times  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public Times ( int wantedNumberOfInvocations ) { if ( wantedNumberOfInvocations < 0 ) { throw new MockitoException (   "Negative value is not allowed here  " ) ; } [ATTENTION] this . wantedCount = wantedCount ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^28^^^^^24^29^
[REPLACE]  if  (  wantedCount  >  0  )  { 	[BUGGY] if (wantedNumberOfInvocations < =  0 ) {[CE] cannot find symbol wantedNumberOfInvocations  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { [ATTENTION] if ( wantedNumberOfInvocations< = 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^32^^^^^31^38^
[REPLACE]  MissingInvocationChecker  missingInvocation  =  new  MissingInvocationChecker  (  )  ; 	[BUGGY] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [CE] method check in class MissingInvocationInOrderChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { [ATTENTION] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( )  ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^33^^^^^31^38^
[REPLACE]  NumberOfInvocationsChecker  numberOfInvocations  =  new  NumberOfInvocationsChecker  (  )  ; 	[BUGGY] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [CE] cannot find symbol numberOfInvocations  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } [ATTENTION] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( )  ; numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^36^^^^^31^38^
[REPLACE]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] numberOfInvocations . check ( null , null , 1 )  , wantedCount ) ; [CE] ' ; ' expected  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; [ATTENTION] numberOfInvocations . check ( null , null , 1 ) , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^37^^^^^31^38^
[REPLACE]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] numberOfInvocations . check ( data . getWanted ( ) , data . getWanted ( ) , wantedCount ) ; [CE] method check in class NumberOfInvocationsChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; [ATTENTION] numberOfInvocations . check ( data . getWanted ( )  , data . getWanted ( )  , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^37^^^^^31^38^
[REPLACE]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] numberOfInvocations . check ( data . getAllInvocations ( ) , data . getAllInvocations ( )  , wantedCount ) ; [CE] method check in class NumberOfInvocationsChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; [ATTENTION] numberOfInvocations . check ( data . getAllInvocations ( )  , data . getAllInvocations ( ) , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^37^^^^^31^38^
[REMOVE]   	[BUGGY] InvocationMatcher wanted = data . getWanted ( ) ; [NO-ERROR]  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] MissingInvocationChecker missingInvocation [TYPE] NumberOfInvocationsChecker numberOfInvocations [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { if ( wantedCount > 0 ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; [ATTENTION] numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^37^^^^^31^38^
[REPLACE]  List<Invocation>  allInvocations  =  data  .  getAllInvocations  (  )  ; 	[BUGGY] List<Invocation> allInvocations = data . getWanted ( ) ; [CE] incompatible types  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { [ATTENTION] List<Invocation> allInvocations = data . getWanted ( )  ; InvocationMatcher wanted = data . getWanted ( ) ;  if ( wantedCount > 0 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^41^^^^^40^50^
[REPLACE]  InvocationMatcher  wanted  =  data  .  getWanted  (  )  ; 	[BUGGY] InvocationMatcher wanted = data . getAllInvocations ( ) ; [CE] incompatible types  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; [ATTENTION] InvocationMatcher wanted = data . getAllInvocations ( )  ;  if ( wantedCount > 0 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^42^^^^^40^50^
[ADD]  InvocationMatcher  wanted  =  data  .  getWanted  (  )  ; 	[BUGGY] [CE] cannot find symbol wanted  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; [ATTENTION]  if ( wantedCount > 0 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^42^^^^^40^50^
[REPLACE]  if  (  wantedCount  >  0  )  { 	[BUGGY] if ( wantedCount < 0 >>> 1 ) {[FE]   assertContains(  "thirdChunk(  " , e.getMessage())   [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  [ATTENTION] if ( wantedCount<0 >>> 1 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^44^^^^^40^50^
[ADD]  if  (  wantedCount  >  0  )  {  MissingInvocationInOrderChecker  missingInvocation  =  new  MissingInvocationInOrderChecker  (  )  ;  missingInvocation  .  check  (  allInvocations,  wanted,  this  )  ;  } 	[BUGGY] [FE]   assertContains(  "thirdChunk(  " , e.getMessage())   [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  [ATTENTION]   NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^44^45^46^47^^40^50^
[REPLACE]  MissingInvocationInOrderChecker  missingInvocation  =  new  MissingInvocationInOrderChecker  (  )  ; 	[BUGGY] MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; [CE] method check in class MissingInvocationChecker cannot be applied to given types ;  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  if ( wantedCount > 0 ) { [ATTENTION] MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( )  ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^45^^^^^40^50^
[REPLACE]  NumberOfInvocationsInOrderChecker  numberOfCalls  =  new  NumberOfInvocationsInOrderChecker  (  )  ; 	[BUGGY] NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( ) ; [CE] cannot find symbol numberOfCalls  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  if ( wantedCount > 0 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } [ATTENTION] NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker ( )  ; numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^48^^^^^40^50^
[REPLACE]  numberOfCalls  .  check  (  allInvocations,  wanted,  wantedCount  )  ; 	[BUGGY] numberOfCalls . check ( null , wanted , wantedCount ) ; [FE] AssertionFailedError [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] Times  [TYPE] boolean false true [TYPE] NumberOfInvocationsInOrderChecker numberOfCalls [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  if ( wantedCount > 0 ) { MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; missingInvocation . check ( allInvocations , wanted , this ) ; } NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker ( ) ; [ATTENTION] numberOfCalls . check ( null , wanted , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^49^^^^^40^50^
[REPLACE]  return    "Wanted  invocations  count:    "  +  wantedCount; 	[BUGGY] return   "Wanted invocations count:   " +true ; [NO-ERROR]  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Times  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "Wanted invocations count:   " +true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/Times.java^54^^^^^53^55^
[REPLACE]  if  (  maxNumberOfInvocations  <  0  )  { 	[BUGGY] if ( maxNumberOfInvocations > 0 ) {[FE] AssertionFailedError [METHOD]  <init> [TYPE] AtMost(int) [PARAMETER] int maxNumberOfInvocations [CLASS] AtMost  [TYPE] int maxNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtMost ( int maxNumberOfInvocations ) { [ATTENTION] if ( maxNumberOfInvocations>0 ) { throw new MockitoException (   "Negative value is not allowed here  " ) ; } this . maxNumberOfInvocations = maxNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^22^^^^^21^26^
[ADD]  if  (  maxNumberOfInvocations  <  0  )  {  throw  new  MockitoException  (  "    ")  ;  } 	[BUGGY] [FE]   assertEquals(  "Negative value is not allowed here  " , e.getMessage())   [METHOD]  <init> [TYPE] AtMost(int) [PARAMETER] int maxNumberOfInvocations [CLASS] AtMost  [TYPE] int maxNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtMost ( int maxNumberOfInvocations ) { [ATTENTION]  this . maxNumberOfInvocations = maxNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^22^23^24^^^21^26^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [CE] variable maxNumberOfInvocations might not have been initialized  [METHOD]  <init> [TYPE] AtMost(int) [PARAMETER] int maxNumberOfInvocations [CLASS] AtMost  [TYPE] int maxNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtMost ( int maxNumberOfInvocations ) { if ( maxNumberOfInvocations < 0 ) { [ATTENTION] return ; } this . maxNumberOfInvocations = maxNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^23^^^^^21^26^
[REPLACE]  this  .  maxNumberOfInvocations  =  maxNumberOfInvocations; 	[BUGGY] this . maxNumberOfInvocations =  null ; [CE] incompatible types  [METHOD]  <init> [TYPE] AtMost(int) [PARAMETER] int maxNumberOfInvocations [CLASS] AtMost  [TYPE] int maxNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtMost ( int maxNumberOfInvocations ) { if ( maxNumberOfInvocations < 0 ) { throw new MockitoException (   "Negative value is not allowed here  " ) ; } [ATTENTION] this . maxNumberOfInvocations = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^25^^^^^21^26^
[REPLACE]  List<Invocation>  invocations  =  data  .  getAllInvocations  (  )  ; 	[BUGGY] List<Invocation> invocations = data . getWanted ( ) ; [CE] incompatible types  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { [ATTENTION] List<Invocation> invocations = data . getWanted ( )  ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^29^^^^^28^42^
[REPLACE]  InvocationMatcher  wanted  =  data  .  getWanted  (  )  ; 	[BUGGY] InvocationMatcher wanted = data . getAllInvocations ( )  ; [CE] incompatible types  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; [ATTENTION] InvocationMatcher wanted = data . getAllInvocations ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^30^^^^^28^42^
[REPLACE]  InvocationsFinder  finder  =  new  InvocationsFinder  (  )  ; 	[BUGGY] InvocationMatcher wanted = data . getWanted ( ) ; [CE] variable wanted is already defined in method verify(VerificationData)  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  [ATTENTION] InvocationMatcher wanted = data . getWanted ( )  ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^32^^^^^28^42^
[REPLACE]  List<Invocation>  found  =  finder  .  findInvocations  (  invocations,  wanted  )  ; 	[BUGGY] List<Invocation> found = finder . findInvocations ( this , wanted ) ; [CE] method findInvocations in class InvocationsFinder cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; [ATTENTION] List<Invocation> found = finder . findInvocations ( this , wanted )  ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^33^^^^^28^42^
[REPLACE]  int  foundSize  =  found  .  size  (  )  ; 	[BUGGY] int thisSize = found . size ( ) ; [CE] cannot find symbol foundSize  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; [ATTENTION] int thisSize = found . size ( )  ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^34^^^^^28^42^
[REPLACE]  if  (  foundSize  >  maxNumberOfInvocations  )  { 	[BUGGY] if ( foundSize ! =  maxNumberOfInvocations ) {[FE] AssertionFailedError [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; [ATTENTION] if ( foundSize! = maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^35^^^^^28^42^
[REPLACE]  new  Reporter  (  )    .  wantedAtMostX  (  maxNumberOfInvocations,  foundSize  )  ; 	[BUGGY] new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , maxNumberOfInvocations ) ; [FE]  AssertionFailedError  expected:<...most 1 time but was [2]> but was:<...most 1 time but was [1]> assertEquals(  "\nWanted at most 1 time but was 2  " , e.getMessage())   [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { [ATTENTION] new Reporter ( )  . wantedAtMostX ( maxNumberOfInvocations , maxNumberOfInvocations )  ; } for ( Invocation i : found ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^36^^^^^28^42^
[REPLACE]  for  (  Invocation  i  :  found  )  { 	[BUGGY] for ( Invocation i : found ) { i . markVerified ( ) ; [NO-ERROR]  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } [ATTENTION] for ( Invocation i : found ) { i . markVerified ( )  ; i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^39^^^^^28^42^
[ADD]  for  (  Invocation  i  :  found  )  {  i  .  markVerified  (  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtMost  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] InvocationMatcher wanted [TYPE] List found invocations [TYPE] int foundSize maxNumberOfInvocations [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> invocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  InvocationsFinder finder = new InvocationsFinder ( ) ; List<Invocation> found = finder . findInvocations ( invocations , wanted ) ; int foundSize = found . size ( ) ; if ( foundSize > maxNumberOfInvocations ) { new Reporter ( ) . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; } [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtMost.java^39^40^41^^^28^42^
[REPLACE]  private  final  InvocationMatcher  wanted; 	[BUGGY] private InvocationMatcher wanted ; [NO-ERROR]  [CONTEXT]    [CLASS] VerificationDataImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationDataImpl.java^16^^^^^^^
[REPLACE]  this  .  allInvocations  =  allInvocations; 	[BUGGY] this . allInvocations =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] InvocationMatcher) [PARAMETER] Invocation> allInvocations InvocationMatcher wanted [CLASS] VerificationDataImpl  [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] boolean false true  [CONTEXT]  public VerificationDataImpl ( List<Invocation> allInvocations , InvocationMatcher wanted ) { [ATTENTION] this . allInvocations = null ; this . wanted = wanted ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationDataImpl.java^19^^^^^18^21^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] InvocationMatcher) [PARAMETER] Invocation> allInvocations InvocationMatcher wanted [CLASS] VerificationDataImpl  [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] boolean false true  [CONTEXT]  public VerificationDataImpl ( List<Invocation> allInvocations , InvocationMatcher wanted ) { this . allInvocations = allInvocations ; [ATTENTION] this . wanted = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationDataImpl.java^20^^^^^18^21^
[REPLACE]  return  allInvocations; 	[BUGGY] return wanted ; [CE] incompatible types  [METHOD]  getAllInvocations [TYPE] List [PARAMETER] [CLASS] VerificationDataImpl  [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] boolean false true  [CONTEXT]  public List<Invocation> getAllInvocations ( ) { [ATTENTION] return wanted ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationDataImpl.java^24^^^^^23^25^
[REPLACE]  return  wanted; 	[BUGGY] return allInvocations ; [CE] incompatible types  [METHOD]  getWanted [TYPE] InvocationMatcher [PARAMETER] [CLASS] VerificationDataImpl  [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher getWanted ( ) { [ATTENTION] return allInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/VerificationDataImpl.java^28^^^^^27^29^
[REPLACE]  private  final  Reporter  reporter; 	[BUGGY] private Reporter reporter ; [NO-ERROR]  [CONTEXT]    [CLASS] NumberOfInvocationsChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^18^^^^^^^
[REPLACE]  this  (  new  Reporter  (  )  ,  new  InvocationsFinder  (  )  )  ; 	[BUGGY] int actualCount = actualInvocations . size ( ) ; [CE] cannot find symbol actualInvocations  [METHOD]  <init> [TYPE] NumberOfInvocationsChecker() [PARAMETER] [CLASS] NumberOfInvocationsChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public NumberOfInvocationsChecker ( ) { [ATTENTION] int actualCount = actualInvocations . size ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^22^^^^^21^23^
[REPLACE]  this  .  reporter  =  reporter; 	[BUGGY] this . reporter =  null ; [FE] NullPointerException assertSame(second.getLocation() , reporterStub.location)   [METHOD]  <init> [TYPE] InvocationsFinder) [PARAMETER] Reporter reporter InvocationsFinder finder [CLASS] NumberOfInvocationsChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  NumberOfInvocationsChecker ( Reporter reporter , InvocationsFinder finder ) { [ATTENTION] this . reporter = null ; this . finder = finder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^26^^^^^25^28^
[REPLACE]  this  .  finder  =  finder; 	[BUGGY] this . finder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] InvocationsFinder) [PARAMETER] Reporter reporter InvocationsFinder finder [CLASS] NumberOfInvocationsChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  NumberOfInvocationsChecker ( Reporter reporter , InvocationsFinder finder ) { this . reporter = reporter ; [ATTENTION] this . finder = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^27^^^^^25^28^
[REPLACE]  List<Invocation>  actualInvocations  =  finder  .  findInvocations  (  invocations,  wanted  )  ; 	[BUGGY] int actualCount = actualInvocations . size ( ) ; [CE] cannot find symbol actualInvocations  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION] int actualCount = actualInvocations . size ( )  ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^31^^^^^30^48^
[REPLACE]  int  actualCount  =  actualInvocations  .  size  (  )  ; 	[BUGGY] int actualCount = this . size ( ) ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  [ATTENTION] int actualCount = this . size ( )  ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^33^^^^^30^48^
[REPLACE]  if  (  wantedCount  >  actualCount  )  { 	[BUGGY] if ( wantedCount > =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; [ATTENTION] if ( wantedCount> = actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^34^^^^^30^48^
[REPLACE]  }  else  if  (  wantedCount  ==  0  &&  actualCount  >  0  )  { 	[BUGGY]  if ( actualCount > 0 ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [ATTENTION] }if ( actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^37^^^^^30^48^
[ADD]  else  if  (  wantedCount  ==  0  &&  actualCount  >  0  )  {  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ;  reporter  .  neverWantedButInvoked  (  wanted,  firstUndesired  )  ;  }  else  if  (  wantedCount  <  actualCount  )  {  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY]  reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; [CE] illegal start of type  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [ATTENTION] } reporter . neverWantedButInvoked ( wanted , firstUndesired )  ; Location firstUndesired = actualInvocations . get ( wantedCount )  . getLocation ( )  ;   reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^37^38^39^40^41^30^48^
[REPLACE]  }  else  if  (  wantedCount  <  actualCount  )  { 	[BUGGY]  else {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; [ATTENTION] }else { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^40^^^^^30^48^
[REMOVE]   	[BUGGY] if ( ( wantedCount = = 0 ) && ( actualCount > 0 ) ) {   Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ;   reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; }else   if ( wantedCount < actualCount ) {     Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ;     reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ;   }[NO-ERROR]  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; [ATTENTION] } else if ( wantedCount < actualCount ) { if ( ( wantedCount = = 0 ) && ( actualCount > 0 ) ) { Location firstUndesired = actualInvocations . get ( wantedCount )  . getLocation ( )  ; reporter . neverWantedButInvoked ( wanted , firstUndesired )  ; }else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount )  . getLocation ( )  ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired )  ; }Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^40^^^^^30^48^
[REPLACE]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = actualInvocations . get ( actualCount ) . getLocation ( ) ; [FE]  IndexOutOfBoundsException Index: 3 , Size: 3 assertSame(third.getLocation() , reporterStub.location)   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] Location firstUndesired = actualInvocations . get ( actualCount )  . getLocation ( )  ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^41^^^^^30^48^
[REPLACE]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = actualInvocations . get ( actualCount ) . getLocation ( ) ; [FE]  IndexOutOfBoundsException Index: 1 , Size: 1 assertEquals(wanted , reporterStub.wanted)   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { [ATTENTION] Location firstUndesired = actualInvocations . get ( actualCount )  . getLocation ( )  ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^38^^^^^30^48^
[REPLACE]  }  else  if  (  wantedCount  <  actualCount  )  { 	[BUGGY] else if ( wantedCount < =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; [ATTENTION] } else if ( wantedCount< = actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^40^^^^^30^48^
[REPLACE]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = this . get ( wantedCount ) . getLocation ( ) ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] Location firstUndesired = this . get ( wantedCount )  . getLocation ( )  ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^41^^^^^30^48^
[ADD]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] [CE] cannot find symbol firstUndesired  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^41^^^^^30^48^
[REPLACE]  Location  lastInvocation  =  finder  .  getLastLocation  (  actualInvocations  )  ; 	[BUGGY] Location lastInvocation = finder . findInvocations ( null , wanted )  ; [CE] incompatible types  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION] Location lastInvocation = finder . findInvocations ( null , wanted ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^35^^^^^30^48^
[ADD]  Location  lastInvocation  =  finder  .  getLastLocation  (  actualInvocations  )  ;  reporter  .  tooLittleActualInvocations  (  new  Discrepancy  (  wantedCount,  actualCount  )  ,  wanted,  lastInvocation  )  ; 	[BUGGY] reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [CE] cannot find symbol lastInvocation  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION] reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount )  , wanted , lastInvocation )  ;  } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^35^36^^^^30^48^
[ADD]  else  if  (  wantedCount  ==  0  &&  actualCount  >  0  )  {  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ;  reporter  .  neverWantedButInvoked  (  wanted,  firstUndesired  )  ;  }  else  if  (  wantedCount  <  actualCount  )  {  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY]  Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; [CE] illegal start of type  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [ATTENTION] } Location firstUndesired = actualInvocations . get ( wantedCount )  . getLocation ( )  ; reporter . neverWantedButInvoked ( wanted , firstUndesired )  ; Location firstUndesired = actualInvocations . get ( wantedCount )  . getLocation ( )  ;   reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^37^38^39^40^41^30^48^
[ADD]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ;  reporter  .  neverWantedButInvoked  (  wanted,  firstUndesired  )  ; 	[BUGGY] reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; [CE] cannot find symbol firstUndesired  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { [ATTENTION] reporter . neverWantedButInvoked ( wanted , firstUndesired )  ;  } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^38^39^^^^30^48^
[REPLACE]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = false . get ( wantedCount ) . getLocation ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] Location firstUndesired = false . get ( wantedCount )  . getLocation ( )  ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^41^^^^^30^48^
[REPLACE]  Location  lastInvocation  =  finder  .  getLastLocation  (  actualInvocations  )  ; 	[BUGGY] Location lastInvocation = finder . getLastLocation ( null ) ; [FE] NullPointerException assertSame(second.getLocation() , reporterStub.location)   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION] Location lastInvocation = finder . getLastLocation ( null )  ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^35^^^^^30^48^
[ADD]  Location  lastInvocation  =  finder  .  getLastLocation  (  actualInvocations  )  ;  reporter  .  tooLittleActualInvocations  (  new  Discrepancy  (  wantedCount,  actualCount  )  ,  wanted,  lastInvocation  )  ; 	[BUGGY] [FE]  expected same:<-> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)> was not:<null> assertSame(second.getLocation() , reporterStub.location)   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION]  } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^35^36^^^^30^48^
[REPLACE]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = null . get ( wantedCount ) . getLocation ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { [ATTENTION] Location firstUndesired = null . get ( wantedCount )  . getLocation ( )  ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^38^^^^^30^48^
[ADD]  Location  firstUndesired  =  actualInvocations  .  get  (  wantedCount  )    .  getLocation  (  )  ;  reporter  .  tooManyActualInvocations  (  wantedCount,  actualCount,  wanted,  firstUndesired  )  ; 	[BUGGY] reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; [CE] cannot find symbol firstUndesired  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired )  ;  } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^41^42^^^^30^48^
[REPLACE]  for  (  Invocation  i  :  actualInvocations  )  { 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] class , interface , or enum expected  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^45^^^^^30^48^
[ADD]  for  (  Invocation  i  :  actualInvocations  )  {  i  .  markVerified  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertFalse(invocation.isVerified())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount = = 0 && actualCount > 0 ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . neverWantedButInvoked ( wanted , firstUndesired ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = actualInvocations . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocations ( wantedCount , actualCount , wanted , firstUndesired ) ; } [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java^45^46^47^^^30^48^
[REPLACE]  private  final  Reporter  reporter; 	[BUGGY] private Reporter reporter ; [NO-ERROR]  [CONTEXT]    [CLASS] MissingInvocationChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^19^^^^^^^
[REPLACE]  this  (  new  InvocationsFinder  (  )  ,  new  Reporter  (  )  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] cannot find symbol invocations  [METHOD]  <init> [TYPE] MissingInvocationChecker() [PARAMETER] [CLASS] MissingInvocationChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public MissingInvocationChecker ( ) { [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^23^^^^^22^24^
[REPLACE]  this  .  finder  =  finder; 	[BUGGY] this . finder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationChecker ( InvocationsFinder finder , Reporter reporter ) { [ATTENTION] this . finder = null ; this . reporter = reporter ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^27^^^^^26^29^
[REPLACE]  this  .  reporter  =  reporter; 	[BUGGY] this . reporter =  null ; [FE] NullPointerException assertTrue(finderStub.actualToReturn.isEmpty())   [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] this . reporter = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^28^^^^^26^29^
[ADD]  this  .  reporter  =  reporter; 	[BUGGY] [CE] variable reporter might not have been initialized  [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^28^^^^^26^29^
[REPLACE]  List<Invocation>  actualInvocations  =  finder  .  findInvocations  (  invocations,  wanted  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . findSimilarInvocation ( invocations , wanted ) ; [CE] incompatible types  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { [ATTENTION] List<Invocation> actualInvocations = finder . findSimilarInvocation ( invocations , wanted )  ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^32^^^^^31^45^
[ADD]  List<Invocation>  actualInvocations  =  finder  .  findInvocations  (  invocations,  wanted  )  ; 	[BUGGY] [CE] cannot find symbol actualInvocations  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { [ATTENTION]  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^32^^^^^31^45^
[REPLACE]  if  (  actualInvocations  .  isEmpty  (  )  )  { 	[BUGGY] if ( similar ! = null ) {[CE] cannot find symbol similar  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  [ATTENTION] if ( similar ! = null ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^34^^^^^31^45^
[REPLACE]  if  (  similar  !=  null  )  { 	[BUGGY] if ( similar = = false ) {[CE] incomparable types: Invocation and boolean  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; [ATTENTION] if ( similar = = false ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^36^^^^^31^45^
[REPLACE]  reporter  .  wantedButNotInvoked  (  wanted,  invocations  )  ; 	[BUGGY] reporter . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { [ATTENTION] reporter . Reporter ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^42^^^^^31^45^
[REPLACE]  ArgumentMatchingTool  argumentMatchingTool  =  new  ArgumentMatchingTool  (  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] variable actualInvocations is already defined in method check(List<Invocation> , InvocationMatcher)  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^37^^^^^31^45^
[REPLACE]  Integer[]  indexesOfSuspiciousArgs  =  argumentMatchingTool  .  getSuspiciouslyNotMatchingArgsIndexes  (  wanted  .  getMatchers  (  )  ,  similar  .  getArguments  (  )  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] variable actualInvocations is already defined in method check(List<Invocation> , InvocationMatcher)  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^38^^^^^31^45^
[ADD]  Integer[]  indexesOfSuspiciousArgs  =  argumentMatchingTool  .  getSuspiciouslyNotMatchingArgsIndexes  (  wanted  .  getMatchers  (  )  ,  similar  .  getArguments  (  )  )  ;  SmartPrinter  smartPrinter  =  new  SmartPrinter  (  wanted,  similar,  indexesOfSuspiciousArgs  )  ; 	[BUGGY] [CE] cannot find symbol smartPrinter  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; [ATTENTION]  reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^38^39^^^^31^45^
[REPLACE]  SmartPrinter  smartPrinter  =  new  SmartPrinter  (  wanted,  similar,  indexesOfSuspiciousArgs  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] variable actualInvocations is already defined in method check(List<Invocation> , InvocationMatcher)  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^39^^^^^31^45^
[ADD]  SmartPrinter  smartPrinter  =  new  SmartPrinter  (  wanted,  similar,  indexesOfSuspiciousArgs  )  ; 	[BUGGY] [CE] cannot find symbol smartPrinter  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; [ATTENTION] reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^39^^^^^31^45^
[REPLACE]  Invocation  similar  =  finder  .  findSimilarInvocation  (  invocations,  wanted  )  ; 	[BUGGY] Invocation similar = finder . findInvocations ( null , wanted )  ; [CE] incompatible types  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { [ATTENTION] Invocation similar = finder . findInvocations ( null , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^35^^^^^31^45^
[ADD]  ArgumentMatchingTool  argumentMatchingTool  =  new  ArgumentMatchingTool  (  )  ;  Integer[]  indexesOfSuspiciousArgs  =  argumentMatchingTool  .  getSuspiciouslyNotMatchingArgsIndexes  (  wanted  .  getMatchers  (  )  ,  similar  .  getArguments  (  )  )  ; 	[BUGGY] [CE] cannot find symbol indexesOfSuspiciousArgs  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { [ATTENTION]  SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^37^38^^^^31^45^
[REPLACE]  Integer[]  indexesOfSuspiciousArgs  =  argumentMatchingTool  .  getSuspiciouslyNotMatchingArgsIndexes  (  wanted  .  getMatchers  (  )  ,  similar  .  getArguments  (  )  )  ; 	[BUGGY] Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getLocation ( )  ) ; [CE] method getSuspiciouslyNotMatchingArgsIndexes in class ArgumentMatchingTool cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; [ATTENTION] Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( )  , similar . getLocation ( )  )  ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^38^^^^^31^45^
[REPLACE]  if  (  similar  !=  null  )  { 	[BUGGY] if ( similar = = null ) {[FE] NullPointerException assertTrue(finderStub.actualToReturn.isEmpty())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; [ATTENTION] if ( similar = = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^36^^^^^31^45^
[REPLACE]  reporter  .  wantedButNotInvoked  (  wanted,  invocations  )  ; 	[BUGGY] reporter . wantedButNotInvoked ( wanted , null ) ; [FE] NullPointerException assertContains(  "<Capturing argument>  " , e.getMessage())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { [ATTENTION] reporter . wantedButNotInvoked ( wanted , null )  ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^42^^^^^31^45^
[REPLACE]  Invocation  similar  =  finder  .  findSimilarInvocation  (  invocations,  wanted  )  ; 	[BUGGY] Invocation similar = finder . findInvocations ( this , wanted )  ; [CE] method findInvocations in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { [ATTENTION] Invocation similar = finder . findInvocations ( this , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getArguments ( ) ) ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^35^^^^^31^45^
[REPLACE]  Integer[]  indexesOfSuspiciousArgs  =  argumentMatchingTool  .  getSuspiciouslyNotMatchingArgsIndexes  (  wanted  .  getMatchers  (  )  ,  similar  .  getArguments  (  )  )  ; 	[BUGGY] Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( ) , similar . getLocation ( ) ) ; [CE] method getSuspiciouslyNotMatchingArgsIndexes in class ArgumentMatchingTool cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] MissingInvocationChecker  [TYPE] boolean false true [TYPE] Invocation similar [TYPE] SmartPrinter smartPrinter [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] ArgumentMatchingTool argumentMatchingTool [TYPE] Integer[] indexesOfSuspiciousArgs  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  if ( actualInvocations . isEmpty ( ) ) { Invocation similar = finder . findSimilarInvocation ( invocations , wanted ) ; if ( similar ! = null ) { ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool ( ) ; [ATTENTION] Integer[] indexesOfSuspiciousArgs = argumentMatchingTool . getSuspiciouslyNotMatchingArgsIndexes ( wanted . getMatchers ( )  , similar . getLocation ( ) )  ; SmartPrinter smartPrinter = new SmartPrinter ( wanted , similar , indexesOfSuspiciousArgs ) ; reporter . argumentsAreDifferent ( smartPrinter . getWanted ( ) , smartPrinter . getActual ( ) , similar . getLocation ( ) ) ; } else { reporter . wantedButNotInvoked ( wanted , invocations ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java^38^^^^^31^45^
[REPLACE]  this  (  new  InvocationsFinder  (  )  ,  new  Reporter  (  )  )  ; 	[BUGGY] Location lastInvocation = finder . getLastLocation ( chunk ) ; [CE] cannot find symbol chunk  [METHOD]  <init> [TYPE] NumberOfInvocationsInOrderChecker() [PARAMETER] [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public NumberOfInvocationsInOrderChecker ( ) { [ATTENTION] Location lastInvocation = finder . getLastLocation ( chunk )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^22^^^^^21^23^
[REPLACE]  this  .  finder  =  finder; 	[BUGGY] this . finder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  NumberOfInvocationsInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { [ATTENTION] this . finder = null ; this . reporter = reporter ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^26^^^^^25^28^
[REPLACE]  this  .  reporter  =  reporter; 	[BUGGY] this . reporter =  null ; [FE] NullPointerException assertContains(  "Wanted 1 time  " , e.getMessage())   [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  NumberOfInvocationsInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] this . reporter = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^27^^^^^25^28^
[ADD]  this  .  reporter  =  reporter; 	[BUGGY] [CE] variable reporter might not have been initialized  [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  NumberOfInvocationsInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^27^^^^^25^28^
[REPLACE]  List<Invocation>  chunk  =  finder  .  findMatchingChunk  (  invocations,  wanted,  wantedCount  )  ; 	[BUGGY] List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , actualCount ) ; [CE] cannot find symbol actualCount  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION] List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , actualCount )  ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^31^^^^^30^46^
[REPLACE]  int  actualCount  =  chunk  .  size  (  )  ; 	[BUGGY] int actualCount = null . size ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  [ATTENTION] int actualCount = null . size ( )  ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^33^^^^^30^46^
[REPLACE]  if  (  wantedCount  >  actualCount  )  { 	[BUGGY] if ( wantedCount  = =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  [ATTENTION] if ( wantedCount = = actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^35^^^^^30^46^
[ADD]  if  (  wantedCount  >  actualCount  )  {  Location  lastInvocation  =  finder  .  getLastLocation  (  chunk  )  ;  reporter  .  tooLittleActualInvocationsInOrder  (  new  Discrepancy  (  wantedCount,  actualCount  )  ,  wanted,  lastInvocation  )  ;  }  else  if  (  wantedCount  <  actualCount  )  {  Location  firstUndesired  =  chunk  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  [ATTENTION]   reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^35^36^37^38^39^30^46^
[REPLACE]  }  else  if  (  wantedCount  <  actualCount  )  { 	[BUGGY]  if ( wantedCount > actualCount ) {[FE] NullPointerException assertContains(  "Wanted 1 time  " , e.getMessage())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [ATTENTION] }if ( wantedCount>actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^38^^^^^30^46^
[REPLACE]  Location  firstUndesired  =  chunk  .  get  (  wantedCount  )    .  getLocation  (  )  ; 	[BUGGY] Location firstUndesired = chunk . get ( actualCount ) . getLocation ( ) ; [FE]  IndexOutOfBoundsException Index: 2 , Size: 2 assertContains(  "Wanted 1 time  " , e.getMessage())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { [ATTENTION] Location firstUndesired = chunk . get ( actualCount )  . getLocation ( )  ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^39^^^^^30^46^
[REPLACE]  Location  lastInvocation  =  finder  .  getLastLocation  (  chunk  )  ; 	[BUGGY] Location lastInvocation = finder . InvocationsFinder ( )  ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { [ATTENTION] Location lastInvocation = finder . InvocationsFinder ( ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^36^^^^^30^46^
[REPLACE]  }  else  if  (  wantedCount  <  actualCount  )  { 	[BUGGY]  if ( wantedCount > =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; [ATTENTION] }if ( wantedCount> = actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^38^^^^^30^46^
[REPLACE]  Location  lastInvocation  =  finder  .  getLastLocation  (  chunk  )  ; 	[BUGGY] Location lastInvocation = finder . getLastLocation ( null ) ; [FE] NullPointerException assertContains(  "Wanted 4 times  " , e.getMessage())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { [ATTENTION] Location lastInvocation = finder . getLastLocation ( null )  ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^36^^^^^30^46^
[REPLACE]  for  (  Invocation  i  :  chunk  )  { 	[BUGGY] Location lastInvocation = finder . getLastLocation ( chunk ) ; [CE] class , interface , or enum expected  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } [ATTENTION] Location lastInvocation = finder . getLastLocation ( chunk )  ; i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^43^^^^^30^46^
[ADD]  for  (  Invocation  i  :  chunk  )  {  i  .  markVerifiedInOrder  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertFalse(invocation.isVerifiedInOrder())   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] NumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired lastInvocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findMatchingChunk ( invocations , wanted , wantedCount ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastInvocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ; } else if ( wantedCount < actualCount ) { Location firstUndesired = chunk . get ( wantedCount ) . getLocation ( ) ; reporter . tooManyActualInvocationsInOrder ( wantedCount , actualCount , wanted , firstUndesired ) ; } [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java^43^44^45^^^30^46^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter ; [CE] variable reporter might not have been initialized  [CONTEXT]    [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^17^^^^^^^
[REPLACE]  private  final  InvocationsFinder  finder  =  new  InvocationsFinder  (  )  ; 	[BUGGY] private final InvocationsFinder finder  = null ; [FE] [CONTEXT]    [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^18^^^^^^^
[REPLACE]  List<Invocation>  chunk  =  finder  .  findAllMatchingUnverifiedChunks  (  invocations,  wanted  )  ; 	[BUGGY] List<Invocation> chunk = finder . InvocationsFinder ( )  ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION] List<Invocation> chunk = finder . InvocationsFinder ( ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^21^^^^^20^33^
[ADD]  List<Invocation>  chunk  =  finder  .  findAllMatchingUnverifiedChunks  (  invocations,  wanted  )  ;  int  actualCount  =  chunk  .  size  (  )  ; 	[BUGGY] [CE] cannot find symbol actualCount  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION]   if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^21^22^23^^^20^33^
[REPLACE]  int  actualCount  =  chunk  .  size  (  )  ; 	[BUGGY] int actualCount = true . size ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  [ATTENTION] int actualCount = true . size ( )  ;  if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^23^^^^^20^33^
[REPLACE]  if  (  wantedCount  >  actualCount  )  { 	[BUGGY] if ( wantedCount < =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  int actualCount = chunk . size ( ) ;  [ATTENTION] if ( wantedCount< = actualCount ) { Location lastLocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^25^^^^^20^33^
[REPLACE]  Location  lastLocation  =  finder  .  getLastLocation  (  chunk  )  ; 	[BUGGY] Location lastLocation = finder . getLastLocation ( null ) ; [NO-ERROR]  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { [ATTENTION] Location lastLocation = finder . getLastLocation ( null )  ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^26^^^^^20^33^
[REPLACE]  Location  lastLocation  =  finder  .  getLastLocation  (  chunk  )  ; 	[BUGGY] Location lastLocation = finder . getLastLocation ( false ) ; [CE] method getLastLocation in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { [ATTENTION] Location lastLocation = finder . getLastLocation ( false )  ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^26^^^^^20^33^
[REPLACE]  for  (  Invocation  i  :  chunk  )  { 	[BUGGY] for ( Invocation i : chunk ) { i . markVerifiedInOrder ( ) ; [NO-ERROR]  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsInOrderChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  int actualCount = chunk . size ( ) ;  if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( chunk ) ; reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } [ATTENTION] for ( Invocation i : chunk ) { i . markVerifiedInOrder ( )  ; i . markVerifiedInOrder ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java^30^^^^^20^33^
[REPLACE]  super  (  wantedCount,  actualCount  )  ; 	[BUGGY] return   "*at least*   " + super . getPluralizedWantedCount ( ) ; [CE] constructor Discrepancy in class Discrepancy cannot be applied to given types ;  [METHOD]  <init> [TYPE] AtLeastDiscrepancy(int , int) [PARAMETER] int wantedCount int actualCount [CLASS] AtLeastDiscrepancy  [TYPE] boolean false true [TYPE] int actualCount wantedCount  [CONTEXT]  public AtLeastDiscrepancy ( int wantedCount , int actualCount ) { [ATTENTION] return   "*at least*   " + super . getPluralizedWantedCount ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java^12^^^^^11^13^
[REPLACE]  return    "*at  least*    "  +  super  .  getPluralizedWantedCount  (  )  ; 	[BUGGY] return   "*at least*   " + super . getPluralizedWantedCount ( )  ; [NO-ERROR]  [METHOD]  getPluralizedWantedCount [TYPE] String [PARAMETER] [CLASS] AtLeastDiscrepancy  [TYPE] boolean false true  [CONTEXT]  public String getPluralizedWantedCount ( ) { [ATTENTION] return   "*at least*   " + super . getPluralizedWantedCount ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java^17^^^^^16^18^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter  = null ; [NO-ERROR]  [CONTEXT]    [CLASS] AtLeastXNumberOfInvocationsChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^17^^^^^^^
[REPLACE]  private  final  InvocationsFinder  finder  =  new  InvocationsFinder  (  )  ; 	[BUGGY] private final InvocationsFinder finder  = null ; [FE] [CONTEXT]    [CLASS] AtLeastXNumberOfInvocationsChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^18^^^^^^^
[REPLACE]  List<Invocation>  actualInvocations  =  finder  .  findInvocations  (  invocations,  wanted  )  ; 	[BUGGY] List<Invocation> actualInvocations = finder . InvocationsFinder ( )  ; [CE] cannot find symbol  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION] List<Invocation> actualInvocations = finder . InvocationsFinder ( ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^21^^^^^20^32^
[REPLACE]  int  actualCount  =  actualInvocations  .  size  (  )  ; 	[BUGGY] int actualCount = null . size ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  [ATTENTION] int actualCount = null . size ( )  ; if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^23^^^^^20^32^
[ADD]  int  actualCount  =  actualInvocations  .  size  (  )  ; 	[BUGGY] [CE] cannot find symbol actualCount  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  [ATTENTION] if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^23^^^^^20^32^
[REPLACE]  if  (  wantedCount  >  actualCount  )  { 	[BUGGY] if ( wantedCount ! =  actualCount ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; [ATTENTION] if ( wantedCount! = actualCount ) { Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^24^^^^^20^32^
[REPLACE]  Location  lastLocation  =  finder  .  getLastLocation  (  actualInvocations  )  ; 	[BUGGY] Location lastLocation = finder . getLastLocation ( 0 ) ; [CE] method getLastLocation in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION] Location lastLocation = finder . getLastLocation ( 0 )  ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^25^^^^^20^32^
[REPLACE]  Location  lastLocation  =  finder  .  getLastLocation  (  actualInvocations  )  ; 	[BUGGY] Location lastLocation = finder . getLastLocation ( false ) ; [CE] method getLastLocation in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { [ATTENTION] Location lastLocation = finder . getLastLocation ( false )  ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } for ( Invocation i : actualInvocations ) { i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^25^^^^^20^32^
[REPLACE]  for  (  Invocation  i  :  actualInvocations  )  { 	[BUGGY] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ; [CE] class , interface , or enum expected  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] AtLeastXNumberOfInvocationsChecker  [TYPE] boolean false true [TYPE] Invocation i [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List actualInvocations invocations [TYPE] int actualCount wantedCount [TYPE] Location lastLocation  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted ) ;  int actualCount = actualInvocations . size ( ) ; if ( wantedCount > actualCount ) { Location lastLocation = finder . getLastLocation ( actualInvocations ) ; reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastLocation ) ; } [ATTENTION] List<Invocation> actualInvocations = finder . findInvocations ( invocations , wanted )  ; i . markVerified ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java^29^^^^^20^32^
[REPLACE]  private  final  InvocationsFinder  finder; 	[BUGGY] private InvocationsFinder finder ; [NO-ERROR]  [CONTEXT]    [CLASS] MissingInvocationInOrderChecker  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^18^^^^^^^
[REPLACE]  this  (  new  InvocationsFinder  (  )  ,  new  Reporter  (  )  )  ; 	[BUGGY] List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; [CE] cannot find symbol invocations  [METHOD]  <init> [TYPE] MissingInvocationInOrderChecker() [PARAMETER] [CLASS] MissingInvocationInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  public MissingInvocationInOrderChecker ( ) { [ATTENTION] List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^21^^^^^20^22^
[REPLACE]  this  .  finder  =  finder; 	[BUGGY] this . finder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { [ATTENTION] this . finder = null ; this . reporter = reporter ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^25^^^^^24^27^
[REPLACE]  this  .  reporter  =  reporter; 	[BUGGY] this . reporter =  null ; [FE] NullPointerException assertEquals(wanted , reporterStub.wanted)   [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] this . reporter = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^26^^^^^24^27^
[ADD]  this  .  reporter  =  reporter; 	[BUGGY] [CE] variable reporter might not have been initialized  [METHOD]  <init> [TYPE] Reporter) [PARAMETER] InvocationsFinder finder Reporter reporter [CLASS] MissingInvocationInOrderChecker  [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] boolean false true  [CONTEXT]  MissingInvocationInOrderChecker ( InvocationsFinder finder , Reporter reporter ) { this . finder = finder ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^26^^^^^24^27^
[REPLACE]  List<Invocation>  chunk  =  finder  .  findAllMatchingUnverifiedChunks  (  invocations,  wanted  )  ; 	[BUGGY] List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( 1 , wanted ) ; [CE] method findAllMatchingUnverifiedChunks in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { [ATTENTION] List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( 1 , wanted )  ;  if ( !chunk . isEmpty ( ) ) { return ; } Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; if ( previousInOrder = = null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^30^^^^^29^42^
[REPLACE]  if  (  !chunk  .  isEmpty  (  )  )  { 	[BUGGY] if ( chunk . isEmpty ( ) ) {[FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  [ATTENTION] if ( chunk . isEmpty ( ) ) { return ; } Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; if ( previousInOrder = = null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^32^^^^^29^42^
[ADD]  if  (  !chunk  .  isEmpty  (  )  )  {  return;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  [ATTENTION]   Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; if ( previousInOrder = = null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^32^33^34^^^29^42^
[REPLACE]  Invocation  previousInOrder  =  finder  .  findPreviousVerifiedInOrder  (  invocations  )  ; 	[BUGGY] Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( this ) ; [CE] method findPreviousVerifiedInOrder in class InvocationsFinder cannot be applied to given types ;  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  if ( !chunk . isEmpty ( ) ) { return ; } [ATTENTION] Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( this )  ; if ( previousInOrder = = null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^36^^^^^29^42^
[REPLACE]  if  (  previousInOrder  ==  null  )  { 	[BUGGY] if ( previousInOrder ! = false ) {[CE] incomparable types: Invocation and boolean  [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  if ( !chunk . isEmpty ( ) ) { return ; } Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; [ATTENTION] if ( previousInOrder ! = false ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^37^^^^^29^42^
[REPLACE]  reporter  .  wantedButNotInvokedInOrder  (  wanted,  previousInOrder  )  ; 	[BUGGY] reporter . wantedButNotInvoked ( wanted )  ; [FE]  AssertionFailedError  expected:<iMethods.simpleMethod()   [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  if ( !chunk . isEmpty ( ) ) { return ; } Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; if ( previousInOrder = = null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { [ATTENTION] reporter . wantedButNotInvoked ( wanted ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^40^^^^^29^42^
[REPLACE]  reporter  .  wantedButNotInvoked  (  wanted  )  ; 	[BUGGY] reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; [FE] AssertionFailedError [METHOD]  check [TYPE] void [PARAMETER] Invocation> invocations InvocationMatcher wanted VerificationMode mode [CLASS] MissingInvocationInOrderChecker  [TYPE] boolean false true [TYPE] Invocation previousInOrder [TYPE] InvocationsFinder finder [TYPE] Reporter reporter [TYPE] InvocationMatcher wanted [TYPE] List chunk invocations [TYPE] VerificationMode mode  [CONTEXT]  public void check ( List<Invocation> invocations , InvocationMatcher wanted , VerificationMode mode ) { List<Invocation> chunk = finder . findAllMatchingUnverifiedChunks ( invocations , wanted ) ;  if ( !chunk . isEmpty ( ) ) { return ; } Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ; if ( previousInOrder = = null ) { [ATTENTION] reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder )  ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java^38^^^^^29^42^
[REPLACE]  if  (  matchers  .  size  (  )  !=  arguments  .  length  )  { 	[BUGGY] if ( matchers . size ( ) + 4 ! = arguments . length ) {[FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , suspicious.length)   [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { [ATTENTION] if ( matchers . size ( ) + 4 ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^21^^^^^20^37^
[REPLACE]  return  new  Integer[0]; 	[BUGGY] return new Integer[2] ; [FE]  AssertionFailedError  expected:<0> but was:<2> assertEquals(0 , suspicious.length)   [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { [ATTENTION] return new Integer[2] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^22^^^^^20^37^
[REPLACE]  List<Integer>  suspicious  =  new  LinkedList<Integer>  (  )  ; 	[BUGGY] for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation[CE] ')' expected  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } [ATTENTION] for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^25^^^^^20^37^
[ADD]  List<Integer>  suspicious  =  new  LinkedList<Integer>  (  )  ; 	[BUGGY] [CE] cannot find symbol suspicious  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } [ATTENTION] int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^25^^^^^20^37^
[REPLACE]  int  i  =  0; 	[BUGGY] int i = 4 ; [FE]  4 assertEquals(0 , suspicious.length)   [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; [ATTENTION] int i = 4 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^26^^^^^20^37^
[REPLACE]  if  (  m  instanceof  ContainsExtraTypeInformation  &&  !safelyMatches  (  m,  arguments[i]  )  &&  toStringEquals  (  m,  arguments[i]  )  &&  !  (  (  ContainsExtraTypeInformation  )  m  )    .  typeMatches  (  arguments[i]  )  )  { 	[BUGGY] if ( ! m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) {[CE] bad operand type Matcher for unary operator '!'  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { [ATTENTION] if ( ! m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m )  . typeMatches ( arguments[i] ) ) {  suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^28^29^30^31^^20^37^
[ADD]  if  (  m  instanceof  ContainsExtraTypeInformation  &&  !safelyMatches  (  m,  arguments[i]  )  &&  toStringEquals  (  m,  arguments[i]  )  &&  !  (  (  ContainsExtraTypeInformation  )  m  )    .  typeMatches  (  arguments[i]  )  )  {  suspicious  .  add  (  i  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { [ATTENTION]   } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^28^29^30^31^32^20^37^
[REPLACE]  suspicious  .  add  (  i  )  ; 	[BUGGY] suspicious . toArray ( i ) ; [CE] no suitable method found for toArray(int)  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { [ATTENTION] suspicious . toArray ( i )  ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^32^^^^^20^37^
[REPLACE]  for  (  Matcher  m  :  matchers  )  { 	[BUGGY] for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation[CE] ')' expected  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; [ATTENTION] for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^27^^^^^20^37^
[ADD]  for  (  Matcher  m  :  matchers  )  {  if  (  m  instanceof  ContainsExtraTypeInformation  &&  !safelyMatches  (  m,  arguments[i]  )  &&  toStringEquals  (  m,  arguments[i]  ) 	[BUGGY] [CE] illegal start of expression  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; [ATTENTION]   && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } return suspicious . toArray ( new Integer[0] ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^27^28^29^30^^20^37^
[REPLACE]  return  suspicious  .  toArray  (  new  Integer[0]  )  ; 	[BUGGY] return true . add ( new Integer[0 - 1] ) ; [CE] boolean cannot be dereferenced  [METHOD]  getSuspiciouslyNotMatchingArgsIndexes [TYPE] Integer[] [PARAMETER] Matcher> matchers Object[] arguments [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] List matchers suspicious [TYPE] Object[] arguments [TYPE] int i  [CONTEXT]  public Integer[] getSuspiciouslyNotMatchingArgsIndexes ( List<Matcher> matchers , Object[] arguments ) { if ( matchers . size ( ) ! = arguments . length ) { return new Integer[0] ; } List<Integer> suspicious = new LinkedList<Integer> ( ) ; int i = 0 ; for ( Matcher m : matchers ) { if ( m instanceof ContainsExtraTypeInformation && !safelyMatches ( m , arguments[i] ) && toStringEquals ( m , arguments[i] ) && ! ( ( ContainsExtraTypeInformation ) m ) . typeMatches ( arguments[i] ) ) { suspicious . add ( i ) ; } i++ ; } [ATTENTION] return true . add ( new Integer[0 - 1] )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^36^^^^^20^37^
[ADD]  try  {  return  m  .  matches  (  arg  )  ;  }  catch  (  Throwable  t  )  {  return  false;  } 	[BUGGY] return m . matches ( arg ) ; return false ; [CE] unreachable statement  [METHOD]  safelyMatches [TYPE] boolean [PARAMETER] Matcher m Object arg [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] Throwable t [TYPE] Object arg  [CONTEXT]  private boolean safelyMatches ( Matcher m , Object arg ) { [ATTENTION] return m . matches ( arg )  ; return false ;   }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^40^41^42^43^44^39^45^
[REPLACE]  return  m  .  matches  (  arg  )  ; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  safelyMatches [TYPE] boolean [PARAMETER] Matcher m Object arg [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] Throwable t [TYPE] Object arg  [CONTEXT]  private boolean safelyMatches ( Matcher m , Object arg ) { try { [ATTENTION] return false ; } catch ( Throwable t ) { return false ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^41^^^^^39^45^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  safelyMatches [TYPE] boolean [PARAMETER] Matcher m Object arg [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] Throwable t [TYPE] Object arg  [CONTEXT]  private boolean safelyMatches ( Matcher m , Object arg ) { try { return m . matches ( arg ) ; } catch ( Throwable t ) { [ATTENTION] return true ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^43^^^^^39^45^
[REPLACE]  return  StringDescription  .  toString  (  m  )    .  equals  (  arg  ==  null?    "null  "  :  arg  .  toString  (  )  )  ; 	[BUGGY] return  m  . equals ( arg = = null?   "null  " : arg . [CE] <identifier> expected  [METHOD]  toStringEquals [TYPE] boolean [PARAMETER] Matcher m Object arg [CLASS] ArgumentMatchingTool  [TYPE] boolean false true [TYPE] Matcher m [TYPE] Object arg  [CONTEXT]  private boolean toStringEquals ( Matcher m , Object arg ) { [ATTENTION] return m . equals ( arg = = null?   "null  " : arg . }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java^48^^^^^47^49^
[REPLACE]  private  final  List<Invocation>  invocations  =  Collections  .  synchronizedList  (  new  LinkedList<Invocation>  (  )  )  ; 	[BUGGY] private final List<Invocation> invocations  = null ; [FE] [CONTEXT]    [CLASS] RegisteredInvocations RemoveToString  	None^18^^^^^^^
[REPLACE]  invocations  .  add  (  invocation  )  ; 	[BUGGY] invocations . add ( invocation )  ; [NO-ERROR]  [METHOD]  add [TYPE] void [PARAMETER] Invocation invocation [CLASS] RegisteredInvocations RemoveToString  [TYPE] Invocation invocation [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public void add ( Invocation invocation ) { [ATTENTION] invocations . add ( invocation ) ; }  	None^21^^^^^20^22^
[REPLACE]  invocations  .  remove  (  invocations  .  size  (  )  -1  )  ; 	[BUGGY] invocations . size ( invocations . length ( ) -0 ) ; [CE] cannot find symbol  [METHOD]  removeLast [TYPE] void [PARAMETER] [CLASS] RegisteredInvocations RemoveToString  [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public void removeLast ( ) { [ATTENTION] invocations . size ( invocations . length ( ) -0 )  ; }  	None^25^^^^^24^26^
[REMOVE]   	[BUGGY] invocations . add ( invocation ) ; [CE] cannot find symbol invocation  [METHOD]  removeLast [TYPE] void [PARAMETER] [CLASS] RegisteredInvocations RemoveToString  [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public void removeLast ( ) { [ATTENTION] invocations . remove ( invocations . size ( ) -1 ) ;   	None^25^^^^^24^26^
[REPLACE]  invocations  .  remove  (  invocations  .  size  (  )  -1  )  ; 	[BUGGY] invocations . remove ( invocations . add ( ) -1 ) ; [CE] no suitable method found for add()  [METHOD]  removeLast [TYPE] void [PARAMETER] [CLASS] RegisteredInvocations RemoveToString  [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public void removeLast ( ) { [ATTENTION] invocations . remove ( invocations . add ( ) -1 )  ; }  	None^25^^^^^24^26^
[ADD]  invocations  .  remove  (  invocations  .  size  (  )  -1  )  ; 	[BUGGY] [FE]   assertEquals(  "hello  " , result)   [METHOD]  removeLast [TYPE] void [PARAMETER] [CLASS] RegisteredInvocations RemoveToString  [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public void removeLast ( ) { [ATTENTION] }  	None^25^^^^^24^26^
[REPLACE]  return  ListUtil  .  filter  (  new  LinkedList<Invocation>  (  invocations  )  ,  new  RemoveToString  (  )  )  ; 	[BUGGY] return  new LinkedList<Invocation> ( invocations )  ) ; [CE] ' ; ' expected  [METHOD]  getAll [TYPE] List [PARAMETER] [CLASS] RegisteredInvocations RemoveToString  [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public List<Invocation> getAll ( ) { [ATTENTION] return new LinkedList<Invocation> ( invocations )  )  ; }  	None^29^^^^^28^30^
[REPLACE]  return  Invocation  .  isToString  (  invocation  )  ; 	[BUGGY] return  invocation  ; [CE] incompatible types  [METHOD]  isOut [TYPE] boolean [PARAMETER] Invocation invocation [CLASS] RegisteredInvocations RemoveToString  [TYPE] Invocation invocation [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public boolean isOut ( Invocation invocation ) { [ATTENTION] return invocation ; }  	None^34^^^^^33^35^
[REPLACE]  return  Invocation  .  isToString  (  invocation  )  ; 	[BUGGY] return  invocation  ; [CE] incompatible types  [METHOD]  isOut [TYPE] boolean [PARAMETER] Invocation invocation [CLASS] RemoveToString  [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  public boolean isOut ( Invocation invocation ) { [ATTENTION] return invocation ; }  	None^34^^^^^33^35^
[REPLACE]  final  int  wantedCount; 	[BUGGY] final long wantedCount ; [CE] method check in class AtLeastXNumberOfInvocationsChecker cannot be applied to given types ;  [CONTEXT]    [CLASS] AtLeast  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^22^^^^^^^
[REPLACE]  if  (  wantedNumberOfInvocations  <=  0  )  { 	[BUGGY] if ( wantedNumberOfInvocations > wantedCount ) {[CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] AtLeast(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] AtLeast  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtLeast ( int wantedNumberOfInvocations ) { [ATTENTION] if ( wantedNumberOfInvocations> wantedCount ) { throw new MockitoException (   "Negative value or zero are not allowed here  " ) ; } this . wantedCount = wantedNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^25^^^^^24^29^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] AtLeast(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] AtLeast  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtLeast ( int wantedNumberOfInvocations ) { if ( wantedNumberOfInvocations < = 0 ) { [ATTENTION] return ; } this . wantedCount = wantedNumberOfInvocations ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^26^^^^^24^29^
[REPLACE]  this  .  wantedCount  =  wantedNumberOfInvocations; 	[BUGGY] this . wantedCount =  wantedCount ; [CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] AtLeast(int) [PARAMETER] int wantedNumberOfInvocations [CLASS] AtLeast  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public AtLeast ( int wantedNumberOfInvocations ) { if ( wantedNumberOfInvocations < = 0 ) { throw new MockitoException (   "Negative value or zero are not allowed here  " ) ; } [ATTENTION] this . wantedCount = wantedCount ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^28^^^^^24^29^
[REPLACE]  MissingInvocationChecker  missingInvocation  =  new  MissingInvocationChecker  (  )  ; 	[BUGGY] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [CE] method check in class MissingInvocationInOrderChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { [ATTENTION] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( )  ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^32^^^^^31^39^
[REPLACE]  AtLeastXNumberOfInvocationsChecker  numberOfInvocations  =  new  AtLeastXNumberOfInvocationsChecker  (  )  ; 	[BUGGY] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [CE] variable missingInvocation is already defined in method verify(VerificationData)  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; [ATTENTION] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( )  ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^33^^^^^31^39^
[REPLACE]  if  (  wantedCount  ==  1  )  { 	[BUGGY] if ( wantedCount || 1 ) {[CE] bad operand types for binary operator '||'  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  [ATTENTION] if ( wantedCount||1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^35^^^^^31^39^
[ADD]  if  (  wantedCount  ==  1  )  {  missingInvocation  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  )  ;  } 	[BUGGY] missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; [NO-ERROR]  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  [ATTENTION] missingInvocation . check ( data . getAllInvocations ( )  , data . getWanted ( ) )  ;  numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^35^36^37^^^31^39^
[REPLACE]  missingInvocation  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  )  ; 	[BUGGY] missingInvocation . check ( data . getWanted ( )  , data . getWanted ( ) ) ; [CE] method check in class MissingInvocationChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { [ATTENTION] missingInvocation . check ( data . getWanted ( ) , data . getWanted ( ) )  ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^36^^^^^31^39^
[REMOVE]   	[BUGGY] InvocationMatcher wanted = data . getWanted ( ) ; [NO-ERROR]  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { [ATTENTION] missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ;  InvocationMatcher wanted = data . getWanted ( )  ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^36^^^^^31^39^
[REPLACE]  missingInvocation  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  )  ; 	[BUGGY] missingInvocation . check ( data . getAllInvocations ( ) , data . getAllInvocations ( ) ) ; [CE] method check in class MissingInvocationChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { [ATTENTION] missingInvocation . check ( data . getAllInvocations ( )  , data . getAllInvocations ( ) )  ; } numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^36^^^^^31^39^
[REPLACE]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] numberOfInvocations . check ( data . getAllInvocations ( ) , data . getAllInvocations ( ) , wantedCount ) ; [CE] method check in class AtLeastXNumberOfInvocationsChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } [ATTENTION] numberOfInvocations . check ( data . getAllInvocations ( )  , data . getAllInvocations ( )  , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^38^^^^^31^39^
[REMOVE]   	[BUGGY] InvocationMatcher wanted = data . getWanted ( ) ; [NO-ERROR]  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } [ATTENTION] numberOfInvocations . check ( data . getAllInvocations ( ) , data . getWanted ( ) , wantedCount ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^38^^^^^31^39^
[REPLACE]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] numberOfInvocations . check ( data . getWanted ( ) , data . getWanted ( ) , wantedCount ) ; [CE] method check in class AtLeastXNumberOfInvocationsChecker cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } [ATTENTION] numberOfInvocations . check ( data . getWanted ( )  , data . getWanted ( )  , wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^38^^^^^31^39^
[ADD]  numberOfInvocations  .  check  (  data  .  getAllInvocations  (  )  ,  data  .  getWanted  (  )  ,  wantedCount  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] MissingInvocationChecker missingInvocation [TYPE] boolean false true [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] AtLeastXNumberOfInvocationsChecker numberOfInvocations  [CONTEXT]  public void verify ( VerificationData data ) { MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( data . getAllInvocations ( ) , data . getWanted ( ) ) ; } [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^38^^^^^31^39^
[REPLACE]  List<Invocation>  allInvocations  =  data  .  getAllInvocations  (  )  ; 	[BUGGY] List<Invocation> allInvocations = data . getWanted ( ) ; [CE] incompatible types  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { [ATTENTION] List<Invocation> allInvocations = data . getWanted ( )  ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^42^^^^^41^53^
[REPLACE]  InvocationMatcher  wanted  =  data  .  getWanted  (  )  ; 	[BUGGY] InvocationMatcher wanted = data . getAllInvocations ( ) ; [CE] incompatible types  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; [ATTENTION] InvocationMatcher wanted = data . getAllInvocations ( )  ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^43^^^^^41^53^
[REPLACE]  MissingInvocationInOrderChecker  missingInvocation  =  new  MissingInvocationInOrderChecker  (  )  ; 	[BUGGY] MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( ) ; [CE] method check in class MissingInvocationChecker cannot be applied to given types ;  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  [ATTENTION] MissingInvocationChecker missingInvocation = new MissingInvocationChecker ( )  ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^45^^^^^41^53^
[REPLACE]  AtLeastXNumberOfInvocationsInOrderChecker  numberOfCalls  =  new  AtLeastXNumberOfInvocationsInOrderChecker  (  )  ; 	[BUGGY] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [CE] variable missingInvocation is already defined in method verifyInOrder(VerificationData)  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; [ATTENTION] MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( )  ;  if ( wantedCount = = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^46^^^^^41^53^
[REPLACE]  if  (  wantedCount  ==  1  )  { 	[BUGGY] if ( wantedCount ! =  1 ) {[FE]   assertContains(expected , e.getMessage())   [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  [ATTENTION] if ( wantedCount! = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^48^^^^^41^53^
[ADD]  if  (  wantedCount  ==  1  )  {  missingInvocation  .  check  (  allInvocations,  wanted,  this  )  ;  } 	[BUGGY] [FE]   assertContains(expected , e.getMessage())   [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  [ATTENTION]   numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^48^49^50^^^41^53^
[REPLACE]  missingInvocation  .  check  (  allInvocations,  wanted,  this  )  ; 	[BUGGY] missingInvocation . check ( )  ; [CE] method check in class MissingInvocationInOrderChecker cannot be applied to given types ;  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  if ( wantedCount = = 1 ) { [ATTENTION] missingInvocation . check ( ) ; } numberOfCalls . check ( allInvocations , wanted , wantedCount ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^49^^^^^41^53^
[REPLACE]  numberOfCalls  .  check  (  allInvocations,  wanted,  wantedCount  )  ; 	[BUGGY] numberOfCalls . check ( )  ; [CE] method check in class AtLeastXNumberOfInvocationsInOrderChecker cannot be applied to given types ;  [METHOD]  verifyInOrder [TYPE] void [PARAMETER] VerificationData data [CLASS] AtLeast  [TYPE] boolean false true [TYPE] InvocationMatcher wanted [TYPE] List allInvocations [TYPE] AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] VerificationData data [TYPE] MissingInvocationInOrderChecker missingInvocation  [CONTEXT]  public void verifyInOrder ( VerificationData data ) { List<Invocation> allInvocations = data . getAllInvocations ( ) ; InvocationMatcher wanted = data . getWanted ( ) ;  MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker ( ) ; AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker ( ) ;  if ( wantedCount = = 1 ) { missingInvocation . check ( allInvocations , wanted , this ) ; } [ATTENTION] numberOfCalls . check ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^52^^^^^41^53^
[REPLACE]  return    "Wanted  invocations  count:  at  least    "  +  wantedCount; 	[BUGGY] return   "Wanted invocations count: at least   " +this ; [NO-ERROR]  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] AtLeast  [TYPE] int wantedCount wantedNumberOfInvocations [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "Wanted invocations count: at least   " +this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/AtLeast.java^57^^^^^56^58^
[REPLACE]  this  .  mode  =  mode; 	[BUGGY] this . mode =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] List) [PARAMETER] VerificationInOrderMode mode Object> mocksToBeVerifiedInOrder [CLASS] InOrderWrapper  [TYPE] List mocksToBeVerifiedInOrder [TYPE] VerificationInOrderMode mode [TYPE] boolean false true  [CONTEXT]  public InOrderWrapper ( VerificationInOrderMode mode , List<Object> mocksToBeVerifiedInOrder ) { [ATTENTION] this . mode = null ; this . mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^21^^^^^20^23^
[ADD]  this  .  mode  =  mode;  this  .  mocksToBeVerifiedInOrder  =  mocksToBeVerifiedInOrder; 	[BUGGY] [CE] variable mode might not have been initialized  [METHOD]  <init> [TYPE] List) [PARAMETER] VerificationInOrderMode mode Object> mocksToBeVerifiedInOrder [CLASS] InOrderWrapper  [TYPE] List mocksToBeVerifiedInOrder [TYPE] VerificationInOrderMode mode [TYPE] boolean false true  [CONTEXT]  public InOrderWrapper ( VerificationInOrderMode mode , List<Object> mocksToBeVerifiedInOrder ) { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^21^22^^^^20^23^
[REPLACE]  this  .  mocksToBeVerifiedInOrder  =  mocksToBeVerifiedInOrder; 	[BUGGY] this . mocksToBeVerifiedInOrder =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] List) [PARAMETER] VerificationInOrderMode mode Object> mocksToBeVerifiedInOrder [CLASS] InOrderWrapper  [TYPE] List mocksToBeVerifiedInOrder [TYPE] VerificationInOrderMode mode [TYPE] boolean false true  [CONTEXT]  public InOrderWrapper ( VerificationInOrderMode mode , List<Object> mocksToBeVerifiedInOrder ) { this . mode = mode ; [ATTENTION] this . mocksToBeVerifiedInOrder = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^22^^^^^20^23^
[REPLACE]  List<Invocation>  allInvocations  =  new  AllInvocationsFinder  (  )    .  getAllInvocations  (  mocksToBeVerifiedInOrder  )  ; 	[BUGGY] List<Invocation> allInvocations = new AllInvocationsFinder ( )  . AllInvocationsFinder ( )  ; [CE] cannot find symbol  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] InOrderWrapper  [TYPE] List allInvocations mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] VerificationInOrderMode mode [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { [ATTENTION] List<Invocation> allInvocations = new AllInvocationsFinder ( ) . AllInvocationsFinder ( ) ; mode . verifyInOrder ( new VerificationDataImpl ( allInvocations , data . getWanted ( ) ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^26^^^^^25^28^
[REPLACE]  mode  .  verifyInOrder  (  new  VerificationDataImpl  (  allInvocations,  data  .  getWanted  (  )  )  )  ; 	[BUGGY] mode . verifyInOrder ( new VerificationDataImpl ( 1 , data . getWanted ( ) ) ) ; [CE] constructor VerificationDataImpl in class VerificationDataImpl cannot be applied to given types ;  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] InOrderWrapper  [TYPE] List allInvocations mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] VerificationInOrderMode mode [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> allInvocations = new AllInvocationsFinder ( ) . getAllInvocations ( mocksToBeVerifiedInOrder ) ; [ATTENTION] mode . verifyInOrder ( new VerificationDataImpl ( 1 , data . getWanted ( ) ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^27^^^^^25^28^
[ADD]  mode  .  verifyInOrder  (  new  VerificationDataImpl  (  allInvocations,  data  .  getWanted  (  )  )  )  ;  } 	[BUGGY] [CE] reached end of file while parsing  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] InOrderWrapper  [TYPE] List allInvocations mocksToBeVerifiedInOrder [TYPE] boolean false true [TYPE] VerificationInOrderMode mode [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { List<Invocation> allInvocations = new AllInvocationsFinder ( ) . getAllInvocations ( mocksToBeVerifiedInOrder ) ; [ATTENTION]   	./Perturbation-Mockito-38/src/org/mockito/internal/verification/InOrderWrapper.java^27^28^^^^25^28^
[REPLACE]  if  (  unverified  !=  null  )  { 	[BUGGY] if ( unverified = = this ) {[CE] incomparable types: Invocation and NoMoreInteractions  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] NoMoreInteractions  [TYPE] boolean false true [TYPE] Invocation unverified [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { Invocation unverified = new InvocationsFinder ( ) . findFirstUnverified ( data . getAllInvocations ( ) ) ;  [ATTENTION] if ( unverified = = this ) { new Reporter ( ) . noMoreInteractionsWanted ( unverified ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/NoMoreInteractions.java^18^^^^^15^21^
[ADD]  if  (  unverified  !=  null  )  {  new  Reporter  (  )    .  noMoreInteractionsWanted  (  unverified  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] NoMoreInteractions  [TYPE] boolean false true [TYPE] Invocation unverified [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { Invocation unverified = new InvocationsFinder ( ) . findFirstUnverified ( data . getAllInvocations ( ) ) ;  [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/NoMoreInteractions.java^18^19^20^^^15^21^
[REPLACE]  new  Reporter  (  )    .  noMoreInteractionsWanted  (  unverified  )  ; 	[BUGGY] new Reporter ( )  . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  verify [TYPE] void [PARAMETER] VerificationData data [CLASS] NoMoreInteractions  [TYPE] boolean false true [TYPE] Invocation unverified [TYPE] VerificationData data  [CONTEXT]  public void verify ( VerificationData data ) { Invocation unverified = new InvocationsFinder ( ) . findFirstUnverified ( data . getAllInvocations ( ) ) ;  if ( unverified ! = null ) { [ATTENTION] new Reporter ( ) . Reporter ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/verification/NoMoreInteractions.java^19^^^^^15^21^
[REPLACE]  private  final  T  object; 	[BUGGY] private T object ; [NO-ERROR]  [CONTEXT]    [CLASS] Localized  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^10^^^^^^^
[REPLACE]  private  final  Location  location; 	[BUGGY] private Location location ; [NO-ERROR]  [CONTEXT]    [CLASS] Localized  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^11^^^^^^^
[REPLACE]  this  .  object  =  object; 	[BUGGY] this . object =  null ; [FE]  expected same:<Wanted invocations count: 19> was not:<null> assertNull(mockingProgress.pullVerificationMode())   [METHOD]  <init> [TYPE] Localized(T) [PARAMETER] T object [CLASS] Localized  [TYPE] T object [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public Localized ( T object ) { [ATTENTION] this . object = null ; location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^14^^^^^13^16^
[ADD]  this  .  object  =  object;  location  =  new  Location  (  )  ; 	[BUGGY] [CE] variable object might not have been initialized  [METHOD]  <init> [TYPE] Localized(T) [PARAMETER] T object [CLASS] Localized  [TYPE] T object [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public Localized ( T object ) { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^14^15^^^^13^16^
[REPLACE]  location  =  new  Location  (  )  ; 	[BUGGY] location  = null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Localized(T) [PARAMETER] T object [CLASS] Localized  [TYPE] T object [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public Localized ( T object ) { this . object = object ; [ATTENTION] location = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^15^^^^^13^16^
[REPLACE]  return  object; 	[BUGGY] return location ; [CE] incompatible types  [METHOD]  getObject [TYPE] T [PARAMETER] [CLASS] Localized  [TYPE] T object [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public T getObject ( ) { [ATTENTION] return location ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^19^^^^^18^20^
[REPLACE]  return  location; 	[BUGGY] return object ; [CE] incompatible types  [METHOD]  getLocation [TYPE] Location [PARAMETER] [CLASS] Localized  [TYPE] T object [TYPE] Location location [TYPE] boolean false true  [CONTEXT]  public Location getLocation ( ) { [ATTENTION] return object ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Localized.java^23^^^^^22^24^
[REPLACE]  this  .  unusedStubs  =  new  LinkedList<Invocation>  (  unusedStubs  )  ; 	[BUGGY] this . unusedStubs =  new InvocationMatcher> ( unstubbedInvocations )  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation> unusedStubs InvocationMatcher> unstubbedInvocations [CLASS] WarningsPrinter  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true  [CONTEXT]  public WarningsPrinter ( List<Invocation> unusedStubs , List<InvocationMatcher> unstubbedInvocations ) { [ATTENTION] this . unusedStubs = new InvocationMatcher> ( unstubbedInvocations ) ; this . unstubbedInvocations = new LinkedList<InvocationMatcher> ( unstubbedInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^23^^^^^22^25^
[REPLACE]  this  .  unstubbedInvocations  =  new  LinkedList<InvocationMatcher>  (  unstubbedInvocations  )  ; 	[BUGGY] this . unstubbedInvocations =  new LinkedList<InvocationMatcher> ( 1 ) ; [CE] no suitable constructor found for LinkedList(int)  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation> unusedStubs InvocationMatcher> unstubbedInvocations [CLASS] WarningsPrinter  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true  [CONTEXT]  public WarningsPrinter ( List<Invocation> unusedStubs , List<InvocationMatcher> unstubbedInvocations ) { this . unusedStubs = new LinkedList<Invocation> ( unusedStubs ) ; [ATTENTION] this . unstubbedInvocations = new LinkedList<InvocationMatcher> ( 1 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^24^^^^^22^25^
[REPLACE]  Iterator<Invocation>  unusedIterator  =  unusedStubs  .  iterator  (  )  ; 	[BUGGY] Invocation unused = unusedIterator . next ( ) ; [CE] cannot find symbol unusedIterator  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { [ATTENTION] Invocation unused = unusedIterator . next ( )  ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^28^^^^^27^49^
[REPLACE]  while  (  unusedIterator  .  hasNext  (  )  )  { 	[BUGGY] while ( unusedIterator . next ( )  ) {[CE] incompatible types  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; [ATTENTION] while ( unusedIterator . next ( )  ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^29^^^^^27^49^
[REPLACE]  while  (  unstubbedIterator  .  hasNext  (  )  )  { 	[BUGGY] while ( unstubbedIterator . next ( ) ) {[CE] incompatible types  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; [ATTENTION] while ( unstubbedIterator . next ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^32^^^^^27^49^
[REPLACE]  if  (  unstubbed  .  hasSimilarMethod  (  unused  )  )  { 	[BUGGY] if ( ! unstubbed . hasSimilarMethod ( unused ) ) {[FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION] if ( ! unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^34^^^^^27^49^
[REPLACE]  unusedIterator  .  remove  (  )  ; 	[BUGGY] unusedIterator . next ( ) ; [FE] NullPointerException assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; [ATTENTION] unusedIterator . next ( )  ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^36^^^^^27^49^
[REPLACE]  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] unstubbedIterator . next ( ) ; [FE] NullPointerException assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; [ATTENTION] unstubbedIterator . next ( )  ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^37^^^^^27^49^
[REPLACE]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] InvocationMatcher unstubbed = null . next ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] InvocationMatcher unstubbed = null . next ( )  ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^33^^^^^27^49^
[ADD]  if  (  unstubbed  .  hasSimilarMethod  (  unused  )  )  {  logger  .  log  (  stubbedMethodCalledWithDifferentArguments  (  unused,  unstubbed  )  )  ;  unusedIterator  .  remove  (  )  ;  unstubbedIterator  .  remove  (  )  ;  } 	[BUGGY] [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION]   } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^34^35^36^37^38^27^49^
[REPLACE]  unusedIterator  .  remove  (  )  ; 	[BUGGY] unusedIterator . next ( )  ; [FE] NullPointerException assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; [ATTENTION] unusedIterator . next ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^36^^^^^27^49^
[ADD]  unusedIterator  .  remove  (  )  ;  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] unstubbedIterator . remove ( ) ; [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; [ATTENTION] unstubbedIterator . remove ( )  ;  } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^36^37^^^^27^49^
[ADD]  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; [ATTENTION] } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^37^^^^^27^49^
[REPLACE]  Invocation  unused  =  unusedIterator  .  next  (  )  ; 	[BUGGY] Invocation unused = null . next ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { [ATTENTION] Invocation unused = null . next ( )  ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^30^^^^^27^49^
[REPLACE]  Iterator<InvocationMatcher>  unstubbedIterator  =  unstubbedInvocations  .  iterator  (  )  ; 	[BUGGY] Invocation unused = unusedIterator . next ( ) ; [CE] variable unused is already defined in method print(MockitoLogger)  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; [ATTENTION] Invocation unused = unusedIterator . next ( )  ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^31^^^^^27^49^
[ADD]  Iterator<InvocationMatcher>  unstubbedIterator  =  unstubbedInvocations  .  iterator  (  )  ; 	[BUGGY] [CE] cannot find symbol unstubbedIterator  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; [ATTENTION] while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^31^^^^^27^49^
[REPLACE]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] InvocationMatcher unstubbed = unstubbedIterator . hasNext ( ) ; [CE] incompatible types  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] InvocationMatcher unstubbed = unstubbedIterator . hasNext ( )  ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^33^^^^^27^49^
[ADD]  if  (  unstubbed  .  hasSimilarMethod  (  unused  )  )  {  logger  .  log  (  stubbedMethodCalledWithDifferentArguments  (  unused,  unstubbed  )  )  ;  unusedIterator  .  remove  (  )  ;  unstubbedIterator  .  remove  (  )  ;  } 	[BUGGY] logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; [NO-ERROR]  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION] logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) )  ; unusedIterator . remove ( )  ; unstubbedIterator . remove ( )  ;   } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^34^35^36^37^38^27^49^
[ADD]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol unstubbed  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^33^^^^^27^49^
[ADD]  unusedIterator  .  remove  (  )  ;  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; [ATTENTION]  } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^36^37^^^^27^49^
[REPLACE]  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] unstubbedIterator . next ( )  ; [FE] NullPointerException assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; [ATTENTION] unstubbedIterator . next ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^37^^^^^27^49^
[REMOVE]   	[BUGGY] unstubbed . getInvocation ( ) . getLocation ( ) ,   "  " ) ; [CE]  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; [ATTENTION] unstubbedIterator . remove ( ) ;  unstubbed . getInvocation ( )  . getLocation ( )  ,   "  " )  ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^37^^^^^27^49^
[REPLACE]  Invocation  unused  =  unusedIterator  .  next  (  )  ; 	[BUGGY] Invocation unused = false . next ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { [ATTENTION] Invocation unused = false . next ( )  ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^30^^^^^27^49^
[REPLACE]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] InvocationMatcher unstubbed = this . hasNext ( ) ; [CE] cannot find symbol  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] InvocationMatcher unstubbed = this . hasNext ( )  ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^33^^^^^27^49^
[REPLACE]  for  (  Invocation  i  :  unusedStubs  )  { 	[BUGGY] Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; [CE] illegal start of type  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } [ATTENTION] Iterator<Invocation> unusedIterator = unusedStubs . iterator ( )  ; logger . log ( thisStubWasNotUsed ( i ) ) ; } for ( InvocationMatcher i1 : unstubbedInvocations ) { logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^42^^^^^27^49^
[REPLACE]  for  (  InvocationMatcher  i1  :  unstubbedInvocations  )  { 	[BUGGY] Invocation unused = unusedIterator . next ( ) ; [CE] class , interface , or enum expected  [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } [ATTENTION] Invocation unused = unusedIterator . next ( )  ; logger . log ( thisMethodWasNotStubbed ( i1 ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^46^^^^^27^49^
[ADD]  for  (  InvocationMatcher  i1  :  unstubbedInvocations  )  {  logger  .  log  (  thisMethodWasNotStubbed  (  i1  )  )  ;  } 	[BUGGY] [FE]   assertContains(  "was not stubbed  " , logger.getLoggedInfo())   [METHOD]  print [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] WarningsPrinter  [TYPE] Iterator unstubbedIterator unusedIterator [TYPE] InvocationMatcher i1 unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation i unused [TYPE] MockitoLogger logger  [CONTEXT]  public void print ( MockitoLogger logger ) { Iterator<Invocation> unusedIterator = unusedStubs . iterator ( ) ; while ( unusedIterator . hasNext ( ) ) { Invocation unused = unusedIterator . next ( ) ; Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . hasSimilarMethod ( unused ) ) { logger . log ( stubbedMethodCalledWithDifferentArguments ( unused , unstubbed ) ) ; unusedIterator . remove ( ) ; unstubbedIterator . remove ( ) ; } } } for ( Invocation i : unusedStubs ) { logger . log ( thisStubWasNotUsed ( i ) ) ; } [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^46^47^48^^^27^49^
[REPLACE]  return  join  (    "[Mockito]  Warning  -  this  stub  was  not  used:  ",  i,  i  .  getLocation  (  )  , 	[BUGGY] return join (   "[Mockito] Warning - null stub was not used:  " , i , i . getLocation ( ) , [FE] AssertionFailedError [METHOD]  thisStubWasNotUsed [TYPE] String [PARAMETER] Invocation i [CLASS] WarningsPrinter  [TYPE] Invocation i [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true  [CONTEXT]  private String thisStubWasNotUsed ( Invocation i ) { [ATTENTION] return join (   "[Mockito] Warning - null stub was not used:  " , i , i . getLocation ( )  ,     "  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^52^53^54^55^^51^57^
[REPLACE]  return  join  (    "[Mockito]  Warning  -  this  method  was  not  stubbed:  ",  i,  i  .  getInvocation  (  )    .  getLocation  (  )  , 	[BUGGY] return join (   "[Mockito] Warning - null method was not stubbed:  " , i , i . getInvocation ( ) . getLocation ( ) , [FE] AssertionFailedError [METHOD]  thisMethodWasNotStubbed [TYPE] String [PARAMETER] InvocationMatcher i [CLASS] WarningsPrinter  [TYPE] InvocationMatcher i [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true  [CONTEXT]  private String thisMethodWasNotStubbed ( InvocationMatcher i ) { [ATTENTION] return join (   "[Mockito] Warning - null method was not stubbed:  " , i , i . getInvocation ( )  . getLocation ( )  ,     "  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^60^61^62^63^^59^65^
[REPLACE]  return  join  (    "[Mockito]  Warning  -  stubbed  method  called  with  different  arguments  .    ",    "Stubbed  this  way:  ",  unused, 	[BUGGY] return join (   "[Mockito] Warning - stubbed method called with different arguments .   " ,   "Stubbed null way:  " , unused , [FE]   assertContains(  "Stubbed this way  " , logger.getLoggedInfo())   [METHOD]  stubbedMethodCalledWithDifferentArguments [TYPE] String [PARAMETER] Invocation unused InvocationMatcher unstubbed [CLASS] WarningsPrinter  [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean false true [TYPE] Invocation unused  [CONTEXT]  private String stubbedMethodCalledWithDifferentArguments ( Invocation unused , InvocationMatcher unstubbed ) { [ATTENTION] return join (   "[Mockito] Warning - stubbed method called with different arguments .   " ,   "Stubbed null way:  " , unused ,   unused . getLocation ( ) ,   "  " ,   "But called with different arguments:  " , unstubbed , unstubbed . getInvocation ( ) . getLocation ( ) ,   "  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/WarningsPrinter.java^68^69^70^71^^67^78^
[REPLACE]  private  final  StackTraceElement  firstTraceElement; 	[BUGGY] private StackTraceElement firstTraceElement ; [NO-ERROR]  [CONTEXT]    [CLASS] Location  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^11^^^^^^^
[REPLACE]  StackTraceElement[]  stackTrace  =  Thread  .  currentThread  (  )    .  getStackTrace  (  )  ; 	[BUGGY] StackTraceElement[] stackTrace = Thread . getStackTrace ( )  . getStackTrace ( ) ; [CE] non-static method getStackTrace() cannot be referenced from a static context  [METHOD]  <init> [TYPE] Location() [PARAMETER] [CLASS] Location  [TYPE] StackTraceElement firstTraceElement [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] StackTraceElement[] stackTrace  [CONTEXT]  public Location ( ) { [ATTENTION] StackTraceElement[] stackTrace = Thread . getStackTrace ( ) . getStackTrace ( )  ; StackTraceFilter filter = new StackTraceFilter ( ) ; this . firstTraceElement = filter . filter ( stackTrace , false ) [0] ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^14^^^^^13^17^
[REPLACE]  StackTraceFilter  filter  =  new  StackTraceFilter  (  )  ; 	[BUGGY] StackTraceElement[] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; [CE] variable stackTrace is already defined in constructor Location()  [METHOD]  <init> [TYPE] Location() [PARAMETER] [CLASS] Location  [TYPE] StackTraceElement firstTraceElement [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] StackTraceElement[] stackTrace  [CONTEXT]  public Location ( ) { StackTraceElement[] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; [ATTENTION] StackTraceElement[] stackTrace = Thread . currentThread ( )  . getStackTrace ( )  ; this . firstTraceElement = filter . filter ( stackTrace , false ) [0] ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^15^^^^^13^17^
[ADD]  StackTraceFilter  filter  =  new  StackTraceFilter  (  )  ; 	[BUGGY] [CE] cannot find symbol filter  [METHOD]  <init> [TYPE] Location() [PARAMETER] [CLASS] Location  [TYPE] StackTraceElement firstTraceElement [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] StackTraceElement[] stackTrace  [CONTEXT]  public Location ( ) { StackTraceElement[] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; [ATTENTION] this . firstTraceElement = filter . filter ( stackTrace , false ) [0] ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^15^^^^^13^17^
[REPLACE]  this  .  firstTraceElement  =  filter  .  filter  (  stackTrace,  false  )  [0]; 	[BUGGY] this . firstTraceElement = filter . filter ( stackTrace , true ) [0] ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Location() [PARAMETER] [CLASS] Location  [TYPE] StackTraceElement firstTraceElement [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] StackTraceElement[] stackTrace  [CONTEXT]  public Location ( ) { StackTraceElement[] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; StackTraceFilter filter = new StackTraceFilter ( ) ; [ATTENTION] this . firstTraceElement = filter . filter ( stackTrace , true ) [0] ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^16^^^^^13^17^
[REPLACE]  return    "->  at    "  +  this  .  firstTraceElement  .  toString  (  )  ; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Location  [TYPE] StackTraceElement firstTraceElement [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/Location.java^21^^^^^20^22^
[REPLACE]  private  final  List<Invocation>  unusedStubs  =  new  LinkedList<Invocation>  (  )  ; 	[BUGGY] private List<Invocation> unusedStubs = new LinkedList<Invocation> ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] DebuggingInfo  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^17^^^^^^^
[REPLACE]  private  final  List<InvocationMatcher>  unstubbedInvocations  =  new  LinkedList<InvocationMatcher>  (  )  ; 	[BUGGY] private final List<InvocationMatcher> unstubbedInvocations ; [CE] variable unstubbedInvocations might not have been initialized  [CONTEXT]    [CLASS] DebuggingInfo  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^18^^^^^^^
[REPLACE]  if  (  !collectingData  )  { 	[BUGGY] if ( collectingData ) {[FE] NullPointerException assertFalse(progress.getDebuggingInfo().hasData())   [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { [ATTENTION] if ( collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^23^^^^^22^36^
[REPLACE]  return; 	[BUGGY] return !unusedStubs . isEmpty ( ) || !unstubbedInvocations . isEmpty ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { [ATTENTION] return !unusedStubs . isEmpty ( ) || !unstubbedInvocations . isEmpty ( )  ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^24^^^^^22^36^
[REPLACE]  Iterator<InvocationMatcher>  unstubbedIterator  =  unstubbedInvocations  .  iterator  (  )  ; 	[BUGGY] Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . clear ( ) ; [CE] incompatible types  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } [ATTENTION] Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . clear ( )  ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^27^^^^^22^36^
[ADD]  Iterator<InvocationMatcher>  unstubbedIterator  =  unstubbedInvocations  .  iterator  (  )  ; 	[BUGGY] [CE] cannot find symbol unstubbedIterator  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } [ATTENTION] while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^27^^^^^22^36^
[REPLACE]  if  (  unstubbed  .  getInvocation  (  )    .  equals  (  invocation  )  )  { 	[BUGGY] if ( unstubbed . matches ( invocation )  . equals ( invocation ) ) {[CE] boolean cannot be dereferenced  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION] if ( unstubbed . matches ( invocation ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^30^^^^^22^36^
[ADD]  if  (  unstubbed  .  getInvocation  (  )    .  equals  (  invocation  )  )  {  unstubbedIterator  .  remove  (  )  ;  } 	[BUGGY] unstubbedIterator . remove ( ) ; [NO-ERROR]  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION] unstubbedIterator . remove ( )  ;  } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^30^31^32^^^22^36^
[REPLACE]  unstubbedIterator  .  remove  (  )  ; 	[BUGGY] unstubbedIterator . next ( ) ; [FE] AssertionFailedError [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { [ATTENTION] unstubbedIterator . next ( )  ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^31^^^^^22^36^
[REPLACE]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] InvocationMatcher unstubbed = null . next ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] InvocationMatcher unstubbed = null . next ( )  ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^29^^^^^22^36^
[ADD]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol unstubbed  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^29^^^^^22^36^
[REPLACE]  if  (  unstubbed  .  getInvocation  (  )    .  equals  (  invocation  )  )  { 	[BUGGY] if ( !collectingData ) {[FE] AssertionFailedError [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [ATTENTION] if ( !collectingData ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^30^^^^^22^36^
[REPLACE]  InvocationMatcher  unstubbed  =  unstubbedIterator  .  next  (  )  ; 	[BUGGY] InvocationMatcher unstubbed = this . hasNext ( ) ; [CE] cannot find symbol  [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { [ATTENTION] InvocationMatcher unstubbed = this . hasNext ( )  ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } unusedStubs . add ( invocation ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^29^^^^^22^36^
[REPLACE]  unusedStubs  .  add  (  invocation  )  ; 	[BUGGY] unusedStubs . iterator ( )  ; [FE] AssertionFailedError [METHOD]  addStubbedInvocation [TYPE] void [PARAMETER] Invocation invocation [CLASS] DebuggingInfo  [TYPE] Iterator unstubbedIterator [TYPE] InvocationMatcher unstubbed [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void addStubbedInvocation ( Invocation invocation ) { if ( !collectingData ) { return ; } Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations . iterator ( ) ; while ( unstubbedIterator . hasNext ( ) ) { InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; if ( unstubbed . getInvocation ( ) . equals ( invocation ) ) { unstubbedIterator . remove ( ) ; } } [ATTENTION] unusedStubs . iterator ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^35^^^^^22^36^
[REPLACE]  if  (  !collectingData  )  { 	[BUGGY] if ( collectingData ) {[FE] NullPointerException assertFalse(progress.getDebuggingInfo().hasData())   [METHOD]  addPotentiallyUnstubbed [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { [ATTENTION] if ( collectingData ) { return ; } unstubbedInvocations . add ( invocationMatcher ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^39^^^^^38^43^
[ADD]  if  (  !collectingData  )  {  return;  } 	[BUGGY] return ; [CE] unreachable statement  [METHOD]  addPotentiallyUnstubbed [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { [ATTENTION] return ;  unstubbedInvocations . add ( invocationMatcher ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^39^40^41^^^38^43^
[REPLACE]  return; 	[BUGGY] return !unusedStubs . isEmpty ( ) || !unstubbedInvocations . isEmpty ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  addPotentiallyUnstubbed [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( !collectingData ) { [ATTENTION] return !unusedStubs . isEmpty ( ) || !unstubbedInvocations . isEmpty ( )  ; } unstubbedInvocations . add ( invocationMatcher ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^40^^^^^38^43^
[REPLACE]  unstubbedInvocations  .  add  (  invocationMatcher  )  ; 	[BUGGY] if ( invocationMatcher . matches ( invocation ) ) { i . remove ( ) ; [CE] illegal start of expression  [METHOD]  addPotentiallyUnstubbed [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( !collectingData ) { return ; } [ATTENTION] if ( invocationMatcher . matches ( invocation ) ) { i . remove ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^42^^^^^38^43^
[REPLACE]  Iterator<Invocation>  i  =  unusedStubs  .  iterator  (  )  ; 	[BUGGY] Iterator<Invocation> i = unusedStubs . clear ( ) ; [CE] incompatible types  [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { [ATTENTION] Iterator<Invocation> i = unusedStubs . clear ( )  ; while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; if ( invocationMatcher . matches ( invocation ) ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^46^^^^^45^53^
[ADD]  Iterator<Invocation>  i  =  unusedStubs  .  iterator  (  )  ; 	[BUGGY] [CE] cannot find symbol i  [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { [ATTENTION] while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; if ( invocationMatcher . matches ( invocation ) ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^46^^^^^45^53^
[REPLACE]  while  (  i  .  hasNext  (  )  )  { 	[BUGGY] while ( i . next ( ) ) {[CE] incompatible types  [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; [ATTENTION] while ( i . next ( ) ) { Invocation invocation = i . next ( ) ; if ( invocationMatcher . matches ( invocation ) ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^47^^^^^45^53^
[REPLACE]  if  (  invocationMatcher  .  matches  (  invocation  )  )  { 	[BUGGY] if ( !collectingData ) {[FE] AssertionFailedError [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; [ATTENTION] if ( !collectingData ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^49^^^^^45^53^
[REPLACE]  i  .  remove  (  )  ; 	[BUGGY] i . next ( ) ; [FE] AssertionFailedError [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; if ( invocationMatcher . matches ( invocation ) ) { [ATTENTION] i . next ( )  ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^50^^^^^45^53^
[ADD]  i  .  remove  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; if ( invocationMatcher . matches ( invocation ) ) { [ATTENTION] } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^50^^^^^45^53^
[REPLACE]  Invocation  invocation  =  i  .  next  (  )  ; 	[BUGGY] Invocation invocation = i . hasNext ( ) ; [CE] incompatible types  [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; while ( i . hasNext ( ) ) { [ATTENTION] Invocation invocation = i . hasNext ( )  ; if ( invocationMatcher . matches ( invocation ) ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^48^^^^^45^53^
[REPLACE]  if  (  invocationMatcher  .  matches  (  invocation  )  )  { 	[BUGGY] if ( nullnvocationMatcher . matches ( invocation ) ) {[CE] cannot find symbol nullnvocationMatcher  [METHOD]  reportUsedStub [TYPE] void [PARAMETER] InvocationMatcher invocationMatcher [CLASS] DebuggingInfo  [TYPE] Iterator i [TYPE] InvocationMatcher invocationMatcher [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] Invocation invocation  [CONTEXT]  public void reportUsedStub ( InvocationMatcher invocationMatcher ) { Iterator<Invocation> i = unusedStubs . iterator ( ) ; while ( i . hasNext ( ) ) { Invocation invocation = i . next ( ) ; [ATTENTION] if ( nullnvocationMatcher . matches ( invocation ) ) { i . remove ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^49^^^^^45^53^
[REPLACE]  collectingData  =  true; 	[BUGGY] collectingData = false ; [FE] AssertionFailedError [METHOD]  collectData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void collectData ( ) { [ATTENTION] collectingData = false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^56^^^^^55^57^
[REPLACE]  collectingData  =  false; 	[BUGGY] collectingData = true ; [NO-ERROR]  [METHOD]  clearData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void clearData ( ) { [ATTENTION] collectingData = true ; unstubbedInvocations . clear ( ) ; unusedStubs . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^60^^^^^59^63^
[ADD]  collectingData  =  false; 	[BUGGY] [NO-ERROR]  [METHOD]  clearData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void clearData ( ) { [ATTENTION] unstubbedInvocations . clear ( ) ; unusedStubs . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^60^^^^^59^63^
[REPLACE]  unstubbedInvocations  .  clear  (  )  ; 	[BUGGY] unstubbedInvocations . iterator ( ) ; [FE] AssertionFailedError [METHOD]  clearData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void clearData ( ) { collectingData = false ; [ATTENTION] unstubbedInvocations . iterator ( )  ; unusedStubs . clear ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^61^^^^^59^63^
[REPLACE]  unusedStubs  .  clear  (  )  ; 	[BUGGY] unusedStubs . iterator ( )  ; [FE] AssertionFailedError [METHOD]  clearData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void clearData ( ) { collectingData = false ; unstubbedInvocations . clear ( ) ; [ATTENTION] unusedStubs . iterator ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^62^^^^^59^63^
[ADD]  unusedStubs  .  clear  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  clearData [TYPE] void [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public void clearData ( ) { collectingData = false ; unstubbedInvocations . clear ( ) ; [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^62^^^^^59^63^
[REPLACE]  if  (  hasData  (  )  )  { 	[BUGGY] if ( !collectingData ) {[FE] AssertionFailedError [METHOD]  printWarnings [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] DebuggingInfo  [TYPE] WarningsPrinter warningsPrinter [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] MockitoLogger logger  [CONTEXT]  public void printWarnings ( MockitoLogger logger ) { [ATTENTION] if ( !collectingData ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( unusedStubs , unstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^66^^^^^65^70^
[REPLACE]  WarningsPrinter  warningsPrinter  =  new  WarningsPrinter  (  unusedStubs,  unstubbedInvocations  )  ; 	[BUGGY] InvocationMatcher unstubbed = unstubbedIterator . next ( ) ; [CE] cannot find symbol unstubbedIterator  [METHOD]  printWarnings [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] DebuggingInfo  [TYPE] WarningsPrinter warningsPrinter [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] MockitoLogger logger  [CONTEXT]  public void printWarnings ( MockitoLogger logger ) { if ( hasData ( ) ) { [ATTENTION] InvocationMatcher unstubbed = unstubbedIterator . next ( )  ; warningsPrinter . print ( logger ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^67^^^^^65^70^
[ADD]  WarningsPrinter  warningsPrinter  =  new  WarningsPrinter  (  unusedStubs,  unstubbedInvocations  )  ; 	[BUGGY] [CE] cannot find symbol warningsPrinter  [METHOD]  printWarnings [TYPE] void [PARAMETER] MockitoLogger logger [CLASS] DebuggingInfo  [TYPE] WarningsPrinter warningsPrinter [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true [TYPE] MockitoLogger logger  [CONTEXT]  public void printWarnings ( MockitoLogger logger ) { if ( hasData ( ) ) { [ATTENTION] warningsPrinter . print ( logger ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^67^^^^^65^70^
[REPLACE]  return  !unusedStubs  .  isEmpty  (  )  ||  !unstubbedInvocations  .  isEmpty  (  )  ; 	[BUGGY] return !unusedStubs . iterator ( )  && !unstubbedInvocations[CE] ' ; ' expected  [METHOD]  hasData [TYPE] boolean [PARAMETER] [CLASS] DebuggingInfo  [TYPE] List unstubbedInvocations unusedStubs [TYPE] boolean collectingData false true  [CONTEXT]  public boolean hasData ( ) { [ATTENTION] return !unusedStubs . iterator ( ) && !unstubbedInvocations }  	./Perturbation-Mockito-38/src/org/mockito/internal/debugging/DebuggingInfo.java^73^^^^^72^74^
[REPLACE]  this  .  runner  =  new  JUnit4ClassRunner  (  klass  )  { 	[BUGGY] this . runner = new JUnit4ClassRunner ( klass ) { @Override ; [CE] illegal start of type  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] JUnit44RunnerImpl 1  [TYPE] Class klass [TYPE] Object test [TYPE] boolean false true [TYPE] JUnit4ClassRunner runner  [CONTEXT]  public JUnit44RunnerImpl ( Class<?> klass ) throws InitializationError { [ATTENTION] this . runner = new JUnit4ClassRunner ( klass ) { @Override ; @Override protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; return test ; } } ; }  	None^21^^^^^20^29^
[REPLACE]  return  test; 	[BUGGY] return runner . getDescription ( ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] JUnit44RunnerImpl 1  [TYPE] Class klass [TYPE] Object test [TYPE] boolean false true [TYPE] JUnit4ClassRunner runner  [CONTEXT]  public JUnit44RunnerImpl ( Class<?> klass ) throws InitializationError { this . runner = new JUnit4ClassRunner ( klass ) { @Override protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; [ATTENTION] return runner . getDescription ( )  ; } } ; }  	None^26^^^^^20^29^
[REPLACE]  Object  test  =  super  .  createTest  (  )  ; 	[BUGGY] Object test = super . createTest ( )  ; [NO-ERROR]  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] JUnit44RunnerImpl 1  [TYPE] Class klass [TYPE] Object test [TYPE] boolean false true [TYPE] JUnit4ClassRunner runner  [CONTEXT]  public JUnit44RunnerImpl ( Class<?> klass ) throws InitializationError { this . runner = new JUnit4ClassRunner ( klass ) { @Override protected Object createTest ( ) throws Exception { [ATTENTION] Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; return test ; } } ; }  	None^24^^^^^20^29^
[REPLACE]  Object  test  =  super  .  createTest  (  )  ; 	[BUGGY] Object test = super . createTest ( )  ; [NO-ERROR]  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] Object test [TYPE] boolean false true  [CONTEXT]  protected Object createTest ( ) throws Exception { [ATTENTION] Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; return test ; }  	None^24^^^^^23^27^
[ADD]  Object  test  =  super  .  createTest  (  )  ;  MockitoAnnotations  .  initMocks  (  test  )  ; 	[BUGGY] [CE] cannot find symbol test  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] Object test [TYPE] boolean false true  [CONTEXT]  protected Object createTest ( ) throws Exception { [ATTENTION]  return test ; }  	None^24^25^^^^23^27^
[REPLACE]  MockitoAnnotations  .  initMocks  (  test  )  ; 	[BUGGY] test  ; [CE] not a statement  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] Object test [TYPE] boolean false true  [CONTEXT]  protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; [ATTENTION] test ; return test ; }  	None^25^^^^^23^27^
[REPLACE]  return  test; 	[BUGGY] return runner . getDescription ( ) ; [NO-ERROR]  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] Object test [TYPE] boolean false true  [CONTEXT]  protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; [ATTENTION] return runner . getDescription ( )  ; }  	None^26^^^^^23^27^
[REPLACE]  runner  .  run  (  notifier  )  ; 	[BUGGY] runner . filter ( notifier ) ; [CE] method filter in class JUnit4ClassRunner cannot be applied to given types ;  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] RunNotifier notifier [TYPE] boolean false true  [CONTEXT]  public void run ( RunNotifier notifier ) {  notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ;  [ATTENTION] runner . filter ( notifier )  ; }  	None^35^^^^^31^36^
[REPLACE]  return  runner  .  getDescription  (  )  ; 	[BUGGY] return runner . run ( null )  ; [CE] incompatible types  [METHOD]  getDescription [TYPE] Description [PARAMETER] [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] boolean false true  [CONTEXT]  public Description getDescription ( ) { [ATTENTION] return runner . run ( null ) ; }  	None^39^^^^^38^40^
[REPLACE]  runner  .  filter  (  filter  )  ; 	[BUGGY] runner . run ( filter ) ; [CE] no suitable method found for run(Filter)  [METHOD]  filter [TYPE] void [PARAMETER] Filter filter [CLASS] JUnit44RunnerImpl 1  [TYPE] JUnit4ClassRunner runner [TYPE] Filter filter [TYPE] boolean false true  [CONTEXT]  public void filter ( org . junit . runner . manipulation . Filter filter ) throws org . junit . runner . manipulation . NoTestsRemainException {  [ATTENTION] runner . run ( filter )  ; }  	None^43^^^^^41^44^
[REPLACE]  Object  test  =  super  .  createTest  (  )  ; 	[BUGGY] Object test = super . createTest ( )  ; [NO-ERROR]  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] 1  [TYPE] boolean false true [TYPE] Object test  [CONTEXT]  protected Object createTest ( ) throws Exception { [ATTENTION] Object test = super . createTest ( ) ; MockitoAnnotations . initMocks ( test ) ; return test ; }  	None^24^^^^^23^27^
[REPLACE]  MockitoAnnotations  .  initMocks  (  test  )  ; 	[BUGGY] test  ; [CE] not a statement  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] 1  [TYPE] boolean false true [TYPE] Object test  [CONTEXT]  protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; [ATTENTION] test ; return test ; }  	None^25^^^^^23^27^
[ADD]  MockitoAnnotations  .  initMocks  (  test  )  ;  return  test; 	[BUGGY] [CE] missing return statement  [METHOD]  createTest [TYPE] Object [PARAMETER] [CLASS] 1  [TYPE] boolean false true [TYPE] Object test  [CONTEXT]  protected Object createTest ( ) throws Exception { Object test = super . createTest ( ) ; [ATTENTION]  }  	None^25^26^^^^23^27^
[REPLACE]  runner  =  new  BlockJUnit4ClassRunner  (  klass  )  { 	[BUGGY] runner =  new BlockJUnit4ClassRunner ( false ) {[CE] constructor BlockJUnit4ClassRunner in class BlockJUnit4ClassRunner cannot be applied to given types ;  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] Class klass [TYPE] Object target [TYPE] boolean false true [TYPE] BlockJUnit4ClassRunner runner [TYPE] FrameworkMethod method [TYPE] Statement statement  [CONTEXT]  public JUnit45AndHigherRunnerImpl ( Class<?> klass ) throws InitializationError { [ATTENTION] runner = new BlockJUnit4ClassRunner ( false ) { protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  MockitoAnnotations . initMocks ( target ) ; return super . withBefores ( method , target , statement ) ; } } ; }  	None^22^^^^^21^30^
[REPLACE]  return  super  .  withBefores  (  method,  target,  statement  )  ; 	[BUGGY] return runner . getDescription ( ) ; [CE] incompatible types  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] Class klass [TYPE] Object target [TYPE] boolean false true [TYPE] BlockJUnit4ClassRunner runner [TYPE] FrameworkMethod method [TYPE] Statement statement  [CONTEXT]  public JUnit45AndHigherRunnerImpl ( Class<?> klass ) throws InitializationError { runner = new BlockJUnit4ClassRunner ( klass ) { protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  MockitoAnnotations . initMocks ( target ) ; [ATTENTION] return runner . getDescription ( )  ; } } ; }  	None^27^^^^^21^30^
[REPLACE]  MockitoAnnotations  .  initMocks  (  target  )  ; 	[BUGGY] target  ; [CE] not a statement  [METHOD]  withBefores [TYPE] Statement [PARAMETER] FrameworkMethod method Object target Statement statement [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] Object target [TYPE] boolean false true [TYPE] BlockJUnit4ClassRunner runner [TYPE] FrameworkMethod method [TYPE] Statement statement  [CONTEXT]  protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  [ATTENTION] target ; return super . withBefores ( method , target , statement ) ; }  	None^26^^^^^23^28^
[REPLACE]  return  super  .  withBefores  (  method,  target,  statement  )  ; 	[BUGGY] return runner . getDescription ( ) ; [CE] incompatible types  [METHOD]  withBefores [TYPE] Statement [PARAMETER] FrameworkMethod method Object target Statement statement [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] Object target [TYPE] boolean false true [TYPE] BlockJUnit4ClassRunner runner [TYPE] FrameworkMethod method [TYPE] Statement statement  [CONTEXT]  protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  MockitoAnnotations . initMocks ( target ) ; [ATTENTION] return runner . getDescription ( )  ; }  	None^27^^^^^23^28^
[REPLACE]  runner  .  run  (  notifier  )  ; 	[BUGGY] runner . filter ( notifier ) ; [CE] method filter in class ParentRunner<T> cannot be applied to given types ;  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] BlockJUnit4ClassRunner runner [TYPE] RunNotifier notifier [TYPE] boolean false true  [CONTEXT]  public void run ( final RunNotifier notifier ) {  notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ;  [ATTENTION] runner . filter ( notifier )  ; }  	None^36^^^^^32^37^
[ADD]  runner  .  run  (  notifier  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] BlockJUnit4ClassRunner runner [TYPE] RunNotifier notifier [TYPE] boolean false true  [CONTEXT]  public void run ( final RunNotifier notifier ) {  notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ;  [ATTENTION]   	None^36^37^^^^32^37^
[REPLACE]  return  runner  .  getDescription  (  )  ; 	[BUGGY] return super . withBefores ( method , target , statement ) ; [CE] cannot find symbol method  [METHOD]  getDescription [TYPE] Description [PARAMETER] [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] BlockJUnit4ClassRunner runner [TYPE] boolean false true  [CONTEXT]  public Description getDescription ( ) { [ATTENTION] return super . withBefores ( method , target , statement )  ; }  	None^40^^^^^39^41^
[REPLACE]  runner  .  filter  (  filter  )  ; 	[BUGGY] runner . run ( filter ) ; [CE] no suitable method found for run(Filter)  [METHOD]  filter [TYPE] void [PARAMETER] Filter filter [CLASS] JUnit45AndHigherRunnerImpl 1  [TYPE] BlockJUnit4ClassRunner runner [TYPE] Filter filter [TYPE] boolean false true  [CONTEXT]  public void filter ( org . junit . runner . manipulation . Filter filter ) throws org . junit . runner . manipulation . NoTestsRemainException {  [ATTENTION] runner . run ( filter )  ; }  	None^45^^^^^43^46^
[REPLACE]  MockitoAnnotations  .  initMocks  (  target  )  ; 	[BUGGY] target  ; [CE] not a statement  [METHOD]  withBefores [TYPE] Statement [PARAMETER] FrameworkMethod method Object target Statement statement [CLASS] 1  [TYPE] boolean false true [TYPE] Statement statement [TYPE] Object target [TYPE] FrameworkMethod method  [CONTEXT]  protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  [ATTENTION] target ; return super . withBefores ( method , target , statement ) ; }  	None^26^^^^^23^28^
[REPLACE]  return  super  .  withBefores  (  method,  target,  statement  )  ; 	[BUGGY] return super . withBefores ( method , target , statement )  ; [NO-ERROR]  [METHOD]  withBefores [TYPE] Statement [PARAMETER] FrameworkMethod method Object target Statement statement [CLASS] 1  [TYPE] boolean false true [TYPE] Statement statement [TYPE] Object target [TYPE] FrameworkMethod method  [CONTEXT]  protected Statement withBefores ( FrameworkMethod method , Object target , Statement statement ) {  MockitoAnnotations . initMocks ( target ) ; [ATTENTION] return super . withBefores ( method , target , statement ) ; }  	None^27^^^^^23^28^
[REPLACE]  this  .  runnerProvider  =  runnerProvider; 	[BUGGY] this . runnerProvider =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RunnerProvider) [PARAMETER] RunnerProvider runnerProvider [CLASS] RunnerFactory  [TYPE] RunnerProvider runnerProvider [TYPE] boolean false true  [CONTEXT]  RunnerFactory ( RunnerProvider runnerProvider ) { [ATTENTION] this . runnerProvider = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^15^^^^^14^16^
[REPLACE]  this  (  new  RunnerProvider  (  )  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  <init> [TYPE] RunnerFactory() [PARAMETER] [CLASS] RunnerFactory  [TYPE] RunnerProvider runnerProvider [TYPE] boolean false true  [CONTEXT]  public RunnerFactory ( ) { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^19^^^^^18^20^
[ADD]  this  (  new  RunnerProvider  (  )  )  ; 	[BUGGY] [CE] variable runnerProvider might not have been initialized  [METHOD]  <init> [TYPE] RunnerFactory() [PARAMETER] [CLASS] RunnerFactory  [TYPE] RunnerProvider runnerProvider [TYPE] boolean false true  [CONTEXT]  public RunnerFactory ( ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^19^^^^^18^20^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit44RunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; [NO-ERROR]  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass )  ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^27^^^^^22^39^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit45AndHigherRunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; [NO-ERROR]  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass )  ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^25^^^^^22^39^
[ADD]  try  {  if  (  runnerProvider  .  isJUnit45OrHigherAvailable  (  )  )  {  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit45AndHigherRunnerImpl  ",  klass  )  ;  }  else  {  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit44RunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; [CE] class , interface , or enum expected  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass )  ; return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass )  ;   } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^23^24^25^26^27^22^39^
[REPLACE]  if  (  runnerProvider  .  isJUnit45OrHigherAvailable  (  )  )  { 	[BUGGY] if ( runnerProvider . RunnerProvider ( ) ) {[CE] cannot find symbol  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { [ATTENTION] if ( runnerProvider . RunnerProvider ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^24^^^^^22^39^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit44RunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , true ) ; [CE] method newInstance in class RunnerProvider cannot be applied to given types ;  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , true )  ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^27^^^^^22^39^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit45AndHigherRunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , this ) ; [CE] method newInstance in class RunnerProvider cannot be applied to given types ;  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , this )  ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^25^^^^^22^39^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit45AndHigherRunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , null ) ; [FE] AssertionFailedError [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , null )  ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^25^^^^^22^39^
[REPLACE]  return  runnerProvider  .  newInstance  (    "org  .  mockito  .  internal  .  runners  .  JUnit44RunnerImpl  ",  klass  )  ; 	[BUGGY] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , null ) ; [NO-ERROR]  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { [ATTENTION] return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , null )  ; } } catch ( Throwable t ) { throw new MockitoException (   "\n  " +   "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^27^^^^^22^39^
[REPLACE]  throw  new  MockitoException  (    "\n  "  +    "\n  "  +    "MockitoRunner  can  only  be  used  with  JUnit  4  .  4  or  higher  .  \n  "  + 	[BUGGY] return ; [CE] not a statement  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { [ATTENTION] return ;     "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^30^31^32^33^^22^39^
[ADD]  throw  new  MockitoException  (    "\n  "  +    "\n  "  + 	[BUGGY] [CE] not a statement  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } } catch ( Throwable t ) { [ATTENTION]    "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^30^31^32^^^22^39^
[ADD]  catch  (  Throwable  t  )  {  throw  new  MockitoException  (    "\n  "  + 	[BUGGY] [CE] not a statement  [METHOD]  create [TYPE] RunnerImpl [PARAMETER] Class<?> klass [CLASS] RunnerFactory  [TYPE] Throwable t [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerProvider runnerProvider  [CONTEXT]  public RunnerImpl create ( Class<?> klass ) { try { if ( runnerProvider . isJUnit45OrHigherAvailable ( ) ) { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit45AndHigherRunnerImpl  " , klass ) ; } else { return runnerProvider . newInstance (   "org . mockito . internal . runners . JUnit44RunnerImpl  " , klass ) ; } [ATTENTION]    "\n  " +   "MockitoRunner can only be used with JUnit 4 . 4 or higher . \n  " +   "You can upgrade your JUnit version or write your own Runner ( please consider contributing your runner to the Mockito community ) . \n  " +   "Bear in mind that you can still enjoy all features of the framework without using runners ( they are completely optional ) . \n  " +   "If you get this error despite using JUnit 4 . 4 or higher then please report this error to the mockito mailing list . \n  " , t ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/RunnerFactory.java^29^30^31^^^22^39^
[REPLACE]  this  .  notifier  =  notifier; 	[BUGGY] this . notifier =  null ; [NO-ERROR]  [METHOD]  <init> [TYPE] RunNotifier) [PARAMETER] RunNotifier notifier [CLASS] FrameworkUsageValidator  [TYPE] RunNotifier notifier [TYPE] boolean false true  [CONTEXT]  public FrameworkUsageValidator ( RunNotifier notifier ) { [ATTENTION] this . notifier = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/FrameworkUsageValidator.java^18^^^^^17^19^
[REPLACE]  super  .  testFinished  (  description  )  ; 	[BUGGY] Mockito . validateMockitoUsage ( ) ; [NO-ERROR]  [METHOD]  testFinished [TYPE] void [PARAMETER] Description description [CLASS] FrameworkUsageValidator  [TYPE] Throwable t [TYPE] RunNotifier notifier [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void testFinished ( Description description ) throws Exception { [ATTENTION] Mockito . validateMockitoUsage ( )  ; try { Mockito . validateMockitoUsage ( ) ; } catch ( Throwable t ) { notifier . fireTestFailure ( new Failure ( description , t ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/FrameworkUsageValidator.java^23^^^^^22^29^
[ADD]  try  {  Mockito  .  validateMockitoUsage  (  )  ;  }  catch  (  Throwable  t  )  {  notifier  .  fireTestFailure  (  new  Failure  (  description,  t  )  )  ;  } 	[BUGGY] Mockito . validateMockitoUsage ( ) ; notifier . fireTestFailure ( new Failure ( description , t ) ) ; [CE] cannot find symbol t  [METHOD]  testFinished [TYPE] void [PARAMETER] Description description [CLASS] FrameworkUsageValidator  [TYPE] Throwable t [TYPE] RunNotifier notifier [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void testFinished ( Description description ) throws Exception { super . testFinished ( description ) ; [ATTENTION] Mockito . validateMockitoUsage ( )  ; notifier . fireTestFailure ( new Failure ( description , t ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/FrameworkUsageValidator.java^24^25^26^27^28^22^29^
[REPLACE]  Mockito  .  validateMockitoUsage  (  )  ; 	[BUGGY] super . testFinished ( description ) ; [NO-ERROR]  [METHOD]  testFinished [TYPE] void [PARAMETER] Description description [CLASS] FrameworkUsageValidator  [TYPE] Throwable t [TYPE] RunNotifier notifier [TYPE] Description description [TYPE] boolean false true  [CONTEXT]  public void testFinished ( Description description ) throws Exception { super . testFinished ( description ) ; try { [ATTENTION] super . testFinished ( description )  ; } catch ( Throwable t ) { notifier . fireTestFailure ( new Failure ( description , t ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/FrameworkUsageValidator.java^25^^^^^22^29^
[REPLACE]  private  static  boolean  hasJUnit45OrHigher; 	[BUGGY] private boolean hasJUnit45OrHigher ; [CE] non-static variable hasJUnit45OrHigher cannot be referenced from a static context  [CONTEXT]    [CLASS] RunnerProvider  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^13^^^^^^^
[REPLACE]  return  hasJUnit45OrHigher; 	[BUGGY] return ( RunnerImpl ) constructor . newInstance ( constructorParam ) ; [CE] cannot find symbol constructorParam  [METHOD]  isJUnit45OrHigherAvailable [TYPE] boolean [PARAMETER] [CLASS] RunnerProvider  [TYPE] boolean false hasJUnit45OrHigher true  [CONTEXT]  public boolean isJUnit45OrHigherAvailable ( ) { [ATTENTION] return ( RunnerImpl ) constructor . newInstance ( constructorParam )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^25^^^^^24^26^
[REPLACE]  Class<?>  runnerClass  =  Class  .  forName  (  runnerClassName  )  ; 	[BUGGY] Class<?> runnerClass = Class . getConstructor ( runnerClassName ) ; [CE] method getConstructor in class Class<T> cannot be applied to given types ;  [METHOD]  newInstance [TYPE] RunnerImpl [PARAMETER] String runnerClassName Class<?> constructorParam [CLASS] RunnerProvider  [TYPE] Class constructorParam runnerClass [TYPE] boolean false hasJUnit45OrHigher true [TYPE] String runnerClassName [TYPE] Constructor constructor  [CONTEXT]  public RunnerImpl newInstance ( String runnerClassName , Class<?> constructorParam ) throws Exception { [ATTENTION] Class<?> runnerClass = Class . getConstructor ( runnerClassName )  ; Constructor<?> constructor = runnerClass . getConstructor ( Class . class . getClass ( ) ) ; return ( RunnerImpl ) constructor . newInstance ( constructorParam ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^29^^^^^28^32^
[REPLACE]  Constructor<?>  constructor  =  runnerClass  .  getConstructor  (  Class  .  class  .  getClass  (  )  )  ; 	[BUGGY] Constructor<?> constructor = this . getConstructor ( Class . class . getClass ( ) ) ; [CE] cannot find symbol  [METHOD]  newInstance [TYPE] RunnerImpl [PARAMETER] String runnerClassName Class<?> constructorParam [CLASS] RunnerProvider  [TYPE] Class constructorParam runnerClass [TYPE] boolean false hasJUnit45OrHigher true [TYPE] String runnerClassName [TYPE] Constructor constructor  [CONTEXT]  public RunnerImpl newInstance ( String runnerClassName , Class<?> constructorParam ) throws Exception { Class<?> runnerClass = Class . forName ( runnerClassName ) ; [ATTENTION] Constructor<?> constructor = this . getConstructor ( Class . class . getClass ( ) )  ; return ( RunnerImpl ) constructor . newInstance ( constructorParam ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^30^^^^^28^32^
[ADD]  Constructor<?>  constructor  =  runnerClass  .  getConstructor  (  Class  .  class  .  getClass  (  )  )  ;  return  (  RunnerImpl  )  constructor  .  newInstance  (  constructorParam  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  newInstance [TYPE] RunnerImpl [PARAMETER] String runnerClassName Class<?> constructorParam [CLASS] RunnerProvider  [TYPE] Class constructorParam runnerClass [TYPE] boolean false hasJUnit45OrHigher true [TYPE] String runnerClassName [TYPE] Constructor constructor  [CONTEXT]  public RunnerImpl newInstance ( String runnerClassName , Class<?> constructorParam ) throws Exception { Class<?> runnerClass = Class . forName ( runnerClassName ) ; [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^30^31^^^^28^32^
[REPLACE]  return  (  RunnerImpl  )  constructor  .  newInstance  (  constructorParam  )  ; 	[BUGGY] return ( RunnerImpl ) constructor . newInstance ( false ) ; [FE] AssertionFailedError [METHOD]  newInstance [TYPE] RunnerImpl [PARAMETER] String runnerClassName Class<?> constructorParam [CLASS] RunnerProvider  [TYPE] Class constructorParam runnerClass [TYPE] boolean false hasJUnit45OrHigher true [TYPE] String runnerClassName [TYPE] Constructor constructor  [CONTEXT]  public RunnerImpl newInstance ( String runnerClassName , Class<?> constructorParam ) throws Exception { Class<?> runnerClass = Class . forName ( runnerClassName ) ; Constructor<?> constructor = runnerClass . getConstructor ( Class . class . getClass ( ) ) ; [ATTENTION] return ( RunnerImpl ) constructor . newInstance ( false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/runners/util/RunnerProvider.java^31^^^^^28^32^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter ; [CE] variable reporter might not have been initialized  [CONTEXT]    [CLASS] MockingProgressImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^18^^^^^^^
[REPLACE]  private  final  ArgumentMatcherStorage  argumentMatcherStorage  =  new  ArgumentMatcherStorageImpl  (  )  ; 	[BUGGY] private final ArgumentMatcherStorage argumentMatcherStorage ; [CE] variable argumentMatcherStorage might not have been initialized  [CONTEXT]    [CLASS] MockingProgressImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^19^^^^^^^
[REPLACE]  private  final  DebuggingInfo  debuggingInfo  =  new  DebuggingInfo  (  )  ; 	[BUGGY] private final DebuggingInfo debuggingInfo ; [CE] variable debuggingInfo might not have been initialized  [CONTEXT]    [CLASS] MockingProgressImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^21^^^^^^^
[REPLACE]  private  Location  stubbingInProgress  =  null; 	[BUGGY] private Location stubbingInProgress  = null ; [NO-ERROR]  [CONTEXT]    [CLASS] MockingProgressImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^25^^^^^^^
[REPLACE]  this  .  iOngoingStubbing  =  iOngoingStubbing; 	[BUGGY] this . iOngoingStubbing =  null ; [FE] AssertionFailedError [METHOD]  reportOngoingStubbing [TYPE] void [PARAMETER] IOngoingStubbing iOngoingStubbing [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { [ATTENTION] this . iOngoingStubbing = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^28^^^^^27^29^
[REPLACE]  IOngoingStubbing  temp  =  iOngoingStubbing; 	[BUGGY] VerificationMode temp = verificationMode . getObject ( ) ; [CE] incompatible types  [METHOD]  pullOngoingStubbing [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public IOngoingStubbing pullOngoingStubbing ( ) { [ATTENTION] VerificationMode temp = verificationMode . getObject ( )  ; iOngoingStubbing = null ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^32^^^^^31^35^
[REPLACE]  iOngoingStubbing  =  null; 	[BUGGY] iOngoingStubbing = this ; [CE] incompatible types  [METHOD]  pullOngoingStubbing [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public IOngoingStubbing pullOngoingStubbing ( ) { IOngoingStubbing temp = iOngoingStubbing ; [ATTENTION] iOngoingStubbing = this ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^33^^^^^31^35^
[REPLACE]  return  temp; 	[BUGGY] return iOngoingStubbing ; [FE] AssertionFailedError [METHOD]  pullOngoingStubbing [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public IOngoingStubbing pullOngoingStubbing ( ) { IOngoingStubbing temp = iOngoingStubbing ; iOngoingStubbing = null ; [ATTENTION] return iOngoingStubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^34^^^^^31^35^
[REPLACE]  validateState  (  )  ; 	[BUGGY] GlobalConfiguration . validate ( ) ; [FE] AssertionFailedError [METHOD]  verificationStarted [TYPE] void [PARAMETER] VerificationMode verify [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode verify [TYPE] Location stubbingInProgress  [CONTEXT]  public void verificationStarted ( VerificationMode verify ) { [ATTENTION] GlobalConfiguration . validate ( )  ; resetOngoingStubbing ( ) ; verificationMode = new Localized ( verify ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^38^^^^^37^41^
[REPLACE]  resetOngoingStubbing  (  )  ; 	[BUGGY] debuggingInfo . addStubbedInvocation ( invocation ) ; [CE] cannot find symbol invocation  [METHOD]  verificationStarted [TYPE] void [PARAMETER] VerificationMode verify [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode verify [TYPE] Location stubbingInProgress  [CONTEXT]  public void verificationStarted ( VerificationMode verify ) { validateState ( ) ; [ATTENTION] debuggingInfo . addStubbedInvocation ( invocation )  ; verificationMode = new Localized ( verify ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^39^^^^^37^41^
[REPLACE]  verificationMode  =  new  Localized  (  verify  )  ; 	[BUGGY] verificationMode =  new Localized ( null ) ; [FE]  expected same:<Wanted invocations count: 19> was not:<null> assertNull(mockingProgress.pullVerificationMode())   [METHOD]  verificationStarted [TYPE] void [PARAMETER] VerificationMode verify [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode verify [TYPE] Location stubbingInProgress  [CONTEXT]  public void verificationStarted ( VerificationMode verify ) { validateState ( ) ; resetOngoingStubbing ( ) ; [ATTENTION] verificationMode = new Localized ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^40^^^^^37^41^
[REPLACE]  iOngoingStubbing  =  null; 	[BUGGY] iOngoingStubbing = false ; [CE] incompatible types  [METHOD]  resetOngoingStubbing [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public void resetOngoingStubbing ( ) { [ATTENTION] iOngoingStubbing = false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^47^^^^^46^48^
[REPLACE]  if  (  verificationMode  ==  null  )  { 	[BUGGY] if ( verificationMode ! = null ) {[FE] AssertionFailedError [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { [ATTENTION] if ( verificationMode ! = null ) { return null ; } VerificationMode temp = verificationMode . getObject ( ) ; verificationMode = null ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^51^^^^^50^58^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { [ATTENTION] return this ; } VerificationMode temp = verificationMode . getObject ( ) ; verificationMode = null ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^52^^^^^50^58^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { [ATTENTION] return false ; } VerificationMode temp = verificationMode . getObject ( ) ; verificationMode = null ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^52^^^^^50^58^
[REPLACE]  VerificationMode  temp  =  verificationMode  .  getObject  (  )  ; 	[BUGGY] VerificationMode temp = verificationMode . getLocation ( ) ; [CE] incompatible types  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { return null ; } [ATTENTION] VerificationMode temp = verificationMode . getLocation ( )  ; verificationMode = null ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^55^^^^^50^58^
[ADD]  VerificationMode  temp  =  verificationMode  .  getObject  (  )  ;  verificationMode  =  null;  return  temp;  } 	[BUGGY] verificationMode = null ; return temp ; [CE] illegal start of expression  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { return null ; } [ATTENTION] verificationMode = null ; return temp ;    	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^55^56^57^58^^50^58^
[REPLACE]  verificationMode  =  null; 	[BUGGY] verificationMode = false ; [CE] incompatible types  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { return null ; } VerificationMode temp = verificationMode . getObject ( ) ; [ATTENTION] verificationMode = false ; return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^56^^^^^50^58^
[REPLACE]  return  temp; 	[BUGGY] return null ; [FE]  expected same:<Wanted invocations count: 19> was not:<null> assertNull(mockingProgress.pullVerificationMode())   [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] VerificationMode temp [TYPE] Location stubbingInProgress  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { if ( verificationMode = = null ) { return null ; } VerificationMode temp = verificationMode . getObject ( ) ; verificationMode = null ; [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^57^^^^^50^58^
[REPLACE]  validateState  (  )  ; 	[BUGGY] GlobalConfiguration . validate ( ) ; [FE] AssertionFailedError [METHOD]  stubbingStarted [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public void stubbingStarted ( ) { [ATTENTION] GlobalConfiguration . validate ( )  ; stubbingInProgress = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^61^^^^^60^63^
[REPLACE]  stubbingInProgress  =  new  Location  (  )  ; 	[BUGGY] stubbingInProgress =  new Localized ( verify )  ; [CE] cannot find symbol verify  [METHOD]  stubbingStarted [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location stubbingInProgress  [CONTEXT]  public void stubbingStarted ( ) { validateState ( ) ; [ATTENTION] stubbingInProgress = new Localized ( verify ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^62^^^^^60^63^
[REPLACE]  GlobalConfiguration  .  validate  (  )  ; 	[BUGGY] getArgumentMatcherStorage ( ) . validateState ( ) ; [FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   [ATTENTION] getArgumentMatcherStorage ( )  . validateState ( )  ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^68^^^^^65^83^
[REPLACE]  if  (  verificationMode  !=  null  )  { 	[BUGGY] if ( verificationMode = = null ) {[FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  [ATTENTION] if ( verificationMode = = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^70^^^^^65^83^
[ADD]  if  (  verificationMode  !=  null  )  {  Location  location  =  verificationMode  .  getLocation  (  )  ;  verificationMode  =  null;  reporter  .  unfinishedVerificationException  (  location  )  ;  } 	[BUGGY] Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; [FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  [ATTENTION] Location location = verificationMode . getLocation ( )  ; verificationMode = null ; reporter . unfinishedVerificationException ( location )  ;    if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^70^71^72^73^74^65^83^
[REPLACE]  verificationMode  =  null; 	[BUGGY] verificationMode = false ; [CE] incompatible types  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; [ATTENTION] verificationMode = false ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^72^^^^^65^83^
[REPLACE]  Location  location  =  verificationMode  .  getLocation  (  )  ; 	[BUGGY] Location location = verificationMode . getObject ( ) ; [CE] incompatible types  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { [ATTENTION] Location location = verificationMode . getObject ( )  ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^71^^^^^65^83^
[ADD]  Location  location  =  verificationMode  .  getLocation  (  )  ;  verificationMode  =  null;  reporter  .  unfinishedVerificationException  (  location  )  ;  } 	[BUGGY] verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; [CE] illegal start of expression  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { [ATTENTION] verificationMode = null ; reporter . unfinishedVerificationException ( location )  ;   if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^71^72^73^74^^65^83^
[REPLACE]  if  (  stubbingInProgress  !=  null  )  { 	[BUGGY] if ( stubbingInProgress = = temp ) {[CE] cannot find symbol temp  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } [ATTENTION] if ( stubbingInProgress = = temp ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^76^^^^^65^83^
[REPLACE]  stubbingInProgress  =  null; 	[BUGGY] stubbingInProgress = false ; [CE] incompatible types  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; [ATTENTION] stubbingInProgress = false ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^78^^^^^65^83^
[REPLACE]  Location  temp  =  stubbingInProgress; 	[BUGGY] VerificationMode temp = verificationMode . getObject ( ) ; [CE] method unfinishedStubbing in class Reporter cannot be applied to given types ;  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { [ATTENTION] VerificationMode temp = verificationMode . getObject ( )  ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^77^^^^^65^83^
[ADD]  Location  temp  =  stubbingInProgress; 	[BUGGY] [CE] cannot find symbol temp  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { [ATTENTION] stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^77^^^^^65^83^
[ADD]  stubbingInProgress  =  null;  reporter  .  unfinishedStubbing  (  temp  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; [ATTENTION]  } getArgumentMatcherStorage ( ) . validateState ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^78^79^^^^65^83^
[REPLACE]  getArgumentMatcherStorage  (  )    .  validateState  (  )  ; 	[BUGGY] GlobalConfiguration . validate ( ) ; [FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void validateState ( ) {   GlobalConfiguration . validate ( ) ;  if ( verificationMode ! = null ) { Location location = verificationMode . getLocation ( ) ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; } if ( stubbingInProgress ! = null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; } [ATTENTION] GlobalConfiguration . validate ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^82^^^^^65^83^
[REPLACE]  debuggingInfo  .  addStubbedInvocation  (  invocation  )  ; 	[BUGGY] reporter . unfinishedVerificationException ( location ) ; [CE] cannot find symbol location  [METHOD]  stubbingCompleted [TYPE] void [PARAMETER] Invocation invocation [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void stubbingCompleted ( Invocation invocation ) { [ATTENTION] reporter . unfinishedVerificationException ( location )  ; stubbingInProgress = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^86^^^^^85^88^
[REPLACE]  stubbingInProgress  =  null; 	[BUGGY] stubbingInProgress = false ; [CE] incompatible types  [METHOD]  stubbingCompleted [TYPE] void [PARAMETER] Invocation invocation [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; [ATTENTION] stubbingInProgress = false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^87^^^^^85^88^
[REPLACE]  return    "iOngoingStubbing:    "  +  iOngoingStubbing  +    ",  verificationMode:    "  +  verificationMode  +    ",  stubbingInProgress:    "  +  stubbingInProgress; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public String toString ( ) { [ATTENTION] return true ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^91^92^93^^^90^94^
[REPLACE]  stubbingInProgress  =  null; 	[BUGGY] stubbingInProgress = true ; [CE] incompatible types  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void reset ( ) { [ATTENTION] stubbingInProgress = true ; verificationMode = null ; getArgumentMatcherStorage ( ) . reset ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^97^^^^^96^100^
[REPLACE]  verificationMode  =  null; 	[BUGGY] verificationMode = this ; [CE] incompatible types  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void reset ( ) { stubbingInProgress = null ; [ATTENTION] verificationMode = this ; getArgumentMatcherStorage ( ) . reset ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^98^^^^^96^100^
[REPLACE]  getArgumentMatcherStorage  (  )    .  reset  (  )  ; 	[BUGGY] getArgumentMatcherStorage ( ) . validateState ( ) ; [FE] AssertionFailedError [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public void reset ( ) { stubbingInProgress = null ; verificationMode = null ; [ATTENTION] getArgumentMatcherStorage ( )  . validateState ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^99^^^^^96^100^
[REPLACE]  return  argumentMatcherStorage; 	[BUGGY] return temp ; [CE] cannot find symbol temp  [METHOD]  getArgumentMatcherStorage [TYPE] ArgumentMatcherStorage [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public ArgumentMatcherStorage getArgumentMatcherStorage ( ) { [ATTENTION] return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^103^^^^^102^104^
[REPLACE]  return  debuggingInfo; 	[BUGGY] return temp ; [CE] cannot find symbol temp  [METHOD]  getDebuggingInfo [TYPE] DebuggingInfo [PARAMETER] [CLASS] MockingProgressImpl  [TYPE] boolean false true [TYPE] Reporter reporter [TYPE] DebuggingInfo debuggingInfo [TYPE] IOngoingStubbing iOngoingStubbing temp [TYPE] ArgumentMatcherStorage argumentMatcherStorage [TYPE] Localized verificationMode [TYPE] Location location stubbingInProgress temp  [CONTEXT]  public DebuggingInfo getDebuggingInfo ( ) { [ATTENTION] return temp ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/MockingProgressImpl.java^107^^^^^106^108^
[REPLACE]  private  static  int  sequenceNumber  =  1; 	[BUGGY] private  short sequenceNumber = 1 >>> 2 ; [CE] non-static variable sequenceNumber cannot be referenced from a static context  [CONTEXT]    [CLASS] SequenceNumber  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/SequenceNumber.java^9^^^^^^^
[REPLACE]  private  static  ThreadLocal<MockingProgress>  mockingProgress  =  new  ThreadLocal<MockingProgress>  (  )  ; 	[BUGGY] private static ThreadLocal<MockingProgress> mockingProgress ; [FE] [CONTEXT]    [CLASS] ThreadSafeMockingProgress  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^13^^^^^^^
[REPLACE]  if  (  mockingProgress  .  get  (  )  ==  null  )  { 	[BUGGY] if ( mockingProgress . get ( ) ! = null ) {[FE] AssertionFailedError [METHOD]  threadSafely [TYPE] MockingProgress [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  static MockingProgress threadSafely ( ) { [ATTENTION] if ( mockingProgress . get ( ) ! = null ) { mockingProgress . set ( new MockingProgressImpl ( ) ) ; } return mockingProgress . get ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^16^^^^^15^20^
[REPLACE]  mockingProgress  .  set  (  new  MockingProgressImpl  (  )  )  ; 	[BUGGY] if ( mockingProgress . get ( )  = = null ) { mockingProgress . set ( new MockingProgressImpl ( ) ) ; [CE] illegal start of expression  [METHOD]  threadSafely [TYPE] MockingProgress [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  static MockingProgress threadSafely ( ) { if ( mockingProgress . get ( )  = = null ) { [ATTENTION] if ( mockingProgress . get ( ) = = null ) { mockingProgress . set ( new MockingProgressImpl ( ) )  ; } return mockingProgress . get ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^17^^^^^15^20^
[REPLACE]  return  mockingProgress  .  get  (  )  ; 	[BUGGY] return mockingProgress . ThreadLocal ( ) ; [CE] cannot find symbol  [METHOD]  threadSafely [TYPE] MockingProgress [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  static MockingProgress threadSafely ( ) { if ( mockingProgress . get ( )  = = null ) { mockingProgress . set ( new MockingProgressImpl ( ) ) ; } [ATTENTION] return mockingProgress . ThreadLocal ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^19^^^^^15^20^
[REPLACE]  threadSafely  (  )    .  reportOngoingStubbing  (  iOngoingStubbing  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  reportOngoingStubbing [TYPE] void [PARAMETER] IOngoingStubbing iOngoingStubbing [CLASS] ThreadSafeMockingProgress  [TYPE] IOngoingStubbing iOngoingStubbing [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^23^^^^^22^24^
[ADD]  threadSafely  (  )    .  reportOngoingStubbing  (  iOngoingStubbing  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  reportOngoingStubbing [TYPE] void [PARAMETER] IOngoingStubbing iOngoingStubbing [CLASS] ThreadSafeMockingProgress  [TYPE] IOngoingStubbing iOngoingStubbing [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^23^^^^^22^24^
[REPLACE]  return  threadSafely  (  )    .  pullOngoingStubbing  (  )  ; 	[BUGGY] return threadSafely ( )  . reportOngoingStubbing ( null )  ; [CE] incompatible types  [METHOD]  pullOngoingStubbing [TYPE] IOngoingStubbing [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public IOngoingStubbing pullOngoingStubbing ( ) { [ATTENTION] return threadSafely ( ) . reportOngoingStubbing ( null ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^27^^^^^26^28^
[REPLACE]  threadSafely  (  )    .  verificationStarted  (  verify  )  ; 	[BUGGY] threadSafely ( )  . pullVerificationMode ( )  ; [FE] AssertionFailedError [METHOD]  verificationStarted [TYPE] void [PARAMETER] VerificationMode verify [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] VerificationMode verify [TYPE] boolean false true  [CONTEXT]  public void verificationStarted ( VerificationMode verify ) { [ATTENTION] threadSafely ( ) . pullVerificationMode ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^31^^^^^30^32^
[ADD]  threadSafely  (  )    .  verificationStarted  (  verify  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  verificationStarted [TYPE] void [PARAMETER] VerificationMode verify [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] VerificationMode verify [TYPE] boolean false true  [CONTEXT]  public void verificationStarted ( VerificationMode verify ) { [ATTENTION]   	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^31^32^^^^30^32^
[REPLACE]  return  threadSafely  (  )    .  pullVerificationMode  (  )  ; 	[BUGGY] return threadSafely ( ) . stubbingCompleted ( ) ; [CE] method stubbingCompleted in interface MockingProgress cannot be applied to given types ;  [METHOD]  pullVerificationMode [TYPE] VerificationMode [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public VerificationMode pullVerificationMode ( ) { [ATTENTION] return threadSafely ( )  . stubbingCompleted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^35^^^^^34^36^
[REPLACE]  threadSafely  (  )    .  stubbingStarted  (  )  ; 	[BUGGY] threadSafely ( ) . stubbingCompleted ( ) ; [CE] method stubbingCompleted in interface MockingProgress cannot be applied to given types ;  [METHOD]  stubbingStarted [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingStarted ( ) { [ATTENTION] threadSafely ( )  . stubbingCompleted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^39^^^^^38^40^
[REPLACE]  threadSafely  (  )    .  stubbingStarted  (  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  stubbingStarted [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingStarted ( ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^39^^^^^38^40^
[REMOVE]   	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  stubbingStarted [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingStarted ( ) { [ATTENTION] threadSafely ( ) . stubbingStarted ( ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^39^^^^^38^40^
[REPLACE]  threadSafely  (  )    .  validateState  (  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void validateState ( ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^43^^^^^42^44^
[ADD]  threadSafely  (  )    .  validateState  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void validateState ( ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^43^^^^^42^44^
[REPLACE]  threadSafely  (  )    .  stubbingCompleted  (  invocation  )  ; 	[BUGGY] threadSafely ( )  . stubbingStarted ( )  ; [FE] AssertionFailedError [METHOD]  stubbingCompleted [TYPE] void [PARAMETER] Invocation invocation [CLASS] ThreadSafeMockingProgress  [TYPE] Invocation invocation [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingCompleted ( Invocation invocation ) { [ATTENTION] threadSafely ( ) . stubbingStarted ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^47^^^^^46^48^
[REPLACE]  threadSafely  (  )    .  stubbingCompleted  (  invocation  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  stubbingCompleted [TYPE] void [PARAMETER] Invocation invocation [CLASS] ThreadSafeMockingProgress  [TYPE] Invocation invocation [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingCompleted ( Invocation invocation ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^47^^^^^46^48^
[ADD]  threadSafely  (  )    .  stubbingCompleted  (  invocation  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  stubbingCompleted [TYPE] void [PARAMETER] Invocation invocation [CLASS] ThreadSafeMockingProgress  [TYPE] Invocation invocation [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void stubbingCompleted ( Invocation invocation ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^47^^^^^46^48^
[REPLACE]  return  threadSafely  (  )    .  toString  (  )  ; 	[BUGGY] return threadSafely ( ) . stubbingCompleted ( ) ; [CE] method stubbingCompleted in interface MockingProgress cannot be applied to given types ;  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return threadSafely ( )  . stubbingCompleted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^51^^^^^50^52^
[REPLACE]  threadSafely  (  )    .  reset  (  )  ; 	[BUGGY] threadSafely ( )  . resetOngoingStubbing ( )  ; [FE] AssertionFailedError [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void reset ( ) { [ATTENTION] threadSafely ( ) . resetOngoingStubbing ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^55^^^^^54^56^
[REPLACE]  threadSafely  (  )    .  reset  (  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void reset ( ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^55^^^^^54^56^
[REPLACE]  threadSafely  (  )    .  resetOngoingStubbing  (  )  ; 	[BUGGY] threadSafely ( )  . reportOngoingStubbing ( true )  ; [CE] method reportOngoingStubbing in interface MockingProgress cannot be applied to given types ;  [METHOD]  resetOngoingStubbing [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void resetOngoingStubbing ( ) { [ATTENTION] threadSafely ( ) . reportOngoingStubbing ( true ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^59^^^^^58^60^
[REPLACE]  threadSafely  (  )    .  resetOngoingStubbing  (  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  resetOngoingStubbing [TYPE] void [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public void resetOngoingStubbing ( ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^59^^^^^58^60^
[REPLACE]  return  threadSafely  (  )    .  getArgumentMatcherStorage  (  )  ; 	[BUGGY] return threadSafely ( ) . pullOngoingStubbing ( ) ; [CE] incompatible types  [METHOD]  getArgumentMatcherStorage [TYPE] ArgumentMatcherStorage [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public ArgumentMatcherStorage getArgumentMatcherStorage ( ) { [ATTENTION] return threadSafely ( )  . pullOngoingStubbing ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^63^^^^^62^64^
[REPLACE]  return  threadSafely  (  )    .  getDebuggingInfo  (  )  ; 	[BUGGY] return threadSafely ( ) . stubbingCompleted ( ) ; [CE] method stubbingCompleted in interface MockingProgress cannot be applied to given types ;  [METHOD]  getDebuggingInfo [TYPE] DebuggingInfo [PARAMETER] [CLASS] ThreadSafeMockingProgress  [TYPE] ThreadLocal mockingProgress [TYPE] boolean false true  [CONTEXT]  public DebuggingInfo getDebuggingInfo ( ) { [ATTENTION] return threadSafely ( )  . stubbingCompleted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java^67^^^^^66^68^
[REPLACE]  private  Stack<LocalizedMatcher>  matcherStack  =  new  Stack<LocalizedMatcher>  (  )  ; 	[BUGGY] private new LocalizedMatcher ( and )  ; [CE] illegal start of type  [CONTEXT]    [CLASS] ArgumentMatcherStorageImpl  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^24^^^^^^^
[REPLACE]  matcherStack  .  push  (  new  LocalizedMatcher  (  matcher  )  )  ; 	[BUGGY] matcherStack . subList ( )  ; [CE] no suitable method found for subList()  [METHOD]  reportMatcher [TYPE] HandyReturnValues [PARAMETER] Matcher matcher [CLASS] ArgumentMatcherStorageImpl  [TYPE] Matcher matcher [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportMatcher ( Matcher matcher ) { [ATTENTION] matcherStack . subList ( ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^30^^^^^29^32^
[REPLACE]  return  new  HandyReturnValues  (  )  ; 	[BUGGY] return Collections . emptyList ( ) ; [CE] incompatible types ; no instance(s) of type variable(s) T exist so that List<T> conforms to HandyReturnValues  [METHOD]  reportMatcher [TYPE] HandyReturnValues [PARAMETER] Matcher matcher [CLASS] ArgumentMatcherStorageImpl  [TYPE] Matcher matcher [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportMatcher ( Matcher matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; [ATTENTION] return Collections . emptyList ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^31^^^^^29^32^
[REPLACE]  if  (  matcherStack  .  isEmpty  (  )  )  { 	[BUGGY] if ( !matcherStack . isEmpty ( ) ) {[FE] AssertionFailedError [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { [ATTENTION] if ( !matcherStack . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack ) ; matcherStack . clear ( ) ; return ( List ) matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^38^^^^^37^45^
[REPLACE]  return  Collections  .  emptyList  (  )  ; 	[BUGGY] return ( List ) matchers ; [CE] cannot find symbol matchers  [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { if ( matcherStack . isEmpty ( ) ) { [ATTENTION] return ( List ) matchers ; } List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack ) ; matcherStack . clear ( ) ; return ( List ) matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^39^^^^^37^45^
[REPLACE]  List<LocalizedMatcher>  matchers  =  new  ArrayList<LocalizedMatcher>  (  matcherStack  )  ; 	[BUGGY] LocalizedMatcher lastMatcher = matcherStack . lastElement ( ) ; [CE] cannot find symbol matchers  [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { if ( matcherStack . isEmpty ( ) ) { return Collections . emptyList ( ) ; } [ATTENTION] LocalizedMatcher lastMatcher = matcherStack . lastElement ( )  ; matcherStack . clear ( ) ; return ( List ) matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^42^^^^^37^45^
[ADD]  List<LocalizedMatcher>  matchers  =  new  ArrayList<LocalizedMatcher>  (  matcherStack  )  ;  matcherStack  .  clear  (  )  ; 	[BUGGY] [CE] cannot find symbol matchers  [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { if ( matcherStack . isEmpty ( ) ) { return Collections . emptyList ( ) ; } [ATTENTION]  return ( List ) matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^42^43^^^^37^45^
[REPLACE]  matcherStack  .  clear  (  )  ; 	[BUGGY] matcherStack . Stack ( ) ; [CE] cannot find symbol  [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { if ( matcherStack . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack ) ; [ATTENTION] matcherStack . Stack ( )  ; return ( List ) matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^43^^^^^37^45^
[REPLACE]  return  (  List  )  matchers; 	[BUGGY] return Collections . emptyList ( ) ; [FE] AssertionFailedError [METHOD]  pullMatchers [TYPE] List [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] List matchers [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public List<Matcher> pullMatchers ( ) { if ( matcherStack . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack ) ; matcherStack . clear ( ) ; [ATTENTION] return Collections . emptyList ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^44^^^^^37^45^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  for  And  (  ?  )    .    "  )  ; 	[BUGGY] assertState ( !matcherStack . lastElement ( )  ,   "No matchers found for And ( ? ) .   " ) ; [CE] bad operand type LocalizedMatcher for unary operator  [METHOD]  reportAnd [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] And and [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportAnd ( ) { [ATTENTION] assertState ( !matcherStack . lastElement ( ) ,   "No matchers found for And ( ? )  .   " )  ; And and = new And ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( and ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^51^^^^^50^55^
[REMOVE]   	[BUGGY] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [CE] cannot find symbol count  [METHOD]  reportAnd [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] And and [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportAnd ( ) { [ATTENTION] assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for And ( ? ) .   " ) ;  assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " )  ; And and = new And ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( and ) ) ; return new HandyReturnValues ( ) ;   	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^51^^^^^50^55^
[REPLACE]  And  and  =  new  And  (  popLastArgumentMatchers  (  2  )  )  ; 	[BUGGY] And and = new And ( popLastArgumentMatchers ( 5 ) ) ; [FE]  5 matchers expected , 2 recorded. assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  reportAnd [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] And and [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportAnd ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for And ( ? ) .   " ) ; [ATTENTION] And and = new And ( popLastArgumentMatchers ( 5 ) )  ; matcherStack . push ( new LocalizedMatcher ( and ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^52^^^^^50^55^
[REPLACE]  matcherStack  .  push  (  new  LocalizedMatcher  (  and  )  )  ; 	[BUGGY] matcherStack . subList ( )  ; [CE] no suitable method found for subList()  [METHOD]  reportAnd [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] And and [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportAnd ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for And ( ? ) .   " ) ; And and = new And ( popLastArgumentMatchers ( 2 ) ) ; [ATTENTION] matcherStack . subList ( ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^53^^^^^50^55^
[REPLACE]  return  new  HandyReturnValues  (  )  ; 	[BUGGY] return Collections . emptyList ( ) ; [CE] incompatible types ; no instance(s) of type variable(s) T exist so that List<T> conforms to HandyReturnValues  [METHOD]  reportAnd [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] And and [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportAnd ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for And ( ? ) .   " ) ; And and = new And ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( and ) ) ; [ATTENTION] return Collections . emptyList ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^54^^^^^50^55^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  for  Not  (  ?  )    .    "  )  ; 	[BUGGY] assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for And ( ? ) .   " ) ; [FE]   assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  reportNot [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Not not [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportNot ( ) { [ATTENTION] assertState ( !matcherStack . isEmpty ( )  ,   "No matchers found for And ( ? )  .   " )  ; Not not = new Not ( popLastArgumentMatchers ( 1 ) . get ( 0 ) ) ; matcherStack . push ( new LocalizedMatcher ( not ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^61^^^^^60^65^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  for  Not  (  ?  )    .    "  )  ; 	[BUGGY] assertState ( !matcherStack . push ( ) ,   "No matchers found for Not ( ? ) .   " ) ; [CE] method push in class Stack<E> cannot be applied to given types ;  [METHOD]  reportNot [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Not not [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportNot ( ) { [ATTENTION] assertState ( !matcherStack . push ( )  ,   "No matchers found for Not ( ? )  .   " )  ; Not not = new Not ( popLastArgumentMatchers ( 1 ) . get ( 0 ) ) ; matcherStack . push ( new LocalizedMatcher ( not ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^61^^^^^60^65^
[REPLACE]  Not  not  =  new  Not  (  popLastArgumentMatchers  (  1  )    .  get  (  0  )  )  ; 	[BUGGY] Not not = new Not ( popLastArgumentMatchers ( 4 ) . get ( 0 ) ) ; [FE]  4 matchers expected , 1 recorded. assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  reportNot [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Not not [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportNot ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for Not ( ? ) .   " ) ; [ATTENTION] Not not = new Not ( popLastArgumentMatchers ( 4 )  . get ( 0 ) )  ; matcherStack . push ( new LocalizedMatcher ( not ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^62^^^^^60^65^
[REPLACE]  matcherStack  .  push  (  new  LocalizedMatcher  (  not  )  )  ; 	[BUGGY] matcherStack . subList ( )  ; [CE] no suitable method found for subList()  [METHOD]  reportNot [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Not not [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportNot ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for Not ( ? ) .   " ) ; Not not = new Not ( popLastArgumentMatchers ( 1 ) . get ( 0 ) ) ; [ATTENTION] matcherStack . subList ( ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^63^^^^^60^65^
[REPLACE]  return  new  HandyReturnValues  (  )  ; 	[BUGGY] return Collections . emptyList ( ) ; [CE] incompatible types ; no instance(s) of type variable(s) T exist so that List<T> conforms to HandyReturnValues  [METHOD]  reportNot [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Not not [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportNot ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found for Not ( ? ) .   " ) ; Not not = new Not ( popLastArgumentMatchers ( 1 ) . get ( 0 ) ) ; matcherStack . push ( new LocalizedMatcher ( not ) ) ; [ATTENTION] return Collections . emptyList ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^64^^^^^60^65^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  .    "  )  ; 	[BUGGY] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [NO-ERROR]  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { [ATTENTION] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " )  ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^68^^^^^67^77^
[REMOVE]   	[BUGGY] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [NO-ERROR]  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { [ATTENTION] assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ;  assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " )  ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ;   	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^68^^^^^67^77^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  .    "  )  ; 	[BUGGY] assertState ( !matcherStack . push ( ) ,   "No matchers found .   " ) ; [CE] method push in class Stack<E> cannot be applied to given types ;  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { [ATTENTION] assertState ( !matcherStack . push ( )  ,   "No matchers found .   " )  ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^68^^^^^67^77^
[REPLACE]  assertState  (  matcherStack  .  size  (  )  >=  count,    "  "  +  count  +    "  matchers  expected,    "  +  matcherStack  .  size  (  )  +    "  recorded  .    "  )  ; 	[BUGGY] assertState ( matcherStack . length ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . length ( ) +   " recorded .   " ) ; [CE] cannot find symbol  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; [ATTENTION] assertState ( matcherStack . length ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . length ( ) +   " recorded .   " )  ;  List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^69^70^^^^67^77^
[REPLACE]  assertState  (  matcherStack  .  size  (  )  >=  count,    "  "  +  count  +    "  matchers  expected,    "  +  matcherStack  .  size  (  )  +    "  recorded  .    "  )  ; 	[BUGGY] assertState ( matcherStack . push ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [CE] method push in class Stack<E> cannot be applied to given types ;  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; [ATTENTION] assertState ( matcherStack . push ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " )  ;  List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^69^70^^^^67^77^
[REPLACE]    "  "  +  count  +    "  matchers  expected,    "  +  matcherStack  .  size  (  )  +    "  recorded  .    "  )  ; 	[BUGGY]   "  " + count +   " matchers expected ,   " + matcherStack . subList ( )  +   " recorded .   " ) ; [CE] no suitable method found for subList()  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count , [ATTENTION]   "  " + count +   " matchers expected ,   " + matcherStack . subList ( ) +   " recorded .   " )  ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^70^^^^^67^77^
[ADD]    "  "  +  count  +    "  matchers  expected,    "  +  matcherStack  .  size  (  )  +    "  recorded  .    "  )  ;  List<Matcher>  result  =  new  LinkedList<Matcher>  (  )  ; 	[BUGGY] List<Matcher> result = new LinkedList<Matcher> ( ) ; [CE] ')' expected  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count , [ATTENTION] List<Matcher> result = new LinkedList<Matcher> ( )  ;  result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^70^71^^^^67^77^
[REPLACE]  List<Matcher>  result  =  new  LinkedList<Matcher>  (  )  ; 	[BUGGY] List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack ) ; [CE] cannot find symbol result  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [ATTENTION] List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher> ( matcherStack )  ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^71^^^^^67^77^
[REPLACE]  result  .  addAll  (  matcherStack  .  subList  (  matcherStack  .  size  (  )  -  count,  matcherStack  .  size  (  )  )  )  ; 	[BUGGY] result . addAll ( matcherStack . subList ( matcherStack . size ( ) % 0 . 5 - count , matcherStack . size ( ) % 0 . 5 ) ) ; [CE] no suitable method found for subList(double , double)  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; [ATTENTION] result . addAll ( matcherStack . subList ( matcherStack . size ( ) %0 . 5- count , matcherStack . size ( ) %0 . 5 ) )  ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^72^^^^^67^77^
[REPLACE]  result  .  addAll  (  matcherStack  .  subList  (  matcherStack  .  size  (  )  -  count,  matcherStack  .  size  (  )  )  )  ; 	[BUGGY] result . addAll ( matcherStack . subList ( matcherStack . size ( ) + 3 - count , matcherStack . size ( ) + 3 ) ) ; [FE]  toIndex = 4 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; [ATTENTION] result . addAll ( matcherStack . subList ( matcherStack . size ( ) + 3 - count , matcherStack . size ( ) + 3 ) )  ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^72^^^^^67^77^
[REPLACE]  result  .  addAll  (  matcherStack  .  subList  (  matcherStack  .  size  (  )  -  count,  matcherStack  .  size  (  )  )  )  ; 	[BUGGY] result . addAll ( matcherStack . subList ( matcherStack . push ( ) - count , matcherStack . size ( ) ) ) ; [CE] method push in class Stack<E> cannot be applied to given types ;  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; [ATTENTION] result . addAll ( matcherStack . subList ( matcherStack . push ( ) - count , matcherStack . size ( ) ) )  ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^72^^^^^67^77^
[ADD]  result  .  addAll  (  matcherStack  .  subList  (  matcherStack  .  size  (  )  -  count,  matcherStack  .  size  (  )  )  )  ; 	[BUGGY] [FE]  IndexOutOfBoundsException Index: 0 , Size: 0 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; [ATTENTION] for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^72^^^^^67^77^
[REPLACE]  result  .  addAll  (  matcherStack  .  subList  (  matcherStack  .  size  (  )  -  count,  matcherStack  .  size  (  )  )  )  ; 	[BUGGY] result . addAll ( matcherStack . subList ( matcherStack . Stack ( ) - count , matcherStack . size ( ) ) ) ; [CE] cannot find symbol  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; [ATTENTION] result . addAll ( matcherStack . subList ( matcherStack . Stack ( ) - count , matcherStack . size ( ) ) )  ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^72^^^^^67^77^
[REPLACE]  for  (  int  i  =  0;  i  <  count;  i++  )  { 	[BUGGY] for ( int i = 0 ; i  = =  count ; i++ ) {[FE]   assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; [ATTENTION] for ( int i = 0 ; i = = count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^73^^^^^67^77^
[REPLACE]  matcherStack  .  pop  (  )  ; 	[BUGGY] matcherStack . size ( ) ; [FE]   assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { [ATTENTION] matcherStack . size ( )  ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^74^^^^^67^77^
[REPLACE]  for  (  int  i  =  0;  i  <  count;  i++  )  { 	[BUGGY] for ( int i = 0 - 2 ; i < count ; i++ ) {[FE] NullPointerException assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; [ATTENTION] for ( int i = 0 - 2 ; i < count ; i++ ) { matcherStack . pop ( ) ; } return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^73^^^^^67^77^
[ADD]  for  (  int  i  =  0;  i  <  count;  i++  )  {  matcherStack  .  pop  (  )  ;  } 	[BUGGY] [FE]   assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; [ATTENTION]  return result ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^73^74^75^^^67^77^
[REPLACE]  return  result; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  popLastArgumentMatchers [TYPE] List [PARAMETER] int count [CLASS] ArgumentMatcherStorageImpl  [TYPE] List result [TYPE] boolean false true [TYPE] int count i [TYPE] Stack matcherStack  [CONTEXT]  private List<Matcher> popLastArgumentMatchers ( int count ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; List<Matcher> result = new LinkedList<Matcher> ( ) ; result . addAll ( matcherStack . subList ( matcherStack . size ( ) - count , matcherStack . size ( ) ) ) ; for ( int i = 0 ; i < count ; i++ ) { matcherStack . pop ( ) ; } [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^76^^^^^67^77^
[REPLACE]  if  (  !toAssert  )  { 	[BUGGY] if ( !true ) {[FE]  fromIndex = -1 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  assertState [TYPE] void [PARAMETER] boolean toAssert String message [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false toAssert true [TYPE] String message  [CONTEXT]  private void assertState ( boolean toAssert , String message ) { [ATTENTION] if ( !true ) { matcherStack . clear ( ) ; throw new InvalidUseOfMatchersException ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^80^^^^^79^84^
[ADD]  if  (  !toAssert  )  {  matcherStack  .  clear  (  )  ;  throw  new  InvalidUseOfMatchersException  (  "    ")  ;  } 	[BUGGY] [FE]  fromIndex = -1 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  assertState [TYPE] void [PARAMETER] boolean toAssert String message [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false toAssert true [TYPE] String message  [CONTEXT]  private void assertState ( boolean toAssert , String message ) { [ATTENTION]   }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^80^81^82^83^^79^84^
[REPLACE]  throw  new  InvalidUseOfMatchersException  (  "    ")  ; 	[BUGGY] return ; [FE]  fromIndex = -1 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  assertState [TYPE] void [PARAMETER] boolean toAssert String message [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false toAssert true [TYPE] String message  [CONTEXT]  private void assertState ( boolean toAssert , String message ) { if ( !toAssert ) { matcherStack . clear ( ) ; [ATTENTION] return ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^82^^^^^79^84^
[REPLACE]  matcherStack  .  clear  (  )  ; 	[BUGGY] matcherStack . Stack ( ) ; [CE] cannot find symbol  [METHOD]  assertState [TYPE] void [PARAMETER] boolean toAssert String message [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false toAssert true [TYPE] String message  [CONTEXT]  private void assertState ( boolean toAssert , String message ) { if ( !toAssert ) { [ATTENTION] matcherStack . Stack ( )  ; throw new InvalidUseOfMatchersException ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^81^^^^^79^84^
[ADD]  throw  new  InvalidUseOfMatchersException  (  "    ")  ; 	[BUGGY] [FE]  fromIndex = -1 assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  assertState [TYPE] void [PARAMETER] boolean toAssert String message [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false toAssert true [TYPE] String message  [CONTEXT]  private void assertState ( boolean toAssert , String message ) { if ( !toAssert ) { matcherStack . clear ( ) ; [ATTENTION] } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^82^^^^^79^84^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  .    "  )  ; 	[BUGGY] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " ) ; [CE] cannot find symbol count  [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { [ATTENTION] assertState ( matcherStack . size ( ) > = count ,   "  " + count +   " matchers expected ,   " + matcherStack . size ( ) +   " recorded .   " )  ; Or or = new Or ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( or ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^90^^^^^89^94^
[REPLACE]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  .    "  )  ; 	[BUGGY] assertState ( !matcherStack . push ( ) ,   "No matchers found .   " ) ; [CE] method push in class Stack<E> cannot be applied to given types ;  [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { [ATTENTION] assertState ( !matcherStack . push ( )  ,   "No matchers found .   " )  ; Or or = new Or ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( or ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^90^^^^^89^94^
[ADD]  assertState  (  !matcherStack  .  isEmpty  (  )  ,    "No  matchers  found  .    "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { [ATTENTION] Or or = new Or ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( or ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^90^^^^^89^94^
[REPLACE]  Or  or  =  new  Or  (  popLastArgumentMatchers  (  2  )  )  ; 	[BUGGY] Or or = new Or ( popLastArgumentMatchers ( 5 ) ) ; [FE]   assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; [ATTENTION] Or or = new Or ( popLastArgumentMatchers ( 5 ) )  ; matcherStack . push ( new LocalizedMatcher ( or ) ) ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^91^^^^^89^94^
[ADD]  Or  or  =  new  Or  (  popLastArgumentMatchers  (  2  )  )  ;  matcherStack  .  push  (  new  LocalizedMatcher  (  or  )  )  ; 	[BUGGY] [FE] NullPointerException assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; [ATTENTION]  return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^91^92^^^^89^94^
[REPLACE]  matcherStack  .  push  (  new  LocalizedMatcher  (  or  )  )  ; 	[BUGGY] if ( !matcherStack . isEmpty ( ) ) { LocalizedMatcher lastMatcher = matcherStack . lastElement ( ) ; [CE] illegal start of expression  [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; Or or = new Or ( popLastArgumentMatchers ( 2 ) ) ; [ATTENTION] if ( !matcherStack . isEmpty ( ) ) { LocalizedMatcher lastMatcher = matcherStack . lastElement ( )  ; return new HandyReturnValues ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^92^^^^^89^94^
[REPLACE]  return  new  HandyReturnValues  (  )  ; 	[BUGGY] return Collections . emptyList ( ) ; [CE] incompatible types ; no instance(s) of type variable(s) T exist so that List<T> conforms to HandyReturnValues  [METHOD]  reportOr [TYPE] HandyReturnValues [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] Or or [TYPE] boolean false true  [CONTEXT]  public HandyReturnValues reportOr ( ) { assertState ( !matcherStack . isEmpty ( ) ,   "No matchers found .   " ) ; Or or = new Or ( popLastArgumentMatchers ( 2 ) ) ; matcherStack . push ( new LocalizedMatcher ( or ) ) ; [ATTENTION] return Collections . emptyList ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^93^^^^^89^94^
[REPLACE]  if  (  !matcherStack  .  isEmpty  (  )  )  { 	[BUGGY] if ( matcherStack . isEmpty ( ) ) {[FE] AssertionFailedError [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] LocalizedMatcher lastMatcher [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public void validateState ( ) { [ATTENTION] if ( matcherStack . isEmpty ( ) ) { LocalizedMatcher lastMatcher = matcherStack . lastElement ( ) ; matcherStack . clear ( ) ; new Reporter ( ) . misplacedArgumentMatcher ( lastMatcher . getLocation ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^100^^^^^99^105^
[REPLACE]  LocalizedMatcher  lastMatcher  =  matcherStack  .  lastElement  (  )  ; 	[BUGGY] LocalizedMatcher lastMatcher = matcherStack . isEmpty ( ) ; [CE] incompatible types  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] LocalizedMatcher lastMatcher [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public void validateState ( ) { if ( !matcherStack . isEmpty ( ) ) { [ATTENTION] LocalizedMatcher lastMatcher = matcherStack . isEmpty ( )  ; matcherStack . clear ( ) ; new Reporter ( ) . misplacedArgumentMatcher ( lastMatcher . getLocation ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^101^^^^^99^105^
[ADD]  LocalizedMatcher  lastMatcher  =  matcherStack  .  lastElement  (  )  ;  matcherStack  .  clear  (  )  ; 	[BUGGY] [CE] cannot find symbol lastMatcher  [METHOD]  validateState [TYPE] void [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] LocalizedMatcher lastMatcher [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public void validateState ( ) { if ( !matcherStack . isEmpty ( ) ) { [ATTENTION]  new Reporter ( ) . misplacedArgumentMatcher ( lastMatcher . getLocation ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^101^102^^^^99^105^
[REPLACE]  matcherStack  .  clear  (  )  ; 	[BUGGY] matcherStack . Stack ( ) ; [CE] cannot find symbol  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] ArgumentMatcherStorageImpl  [TYPE] Stack matcherStack [TYPE] boolean false true  [CONTEXT]  public void reset ( ) { [ATTENTION] matcherStack . Stack ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java^111^^^^^110^112^
[REPLACE]  return  0; 	[BUGGY] return 3 ; [NO-ERROR]  [METHOD]  returnZero [TYPE] byte [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public byte returnZero ( ) { [ATTENTION] return 3 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^18^^^^^17^19^
[REPLACE]  return  0; 	[BUGGY] return 0 << 0 ; [NO-ERROR]  [METHOD]  returnChar [TYPE] char [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public char returnChar ( ) { [ATTENTION] return 0 << 0 ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^22^^^^^21^23^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  returnNull [TYPE] <T> [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public <T> T returnNull ( ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^26^^^^^25^27^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  returnFalse [TYPE] boolean [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public boolean returnFalse ( ) { [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^30^^^^^29^31^
[REPLACE]  return    "  "; 	[BUGGY] return new HashSet ( ) ; [CE] incompatible types  [METHOD]  returnString [TYPE] String [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public String returnString ( ) { [ATTENTION] return new HashSet ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^34^^^^^33^35^
[REPLACE]  return  new  HashMap  (  )  ; 	[BUGGY] return new HashSet ( ) ; [CE] incompatible types  [METHOD]  returnMap [TYPE] Map [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public Map returnMap ( ) { [ATTENTION] return new HashSet ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^38^^^^^37^39^
[REPLACE]  return  new  LinkedList  (  )  ; 	[BUGGY] return new HashSet ( )  ; [CE] incompatible types  [METHOD]  returnList [TYPE] List [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public List returnList ( ) { [ATTENTION] returnnew HashSet ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^42^^^^^41^43^
[REPLACE]  return  new  HashSet  (  )  ; 	[BUGGY] return new LinkedList ( )  ; [CE] incompatible types  [METHOD]  returnSet [TYPE] Set [PARAMETER] [CLASS] HandyReturnValues  [TYPE] boolean false true  [CONTEXT]  public Set returnSet ( ) { [ATTENTION] returnnew LinkedList ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/progress/HandyReturnValues.java^46^^^^^45^47^
[REPLACE]  private  final  Reporter  reporter  =  new  Reporter  (  )  ; 	[BUGGY] private final Reporter reporter  = null ; [FE] [CONTEXT]    [CLASS] MockitoCore  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^32^^^^^^^
[REPLACE]  private  final  MockUtil  mockUtil  =  new  MockUtil  (  )  ; 	[BUGGY] private final MockUtil mockUtil ; [CE] variable mockUtil might not have been initialized  [CONTEXT]    [CLASS] MockitoCore  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^33^^^^^^^
[REPLACE]  private  final  MockingProgress  mockingProgress  =  new  ThreadSafeMockingProgress  (  )  ; 	[BUGGY] private MockingProgress mockingProgress = new ThreadSafeMockingProgress ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] MockitoCore  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^34^^^^^^^
[REPLACE]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] mockingProgress . stubbingStarted ( ) ; [FE] AssertionFailedError [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock MockSettings mockSettings [CLASS] MockitoCore  [TYPE] Class classToMock [TYPE] MockSettings mockSettings [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T mock ( Class<T> classToMock , MockSettings mockSettings ) { [ATTENTION] mockingProgress . stubbingStarted ( )  ; mockingProgress . resetOngoingStubbing ( ) ; return mockUtil . createMock ( classToMock , mockingProgress ,  ( MockSettingsImpl ) mockSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^37^^^^^36^40^
[REPLACE]  mockingProgress  .  resetOngoingStubbing  (  )  ; 	[BUGGY] mockingProgress . pullOngoingStubbing ( ) ; [NO-ERROR]  [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock MockSettings mockSettings [CLASS] MockitoCore  [TYPE] Class classToMock [TYPE] MockSettings mockSettings [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T mock ( Class<T> classToMock , MockSettings mockSettings ) { mockingProgress . validateState ( ) ; [ATTENTION] mockingProgress . pullOngoingStubbing ( )  ; return mockUtil . createMock ( classToMock , mockingProgress ,  ( MockSettingsImpl ) mockSettings ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^38^^^^^36^40^
[REPLACE]  return  mockUtil  .  createMock  (  classToMock,  mockingProgress,  (  MockSettingsImpl  )  mockSettings  )  ; 	[BUGGY] return mockUtil . createMock ( null , mockingProgress ,  ( MockSettingsImpl ) mockSettings ) ; [FE] AssertionFailedError [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock MockSettings mockSettings [CLASS] MockitoCore  [TYPE] Class classToMock [TYPE] MockSettings mockSettings [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> T mock ( Class<T> classToMock , MockSettings mockSettings ) { mockingProgress . validateState ( ) ; mockingProgress . resetOngoingStubbing ( ) ; [ATTENTION] return mockUtil . createMock ( null , mockingProgress , ( MockSettingsImpl ) mockSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^39^^^^^36^40^
[REPLACE]  IOngoingStubbing  stubbing  =  mockingProgress  .  pullOngoingStubbing  (  )  ; 	[BUGGY] IOngoingStubbing stubbing = mockingProgress . resetOngoingStubbing ( ) ; [CE] incompatible types  [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { [ATTENTION] IOngoingStubbing stubbing = mockingProgress . resetOngoingStubbing ( )  ; if ( stubbing = = null ) { mockingProgress . reset ( ) ; reporter . missingMethodInvocation ( ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^43^^^^^42^49^
[REPLACE]  if  (  stubbing  ==  null  )  { 	[BUGGY] if ( stubbing ! = null ) {[FE] AssertionFailedError [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; [ATTENTION] if ( stubbing ! = null ) { mockingProgress . reset ( ) ; reporter . missingMethodInvocation ( ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^44^^^^^42^49^
[REPLACE]  mockingProgress  .  reset  (  )  ; 	[BUGGY] mockingProgress . validateState ( ) ; [FE] AssertionFailedError [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; if ( stubbing = = null ) { [ATTENTION] mockingProgress . validateState ( )  ; reporter . missingMethodInvocation ( ) ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^45^^^^^42^49^
[REPLACE]  reporter  .  missingMethodInvocation  (  )  ; 	[BUGGY] reporter . nullPassedToVerify ( ) ; [FE] AssertionFailedError [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; if ( stubbing = = null ) { mockingProgress . reset ( ) ; [ATTENTION] reporter . nullPassedToVerify ( )  ; } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^46^^^^^42^49^
[ADD]  reporter  .  missingMethodInvocation  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; if ( stubbing = = null ) { mockingProgress . reset ( ) ; [ATTENTION] } return stubbing ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^46^^^^^42^49^
[REPLACE]  return  stubbing; 	[BUGGY] return inOrder ; [CE] cannot find symbol inOrder  [METHOD]  stub [TYPE] IOngoingStubbing [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] IOngoingStubbing stubbing [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public IOngoingStubbing stub ( ) { IOngoingStubbing stubbing = mockingProgress . pullOngoingStubbing ( ) ; if ( stubbing = = null ) { mockingProgress . reset ( ) ; reporter . missingMethodInvocation ( ) ; } [ATTENTION] return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^48^^^^^42^49^
[REPLACE]  mockingProgress  .  stubbingStarted  (  )  ; 	[BUGGY] mockingProgress . validateState ( ) ; [NO-ERROR]  [METHOD]  stub [TYPE] <T> [PARAMETER] T methodCall [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T methodCall [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> DeprecatedOngoingStubbing<T> stub ( T methodCall ) { [ATTENTION] mockingProgress . validateState ( )  ; return ( DeprecatedOngoingStubbing ) stub ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^53^^^^^52^55^
[REPLACE]  return  (  DeprecatedOngoingStubbing  )  stub  (  )  ; 	[BUGGY] return mockUtil . createMock ( classToMock , mockingProgress ,  ( MockSettingsImpl ) mockSettings ) ; [CE] cannot find symbol classToMock  [METHOD]  stub [TYPE] <T> [PARAMETER] T methodCall [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T methodCall [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> DeprecatedOngoingStubbing<T> stub ( T methodCall ) { mockingProgress . stubbingStarted ( ) ; [ATTENTION] return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^54^^^^^52^55^
[REPLACE]  mockingProgress  .  stubbingStarted  (  )  ; 	[BUGGY] mockingProgress . validateState ( ) ; [FE] AssertionFailedError [METHOD]  when [TYPE] <T> [PARAMETER] T methodCall [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T methodCall [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> OngoingStubbing<T> when ( T methodCall ) { [ATTENTION] mockingProgress . validateState ( )  ; return ( OngoingStubbing ) stub ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^58^^^^^57^60^
[REPLACE]  return  (  OngoingStubbing  )  stub  (  )  ; 	[BUGGY] return ( DeprecatedOngoingStubbing ) stub ( ) ; [CE] incompatible types  [METHOD]  when [TYPE] <T> [PARAMETER] T methodCall [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T methodCall [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> OngoingStubbing<T> when ( T methodCall ) { mockingProgress . stubbingStarted ( ) ; [ATTENTION] return ( DeprecatedOngoingStubbing ) stub ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^59^^^^^57^60^
[REPLACE]  if  (  mock  ==  null  )  { 	[BUGGY] if ( mock ! = false ) {[CE] incomparable types: T and boolean  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { [ATTENTION] if ( mock ! = false ) { reporter . nullPassedToVerify ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^64^^^^^63^71^
[ADD]  if  (  mock  ==  null  )  {  reporter  .  nullPassedToVerify  (  )  ;  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  {  reporter  .  notAMockPassedToVerify  (  )  ;  } 	[BUGGY] reporter . nullPassedToVerify ( ) ; reporter . notAMockPassedToVerify ( ) ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { [ATTENTION] reporter . nullPassedToVerify ( )  ; reporter . notAMockPassedToVerify ( )  ;   mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^64^65^66^67^68^63^71^
[REPLACE]  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  { 	[BUGGY]  else {[FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { reporter . nullPassedToVerify ( ) ; [ATTENTION] }else { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^66^^^^^63^71^
[REPLACE]  reporter  .  notAMockPassedToVerify  (  )  ; 	[BUGGY] reporter . nullPassedToVerify ( ) ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { reporter . nullPassedToVerify ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { [ATTENTION] reporter . nullPassedToVerify ( )  ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^67^^^^^63^71^
[ADD]  reporter  .  notAMockPassedToVerify  (  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { reporter . nullPassedToVerify ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { [ATTENTION]  mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^67^68^^^^63^71^
[REPLACE]  reporter  .  nullPassedToVerify  (  )  ; 	[BUGGY] reporter . notAMockPassedToVerify ( ) ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { [ATTENTION] reporter . notAMockPassedToVerify ( )  ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^65^^^^^63^71^
[ADD]  else  if  (  !mockUtil  .  isMock  (  mock  )  )  {  reporter  .  notAMockPassedToVerify  (  )  ;  } 	[BUGGY]  reporter . notAMockPassedToVerify ( ) ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { reporter . nullPassedToVerify ( ) ; [ATTENTION] } reporter . notAMockPassedToVerify ( )  ;  mockingProgress . verificationStarted ( mode ) ; return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^66^67^68^^^63^71^
[REPLACE]  return  mock; 	[BUGGY] return inOrder ; [CE] cannot find symbol inOrder  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] VerificationMode mode [TYPE] Reporter reporter  [CONTEXT]  public <T> T verify ( T mock , VerificationMode mode ) { if ( mock = = null ) { reporter . nullPassedToVerify ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; [ATTENTION] return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^70^^^^^63^71^
[REPLACE]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] mockingProgress . stubbingStarted ( ) ; [NO-ERROR]  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { [ATTENTION] mockingProgress . stubbingStarted ( )  ; mockingProgress . reset ( ) ; mockingProgress . resetOngoingStubbing ( ) ;  for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^74^^^^^73^81^
[REMOVE]   	[BUGGY] mockingProgress . resetOngoingStubbing ( ) ; [NO-ERROR]  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { [ATTENTION] mockingProgress . validateState ( ) ;  mockingProgress . resetOngoingStubbing ( )  ; mockingProgress . reset ( ) ; mockingProgress . resetOngoingStubbing ( ) ;  for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^74^^^^^73^81^
[REPLACE]  mockingProgress  .  reset  (  )  ; 	[BUGGY] mockingProgress . validateState ( ) ; [NO-ERROR]  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { mockingProgress . validateState ( ) ; [ATTENTION] mockingProgress . validateState ( )  ; mockingProgress . resetOngoingStubbing ( ) ;  for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^75^^^^^73^81^
[REPLACE]  mockingProgress  .  resetOngoingStubbing  (  )  ; 	[BUGGY] mockingProgress . pullOngoingStubbing ( )  ; [NO-ERROR]  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { mockingProgress . validateState ( ) ; mockingProgress . reset ( ) ; [ATTENTION] mockingProgress . pullOngoingStubbing ( ) ;  for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^76^^^^^73^81^
[ADD]  mockingProgress  .  resetOngoingStubbing  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { mockingProgress . validateState ( ) ; mockingProgress . reset ( ) ; [ATTENTION]  for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^76^^^^^73^81^
[REPLACE]  for  (  T  m  :  mocks  )  { 	[BUGGY] for ( Object mock : mocks ) { if ( mock = = null ) {[CE] illegal start of expression  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { mockingProgress . validateState ( ) ; mockingProgress . reset ( ) ; mockingProgress . resetOngoingStubbing ( ) ;  [ATTENTION] for ( Object mock : mocks ) { if ( mock = = null ) { mockUtil . resetMock ( m , mockingProgress ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^78^^^^^73^81^
[ADD]  for  (  T  m  :  mocks  )  {  mockUtil  .  resetMock  (  m,  mockingProgress  )  ;  } 	[BUGGY] [FE]  Expected: <null> but was: 200 assertNull(mock.objectReturningMethod(200))   [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] T m [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] T[] mocks  [CONTEXT]  public <T> void reset ( T . . . mocks ) { mockingProgress . validateState ( ) ; mockingProgress . reset ( ) ; mockingProgress . resetOngoingStubbing ( ) ;  [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^78^79^80^^^73^81^
[REPLACE]  assertMocksNotEmpty  (  mocks  )  ; 	[BUGGY] return handler . voidMethodStubbable ( mock ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { [ATTENTION] return handler . voidMethodStubbable ( mock )  ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { try { if ( mock = = null ) { reporter . nullPassedToVerifyNoMoreInteractions ( ) ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^84^^^^^83^96^
[REMOVE]   	[BUGGY] mockingProgress . verificationStarted ( mode ) ; [CE] cannot find symbol mode  [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { [ATTENTION] assertMocksNotEmpty ( mocks ) ;  mockingProgress . verificationStarted ( mode )  ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { try { if ( mock = = null ) { reporter . nullPassedToVerifyNoMoreInteractions ( ) ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^84^^^^^83^96^
[REPLACE]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] mockingProgress . verificationStarted ( null )  ; [FE]  assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing())   [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; [ATTENTION] mockingProgress . verificationStarted ( null ) ; for ( Object mock : mocks ) { try { if ( mock = = null ) { reporter . nullPassedToVerifyNoMoreInteractions ( ) ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^85^^^^^83^96^
[REPLACE]  if  (  mock  ==  null  )  { 	[BUGGY] if ( mock ! = null ) {[FE] AssertionFailedError [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { try { [ATTENTION] if ( mock ! = null ) { reporter . nullPassedToVerifyNoMoreInteractions ( ) ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^88^^^^^83^96^
[REPLACE]  reporter  .  nullPassedToVerifyNoMoreInteractions  (  )  ; 	[BUGGY] reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; [FE] AssertionFailedError [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { try { if ( mock = = null ) { [ATTENTION] reporter . notAMockPassedToVerifyNoMoreInteractions ( )  ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^89^^^^^83^96^
[ADD]  try  {  if  (  mock  ==  null  )  {  reporter  .  nullPassedToVerifyNoMoreInteractions  (  )  ;  } 	[BUGGY] reporter . nullPassedToVerifyNoMoreInteractions ( ) ; [CE] 'catch' without 'try'  [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { [ATTENTION] reporter . nullPassedToVerifyNoMoreInteractions ( )  ;   mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^87^88^89^90^^83^96^
[ADD]  if  (  mock  ==  null  )  {  reporter  .  nullPassedToVerifyNoMoreInteractions  (  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; mockingProgress . validateState ( ) ; for ( Object mock : mocks ) { try { [ATTENTION]  mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^88^89^90^^^83^96^
[REPLACE]  for  (  Object  mock  :  mocks  )  { 	[BUGGY] for ( Object mock : mocks ) { if ( mock = = null ) {[CE] illegal start of expression  [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] NotAMockException e [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public void verifyNoMoreInteractions ( Object . . . mocks ) { assertMocksNotEmpty ( mocks ) ; mockingProgress . validateState ( ) ; [ATTENTION] for ( Object mock : mocks ) { if ( mock = = null ) { try { if ( mock = = null ) { reporter . nullPassedToVerifyNoMoreInteractions ( ) ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions ( ) ; } catch ( NotAMockException e ) { reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^86^^^^^83^96^
[REPLACE]  if  (  mocks  ==  null  ||  mocks  .  length  ==  0  )  { 	[BUGGY] if ( mocks = = null ) {[FE] AssertionFailedError [METHOD]  assertMocksNotEmpty [TYPE] void [PARAMETER] Object[] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Object[] mocks [TYPE] Reporter reporter  [CONTEXT]  private void assertMocksNotEmpty ( Object[] mocks ) { [ATTENTION] if ( mocks = = null ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^99^^^^^98^102^
[REPLACE]  reporter  .  mocksHaveToBePassedToVerifyNoMoreInteractions  (  )  ; 	[BUGGY] reporter . notAMockPassedToVerifyNoMoreInteractions ( )  ; [NO-ERROR]  [METHOD]  assertMocksNotEmpty [TYPE] void [PARAMETER] Object[] mocks [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Object[] mocks [TYPE] Reporter reporter  [CONTEXT]  private void assertMocksNotEmpty ( Object[] mocks ) { if ( mocks = = null || mocks . length = = 0 ) { [ATTENTION] reporter . notAMockPassedToVerifyNoMoreInteractions ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^100^^^^^98^102^
[REPLACE]  if  (  mocks  ==  null  ||  mocks  .  length  ==  0  )  { 	[BUGGY] if ( mocks = = null || mocks . length ( )  = = 0 ) {[CE] cannot find symbol  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { [ATTENTION] if ( mocks = = null || mocks . length ( ) = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^105^^^^^104^117^
[REPLACE]  reporter  .  mocksHaveToBePassedWhenCreatingInOrder  (  )  ; 	[BUGGY] reporter . notAMockPassedWhenCreatingInOrder ( )  ; [NO-ERROR]  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { [ATTENTION] reporter . notAMockPassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^106^^^^^104^117^
[REPLACE]  if  (  mock  ==  null  )  { 	[BUGGY] if ( mock ! = this ) {[FE] AssertionFailedError [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { [ATTENTION] if ( mock ! = this ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^109^^^^^104^117^
[REPLACE]  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  { 	[BUGGY]  if ( !mockUtil . getMockHandler ( mock ) ) {[CE] bad operand type MockHandler<Object> for unary operator '!'  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; [ATTENTION] }if ( !mockUtil . getMockHandler ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^111^^^^^104^117^
[REPLACE]  reporter  .  notAMockPassedWhenCreatingInOrder  (  )  ; 	[BUGGY] reporter . nullPassedWhenCreatingInOrder ( )  ; [FE] AssertionFailedError [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { [ATTENTION] reporter . nullPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^112^^^^^104^117^
[REPLACE]  reporter  .  nullPassedWhenCreatingInOrder  (  )  ; 	[BUGGY] reporter . notAMockPassedWhenCreatingInOrder ( ) ; [FE] AssertionFailedError [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { [ATTENTION] reporter . notAMockPassedWhenCreatingInOrder ( )  ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^110^^^^^104^117^
[REPLACE]  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  { 	[BUGGY]  if ( !mockUtil . resetMock ( null , mockingProgress )  ) {[CE] 'void' type not allowed here  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; [ATTENTION] }if ( !mockUtil . resetMock ( null , mockingProgress )  ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^111^^^^^104^117^
[ADD]  else  if  (  !mockUtil  .  isMock  (  mock  )  )  {  reporter  .  notAMockPassedWhenCreatingInOrder  (  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; [ATTENTION] }  } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^111^112^113^^^104^117^
[REPLACE]  reporter  .  notAMockPassedWhenCreatingInOrder  (  )  ; 	[BUGGY] reporter . nullPassedWhenCreatingInOrder ( ) ; [FE] AssertionFailedError [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { [ATTENTION] reporter . nullPassedWhenCreatingInOrder ( )  ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^112^^^^^104^117^
[REPLACE]  for  (  Object  mock  :  mocks  )  { 	[BUGGY] for ( Object mock : mocks ) { if ( mock = = null ) {[CE] illegal start of expression  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } [ATTENTION] for ( Object mock : mocks ) { if ( mock = = null ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^108^^^^^104^117^
[ADD]  for  (  Object  mock  :  mocks  )  {  if  (  mock  ==  null  )  {  reporter  .  nullPassedWhenCreatingInOrder  (  )  ;  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  {  reporter  .  notAMockPassedWhenCreatingInOrder  (  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } [ATTENTION]   } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^108^109^110^111^112^104^117^
[REPLACE]  InOrder  inOrder  =  new  InOrderImpl  (  Arrays  .  asList  (  mocks  )  )  ; 	[BUGGY] InOrder inOrder = new InOrderImpl (  mocks  ) ; [CE] constructor InOrderImpl in class InOrderImpl cannot be applied to given types ;  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } [ATTENTION] InOrder inOrder = new InOrderImpl ( mocks )  ; return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^115^^^^^104^117^
[ADD]  InOrder  inOrder  =  new  InOrderImpl  (  Arrays  .  asList  (  mocks  )  )  ; 	[BUGGY] [CE] cannot find symbol inOrder  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } [ATTENTION] return inOrder ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^115^^^^^104^117^
[REPLACE]  return  inOrder; 	[BUGGY] return mock ; [CE] cannot find symbol mock  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] MockitoCore  [TYPE] InOrder inOrder [TYPE] boolean false true [TYPE] MockUtil mockUtil [TYPE] Reporter reporter [TYPE] Object mock [TYPE] MockingProgress mockingProgress [TYPE] Object[] mocks  [CONTEXT]  public InOrder inOrder ( Object . . . mocks ) { if ( mocks = = null || mocks . length = = 0 ) { reporter . mocksHaveToBePassedWhenCreatingInOrder ( ) ; } for ( Object mock : mocks ) { if ( mock = = null ) { reporter . nullPassedWhenCreatingInOrder ( ) ; } else if ( !mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder ( ) ; } } InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; [ATTENTION] return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^116^^^^^104^117^
[REPLACE]  mockingProgress  .  stubbingStarted  (  )  ; 	[BUGGY] mockingProgress . validateState ( ) ; [FE] AssertionFailedError [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] MockitoCore  [TYPE] Answer answer [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public Stubber doAnswer ( Answer answer ) { [ATTENTION] mockingProgress . validateState ( )  ; mockingProgress . resetOngoingStubbing ( ) ; return new StubberImpl ( ) . doAnswer ( answer ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^120^^^^^119^123^
[REPLACE]  mockingProgress  .  resetOngoingStubbing  (  )  ; 	[BUGGY] mockingProgress . pullOngoingStubbing ( ) ; [NO-ERROR]  [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] MockitoCore  [TYPE] Answer answer [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public Stubber doAnswer ( Answer answer ) { mockingProgress . stubbingStarted ( ) ; [ATTENTION] mockingProgress . pullOngoingStubbing ( )  ; return new StubberImpl ( ) . doAnswer ( answer ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^121^^^^^119^123^
[REPLACE]  return  new  StubberImpl  (  )    .  doAnswer  (  answer  )  ; 	[BUGGY] return new StubberImpl ( )  . StubberImpl ( )  ; [CE] cannot find symbol  [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] MockitoCore  [TYPE] Answer answer [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public Stubber doAnswer ( Answer answer ) { mockingProgress . stubbingStarted ( ) ; mockingProgress . resetOngoingStubbing ( ) ; [ATTENTION] return new StubberImpl ( ) . StubberImpl ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^122^^^^^119^123^
[REPLACE]  MockHandler<T>  handler  =  mockUtil  .  getMockHandler  (  mock  )  ; 	[BUGGY] MockHandler<T> handler = mockUtil . MockUtil ( )  ; [CE] cannot find symbol  [METHOD]  stubVoid [TYPE] <T> [PARAMETER] T mock [CLASS] MockitoCore  [TYPE] MockHandler handler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> VoidMethodStubbable<T> stubVoid ( T mock ) { [ATTENTION] MockHandler<T> handler = mockUtil . MockUtil ( ) ; mockingProgress . stubbingStarted ( ) ; return handler . voidMethodStubbable ( mock ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^126^^^^^125^129^
[REPLACE]  mockingProgress  .  stubbingStarted  (  )  ; 	[BUGGY] mockingProgress . verificationStarted ( null )  ; [FE] AssertionFailedError [METHOD]  stubVoid [TYPE] <T> [PARAMETER] T mock [CLASS] MockitoCore  [TYPE] MockHandler handler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> VoidMethodStubbable<T> stubVoid ( T mock ) { MockHandler<T> handler = mockUtil . getMockHandler ( mock ) ; [ATTENTION] mockingProgress . verificationStarted ( null ) ; return handler . voidMethodStubbable ( mock ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^127^^^^^125^129^
[REPLACE]  return  handler  .  voidMethodStubbable  (  mock  )  ; 	[BUGGY] return ( DeprecatedOngoingStubbing ) stub ( ) ; [CE] incompatible types  [METHOD]  stubVoid [TYPE] <T> [PARAMETER] T mock [CLASS] MockitoCore  [TYPE] MockHandler handler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public <T> VoidMethodStubbable<T> stubVoid ( T mock ) { MockHandler<T> handler = mockUtil . getMockHandler ( mock ) ; mockingProgress . stubbingStarted ( ) ; [ATTENTION] return ( DeprecatedOngoingStubbing ) stub ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^128^^^^^125^129^
[REPLACE]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] mockingProgress . stubbingStarted ( ) ; [FE] AssertionFailedError [METHOD]  validateMockitoUsage [TYPE] void [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public void validateMockitoUsage ( ) { [ATTENTION] mockingProgress . stubbingStarted ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^132^^^^^131^133^
[ADD]  mockingProgress  .  validateState  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  validateMockitoUsage [TYPE] void [PARAMETER] [CLASS] MockitoCore  [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] Reporter reporter  [CONTEXT]  public void validateMockitoUsage ( ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^132^^^^^131^133^
[REPLACE]  OngoingStubbingImpl  ongoingStubbing  =  (  (  OngoingStubbingImpl  )  mockingProgress  .  pullOngoingStubbing  (  )  )  ; 	[BUGGY] OngoingStubbingImpl ongoingStubbing =  ( ( OngoingStubbingImpl ) mockingProgress . resetOngoingStubbing ( ) ) ; [CE] inconvertible types  [METHOD]  getLastInvocation [TYPE] Invocation [PARAMETER] [CLASS] MockitoCore  [TYPE] List allInvocations [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] Reporter reporter  [CONTEXT]  public Invocation getLastInvocation ( ) { [ATTENTION] OngoingStubbingImpl ongoingStubbing = ( ( OngoingStubbingImpl ) mockingProgress . resetOngoingStubbing ( ) )  ; List<Invocation> allInvocations = ongoingStubbing . getRegisteredInvocations ( ) . getAll ( ) ; return allInvocations . get ( allInvocations . size ( ) -1 ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^139^^^^^138^142^
[REPLACE]  List<Invocation>  allInvocations  =  ongoingStubbing  .  getRegisteredInvocations  (  )    .  getAll  (  )  ; 	[BUGGY] InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) ) ; [CE] cannot find symbol mocks  [METHOD]  getLastInvocation [TYPE] Invocation [PARAMETER] [CLASS] MockitoCore  [TYPE] List allInvocations [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] Reporter reporter  [CONTEXT]  public Invocation getLastInvocation ( ) { OngoingStubbingImpl ongoingStubbing =  ( ( OngoingStubbingImpl ) mockingProgress . pullOngoingStubbing ( ) ) ; [ATTENTION] InOrder inOrder = new InOrderImpl ( Arrays . asList ( mocks ) )  ; return allInvocations . get ( allInvocations . size ( ) -1 ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^140^^^^^138^142^
[REPLACE]  return  allInvocations  .  get  (  allInvocations  .  size  (  )  -1  )  ; 	[BUGGY] return true . get ( allInvocations . size ( ) * 2-1 ) ; [CE] boolean cannot be dereferenced  [METHOD]  getLastInvocation [TYPE] Invocation [PARAMETER] [CLASS] MockitoCore  [TYPE] List allInvocations [TYPE] boolean false true [TYPE] MockingProgress mockingProgress [TYPE] MockUtil mockUtil [TYPE] OngoingStubbingImpl ongoingStubbing [TYPE] Reporter reporter  [CONTEXT]  public Invocation getLastInvocation ( ) { OngoingStubbingImpl ongoingStubbing =  ( ( OngoingStubbingImpl ) mockingProgress . pullOngoingStubbing ( ) ) ; List<Invocation> allInvocations = ongoingStubbing . getRegisteredInvocations ( ) . getAll ( ) ; [ATTENTION] return true . get ( allInvocations . size ( ) *2-1 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/MockitoCore.java^141^^^^^138^142^
[REPLACE]  private  final  CreationValidator  creationValidator; 	[BUGGY] private CreationValidator creationValidator ; [NO-ERROR]  [CONTEXT]    [CLASS] MockUtil  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^21^^^^^^^
[REPLACE]  this  .  creationValidator  =  creationValidator; 	[BUGGY] this . creationValidator =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] CreationValidator) [PARAMETER] CreationValidator creationValidator [CLASS] MockUtil  [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public MockUtil ( CreationValidator creationValidator ) { [ATTENTION] this . creationValidator = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^24^^^^^23^25^
[ADD]  this  .  creationValidator  =  creationValidator; 	[BUGGY] [CE] variable creationValidator might not have been initialized  [METHOD]  <init> [TYPE] CreationValidator) [PARAMETER] CreationValidator creationValidator [CLASS] MockUtil  [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public MockUtil ( CreationValidator creationValidator ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^24^^^^^23^25^
[REPLACE]  this  (  new  CreationValidator  (  )  )  ; 	[BUGGY] throw new NotAMockException (  "   ")  ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] MockUtil() [PARAMETER] [CLASS] MockUtil  [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public MockUtil ( ) { [ATTENTION] throw new NotAMockException (   "   " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^28^^^^^27^29^
[REPLACE]  creationValidator  .  validateType  (  classToMock  )  ; 	[BUGGY] creationValidator . validateType ( true ) ; [CE] method validateType in class CreationValidator cannot be applied to given types ;  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { [ATTENTION] creationValidator . validateType ( true )  ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^32^^^^^31^49^
[REPLACE]  creationValidator  .  validateExtraInterfaces  (  classToMock,  settings  .  getExtraInterfaces  (  )  )  ; 	[BUGGY] creationValidator . validateExtraInterfaces ( this , settings . getSpiedInstance ( )  ) ; [CE] method validateExtraInterfaces in class CreationValidator cannot be applied to given types ;  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; [ATTENTION] creationValidator . validateExtraInterfaces ( this , settings . getSpiedInstance ( )  )  ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^33^^^^^31^49^
[REPLACE]  creationValidator  .  validateExtraInterfaces  (  classToMock,  settings  .  getExtraInterfaces  (  )  )  ; 	[BUGGY] creationValidator . validateExtraInterfaces ( classToMock , settings . getSpiedInstance ( ) ) ; [CE] method validateExtraInterfaces in class CreationValidator cannot be applied to given types ;  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; [ATTENTION] creationValidator . validateExtraInterfaces ( classToMock , settings . getSpiedInstance ( ) )  ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^33^^^^^31^49^
[ADD]  creationValidator  .  validateExtraInterfaces  (  classToMock,  settings  .  getExtraInterfaces  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertFalse(creationValidator.extraInterfacesValidated)   [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; [ATTENTION]  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^33^^^^^31^49^
[REPLACE]  MockName  mockName  =  new  MockName  (  settings  .  getMockName  (  )  ,  classToMock  )  ; 	[BUGGY] MockName mockName = new MockName ( settings . getMockName ( ) , null ) ; [FE] AssertionFailedError [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  [ATTENTION] MockName mockName = new MockName ( settings . getMockName ( )  , null )  ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^35^^^^^31^49^
[REPLACE]  MockHandler<T>  mockHandler  =  new  MockHandler<T>  (  mockName,  progress,  new  MatchersBinder  (  )  ,  settings  )  ; 	[BUGGY] MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [CE] variable mockName is already defined in method <T>createMock(Class<T> , MockingProgress , MockSettingsImpl)  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [ATTENTION] MockName mockName = new MockName ( settings . getMockName ( )  , classToMock )  ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^36^^^^^31^49^
[ADD]  MockHandler<T>  mockHandler  =  new  MockHandler<T>  (  mockName,  progress,  new  MatchersBinder  (  )  ,  settings  )  ; 	[BUGGY] [CE] cannot find symbol mockHandler  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [ATTENTION] MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^36^^^^^31^49^
[REPLACE]  MethodInterceptorFilter<MockHandler<T>>  filter  =  new  MethodInterceptorFilter<MockHandler<T>>  (  classToMock,  mockHandler  )  ; 	[BUGGY] MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , false ) ; [CE] constructor MethodInterceptorFilter in class MethodInterceptorFilter<T#2> cannot be applied to given types ;  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; [ATTENTION] MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , false )  ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^37^^^^^31^49^
[REPLACE]  Class<?>[]  interfaces  =  settings  .  getExtraInterfaces  (  )  ; 	[BUGGY] Class<?>[] interfaces = settings . getSpiedInstance ( ) ; [CE] incompatible types  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; [ATTENTION] Class<?>[] interfaces = settings . getSpiedInstance ( )  ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^38^^^^^31^49^
[REPLACE]  Class<?>[]  ancillaryTypes  =  interfaces  ==  null  ?  new  Class<?>[0]  :  interfaces; 	[BUGGY] Class<?>[] ancillaryTypes  =  interfaces ; [FE] AssertionFailedError [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; [ATTENTION] Class<?>[] ancillaryTypes = interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^39^^^^^31^49^
[REPLACE]  Object  spiedInstance  =  settings  .  getSpiedInstance  (  )  ; 	[BUGGY] Object spiedInstance = settings . getMockName ( ) ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; [ATTENTION] Object spiedInstance = settings . getMockName ( )  ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^40^^^^^31^49^
[REPLACE]  T  mock  =  ClassImposterizer  .  INSTANCE  .  imposterise  (  filter,  classToMock,  ancillaryTypes  )  ; 	[BUGGY] T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , false ) ; [CE] method imposterise in class ClassImposterizer cannot be applied to given types ;  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  [ATTENTION] T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , false )  ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^42^^^^^31^49^
[REPLACE]  if  (  spiedInstance  !=  null  )  { 	[BUGGY] if ( spiedInstance = = null ) {[FE] AssertionFailedError [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  [ATTENTION] if ( spiedInstance = = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^44^^^^^31^49^
[REPLACE]  new  LenientCopyTool  (  )    .  copyToMock  (  spiedInstance,  mock  )  ; 	[BUGGY] Object spiedInstance = settings . getSpiedInstance ( ) ; [CE] variable spiedInstance is already defined in method <T>createMock(Class<T> , MockingProgress , MockSettingsImpl)  [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { [ATTENTION] Object spiedInstance = settings . getSpiedInstance ( )  ; } return mock ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^45^^^^^31^49^
[REPLACE]  return  mock; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  createMock [TYPE] <T> [PARAMETER] Class<T> classToMock MockingProgress progress MockSettingsImpl settings [CLASS] MockUtil  [TYPE] MockName mockName [TYPE] Class[] ancillaryTypes interfaces [TYPE] boolean false true [TYPE] T mock [TYPE] MockSettingsImpl settings [TYPE] CreationValidator creationValidator [TYPE] Class classToMock [TYPE] MockHandler mockHandler [TYPE] Object spiedInstance [TYPE] MockingProgress progress [TYPE] MethodInterceptorFilter filter  [CONTEXT]  public <T> T createMock ( Class<T> classToMock , MockingProgress progress , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; creationValidator . validateExtraInterfaces ( classToMock , settings . getExtraInterfaces ( ) ) ;  MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; MockHandler<T> mockHandler = new MockHandler<T> ( mockName , progress , new MatchersBinder ( ) , settings ) ; MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>> ( classToMock , mockHandler ) ; Class<?>[] interfaces = settings . getExtraInterfaces ( ) ; Class<?>[] ancillaryTypes = interfaces = = null ? new Class<?>[0] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;  T mock = ClassImposterizer . INSTANCE . imposterise ( filter , classToMock , ancillaryTypes ) ;  if ( spiedInstance ! = null ) { new LenientCopyTool ( ) . copyToMock ( spiedInstance , mock ) ; } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^48^^^^^31^49^
[REPLACE]  MockHandler<T>  oldMockHandler  =  (  MockHandler<T>  )  getMockHandler  (  mock  )  ; 	[BUGGY] MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [CE] cannot find symbol settings  [METHOD]  resetMock [TYPE] <T> [PARAMETER] T mock MockingProgress progress [CLASS] MockUtil  [TYPE] MockHandler newMockHandler oldMockHandler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress progress [TYPE] CreationValidator creationValidator [TYPE] MethodInterceptorFilter newFilter  [CONTEXT]  public <T> void resetMock ( T mock , MockingProgress progress ) { [ATTENTION] MockName mockName = new MockName ( settings . getMockName ( )  , classToMock )  ; MockHandler<T> newMockHandler = new MockHandler<T> ( oldMockHandler ) ; MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>> ( Object . class , newMockHandler ) ;  ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^52^^^^^51^56^
[REPLACE]  MockHandler<T>  newMockHandler  =  new  MockHandler<T>  (  oldMockHandler  )  ; 	[BUGGY] MockHandler<T> newMockHandler = new MockHandler<T> ( 1 ) ; [CE] no suitable constructor found for MockHandler(int)  [METHOD]  resetMock [TYPE] <T> [PARAMETER] T mock MockingProgress progress [CLASS] MockUtil  [TYPE] MockHandler newMockHandler oldMockHandler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress progress [TYPE] CreationValidator creationValidator [TYPE] MethodInterceptorFilter newFilter  [CONTEXT]  public <T> void resetMock ( T mock , MockingProgress progress ) { MockHandler<T> oldMockHandler =  ( MockHandler<T> ) getMockHandler ( mock ) ; [ATTENTION] MockHandler<T> newMockHandler = new MockHandler<T> ( 1 )  ; MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>> ( Object . class , newMockHandler ) ;  ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^53^^^^^51^56^
[REPLACE]  MethodInterceptorFilter<MockHandler<T>>  newFilter  =  new  MethodInterceptorFilter<MockHandler<T>>  (  Object  .  class,  newMockHandler  )  ; 	[BUGGY] MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>> ( Object . class , true ) ; [CE] constructor MethodInterceptorFilter in class MethodInterceptorFilter<T#2> cannot be applied to given types ;  [METHOD]  resetMock [TYPE] <T> [PARAMETER] T mock MockingProgress progress [CLASS] MockUtil  [TYPE] MockHandler newMockHandler oldMockHandler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress progress [TYPE] CreationValidator creationValidator [TYPE] MethodInterceptorFilter newFilter  [CONTEXT]  public <T> void resetMock ( T mock , MockingProgress progress ) { MockHandler<T> oldMockHandler =  ( MockHandler<T> ) getMockHandler ( mock ) ; MockHandler<T> newMockHandler = new MockHandler<T> ( oldMockHandler ) ; [ATTENTION] MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>> ( Object . class , true )  ;  ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^54^^^^^51^56^
[REPLACE]  (  (  Factory  )  mock  )    .  setCallback  (  0,  newFilter  )  ; 	[BUGGY] ( ( Factory ) mock ) . setCallback ( 1 , newFilter ) ; [FE]  org.mockito.internal.creation.MethodInterceptorFilter cannot be cast to org.mockito.cglib.proxy.NoOp assertContains(  "Mock for IMethods  " ,   "  " + mockTwo)   [METHOD]  resetMock [TYPE] <T> [PARAMETER] T mock MockingProgress progress [CLASS] MockUtil  [TYPE] MockHandler newMockHandler oldMockHandler [TYPE] boolean false true [TYPE] T mock [TYPE] MockingProgress progress [TYPE] CreationValidator creationValidator [TYPE] MethodInterceptorFilter newFilter  [CONTEXT]  public <T> void resetMock ( T mock , MockingProgress progress ) { MockHandler<T> oldMockHandler =  ( MockHandler<T> ) getMockHandler ( mock ) ; MockHandler<T> newMockHandler = new MockHandler<T> ( oldMockHandler ) ; MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>> ( Object . class , newMockHandler ) ; [ATTENTION] ( ( Factory ) mock )  . setCallback ( 1 , newFilter )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^55^^^^^51^56^
[REPLACE]  if  (  mock  ==  null  )  { 	[BUGGY] if ( mock ! = null ) {[FE] AssertionFailedError [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { [ATTENTION] if ( mock ! = null ) { throw new NotAMockException (   "Argument should be a mock , but is null!  " ) ; } if ( isMockitoMock ( mock ) ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { throw new NotAMockException (   "Argument should be a mock , but is:   " + mock . getClass ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^59^^^^^58^68^
[REPLACE]  throw  new  NotAMockException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { [ATTENTION] return ; } if ( isMockitoMock ( mock ) ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { throw new NotAMockException (   "Argument should be a mock , but is:   " + mock . getClass ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^60^^^^^58^68^
[ADD]  throw  new  NotAMockException  (  "    ")  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { [ATTENTION] } if ( isMockitoMock ( mock ) ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { throw new NotAMockException (   "Argument should be a mock , but is:   " + mock . getClass ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^60^^^^^58^68^
[REPLACE]  if  (  isMockitoMock  (  mock  )  )  { 	[BUGGY] if ( mock = = null ) {[FE] AssertionFailedError [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { throw new NotAMockException (   "Argument should be a mock , but is null!  " ) ; } [ATTENTION] if ( mock = = null ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { throw new NotAMockException (   "Argument should be a mock , but is:   " + mock . getClass ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^63^^^^^58^68^
[REPLACE]  throw  new  NotAMockException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { throw new NotAMockException (   "Argument should be a mock , but is null!  " ) ; } if ( isMockitoMock ( mock ) ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { [ATTENTION] return ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^66^^^^^58^68^
[REPLACE]  throw  new  NotAMockException  (  "    ")  ; 	[BUGGY] MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [CE] cannot find symbol settings  [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { throw new NotAMockException (   "Argument should be a mock , but is null!  " ) ; } if ( isMockitoMock ( mock ) ) { return getInterceptor ( mock ) . getDelegate ( ) ; } else { [ATTENTION] MockName mockName = new MockName ( settings . getMockName ( )  , classToMock )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^66^^^^^58^68^
[REPLACE]  return  getInterceptor  (  mock  )    .  getDelegate  (  )  ; 	[BUGGY] return Enhancer . isEnhanced ( mock . getClass ( ) ) && getInterceptor ( mock ) ! = null ; [CE] incompatible types  [METHOD]  getMockHandler [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public <T> MockHandler<T> getMockHandler ( T mock ) { if ( mock = = null ) { throw new NotAMockException (   "Argument should be a mock , but is null!  " ) ; } if ( isMockitoMock ( mock ) ) { [ATTENTION] return Enhancer . isEnhanced ( mock . getClass ( ) ) && getInterceptor ( mock ) ! = null ; } else { throw new NotAMockException (   "Argument should be a mock , but is:   " + mock . getClass ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^64^^^^^58^68^
[REPLACE]  return  Enhancer  .  isEnhanced  (  mock  .  getClass  (  )  )  &&  getInterceptor  (  mock  )  !=  null; 	[BUGGY] return Enhancer . isEnhanced ( mock . getClass ( ) )  ; [FE] AssertionFailedError [METHOD]  isMockitoMock [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] T mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  private <T> boolean isMockitoMock ( T mock ) { [ATTENTION] return Enhancer . isEnhanced ( mock . getClass ( ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^71^^^^^70^72^
[REPLACE]  return  mock  !=  null  &&  isMockitoMock  (  mock  )  ; 	[BUGGY] return  isMockitoMock ( mock ) ; [NO-ERROR]  [METHOD]  isMock [TYPE] boolean [PARAMETER] Object mock [CLASS] MockUtil  [TYPE] Object mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public boolean isMock ( Object mock ) { [ATTENTION] return isMockitoMock ( mock )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^75^^^^^74^76^
[REPLACE]  Factory  factory  =  (  Factory  )  mock; 	[BUGGY] MockName mockName = new MockName ( settings . getMockName ( ) , classToMock ) ; [CE] cannot find symbol settings  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { [ATTENTION] MockName mockName = new MockName ( settings . getMockName ( )  , classToMock )  ; Callback callback = factory . getCallback ( 0 ) ; if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter<MockHandler<T>> ) callback ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^80^^^^^79^86^
[ADD]  Factory  factory  =  (  Factory  )  mock;  Callback  callback  =  factory  .  getCallback  (  0  )  ; 	[BUGGY] Callback callback = factory . getCallback ( 0 ) ; [CE] cannot find symbol factory  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { [ATTENTION] Callback callback = factory . getCallback ( 0 )  ;  if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter<MockHandler<T>> ) callback ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^80^81^^^^79^86^
[REPLACE]  Callback  callback  =  factory  .  getCallback  (  0  )  ; 	[BUGGY] Callback callback = factory . getCallback ( 0L ) ; [CE] method getCallback in interface Factory cannot be applied to given types ;  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { Factory factory =  ( Factory ) mock ; [ATTENTION] Callback callback = factory . getCallback ( 0L )  ; if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter<MockHandler<T>> ) callback ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^81^^^^^79^86^
[REPLACE]  if  (  callback  instanceof  MethodInterceptorFilter  )  { 	[BUGGY] if ( ! callback instanceof MethodInterceptorFilter ) {[CE] bad operand type Callback for unary operator '!'  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { Factory factory =  ( Factory ) mock ; Callback callback = factory . getCallback ( 0 ) ; [ATTENTION] if ( ! callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter<MockHandler<T>> ) callback ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^82^^^^^79^86^
[REPLACE]  return  (  MethodInterceptorFilter<MockHandler<T>>  )  callback; 	[BUGGY] return getInterceptor ( mock ) . getDelegate ( ) ; [CE] incompatible types  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { Factory factory =  ( Factory ) mock ; Callback callback = factory . getCallback ( 0 ) ; if ( callback instanceof MethodInterceptorFilter ) { [ATTENTION] return getInterceptor ( mock )  . getDelegate ( )  ; } return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^83^^^^^79^86^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  getInterceptor [TYPE] <T> [PARAMETER] T mock [CLASS] MockUtil  [TYPE] Factory factory [TYPE] Callback callback [TYPE] boolean false true [TYPE] T mock [TYPE] CreationValidator creationValidator  [CONTEXT]  private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor ( T mock ) { Factory factory =  ( Factory ) mock ; Callback callback = factory . getCallback ( 0 ) ; if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter<MockHandler<T>> ) callback ; } [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^85^^^^^79^86^
[REPLACE]  return  getMockHandler  (  mock  )    .  getMockName  (  )  ; 	[BUGGY] return getMockHandler ( mock )  . getSpiedInstance ( )  ; [CE] cannot find symbol  [METHOD]  getMockName [TYPE] MockName [PARAMETER] Object mock [CLASS] MockUtil  [TYPE] Object mock [TYPE] CreationValidator creationValidator [TYPE] boolean false true  [CONTEXT]  public MockName getMockName ( Object mock ) { [ATTENTION] return getMockHandler ( mock ) . getSpiedInstance ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockUtil.java^89^^^^^88^90^
[REPLACE]  LinkedList<T>  filtered  =  new  LinkedList<T>  (  )  ; 	[BUGGY] for ( T t : collection ) { if ( !filter . isOut ( t ) ) {[CE] illegal start of expression  [METHOD]  filter [TYPE] <T> [PARAMETER] Collection<T> collection Filter<T> filter [CLASS] ListUtil  [TYPE] boolean false true [TYPE] T t [TYPE] Filter filter [TYPE] Collection collection [TYPE] LinkedList filtered  [CONTEXT]  public static <T> LinkedList<T> filter ( Collection<T> collection , Filter<T> filter ) { [ATTENTION] for ( T t : collection ) { if ( !filter . isOut ( t ) ) { for ( T t : collection ) { if ( !filter . isOut ( t ) ) { filtered . add ( t ) ; } } return filtered ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/ListUtil.java^13^^^^^12^20^
[REPLACE]  if  (  !filter  .  isOut  (  t  )  )  { 	[BUGGY] if ( !filter . isOut ( t )  ) {[NO-ERROR]  [METHOD]  filter [TYPE] <T> [PARAMETER] Collection<T> collection Filter<T> filter [CLASS] ListUtil  [TYPE] boolean false true [TYPE] T t [TYPE] Filter filter [TYPE] Collection collection [TYPE] LinkedList filtered  [CONTEXT]  public static <T> LinkedList<T> filter ( Collection<T> collection , Filter<T> filter ) { LinkedList<T> filtered = new LinkedList<T> ( ) ; for ( T t : collection ) { [ATTENTION] if ( !filter . isOut ( t )  ) { filtered . add ( t ) ; } } return filtered ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/ListUtil.java^15^^^^^12^20^
[REPLACE]  filtered  .  add  (  t  )  ; 	[BUGGY] filtered . LinkedList ( )  ; [CE] cannot find symbol  [METHOD]  filter [TYPE] <T> [PARAMETER] Collection<T> collection Filter<T> filter [CLASS] ListUtil  [TYPE] boolean false true [TYPE] T t [TYPE] Filter filter [TYPE] Collection collection [TYPE] LinkedList filtered  [CONTEXT]  public static <T> LinkedList<T> filter ( Collection<T> collection , Filter<T> filter ) { LinkedList<T> filtered = new LinkedList<T> ( ) ; for ( T t : collection ) { if ( !filter . isOut ( t ) ) { [ATTENTION] filtered . LinkedList ( ) ; } } return filtered ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/ListUtil.java^16^^^^^12^20^
[REPLACE]  for  (  T  t  :  collection  )  { 	[BUGGY] for ( T t : collection ) { if ( !filter . isOut ( t ) ) {[CE] illegal start of expression  [METHOD]  filter [TYPE] <T> [PARAMETER] Collection<T> collection Filter<T> filter [CLASS] ListUtil  [TYPE] boolean false true [TYPE] T t [TYPE] Filter filter [TYPE] Collection collection [TYPE] LinkedList filtered  [CONTEXT]  public static <T> LinkedList<T> filter ( Collection<T> collection , Filter<T> filter ) { LinkedList<T> filtered = new LinkedList<T> ( ) ; [ATTENTION] for ( T t : collection ) { if ( !filter . isOut ( t ) ) { if ( !filter . isOut ( t ) ) { filtered . add ( t ) ; } } return filtered ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/ListUtil.java^14^^^^^12^20^
[REPLACE]  return  filtered; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  filter [TYPE] <T> [PARAMETER] Collection<T> collection Filter<T> filter [CLASS] ListUtil  [TYPE] boolean false true [TYPE] T t [TYPE] Filter filter [TYPE] Collection collection [TYPE] LinkedList filtered  [CONTEXT]  public static <T> LinkedList<T> filter ( Collection<T> collection , Filter<T> filter ) { LinkedList<T> filtered = new LinkedList<T> ( ) ; for ( T t : collection ) { if ( !filter . isOut ( t ) ) { filtered . add ( t ) ; } } [ATTENTION] return this ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/ListUtil.java^19^^^^^12^20^
[REPLACE]  if  (  mockName  ==  null  )  { 	[BUGGY] if ( mockName ! = null ) {[FE]  AssertionFailedError  expected:<[iMethods].simpleMethod()   [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { [ATTENTION] if ( mockName ! = null ) { this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; } else { this . mockName = mockName ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^14^^^^^13^20^
[REPLACE]  this  .  mockName  =  mockName; 	[BUGGY] this . mockName =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { if ( mockName = = null ) { this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; } else { [ATTENTION] this . mockName = null ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^18^^^^^13^20^
[REPLACE]  this  .  mockName  =  toInstanceName  (  classToMock  )  ; 	[BUGGY] this . mockName =  toInstanceName ( null ) ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { if ( mockName = = null ) { [ATTENTION] this . mockName = toInstanceName ( null )  ; this . surrogate = true ; } else { this . mockName = mockName ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^15^^^^^13^20^
[ADD]  this  .  mockName  =  toInstanceName  (  classToMock  )  ;  this  .  surrogate  =  true; 	[BUGGY] this . surrogate = true ; [CE] variable mockName might not have been initialized  [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { if ( mockName = = null ) { [ATTENTION] this . surrogate = true ;  } else { this . mockName = mockName ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^15^16^^^^13^20^
[REPLACE]  this  .  surrogate  =  true; 	[BUGGY] this . surrogate = false ; [FE]  AssertionFailedError  expected:<[Mock for DummyClass , hashCode: 1023714065]> but was:<[dummyClass]> assertEquals(  "Mock for DummyClass , hashCode:   " + dummyClass.hashCode() , dummyClass.toString())   [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { if ( mockName = = null ) { this . mockName = toInstanceName ( classToMock ) ; [ATTENTION] this . surrogate = false ; } else { this . mockName = mockName ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^16^^^^^13^20^
[ADD]  this  .  mockName  =  mockName; 	[BUGGY] [CE] variable mockName might not have been initialized  [METHOD]  <init> [TYPE] Class) [PARAMETER] String mockName Class classToMock [CLASS] MockName  [TYPE] Class classToMock [TYPE] boolean false surrogate true [TYPE] String mockName  [CONTEXT]  public MockName ( String mockName , Class classToMock ) { if ( mockName = = null ) { this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; } else { [ATTENTION] } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^18^^^^^13^20^
[REPLACE]  String  className  =  clazz  .  getSimpleName  (  )  ; 	[BUGGY] String className = null . getSimpleName ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  toInstanceName [TYPE] String [PARAMETER] Class<?> clazz [CLASS] MockName  [TYPE] Class clazz [TYPE] boolean false surrogate true [TYPE] String className mockName  [CONTEXT]  private static String toInstanceName ( Class<?> clazz ) { [ATTENTION] String className = null . getSimpleName ( )  ;  return className . substring ( 0 , 1 ) . toLowerCase ( ) + className . substring ( 1 ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^23^^^^^22^26^
[ADD]  String  className  =  clazz  .  getSimpleName  (  )  ; 	[BUGGY] [CE] cannot find symbol className  [METHOD]  toInstanceName [TYPE] String [PARAMETER] Class<?> clazz [CLASS] MockName  [TYPE] Class clazz [TYPE] boolean false surrogate true [TYPE] String className mockName  [CONTEXT]  private static String toInstanceName ( Class<?> clazz ) { [ATTENTION]  return className . substring ( 0 , 1 ) . toLowerCase ( ) + className . substring ( 1 ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^23^^^^^22^26^
[REPLACE]  return  className  .  substring  (  0,  1  )    .  toLowerCase  (  )  +  className  .  substring  (  1  )  ; 	[BUGGY] return className . substring ( 2 , 1 ) . toLowerCase ( )  & className . substring ( 1 ) ; [CE] bad operand types for binary operator '&'  [METHOD]  toInstanceName [TYPE] String [PARAMETER] Class<?> clazz [CLASS] MockName  [TYPE] Class clazz [TYPE] boolean false surrogate true [TYPE] String className mockName  [CONTEXT]  private static String toInstanceName ( Class<?> clazz ) { String className = clazz . getSimpleName ( ) ;  [ATTENTION] return className . substring ( 2 , 1 )  . toLowerCase ( ) &className . substring ( 1 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^25^^^^^22^26^
[REPLACE]  return  surrogate; 	[BUGGY] return mockName ; [CE] incompatible types  [METHOD]  isSurrogate [TYPE] boolean [PARAMETER] [CLASS] MockName  [TYPE] boolean false surrogate true [TYPE] String className mockName  [CONTEXT]  public boolean isSurrogate ( ) { [ATTENTION] return mockName ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^29^^^^^28^30^
[REPLACE]  return  mockName; 	[BUGGY] return surrogate ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] MockName  [TYPE] boolean false surrogate true [TYPE] String className mockName  [CONTEXT]  public String toString ( ) { [ATTENTION] return surrogate ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockName.java^34^^^^^33^35^
[REPLACE]  StringBuilder  out  =  new  StringBuilder  (    "\n  "  )  ; 	[BUGGY] int lastBreak = out . lastIndexOf (   "\n  " ) ; [CE] cannot find symbol out  [METHOD]  join [TYPE] String [PARAMETER] linesToBreak [CLASS] StringJoiner  [TYPE] boolean false true [TYPE] StringBuilder out [TYPE] Object line [TYPE] Object[] linesToBreak [TYPE] int lastBreak  [CONTEXT]  public static String join ( Object . . . linesToBreak ) { [ATTENTION] int lastBreak = out . lastIndexOf (   "\n  " )  ; for ( Object line : linesToBreak ) { out . append ( line . toString ( ) ) . append (   "\n  " ) ; } int lastBreak = out . lastIndexOf (   "\n  " ) ; return out . replace ( lastBreak , lastBreak+1 ,   "  " ) . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/StringJoiner.java^10^^^^^9^16^
[REPLACE]  for  (  Object  line  :  linesToBreak  )  { 	[BUGGY] for ( Object line : linesToBreak ) { out . append ( line . toString ( ) ) . append (   "\n  " ) ; [FE]  AssertionFailedError  expected:<...ost 1 time but was 2[]> but was:<...ost 1 time but was 2[ assertEquals(  "\nWanted at most 1 time but was 2  " , e.getMessage())   [METHOD]  join [TYPE] String [PARAMETER] linesToBreak [CLASS] StringJoiner  [TYPE] boolean false true [TYPE] StringBuilder out [TYPE] Object line [TYPE] Object[] linesToBreak [TYPE] int lastBreak  [CONTEXT]  public static String join ( Object . . . linesToBreak ) { StringBuilder out = new StringBuilder (   "\n  " ) ; [ATTENTION] for ( Object line : linesToBreak ) { out . append ( line . toString ( ) )  . append (   "\n  " )  ; out . append ( line . toString ( ) ) . append (   "\n  " ) ; } int lastBreak = out . lastIndexOf (   "\n  " ) ; return out . replace ( lastBreak , lastBreak+1 ,   "  " ) . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/StringJoiner.java^11^^^^^9^16^
[REPLACE]  int  lastBreak  =  out  .  lastIndexOf  (    "\n  "  )  ; 	[BUGGY] int lastBreak = out . append (   "\n  " ) ; [CE] incompatible types  [METHOD]  join [TYPE] String [PARAMETER] linesToBreak [CLASS] StringJoiner  [TYPE] boolean false true [TYPE] StringBuilder out [TYPE] Object line [TYPE] Object[] linesToBreak [TYPE] int lastBreak  [CONTEXT]  public static String join ( Object . . . linesToBreak ) { StringBuilder out = new StringBuilder (   "\n  " ) ; for ( Object line : linesToBreak ) { out . append ( line . toString ( ) ) . append (   "\n  " ) ; } [ATTENTION] int lastBreak = out . append (   "\n  " )  ; return out . replace ( lastBreak , lastBreak+1 ,   "  " ) . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/StringJoiner.java^14^^^^^9^16^
[REPLACE]  return  out  .  replace  (  lastBreak,  lastBreak+1,    "  "  )    .  toString  (  )  ; 	[BUGGY] return out . StringBuilder ( this )  . toString ( ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  join [TYPE] String [PARAMETER] linesToBreak [CLASS] StringJoiner  [TYPE] boolean false true [TYPE] StringBuilder out [TYPE] Object line [TYPE] Object[] linesToBreak [TYPE] int lastBreak  [CONTEXT]  public static String join ( Object . . . linesToBreak ) { StringBuilder out = new StringBuilder (   "\n  " ) ; for ( Object line : linesToBreak ) { out . append ( line . toString ( ) ) . append (   "\n  " ) ; } int lastBreak = out . lastIndexOf (   "\n  " ) ; [ATTENTION] return out . StringBuilder ( this ) . toString ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/StringJoiner.java^15^^^^^9^16^
[REPLACE]  if  (  className  .  length  (  )  ==  0  )  { 	[BUGGY] if ( className . size ( )  = = 0 ) {[CE] cannot find symbol  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { [ATTENTION] if ( className . size ( ) = = 0 ) { return   "<custom argument matcher>  " ; } String decamelized = decamelizeClassName ( className ) ;  if ( decamelized . length ( )  = = 0 ) { return   "<  " + className +   ">  " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^15^^^^^14^26^
[ADD]  if  (  className  .  length  (  )  ==  0  )  {  return    "<custom  argument  matcher>  ";  } 	[BUGGY] return   "<custom argument matcher>  " ; [CE] unreachable statement  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { [ATTENTION] return   "<custom argument matcher>  " ;   String decamelized = decamelizeClassName ( className ) ;  if ( decamelized . length ( )  = = 0 ) { return   "<  " + className +   ">  " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^15^16^17^^^14^26^
[REPLACE]  return    "<custom  argument  matcher>  "; 	[BUGGY] return   "<  " + className +   ">  " ; [FE]  AssertionFailedError  expected:<<[custom argument matcher]>> but was:<<[]>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { [ATTENTION] return   "<  " + className +   ">  " ; } String decamelized = decamelizeClassName ( className ) ;  if ( decamelized . length ( )  = = 0 ) { return   "<  " + className +   ">  " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^16^^^^^14^26^
[REPLACE]  String  decamelized  =  decamelizeClassName  (  className  )  ; 	[BUGGY] String decamelized = decamelizeClassName ( decamelized ) ; [CE] variable decamelized might not have been initialized  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { return   "<custom argument matcher>  " ; } [ATTENTION] String decamelized = decamelizeClassName ( decamelized )  ;  if ( decamelized . length ( )  = = 0 ) { return   "<  " + className +   ">  " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^19^^^^^14^26^
[REPLACE]  if  (  decamelized  .  length  (  )  ==  0  )  { 	[BUGGY] if ( decamelized . toLowerCase ( )  % 0 . 5  = = 0 ) {[CE] ')' expected  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { return   "<custom argument matcher>  " ; } String decamelized = decamelizeClassName ( className ) ;  [ATTENTION] if ( decamelized . toLowerCase ( ) %0 . 5 = = 0 ) { return   "<  " + className +   ">  " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^21^^^^^14^26^
[ADD]  if  (  decamelized  .  length  (  )  ==  0  )  {  return    "<  "  +  className  +    ">  ";  } 	[BUGGY] [FE]  AssertionFailedError  expected:<<[_]>> but was:<<[]>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { return   "<custom argument matcher>  " ; } String decamelized = decamelizeClassName ( className ) ;  [ATTENTION]   return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^21^22^23^^^14^26^
[REPLACE]  return    "<  "  +  className  +    ">  "; 	[BUGGY] return   " ; [CE] unclosed string literal  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { return   "<custom argument matcher>  " ; } String decamelized = decamelizeClassName ( className ) ;  if ( decamelized . length ( )  = = 0 ) { [ATTENTION] return   " ; } return   "<  " + decamelized +   ">  " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^22^^^^^14^26^
[REPLACE]  return    "<  "  +  decamelized  +    ">  "; 	[BUGGY] return   " ; [CE] unclosed string literal  [METHOD]  decamelizeMatcher [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className decamelized [TYPE] boolean false true  [CONTEXT]  public static String decamelizeMatcher ( String className ) { if ( className . length ( )  = = 0 ) { return   "<custom argument matcher>  " ; } String decamelized = decamelizeClassName ( className ) ;  if ( decamelized . length ( )  = = 0 ) { return   "<  " + className +   ">  " ; } [ATTENTION] return   " ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^25^^^^^14^26^
[REPLACE]  Matcher  match  =  CAPS  .  matcher  (  className  )  ; 	[BUGGY] String decamelized = decamelizeClassName ( className ) ; [CE] cannot find symbol match  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { [ATTENTION] String decamelized = decamelizeClassName ( className )  ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^29^^^^^28^40^
[REPLACE]  StringBuilder  deCameled  =  new  StringBuilder  (  )  ; 	[BUGGY] String decamelized = decamelizeClassName ( className ) ; [CE] cannot find symbol deCameled  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; [ATTENTION] String decamelized = decamelizeClassName ( className )  ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^30^^^^^28^40^
[ADD]  StringBuilder  deCameled  =  new  StringBuilder  (  )  ; 	[BUGGY] [CE] cannot find symbol deCameled  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; [ATTENTION] while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^30^^^^^28^40^
[REPLACE]  if  (  deCameled  .  length  (  )  ==  0  )  { 	[BUGGY] if ( deCameled . length ( ) % 2 = = 0 ) {[FE]  AssertionFailedError  expected:<<Sentence[ with strong l]anguage>> but was:<<Sentence[WithStrongL]anguage>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { [ATTENTION] if ( deCameled . length ( ) %2 = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^32^^^^^28^40^
[ADD]  if  (  deCameled  .  length  (  )  ==  0  )  {  deCameled  .  append  (  match  .  group  (  )  )  ;  }  else  {  deCameled  .  append  (    "    "  )  ;  deCameled  .  append  (  match  .  group  (  )    .  toLowerCase  (  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { [ATTENTION]   } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^32^33^34^35^36^28^40^
[REPLACE]  deCameled  .  append  (    "    "  )  ; 	[BUGGY] deCameled . append ( match . group ( ) ) ; [FE]  AssertionFailedError  expected:<<Sentence[ with strong ]language>> but was:<<Sentence[WithwithStrongstrongLanguage]language>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { [ATTENTION] deCameled . append ( match . group ( ) )  ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^35^^^^^28^40^
[REPLACE]  deCameled  .  append  (  match  .  group  (  )    .  toLowerCase  (  )  )  ; 	[BUGGY] deCameled . append ( match . group ( )  . length ( )  ) ; [FE]  AssertionFailedError  expected:<<Sentence [with strong language]>> but was:<<Sentence [4 6 8]>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; [ATTENTION] deCameled . append ( match . group ( ) . length ( )  )  ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^36^^^^^28^40^
[REPLACE]  deCameled  .  append  (  match  .  group  (  )    .  toLowerCase  (  )  )  ; 	[BUGGY] if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; [CE] reached end of file while parsing  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; [ATTENTION] if ( deCameled . length ( ) = = 0 ) { deCameled . append ( match . group ( ) )  ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^36^^^^^28^40^
[REPLACE]  deCameled  .  append  (  match  .  group  (  )    .  toLowerCase  (  )  )  ; 	[BUGGY] deCameled . append ( match . find ( ) . toLowerCase ( ) ) ; [CE] boolean cannot be dereferenced  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; [ATTENTION] deCameled . append ( match . find ( )  . toLowerCase ( ) )  ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^36^^^^^28^40^
[REPLACE]  deCameled  .  append  (  match  .  group  (  )  )  ; 	[BUGGY] deCameled . append ( match . find ( ) ) ; [FE]  AssertionFailedError  expected:<<[Sentence with] strong language>> but was:<<[true] strong language>> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { [ATTENTION] deCameled . append ( match . find ( ) )  ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^33^^^^^28^40^
[REPLACE]  if  (  deCameled  .  length  (  )  ==  0  )  { 	[BUGGY] if ( deCameled . length ( ) - 3 = = 0 ) {[FE]  AssertionFailedError  expected:<<[S]entence with strong ...> but was:<<[ s]entence with strong ...> assertEquals(  "<Sentence with strong language>  " , decamelizeMatcher(  "SentenceWithStrongLanguage  "))   [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { [ATTENTION] if ( deCameled . length ( ) - 3 = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } return deCameled . toString ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^32^^^^^28^40^
[REPLACE]  return  deCameled  .  toString  (  )  ; 	[BUGGY] return deCameled . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  decamelizeClassName [TYPE] String [PARAMETER] String className [CLASS] Decamelizer  [TYPE] Pattern CAPS [TYPE] String className [TYPE] boolean false true [TYPE] StringBuilder deCameled [TYPE] Matcher match  [CONTEXT]  private static String decamelizeClassName ( String className ) { Matcher match = CAPS . matcher ( className ) ; StringBuilder deCameled = new StringBuilder ( ) ; while ( match . find ( ) ) { if ( deCameled . length ( )  = = 0 ) { deCameled . append ( match . group ( ) ) ; } else { deCameled . append (   "   " ) ; deCameled . append ( match . group ( ) . toLowerCase ( ) ) ; } } [ATTENTION] return deCameled . StringBuilder ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Decamelizer.java^39^^^^^28^40^
[REPLACE]  if  (  !ClassImposterizer  .  INSTANCE  .  canImposterise  (  classToMock  )  )  { 	[BUGGY] if ( ! classToMock  ) {[CE] bad operand type Class for unary operator '!'  [METHOD]  validateType [TYPE] void [PARAMETER] Class classToMock [CLASS] CreationValidator  [TYPE] boolean false true [TYPE] Class classToMock  [CONTEXT]  public void validateType ( Class classToMock ) { [ATTENTION] if ( !classToMock ) { new Reporter ( ) . cannotMockFinalClass ( classToMock ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^14^^^^^13^17^
[REPLACE]  new  Reporter  (  )    .  cannotMockFinalClass  (  classToMock  )  ; 	[BUGGY] new Reporter ( ) . extraInterfacesCannotContainMockedType ( classToMock ) ; [FE]   assertContains(  "Cannot mock/spy  " , e.getMessage())   [METHOD]  validateType [TYPE] void [PARAMETER] Class classToMock [CLASS] CreationValidator  [TYPE] boolean false true [TYPE] Class classToMock  [CONTEXT]  public void validateType ( Class classToMock ) { if ( !ClassImposterizer . INSTANCE . canImposterise ( classToMock ) ) { [ATTENTION] new Reporter ( )  . extraInterfacesCannotContainMockedType ( classToMock )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^15^^^^^13^17^
[REPLACE]  if  (  extraInterfaces  ==  null  )  { 	[BUGGY] if ( extraInterfaces ! = null ) {[FE] AssertionFailedError [METHOD]  validateExtraInterfaces [TYPE] void [PARAMETER] Class classToMock extraInterfaces [CLASS] CreationValidator  [TYPE] Class[] extraInterfaces [TYPE] boolean false true [TYPE] Class classToMock i  [CONTEXT]  public void validateExtraInterfaces ( Class classToMock , Class . . . extraInterfaces ) { [ATTENTION] if ( extraInterfaces ! = null ) { return ; } for ( Class i : extraInterfaces ) { if ( classToMock = = i ) { new Reporter ( ) . extraInterfacesCannotContainMockedType ( classToMock ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^20^^^^^19^29^
[REPLACE]  if  (  classToMock  ==  i  )  { 	[BUGGY] if ( classToMock && i ) {[CE] bad operand types for binary operator '&&'  [METHOD]  validateExtraInterfaces [TYPE] void [PARAMETER] Class classToMock extraInterfaces [CLASS] CreationValidator  [TYPE] Class[] extraInterfaces [TYPE] boolean false true [TYPE] Class classToMock i  [CONTEXT]  public void validateExtraInterfaces ( Class classToMock , Class . . . extraInterfaces ) { if ( extraInterfaces = = null ) { return ; } for ( Class i : extraInterfaces ) { [ATTENTION] if ( classToMock&&i ) { new Reporter ( ) . extraInterfacesCannotContainMockedType ( classToMock ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^25^^^^^19^29^
[REPLACE]  new  Reporter  (  )    .  extraInterfacesCannotContainMockedType  (  classToMock  )  ; 	[BUGGY] new Reporter ( ) . cannotMockFinalClass ( classToMock ) ; [FE]   assertContains(  "You mocked following type: IMethods  " , e.getMessage())   [METHOD]  validateExtraInterfaces [TYPE] void [PARAMETER] Class classToMock extraInterfaces [CLASS] CreationValidator  [TYPE] Class[] extraInterfaces [TYPE] boolean false true [TYPE] Class classToMock i  [CONTEXT]  public void validateExtraInterfaces ( Class classToMock , Class . . . extraInterfaces ) { if ( extraInterfaces = = null ) { return ; } for ( Class i : extraInterfaces ) { if ( classToMock = = i ) { [ATTENTION] new Reporter ( )  . cannotMockFinalClass ( classToMock )  ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^26^^^^^19^29^
[REPLACE]  for  (  Class  i  :  extraInterfaces  )  { 	[BUGGY] for ( Class i : extraInterfaces ) { if ( classToMock = = i ) {[CE] reached end of file while parsing  [METHOD]  validateExtraInterfaces [TYPE] void [PARAMETER] Class classToMock extraInterfaces [CLASS] CreationValidator  [TYPE] Class[] extraInterfaces [TYPE] boolean false true [TYPE] Class classToMock i  [CONTEXT]  public void validateExtraInterfaces ( Class classToMock , Class . . . extraInterfaces ) { if ( extraInterfaces = = null ) { return ; } [ATTENTION] for ( Class i : extraInterfaces ) { if ( classToMock = = i ) { if ( classToMock = = i ) { new Reporter ( ) . extraInterfacesCannotContainMockedType ( classToMock ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/CreationValidator.java^24^^^^^19^29^
[REPLACE]  private  static  Map<Class<?>,  Object>  wrapperReturnValues  =  new  HashMap<Class<?>,  Object>  (  )  ; 	[BUGGY] private Map<Class<?> , Object> wrapperReturnValues = new HashMap<Class<?> , Object> ( ) ; [CE] non-static variable wrapperReturnValues cannot be referenced from a static context  [CONTEXT]    [CLASS] Primitives  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Primitives.java^24^^^^^^^
[REPLACE]  private  static  Map<Class<?>,  Class<?>>  primitiveTypes  =  new  HashMap<Class<?>,  Class<?>>  (  )  ; 	[BUGGY] private static Map<Class<?> , Class<?>> primitiveTypes  = null ; [FE] [CONTEXT]    [CLASS] Primitives  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Primitives.java^25^^^^^^^
[REPLACE]  return  wrapperReturnValues  .  containsKey  (  type  )  ; 	[BUGGY] return wrapperReturnValues . get ( false ) ; [CE] incompatible types  [METHOD]  isPrimitiveWrapper [TYPE] boolean [PARAMETER] Class<?> type [CLASS] Primitives  [TYPE] Map primitiveTypes wrapperReturnValues [TYPE] Class type [TYPE] boolean false true  [CONTEXT]  public static boolean isPrimitiveWrapper ( Class<?> type ) { [ATTENTION] return wrapperReturnValues . get ( false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Primitives.java^13^^^^^12^14^
[REPLACE]  return  wrapperReturnValues  .  get  (  type  )  ; 	[BUGGY] return wrapperReturnValues . get ( this ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  primitiveWrapperOf [TYPE] Object [PARAMETER] Class<?> type [CLASS] Primitives  [TYPE] Map primitiveTypes wrapperReturnValues [TYPE] Class type [TYPE] boolean false true  [CONTEXT]  public static Object primitiveWrapperOf ( Class<?> type ) { [ATTENTION] return wrapperReturnValues . get ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Primitives.java^17^^^^^16^18^
[REPLACE]  return  primitiveTypes  .  get  (  clazz  )  ; 	[BUGGY] return primitiveTypes . get ( false ) ; [FE]   assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing())   [METHOD]  primitiveTypeOf [TYPE] Class [PARAMETER] Class<?> clazz [CLASS] Primitives  [TYPE] Map primitiveTypes wrapperReturnValues [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static Class<?> primitiveTypeOf ( Class<?> clazz ) { [ATTENTION] return primitiveTypes . get ( false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/Primitives.java^21^^^^^20^22^
[REPLACE]  private  Boolean  wasAccessible  =  null; 	[BUGGY] private Boolean wasAccessible  = null ; [NO-ERROR]  [CONTEXT]    [CLASS] AccessibilityChanger  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/AccessibilityChanger.java^11^^^^^^^
[ADD]  try  {  field  .  setAccessible  (  wasAccessible  )  ;  }  catch  (  Throwable  t  )  {  } 	[BUGGY] field . setAccessible ( wasAccessible ) ; [NO-ERROR]  [METHOD]  safelyDisableAccess [TYPE] void [PARAMETER] Field field [CLASS] AccessibilityChanger  [TYPE] Field field [TYPE] Throwable t [TYPE] boolean false true [TYPE] Boolean wasAccessible  [CONTEXT]  public void safelyDisableAccess ( Field field ) { assert wasAccessible ! = null ; [ATTENTION] field . setAccessible ( wasAccessible )  ;    }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/AccessibilityChanger.java^18^19^20^^22^16^23^
[REPLACE]  field  .  setAccessible  (  wasAccessible  )  ; 	[BUGGY] field . isAccessible ( )  ; [NO-ERROR]  [METHOD]  safelyDisableAccess [TYPE] void [PARAMETER] Field field [CLASS] AccessibilityChanger  [TYPE] Field field [TYPE] Throwable t [TYPE] boolean false true [TYPE] Boolean wasAccessible  [CONTEXT]  public void safelyDisableAccess ( Field field ) { assert wasAccessible ! = null ; try { [ATTENTION] field . isAccessible ( ) ; } catch ( Throwable t ) {  } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/AccessibilityChanger.java^19^^^^^16^23^
[REPLACE]  wasAccessible  =  field  .  isAccessible  (  )  ; 	[BUGGY] wasAccessible =  null . isAccessible ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  enableAccess [TYPE] void [PARAMETER] Field field [CLASS] AccessibilityChanger  [TYPE] Boolean wasAccessible [TYPE] Field field [TYPE] boolean false true  [CONTEXT]  public void enableAccess ( Field field ) { [ATTENTION] wasAccessible = null . isAccessible ( )  ; field . setAccessible ( true ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/AccessibilityChanger.java^29^^^^^28^31^
[REPLACE]  field  .  setAccessible  (  true  )  ; 	[BUGGY] field . setAccessible ( false ) ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  enableAccess [TYPE] void [PARAMETER] Field field [CLASS] AccessibilityChanger  [TYPE] Boolean wasAccessible [TYPE] Field field [TYPE] boolean false true  [CONTEXT]  public void enableAccess ( Field field ) { wasAccessible = field . isAccessible ( ) ; [ATTENTION] field . setAccessible ( false )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/AccessibilityChanger.java^30^^^^^28^31^
[REPLACE]  Object  value  =  field  .  get  (  from  )  ; 	[BUGGY] Object value = field . get ( to ) ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValue [TYPE] <T> [PARAMETER] T from T to Field field [CLASS] FieldCopier  [TYPE] Field field [TYPE] boolean false true [TYPE] T from to [TYPE] Object value  [CONTEXT]  public <T> void copyValue ( T from , T to , Field field ) throws IllegalAccessException { [ATTENTION] Object value = field . get ( to )  ; field . set ( to , value ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/FieldCopier.java^12^^^^^11^14^
[REPLACE]  field  .  set  (  to,  value  )  ; 	[BUGGY] field . set ( from , value ) ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValue [TYPE] <T> [PARAMETER] T from T to Field field [CLASS] FieldCopier  [TYPE] Field field [TYPE] boolean false true [TYPE] T from to [TYPE] Object value  [CONTEXT]  public <T> void copyValue ( T from , T to , Field field ) throws IllegalAccessException { Object value = field . get ( from ) ; [ATTENTION] field . set ( from , value )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/FieldCopier.java^13^^^^^11^14^
[REPLACE]  FieldCopier  fieldCopier  =  new  FieldCopier  (  )  ; 	[BUGGY] FieldCopier fieldCopier  = null ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [CONTEXT]    [CLASS] LenientCopyTool  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^13^^^^^^^
[REPLACE]  Class  clazz  =  from  .  getClass  (  )  ; 	[BUGGY] Field[] fields = classFrom . getDeclaredFields ( ) ; [CE] cannot find symbol classFrom  [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { [ATTENTION] Field[] fields = classFrom . getDeclaredFields ( )  ; Class mockSuperClass = mock . getClass ( ) . getSuperclass ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  while ( clazz ! = Object . class ) { copyValues ( from , mock , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^16^^^^^15^25^
[ADD]  Class  clazz  =  from  .  getClass  (  )  ; 	[BUGGY] [CE] cannot find symbol clazz  [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { [ATTENTION] Class mockSuperClass = mock . getClass ( ) . getSuperclass ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  while ( clazz ! = Object . class ) { copyValues ( from , mock , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^16^^^^^15^25^
[REPLACE]  Class  mockSuperClass  =  mock  .  getClass  (  )    .  getSuperclass  (  )  ; 	[BUGGY] Class mockSuperClass = mock . getClass ( )  . getDeclaredFields ( )  ; [CE] incompatible types  [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { Class clazz = from . getClass ( ) ; [ATTENTION] Class mockSuperClass = mock . getClass ( ) . getDeclaredFields ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  while ( clazz ! = Object . class ) { copyValues ( from , mock , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^17^^^^^15^25^
[REPLACE]  while  (  clazz  !=  Object  .  class  )  { 	[BUGGY] while ( clazz  = =  Object . class ) {[FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { Class clazz = from . getClass ( ) ; Class mockSuperClass = mock . getClass ( ) . getSuperclass ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  [ATTENTION] while ( clazz = = Object . class ) { copyValues ( from , mock , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^21^^^^^15^25^
[ADD]  while  (  clazz  !=  Object  .  class  )  {  copyValues  (  from,  mock,  clazz  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { Class clazz = from . getClass ( ) ; Class mockSuperClass = mock . getClass ( ) . getSuperclass ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  [ATTENTION]  clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^21^22^^^^15^25^
[REPLACE]  clazz  =  clazz  .  getSuperclass  (  )  ; 	[BUGGY] clazz =  mockSuperClass . getSuperclass ( ) ; [FE] AssertionFailedError [METHOD]  copyToMock [TYPE] <T> [PARAMETER] T from T mock [CLASS] LenientCopyTool  [TYPE] Class clazz mockSuperClass [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier  [CONTEXT]  public <T> void copyToMock ( T from , T mock ) { Class clazz = from . getClass ( ) ; Class mockSuperClass = mock . getClass ( ) . getSuperclass ( ) ; assert mockSuperClass = = clazz :   "Classes must have the same type: class of the object from:   " + clazz +   " , mock super class:   " + mockSuperClass ;  while ( clazz ! = Object . class ) { copyValues ( from , mock , clazz ) ; [ATTENTION] clazz = mockSuperClass . getSuperclass ( )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^23^^^^^15^25^
[REPLACE]  Field[]  fields  =  classFrom  .  getDeclaredFields  (  )  ; 	[BUGGY] Field[] fields = classFrom . getSuperclass ( )  ; [CE] incompatible types  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { [ATTENTION] Field[] fields = classFrom . getSuperclass ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^28^^^^^27^46^
[REPLACE]  if  (  Modifier  .  isStatic  (  field  .  getModifiers  (  )  )  )  { 	[BUGGY] if (  field . getModifiers ( )  ) {[CE] incompatible types  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; [ATTENTION] if ( field . getModifiers ( )  ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^33^^^^^27^46^
[REPLACE]  for  (  int  i  =  0;  i  <  fields  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < fields . length % 2 ; i++ ) {[FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  [ATTENTION] for ( int i = 0 ; i < fields . length %2 ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^30^^^^^27^46^
[ADD]  for  (  int  i  =  0;  i  <  fields  .  length;  i++  )  {  Field  field  =  fields[i];  if  (  Modifier  .  isStatic  (  field  .  getModifiers  (  )  )  )  {  continue; 	[BUGGY] [CE] illegal start of type  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  [ATTENTION]   } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^30^31^32^33^34^27^46^
[ADD]  try  {  accessibilityChanger  .  enableAccess  (  field  )  ;  fieldCopier  .  copyValue  (  from,  mock,  field  )  ;  }  catch  (  Throwable  t  )  { 	[BUGGY] accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; [CE] 'finally' without 'try'  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; [ATTENTION] accessibilityChanger . enableAccess ( field )  ; fieldCopier . copyValue ( from , mock , field )  ;   } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^37^38^39^40^41^27^46^
[REPLACE]  accessibilityChanger  .  enableAccess  (  field  )  ; 	[BUGGY] accessibilityChanger . safelyDisableAccess ( field ) ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { [ATTENTION] accessibilityChanger . safelyDisableAccess ( field )  ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^38^^^^^27^46^
[REPLACE]  fieldCopier  .  copyValue  (  from,  mock,  field  )  ; 	[BUGGY] fieldCopier . FieldCopier ( )  ; [CE] cannot find symbol  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; [ATTENTION] fieldCopier . FieldCopier ( ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^39^^^^^27^46^
[ADD]  fieldCopier  .  copyValue  (  from,  mock,  field  )  ; 	[BUGGY] [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; [ATTENTION] } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^39^^^^^27^46^
[REPLACE]  Field  field  =  fields[i]; 	[BUGGY] Field[] fields = classFrom . getDeclaredFields ( ) ; [CE] variable fields is already defined in method <T>copyValues(T , T , Class)  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  [ATTENTION] Field[] fields = classFrom . getDeclaredFields ( )  ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^32^^^^^27^46^
[ADD]  Field  field  =  fields[i]; 	[BUGGY] [CE] cannot find symbol field  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  [ATTENTION] if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^32^^^^^27^46^
[REPLACE]  AccessibilityChanger  accessibilityChanger  =  new  AccessibilityChanger  (  )  ; 	[BUGGY] Class clazz = from . getClass ( ) ; [CE] cannot find symbol accessibilityChanger  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } [ATTENTION] Class clazz = from . getClass ( )  ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^36^^^^^27^46^
[ADD]  accessibilityChanger  .  enableAccess  (  field  )  ; 	[BUGGY] [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { [ATTENTION] fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^38^^^^^27^46^
[REPLACE]  for  (  int  i  =  0;  i  <  fields  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < fields . length ; i++ ) {[NO-ERROR]  [METHOD]  copyValues [TYPE] <T> [PARAMETER] T from T mock Class classFrom [CLASS] LenientCopyTool  [TYPE] Field field [TYPE] boolean false true [TYPE] T from mock [TYPE] FieldCopier fieldCopier [TYPE] AccessibilityChanger accessibilityChanger [TYPE] Throwable t [TYPE] Class classFrom [TYPE] Field[] fields [TYPE] int i  [CONTEXT]  private <T> void copyValues ( T from , T mock , Class classFrom ) { Field[] fields = classFrom . getDeclaredFields ( ) ;  [ATTENTION] for ( int i = 0 ; i < fields . length ; i++ ) {  Field field = fields[i] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } AccessibilityChanger accessibilityChanger = new AccessibilityChanger ( ) ; try { accessibilityChanger . enableAccess ( field ) ; fieldCopier . copyValue ( from , mock , field ) ; } catch ( Throwable t ) {  } finally { accessibilityChanger . safelyDisableAccess ( field ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/copy/LenientCopyTool.java^30^^^^^27^46^
[REPLACE]  System  .  out  .  println  (  what  .  toString  (  )  )  ; 	[BUGGY] System . out . println ( what . Object ( )  ) ; [CE] cannot find symbol  [METHOD]  log [TYPE] void [PARAMETER] Object what [CLASS] MockitoLoggerImpl  [TYPE] boolean false true [TYPE] Object what  [CONTEXT]  public void log ( Object what ) { [ATTENTION] System . out . println ( what . Object ( )  )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockitoLoggerImpl.java^13^^^^^12^14^
[ADD]  System  .  out  .  println  (  what  .  toString  (  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  log [TYPE] void [PARAMETER] Object what [CLASS] MockitoLoggerImpl  [TYPE] boolean false true [TYPE] Object what  [CONTEXT]  public void log ( Object what ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/util/MockitoLoggerImpl.java^13^^^^^12^14^
[REPLACE]  Class  configClass  =  null; 	[BUGGY] Class configClass = false ; [CE] incompatible types  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  [ATTENTION] Class configClass = false ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^18^^^^^16^35^
[ADD]  Class  configClass  =  null; 	[BUGGY] [CE] cannot find symbol configClass  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  [ATTENTION] try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^18^^^^^16^35^
[ADD]  try  {  configClass  =  (  Class  )  Class  .  forName  (    "org  .  mockito  .  configuration  .  MockitoConfiguration  "  )  ;  }  catch  (  ClassNotFoundException  e  )  {  return  null; 	[BUGGY] configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; return null ; [CE] illegal start of type  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; [ATTENTION] configClass = ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " )  ; return null ;    } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^19^20^21^^23^16^35^
[REPLACE]  configClass  =  (  Class  )  Class  .  forName  (    "org  .  mockito  .  configuration  .  MockitoConfiguration  "  )  ; 	[BUGGY] configClass  =  configClass ; [CE] exception ClassNotFoundException is never thrown in body of corresponding try statement  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { [ATTENTION] configClass = configClass ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^20^^^^^16^35^
[ADD]  configClass  =  (  Class  )  Class  .  forName  (    "org  .  mockito  .  configuration  .  MockitoConfiguration  "  )  ;  }  catch  (  ClassNotFoundException  e  )  {  return  null;  } 	[BUGGY] [CE] 'try' without 'catch' or 'finally'  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { [ATTENTION]    try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^20^21^^23^24^16^35^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  [ATTENTION] return false ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^23^^^^^16^35^
[ADD]  try  {  return  (  IMockitoConfiguration  )  configClass  .  newInstance  (  )  ;  }  catch  (  ClassCastException  e  )  {  throw  new  MockitoConfigurationException  (    "\n  "  +    "MockitoConfiguration  class  must  implement  org  .  mockito  .  configuration  .  IMockitoConfiguration  interface  .    ",  e  )  ; 	[BUGGY] return ( IMockitoConfiguration ) configClass . newInstance ( ) ;   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; [CE] not a statement  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } [ATTENTION] return ( IMockitoConfiguration ) configClass . newInstance ( )  ;   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e )  ;   } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^26^27^28^29^30^16^35^
[REPLACE]  return  (  IMockitoConfiguration  )  configClass  .  newInstance  (  )  ; 	[BUGGY] return ( IMockitoConfiguration ) configClass . forName ( null )  ; [CE] inconvertible types  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { [ATTENTION] return ( IMockitoConfiguration ) configClass . forName ( null ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^27^^^^^16^35^
[REPLACE]  throw  new  MockitoConfigurationException  (    "\n  "  +    "MockitoConfiguration  class  must  implement  org  .  mockito  .  configuration  .  IMockitoConfiguration  interface  .    ",  e  )  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { [ATTENTION] return ;  } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^29^30^^^^16^35^
[ADD]  throw  new  MockitoConfigurationException  (    "\n  "  +    "MockitoConfiguration  class  must  implement  org  .  mockito  .  configuration  .  IMockitoConfiguration  interface  .    ",  e  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { [ATTENTION]  } catch ( Exception e ) { throw new MockitoConfigurationException (   "\n  " +   "Unable to instantianate org . mockito . configuration . MockitoConfiguration class . Does it have a safe , no-arg constructor?  " , e ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^29^30^^^^16^35^
[REPLACE]  throw  new  MockitoConfigurationException  (    "\n  "  +    "Unable  to  instantianate  org  .  mockito  .  configuration  .  MockitoConfiguration  class  .    Does  it  have  a  safe,  no-arg  constructor?  ",  e  )  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { [ATTENTION] return ;  } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^32^33^^^^16^35^
[ADD]  throw  new  MockitoConfigurationException  (    "\n  "  +    "Unable  to  instantianate  org  .  mockito  .  configuration  .  MockitoConfiguration  class  .    Does  it  have  a  safe,  no-arg  constructor?  ",  e  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  loadConfiguration [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] ClassPathLoader  [TYPE] boolean false true [TYPE] ClassCastException e [TYPE] Class configClass [TYPE] ClassNotFoundException e [TYPE] Exception e  [CONTEXT]  public IMockitoConfiguration loadConfiguration ( ) {  Class configClass = null ; try { configClass =  ( Class ) Class . forName (   "org . mockito . configuration . MockitoConfiguration  " ) ; } catch ( ClassNotFoundException e ) {  return null ; } try { return ( IMockitoConfiguration ) configClass . newInstance ( ) ; } catch ( ClassCastException e ) { throw new MockitoConfigurationException (   "\n  " +   "MockitoConfiguration class must implement org . mockito . configuration . IMockitoConfiguration interface .   " , e ) ; } catch ( Exception e ) { [ATTENTION]  } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/ClassPathLoader.java^32^33^^^^16^35^
[REPLACE]  if  (  annotation  instanceof  Mock  ||  annotation  instanceof  org  .  mockito  .  MockitoAnnotations  .  Mock  )  { 	[BUGGY] if ( ! annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) {[CE] bad operand type Annotation for unary operator '!'  [METHOD]  createMockFor [TYPE] Object [PARAMETER] Annotation annotation Field field [CLASS] DefaultAnnotationEngine  [TYPE] Field field [TYPE] boolean false true [TYPE] Annotation annotation  [CONTEXT]  public Object createMockFor ( Annotation annotation , Field field ) { [ATTENTION] if ( ! annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) { return Mockito . mock ( field . getType ( ) , field . getName ( ) ) ; } else { return null ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java^27^^^^^26^32^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] AssertionFailedError [METHOD]  createMockFor [TYPE] Object [PARAMETER] Annotation annotation Field field [CLASS] DefaultAnnotationEngine  [TYPE] Field field [TYPE] boolean false true [TYPE] Annotation annotation  [CONTEXT]  public Object createMockFor ( Annotation annotation , Field field ) { if ( annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) { return Mockito . mock ( field . getType ( ) , field . getName ( ) ) ; } else { [ATTENTION] return true ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java^30^^^^^26^32^
[REPLACE]  return  Mockito  .  mock  (  field  .  getType  (  )  ,  field  .  getName  (  )  )  ; 	[BUGGY] return Mockito . mock ( field . getType ( ) , field . getType ( )  ) ; [CE] no suitable method found for mock(Class<CAP#1> , Class<CAP#2>)  [METHOD]  createMockFor [TYPE] Object [PARAMETER] Annotation annotation Field field [CLASS] DefaultAnnotationEngine  [TYPE] Field field [TYPE] boolean false true [TYPE] Annotation annotation  [CONTEXT]  public Object createMockFor ( Annotation annotation , Field field ) { if ( annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) { [ATTENTION] return Mockito . mock ( field . getType ( )  , field . getType ( )  )  ; } else { return null ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java^28^^^^^26^32^
[REPLACE]  return  Mockito  .  mock  (  field  .  getType  (  )  ,  field  .  getName  (  )  )  ; 	[BUGGY] return  field . getType ( )  ) ; [CE] ' ; ' expected  [METHOD]  createMockFor [TYPE] Object [PARAMETER] Annotation annotation Field field [CLASS] DefaultAnnotationEngine  [TYPE] Field field [TYPE] boolean false true [TYPE] Annotation annotation  [CONTEXT]  public Object createMockFor ( Annotation annotation , Field field ) { if ( annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) { [ATTENTION] return field . getType ( )  )  ; } else { return null ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java^28^^^^^26^32^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  createMockFor [TYPE] Object [PARAMETER] Annotation annotation Field field [CLASS] DefaultAnnotationEngine  [TYPE] Field field [TYPE] boolean false true [TYPE] Annotation annotation  [CONTEXT]  public Object createMockFor ( Annotation annotation , Field field ) { if ( annotation instanceof Mock || annotation instanceof org . mockito . MockitoAnnotations . Mock ) { return Mockito . mock ( field . getType ( ) , field . getName ( ) ) ; } else { [ATTENTION] return false ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java^30^^^^^26^32^
[REPLACE]  private  static  ThreadLocal<IMockitoConfiguration>  globalConfiguration  =  new  ThreadLocal<IMockitoConfiguration>  (  )  ; 	[BUGGY] private static ThreadLocal<IMockitoConfiguration> globalConfiguration ; [FE] [CONTEXT]    [CLASS] GlobalConfiguration  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^19^^^^^^^
[REPLACE]  if  (  globalConfiguration  .  get  (  )  ==  null  )  { 	[BUGGY] if ( globalConfiguration . get ( ) ! = this ) {[FE]  AssertionFailedError  expected:<foo> but was:<null> assertEquals(  "foo  " , mock.simpleMethod())   [METHOD]  <init> [TYPE] GlobalConfiguration() [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public GlobalConfiguration ( ) {  [ATTENTION] if ( globalConfiguration . get ( ) ! = this ) { globalConfiguration . set ( createConfig ( ) ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^28^^^^^26^31^
[ADD]  if  (  globalConfiguration  .  get  (  )  ==  null  )  {  globalConfiguration  .  set  (  createConfig  (  )  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  <init> [TYPE] GlobalConfiguration() [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public GlobalConfiguration ( ) {  [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^28^29^30^^^26^31^
[REPLACE]  globalConfiguration  .  set  (  createConfig  (  )  )  ; 	[BUGGY] globalConfiguration . get ( )  ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] GlobalConfiguration() [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public GlobalConfiguration ( ) {  if ( globalConfiguration . get ( )  = = null ) { [ATTENTION] globalConfiguration . get ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^29^^^^^26^31^
[REPLACE]  globalConfiguration  .  set  (  createConfig  (  )  )  ; 	[BUGGY] if ( globalConfiguration . get ( )  = = null ) { globalConfiguration . set ( createConfig ( ) ) ; [CE] ' ; ' expected  [METHOD]  <init> [TYPE] GlobalConfiguration() [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public GlobalConfiguration ( ) {  if ( globalConfiguration . get ( )  = = null ) { [ATTENTION] if ( globalConfiguration . get ( ) = = null ) { globalConfiguration . set ( createConfig ( ) )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^29^^^^^26^31^
[REPLACE]  return  globalConfiguration  .  get  (  )  ; 	[BUGGY] return globalConfiguration . set ( null )  ; [CE] incompatible types  [METHOD]  getIt [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  IMockitoConfiguration getIt ( ) { [ATTENTION] return globalConfiguration . set ( null ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^23^^^^^22^24^
[REPLACE]  IMockitoConfiguration  defaultConfiguration  =  new  DefaultMockitoConfiguration  (  )  ; 	[BUGGY] IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; [CE] variable config is already defined in method createConfig()  [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { [ATTENTION] IMockitoConfiguration config = new ClassPathLoader ( )  . loadConfiguration ( )  ; IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; if ( config ! = null ) { return config ; } else { return defaultConfiguration ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^35^^^^^34^42^
[ADD]  IMockitoConfiguration  defaultConfiguration  =  new  DefaultMockitoConfiguration  (  )  ; 	[BUGGY] [CE] cannot find symbol defaultConfiguration  [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { [ATTENTION] IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; if ( config ! = null ) { return config ; } else { return defaultConfiguration ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^35^^^^^34^42^
[REPLACE]  IMockitoConfiguration  config  =  new  ClassPathLoader  (  )    .  loadConfiguration  (  )  ; 	[BUGGY] IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( ) ; [CE] variable defaultConfiguration is already defined in method createConfig()  [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( ) ; [ATTENTION] IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( )  ; if ( config ! = null ) { return config ; } else { return defaultConfiguration ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^36^^^^^34^42^
[REPLACE]  if  (  config  !=  null  )  { 	[BUGGY] if (defaultConfiguration = = this ) {[FE] AssertionFailedError [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( ) ; IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; [ATTENTION] if ( defaultConfiguration = = this ) { return config ; } else { return defaultConfiguration ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^37^^^^^34^42^
[REPLACE]  return  defaultConfiguration; 	[BUGGY] return config ; [NO-ERROR]  [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( ) ; IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; if ( config ! = null ) { return config ; } else { [ATTENTION] return config ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^40^^^^^34^42^
[REPLACE]  return  config; 	[BUGGY] return defaultConfiguration ; [FE] AssertionFailedError [METHOD]  createConfig [TYPE] IMockitoConfiguration [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] IMockitoConfiguration config defaultConfiguration [TYPE] boolean false true  [CONTEXT]  private IMockitoConfiguration createConfig ( ) { IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration ( ) ; IMockitoConfiguration config = new ClassPathLoader ( ) . loadConfiguration ( ) ; if ( config ! = null ) { [ATTENTION] return defaultConfiguration ; } else { return defaultConfiguration ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^38^^^^^34^42^
[REPLACE]  return  globalConfiguration  .  get  (  )    .  getReturnValues  (  )  ; 	[BUGGY] return globalConfiguration . get ( ) . getDefaultAnswer ( ) ; [CE] incompatible types  [METHOD]  getReturnValues [TYPE] ReturnValues [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public ReturnValues getReturnValues ( ) { [ATTENTION] return globalConfiguration . get ( )  . getDefaultAnswer ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^49^^^^^48^50^
[REPLACE]  return  globalConfiguration  .  get  (  )    .  getAnnotationEngine  (  )  ; 	[BUGGY] return defaultConfiguration ; [CE] cannot find symbol defaultConfiguration  [METHOD]  getAnnotationEngine [TYPE] AnnotationEngine [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public AnnotationEngine getAnnotationEngine ( ) { [ATTENTION] return defaultConfiguration ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^53^^^^^52^54^
[REPLACE]  return  globalConfiguration  .  get  (  )    .  cleansStackTrace  (  )  ; 	[BUGGY] return defaultConfiguration ; [CE] cannot find symbol defaultConfiguration  [METHOD]  cleansStackTrace [TYPE] boolean [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public boolean cleansStackTrace ( ) { [ATTENTION] return defaultConfiguration ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^57^^^^^56^58^
[REPLACE]  return  globalConfiguration  .  get  (  )    .  getDefaultAnswer  (  )  ; 	[BUGGY] return globalConfiguration . get ( ) . getReturnValues ( ) ; [CE] incompatible types  [METHOD]  getDefaultAnswer [TYPE] Answer [PARAMETER] [CLASS] GlobalConfiguration  [TYPE] ThreadLocal globalConfiguration [TYPE] boolean false true  [CONTEXT]  public Answer<Object> getDefaultAnswer ( ) { [ATTENTION] return globalConfiguration . get ( )  . getReturnValues ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/configuration/GlobalConfiguration.java^61^^^^^60^62^
[REPLACE]  private  static  final  int  MAX_LINE_LENGTH  =  45; 	[BUGGY] private static final int MAX_LINE_LENGTH ; [CE] variable MAX_LINE_LENGTH might not have been initialized  [CONTEXT]    [CLASS] Invocation  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^36^^^^^^^
[REPLACE]  private  final  int  sequenceNumber; 	[BUGGY] private final short sequenceNumber ; [CE] possible loss of precision  [CONTEXT]    [CLASS] Invocation  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^37^^^^^^^
[REPLACE]  private  final  Method  method; 	[BUGGY] private Method method ; [NO-ERROR]  [CONTEXT]    [CLASS] Invocation  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^39^^^^^^^
[REPLACE]  private  final  Object[]  arguments; 	[BUGGY] private Object[] arguments ; [NO-ERROR]  [CONTEXT]    [CLASS] Invocation  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^40^^^^^^^
[REPLACE]  final  RealMethod  realMethod; 	[BUGGY] RealMethod realMethod ; [NO-ERROR]  [CONTEXT]    [CLASS] Invocation  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^46^^^^^^^
[REPLACE]  this  .  mock  =  mock; 	[BUGGY] this . mock =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { [ATTENTION] this . mock = null ; this . method = method ; this . realMethod = realMethod ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^49^^^^^48^56^
[REPLACE]  this  .  method  =  method; 	[BUGGY] this . realMethod = realMethod ;  ; [CE] variable realMethod might already have been assigned  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; [ATTENTION] this . realMethod = realMethod ;  ; this . realMethod = realMethod ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^50^^^^^48^56^
[REPLACE]  this  .  realMethod  =  realMethod; 	[BUGGY] this . method = method ;  ; [CE] variable method might already have been assigned  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; [ATTENTION] this . method = method ;  ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^51^^^^^48^56^
[ADD]  this  .  realMethod  =  realMethod; 	[BUGGY] [CE] variable realMethod might not have been initialized  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; [ATTENTION] this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^51^^^^^48^56^
[REPLACE]  this  .  arguments  =  expandVarArgs  (  method  .  isVarArgs  (  )  ,  args  )  ; 	[BUGGY] this . arguments =  expandVarArgs ( null . isVarArgs ( ) , args ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; this . realMethod = realMethod ; [ATTENTION] this . arguments = expandVarArgs ( null . isVarArgs ( )  , args )  ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^52^^^^^48^56^
[REPLACE]  this  .  rawArguments  =  args; 	[BUGGY] this . rawArguments =  rawArguments ; [NO-ERROR]  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; this . realMethod = realMethod ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; [ATTENTION] this . rawArguments = rawArguments ; this . sequenceNumber = sequenceNumber ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^53^^^^^48^56^
[REPLACE]  this  .  sequenceNumber  =  sequenceNumber; 	[BUGGY] this . sequenceNumber =  MAX_LINE_LENGTH ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; this . realMethod = realMethod ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; [ATTENTION] this . sequenceNumber = MAX_LINE_LENGTH ; this . location = new Location ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^54^^^^^48^56^
[REPLACE]  this  .  location  =  new  Location  (  )  ; 	[BUGGY] this . location =  new PrintSettings ( )  ; [CE] incompatible types  [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] Object mock Method method Object[] args int sequenceNumber RealMethod realMethod [CLASS] Invocation  [TYPE] boolean false true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH sequenceNumber [TYPE] Object[] args arguments rawArguments [TYPE] Location location  [CONTEXT]  public Invocation ( Object mock , Method method , Object[] args , int sequenceNumber , RealMethod realMethod ) { this . mock = mock ; this . method = method ; this . realMethod = realMethod ; this . arguments = expandVarArgs ( method . isVarArgs ( ) , args ) ; this . rawArguments = args ; this . sequenceNumber = sequenceNumber ; [ATTENTION] this . location = new PrintSettings ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^55^^^^^48^56^
[REPLACE]  if  (  !isVarArgs  ||  isVarArgs  &&  args[args  .  length  -  1]  !=  null  &&  !args[args  .  length  -  1]  .  getClass  (  )    .  isArray  (  )  )  { 	[BUGGY] if ( verifiedInOrder && args[args . length - 3 - 1] ! = null && !args[args . length - 3 - 1] . getClass ( ) . isArray ( ) ) {[CE] non-static variable verifiedInOrder cannot be referenced from a static context  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { [ATTENTION] if ( verifiedInOrder && args[args . length - 3 - 1] ! = null && !args[args . length - 3 - 1] . getClass ( )  . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^61^^^^^60^78^
[REPLACE]  return  args  ==  null  ?  new  Object[0]  :  args; 	[BUGGY] return  new Object[0] ; [FE]  0 assertEquals(3 , invocations.size())   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { [ATTENTION] return new Object[0] ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^62^^^^^60^78^
[REPLACE]  return  args  ==  null  ?  new  Object[0]  :  args; 	[BUGGY] return args ; [NO-ERROR]  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { [ATTENTION] return args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^62^^^^^60^78^
[REPLACE]  final  int  nonVarArgsCount  =  args  .  length  -  1; 	[BUGGY] final int nonVarArgsCount = args . length + 0 - 0 ; [FE]  1 assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } [ATTENTION] final int nonVarArgsCount = args . length + 0- 0 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^65^^^^^60^78^
[REPLACE]  Object[]  varArgs; 	[BUGGY] final int varArgsCount = varArgs . length ; [CE] cannot find symbol varArgs  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; [ATTENTION] final int varArgsCount = varArgs . length ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^66^^^^^60^78^
[ADD]  Object[]  varArgs; 	[BUGGY] [CE] cannot find symbol varArgs  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; [ATTENTION] if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^66^^^^^60^78^
[REPLACE]  if  (  args[nonVarArgsCount]  ==  null  )  { 	[BUGGY] if ( args[nonVarArgsCount] ! = null ) {[FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; [ATTENTION] if ( args[nonVarArgsCount] ! = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^67^^^^^60^78^
[REPLACE]  varArgs  =  ArrayEquals  .  createObjectArray  (  args[nonVarArgsCount]  )  ; 	[BUGGY] varArgs =  ArrayEquals . createObjectArray ( rawArguments[nonVarArgsCount] ) ; [CE] non-static variable rawArguments cannot be referenced from a static context  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { [ATTENTION] varArgs = ArrayEquals . createObjectArray ( rawArguments[nonVarArgsCount] )  ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^71^^^^^60^78^
[REPLACE]  varArgs  =  new  Object[]  {  null  }; 	[BUGGY] varArgs = new Object[] { this } ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  [ATTENTION] varArgs = new Object[] { this } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^69^^^^^60^78^
[ADD]  varArgs  =  new  Object[]  {  null  }; 	[BUGGY] [CE] variable varArgs might not have been initialized  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  [ATTENTION] } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^69^^^^^60^78^
[REPLACE]  varArgs  =  new  Object[]  {  null  }; 	[BUGGY] varArgs = new Object[] { false } ; [NO-ERROR]  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  [ATTENTION] varArgs = new Object[] { false } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^69^^^^^60^78^
[REPLACE]  final  int  varArgsCount  =  varArgs  .  length; 	[BUGGY] final int nonVarArgsCount = args . length - 1 ; [CE] variable nonVarArgsCount is already defined in method expandVarArgs(boolean , Object[])  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } [ATTENTION] final int nonVarArgsCount = args . length - 1 ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^73^^^^^60^78^
[REPLACE]  Object[]  newArgs  =  new  Object[nonVarArgsCount  +  varArgsCount]; 	[BUGGY] Object[] newArgs = new Object[nonVarArgsCount  = =  varArgsCount] ; [CE] incompatible types  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; [ATTENTION] Object[] newArgs = new Object[nonVarArgsCount = = varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^74^^^^^60^78^
[ADD]  Object[]  newArgs  =  new  Object[nonVarArgsCount  +  varArgsCount]; 	[BUGGY] [CE] cannot find symbol newArgs  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; [ATTENTION] System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^74^^^^^60^78^
[REPLACE]  System  .  arraycopy  (  args,  0,  newArgs,  0,  nonVarArgsCount  )  ; 	[BUGGY] System . arraycopy ( args , 0 - 4 , newArgs , 0 - 4 , nonVarArgsCount ) ; [FE] NullPointerException assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; [ATTENTION] System . arraycopy ( args , 0 - 4 , newArgs , 0 - 4 , nonVarArgsCount )  ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^75^^^^^60^78^
[ADD]  System  .  arraycopy  (  args,  0,  newArgs,  0,  nonVarArgsCount  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<false> but was:<true> assertEquals(true , mock.withBooleanVarargs(1))   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; [ATTENTION] System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^75^^^^^60^78^
[REPLACE]  System  .  arraycopy  (  varArgs,  0,  newArgs,  nonVarArgsCount,  varArgsCount  )  ; 	[BUGGY] System . arraycopy ( varArgs , 3 , varArgs , nonVarArgsCount , varArgsCount ) ; [FE] NullPointerException assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; [ATTENTION] System . arraycopy ( varArgs , 3 , varArgs , nonVarArgsCount , varArgsCount )  ; return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^76^^^^^60^78^
[ADD]  System  .  arraycopy  (  varArgs,  0,  newArgs,  nonVarArgsCount,  varArgsCount  )  ;  return  newArgs; 	[BUGGY] [CE] missing return statement  [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^76^77^^^^60^78^
[REPLACE]  return  newArgs; 	[BUGGY] return varArgs ; [FE]  AssertionFailedError  expected:<false> but was:<true> assertEquals(true , mock.withBooleanVarargs(1))   [METHOD]  expandVarArgs [TYPE] Object[] [PARAMETER] final boolean isVarArgs Object[] args [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private static Object[] expandVarArgs ( final boolean isVarArgs , final Object[] args ) { if ( !isVarArgs || isVarArgs && args[args . length - 1] ! = null && !args[args . length - 1] . getClass ( ) . isArray ( ) ) { return args = = null ? new Object[0] : args ; } final int nonVarArgsCount = args . length - 1 ; Object[] varArgs ; if ( args[nonVarArgsCount] = = null ) {  varArgs = new Object[] { null } ; } else { varArgs = ArrayEquals . createObjectArray ( args[nonVarArgsCount] ) ; } final int varArgsCount = varArgs . length ; Object[] newArgs = new Object[nonVarArgsCount + varArgsCount] ; System . arraycopy ( args , 0 , newArgs , 0 , nonVarArgsCount ) ; System . arraycopy ( varArgs , 0 , newArgs , nonVarArgsCount , varArgsCount ) ; [ATTENTION] return varArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^77^^^^^60^78^
[REPLACE]  return  mock; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getMock [TYPE] Object [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Object getMock ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^81^^^^^80^82^
[REPLACE]  return  method; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getMethod [TYPE] Method [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Method getMethod ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^85^^^^^84^86^
[REPLACE]  return  arguments; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getArguments [TYPE] Object[] [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Object[] getArguments ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^89^^^^^88^90^
[REPLACE]  verified  =  true; 	[BUGGY] verified = false ; [FE] NullPointerException assertFalse(invocation.isVerified())   [METHOD]  markVerified [TYPE] void [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public void markVerified ( ) { [ATTENTION] verified = false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^93^^^^^92^94^
[ADD]  verified  =  true;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  markVerified [TYPE] void [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public void markVerified ( ) { [ATTENTION]   	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^93^94^^^^92^94^
[REPLACE]  return  verified; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  isVerified [TYPE] boolean [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isVerified ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^97^^^^^96^98^
[REPLACE]  return  sequenceNumber; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getSequenceNumber [TYPE] Integer [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Integer getSequenceNumber ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^101^^^^^100^102^
[REPLACE]  this  .  markVerified  (  )  ; 	[BUGGY] this . isValidException ( null )  ; [FE] AssertionFailedError [METHOD]  markVerifiedInOrder [TYPE] void [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public void markVerifiedInOrder ( ) { [ATTENTION] this . isValidException ( null ) ; this . verifiedInOrder = true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^105^^^^^104^107^
[REPLACE]  this  .  verifiedInOrder  =  true; 	[BUGGY] this . verifiedInOrder = false ; [FE] NullPointerException assertFalse(invocation.isVerified())   [METHOD]  markVerifiedInOrder [TYPE] void [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public void markVerifiedInOrder ( ) { this . markVerified ( ) ; [ATTENTION] this . verifiedInOrder = false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^106^^^^^104^107^
[REPLACE]  return  verifiedInOrder; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  isVerifiedInOrder [TYPE] boolean [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isVerifiedInOrder ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^110^^^^^109^111^
[REPLACE]  if  (  o  ==  null  ||  !o  .  getClass  (  )    .  equals  (  this  .  getClass  (  )  )  )  { 	[BUGGY] if ( o ! = null ) {[FE] NullPointerException assertTrue(invocation.equals(equal))   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Invocation other [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( o ! = null ) { return false ; } Invocation other =  ( Invocation ) o ;  return this . mock . equals ( other . mock ) && this . method . equals ( other . method ) && this . equalArguments ( other . arguments ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^114^^^^^113^121^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertFalse(invocation.equals(null))   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Invocation other [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !o . getClass ( ) . equals ( this . getClass ( ) ) ) { [ATTENTION] return true ; } Invocation other =  ( Invocation ) o ;  return this . mock . equals ( other . mock ) && this . method . equals ( other . method ) && this . equalArguments ( other . arguments ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^115^^^^^113^121^
[REPLACE]  Invocation  other  =  (  Invocation  )  o; 	[BUGGY] final int varArgsCount = varArgs . length ; [CE] cannot find symbol varArgs  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Invocation other [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !o . getClass ( ) . equals ( this . getClass ( ) ) ) { return false ; } [ATTENTION] final int varArgsCount = varArgs . length ;  return this . mock . equals ( other . mock ) && this . method . equals ( other . method ) && this . equalArguments ( other . arguments ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^118^^^^^113^121^
[REPLACE]  return  this  .  mock  .  equals  (  other  .  mock  )  &&  this  .  method  .  equals  (  other  .  method  )  &&  this  .  equalArguments  (  other  .  arguments  )  ; 	[BUGGY] return this . mock . equals ( other . mock ) || this . method . equals ( other . method ) || this . equalArguments ( other . arguments ) ; [FE] NullPointerException assertFalse(invocation.equals(null))   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Invocation other [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean equals ( Object o ) { if ( o = = null || !o . getClass ( ) . equals ( this . getClass ( ) ) ) { return false ; } Invocation other =  ( Invocation ) o ;  [ATTENTION] return this . mock . equals ( other . mock ) || this . method . equals ( other . method ) || this . equalArguments ( other . arguments )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^120^^^^^113^121^
[REPLACE]  return  Arrays  .  equals  (  arguments,  this  .  arguments  )  ; 	[BUGGY] return Arrays . equals ( varArgs , this . arguments ) ; [CE] cannot find symbol varArgs  [METHOD]  equalArguments [TYPE] boolean [PARAMETER] Object[] arguments [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private boolean equalArguments ( Object[] arguments ) { [ATTENTION] return Arrays . equals ( varArgs , this . arguments )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^124^^^^^123^125^
[REPLACE]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public int hashCode ( ) { [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^128^^^^^127^129^
[ADD]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] [CE] missing return statement  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public int hashCode ( ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^128^^^^^127^129^
[REPLACE]  return  toString  (  argumentsToMatchers  (  )  ,  new  PrintSettings  (  )  )  ; 	[BUGGY] return toString ( argumentsToMatchers ( ) ,  new Location ( )  ) ; [CE] no suitable method found for toString(List<Matcher> , Location)  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public String toString ( ) { [ATTENTION] return toString ( argumentsToMatchers ( )  , new Location ( )  )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^132^^^^^131^133^
[REPLACE]  MatchersPrinter  matchersPrinter  =  new  MatchersPrinter  (  )  ; 	[BUGGY] List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; [CE] variable matchers is already defined in method toString(List<Matcher> , PrintSettings)  [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { [ATTENTION] List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length )  ; String method = qualifiedMethodName ( ) ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^136^^^^^135^144^
[REPLACE]  String  method  =  qualifiedMethodName  (  )  ; 	[BUGGY] final int varArgsCount = varArgs . length ; [CE] cannot find symbol varArgs  [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; [ATTENTION] final int varArgsCount = varArgs . length ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^137^^^^^135^144^
[REPLACE]  String  invocation  =  method  +  matchersPrinter  .  getArgumentsLine  (  matchers,  printSettings  )  ; 	[BUGGY] String invocation = invocation + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; [CE] variable invocation might not have been initialized  [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; String method = qualifiedMethodName ( ) ; [ATTENTION] String invocation = invocation + matchersPrinter . getArgumentsLine ( matchers , printSettings )  ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^138^^^^^135^144^
[REPLACE]  if  (  printSettings  .  isMultiline  (  )  ||  (  !matchers  .  isEmpty  (  )  &&  invocation  .  length  (  )  >  MAX_LINE_LENGTH  )  )  { 	[BUGGY] if ( printSettings . isMultiline ( ) ) {[FE] AssertionFailedError [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; String method = qualifiedMethodName ( ) ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; [ATTENTION] if ( printSettings . isMultiline ( ) ) { return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^139^^^^^135^144^
[REPLACE]  return  invocation; 	[BUGGY] return method ; [FE]   assertContains(  "was not stubbed  " , logger.getLoggedInfo())   [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; String method = qualifiedMethodName ( ) ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; } else { [ATTENTION] return method ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^142^^^^^135^144^
[REPLACE]  return  method  +  matchersPrinter  .  getArgumentsBlock  (  matchers,  printSettings  )  ; 	[BUGGY] return method && matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; String method = qualifiedMethodName ( ) ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { [ATTENTION] return method&&matchersPrinter . getArgumentsBlock ( matchers , printSettings )  ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^140^^^^^135^144^
[REPLACE]  return  method  +  matchersPrinter  .  getArgumentsBlock  (  matchers,  printSettings  )  ; 	[BUGGY] return method & matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; [CE] bad operand types for binary operator '&'  [METHOD]  toString [TYPE] String [PARAMETER] Matcher> matchers PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object mock o [TYPE] List matchers [TYPE] MatchersPrinter matchersPrinter [TYPE] Method method [TYPE] String invocation method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected String toString ( List<Matcher> matchers , PrintSettings printSettings ) { MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; String method = qualifiedMethodName ( ) ; String invocation = method + matchersPrinter . getArgumentsLine ( matchers , printSettings ) ; if ( printSettings . isMultiline ( ) || ( !matchers . isEmpty ( ) && invocation . length ( ) > MAX_LINE_LENGTH ) ) { [ATTENTION] return method&matchersPrinter . getArgumentsBlock ( matchers , printSettings )  ; } else { return invocation ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^140^^^^^135^144^
[REPLACE]  return  new  MockUtil  (  )    .  getMockName  (  mock  )  +    "  .    "  +  method  .  getName  (  )  ; 	[BUGGY] return new Location ( )  . getMockName ( mock )  &   " .   " & method . getName ( ) ; [CE] cannot find symbol  [METHOD]  qualifiedMethodName [TYPE] String [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  private String qualifiedMethodName ( ) { [ATTENTION] returnnew Location ( ) . getMockName ( mock ) &  " .   "&method . getName ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^147^^^^^146^148^
[REPLACE]  List<Matcher>  matchers  =  new  ArrayList<Matcher>  (  arguments  .  length  )  ; 	[BUGGY] MatchersPrinter matchersPrinter = new MatchersPrinter ( ) ; [CE] cannot find symbol matchers  [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { [ATTENTION] MatchersPrinter matchersPrinter = new MatchersPrinter ( )  ; for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { matchers . add ( new Equals ( arg ) ) ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^151^^^^^150^160^
[ADD]  List<Matcher>  matchers  =  new  ArrayList<Matcher>  (  arguments  .  length  )  ; 	[BUGGY] [CE] cannot find symbol matchers  [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { [ATTENTION] for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { matchers . add ( new Equals ( arg ) ) ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^151^^^^^150^160^
[REPLACE]  if  (  arg  !=  null  &&  arg  .  getClass  (  )    .  isArray  (  )  )  { 	[BUGGY] if ( arg . getClass ( )  . isPrimitive ( )  ) {[FE] NullPointerException assertThat(invocation.toString() , endsWith(  "oneArray(null)   [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; for ( Object arg : arguments ) { [ATTENTION] if ( arg . getClass ( ) . isPrimitive ( )  ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { matchers . add ( new Equals ( arg ) ) ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^153^^^^^150^160^
[ADD]  if  (  arg  !=  null  &&  arg  .  getClass  (  )    .  isArray  (  )  )  {  matchers  .  add  (  new  ArrayEquals  (  arg  )  )  ;  }  else  {  matchers  .  add  (  new  Equals  (  arg  )  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; for ( Object arg : arguments ) { [ATTENTION]   } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^153^154^155^156^157^150^160^
[REPLACE]  matchers  .  add  (  new  Equals  (  arg  )  )  ; 	[BUGGY] && method . getName ( ) . equals (   "toString  " ) ; [CE] illegal start of expression  [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { [ATTENTION] && method . getName ( )  . equals (   "toString  " )  ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^156^^^^^150^160^
[REPLACE]  matchers  .  add  (  new  ArrayEquals  (  arg  )  )  ; 	[BUGGY] if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; [CE] illegal start of expression  [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { [ATTENTION] if ( arg ! = null && arg . getClass ( )  . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) )  ; } else { matchers . add ( new Equals ( arg ) ) ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^154^^^^^150^160^
[REPLACE]  for  (  Object  arg  :  arguments  )  { 	[BUGGY] for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) {[CE] illegal start of expression  [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; [ATTENTION] for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( )  . isArray ( ) ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { matchers . add ( new Equals ( arg ) ) ; } } return matchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^152^^^^^150^160^
[REPLACE]  return  matchers; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  argumentsToMatchers [TYPE] List [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] List matchers [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  protected List<Matcher> argumentsToMatchers ( ) { List<Matcher> matchers = new ArrayList<Matcher> ( arguments . length ) ; for ( Object arg : arguments ) { if ( arg ! = null && arg . getClass ( ) . isArray ( ) ) { matchers . add ( new ArrayEquals ( arg ) ) ; } else { matchers . add ( new Equals ( arg ) ) ; } } [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^159^^^^^150^160^
[REPLACE]  return  isToString  (  invocation  .  getMethod  (  )  )  ; 	[BUGGY] return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; [CE] non-static variable method cannot be referenced from a static context  [METHOD]  isToString [TYPE] boolean [PARAMETER] InvocationOnMock invocation [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] InvocationOnMock invocation [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public static boolean isToString ( InvocationOnMock invocation ) { [ATTENTION] return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^163^^^^^162^164^
[REPLACE]  return  method  .  getReturnType  (  )  ==  String  .  class  &&  method  .  getParameterTypes  (  )    .  length  ==  0  &&  method  .  getName  (  )    .  equals  (    "toString  "  )  ; 	[BUGGY] return method . getParameterTypes ( )  = = String . class && method . getParameterTypes ( ) . length = = 0 && method . getName ( ) . equals (   "toString  " ) ; [CE] incomparable types: Class<?>[] and Class<String>  [METHOD]  isToString [TYPE] boolean [PARAMETER] Method method [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public static boolean isToString ( Method method ) { [ATTENTION] return method . getParameterTypes ( )  = = String . class && method . getParameterTypes ( )  . length = = 0 && method . getName ( )  . equals (   "toString  " )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^167^168^^^^166^169^
[REPLACE]  Class<?>[]  exceptions  =  this  .  getMethod  (  )    .  getExceptionTypes  (  )  ; 	[BUGGY] Class<?>[] exceptions = this . markVerified ( ) . getExceptionTypes ( ) ; [CE] void cannot be dereferenced  [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { [ATTENTION] Class<?>[] exceptions = this . markVerified ( )  . getExceptionTypes ( )  ; Class<?> throwableClass = throwable . getClass ( ) ; for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^172^^^^^171^181^
[ADD]  Class<?>[]  exceptions  =  this  .  getMethod  (  )    .  getExceptionTypes  (  )  ; 	[BUGGY] [CE] cannot find symbol exceptions  [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { [ATTENTION] Class<?> throwableClass = throwable . getClass ( ) ; for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^172^^^^^171^181^
[REPLACE]  Class<?>  throwableClass  =  throwable  .  getClass  (  )  ; 	[BUGGY] Class<?> throwableClass = throwable . equals ( o )  ; [CE] cannot find symbol o  [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { Class<?>[] exceptions = this . getMethod ( ) . getExceptionTypes ( ) ; [ATTENTION] Class<?> throwableClass = throwable . equals ( o ) ; for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^173^^^^^171^181^
[REPLACE]  if  (  exception  .  isAssignableFrom  (  throwableClass  )  )  { 	[BUGGY] if ( exception . isAssignableFrom ( null ) ) {[FE] NullPointerException assertFalse(invocation.isValidException(new Exception()))   [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { Class<?>[] exceptions = this . getMethod ( ) . getExceptionTypes ( ) ; Class<?> throwableClass = throwable . getClass ( ) ; for ( Class<?> exception : exceptions ) { [ATTENTION] if ( exception . isAssignableFrom ( null ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^175^^^^^171^181^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertFalse(invocation.isValidException(new Exception()))   [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { Class<?>[] exceptions = this . getMethod ( ) . getExceptionTypes ( ) ; Class<?> throwableClass = throwable . getClass ( ) ; for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { [ATTENTION] return false ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^176^^^^^171^181^
[REPLACE]  for  (  Class<?>  exception  :  exceptions  )  { 	[BUGGY] for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) {[CE] illegal start of expression  [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { Class<?>[] exceptions = this . getMethod ( ) . getExceptionTypes ( ) ; Class<?> throwableClass = throwable . getClass ( ) ; [ATTENTION] for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { if ( exception . isAssignableFrom ( throwableClass ) ) { return true ; } } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^174^^^^^171^181^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertFalse(invocation.isValidException(new Exception()))   [METHOD]  isValidException [TYPE] boolean [PARAMETER] Throwable throwable [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Class[] exceptions [TYPE] Throwable throwable [TYPE] Object arg mock o [TYPE] Class exception throwableClass [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidException ( Throwable throwable ) { Class<?>[] exceptions = this . getMethod ( ) . getExceptionTypes ( ) ; Class<?> throwableClass = throwable . getClass ( ) ; for ( Class<?> exception : exceptions ) { if ( exception . isAssignableFrom ( throwableClass ) ) { return true ; } } [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^180^^^^^171^181^
[REPLACE]  if  (  method  .  getReturnType  (  )    .  isPrimitive  (  )  )  { 	[BUGGY] if ( method . equals ( ) . isPrimitive ( ) ) {[CE] no suitable method found for equals()  [METHOD]  isValidReturnType [TYPE] boolean [PARAMETER] Class clazz [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Class clazz [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidReturnType ( Class clazz ) { [ATTENTION] if ( method . equals ( )  . isPrimitive ( ) ) { return Primitives . primitiveTypeOf ( clazz )  = = method . getReturnType ( ) ; } else { return method . getReturnType ( ) . isAssignableFrom ( clazz ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^184^^^^^183^189^
[REPLACE]  return  method  .  getReturnType  (  )    .  isAssignableFrom  (  clazz  )  ; 	[BUGGY] return method . getReturnType ( )  . isArray ( )  ; [FE] AssertionFailedError [METHOD]  isValidReturnType [TYPE] boolean [PARAMETER] Class clazz [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Class clazz [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidReturnType ( Class clazz ) { if ( method . getReturnType ( ) . isPrimitive ( ) ) { return Primitives . primitiveTypeOf ( clazz )  = = method . getReturnType ( ) ; } else { [ATTENTION] return method . getReturnType ( ) . isArray ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^187^^^^^183^189^
[REPLACE]  return  Primitives  .  primitiveTypeOf  (  clazz  )  ==  method  .  getReturnType  (  )  ; 	[BUGGY] return  clazz   && method . getReturnType ( ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  isValidReturnType [TYPE] boolean [PARAMETER] Class clazz [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Class clazz [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidReturnType ( Class clazz ) { if ( method . getReturnType ( ) . isPrimitive ( ) ) { [ATTENTION] return clazz &&method . getReturnType ( )  ; } else { return method . getReturnType ( ) . isAssignableFrom ( clazz ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^185^^^^^183^189^
[REPLACE]  return  Primitives  .  primitiveTypeOf  (  clazz  )  ==  method  .  getReturnType  (  )  ; 	[BUGGY] return Primitives . primitiveTypeOf ( clazz )  || method . getParameterTypes ( )  ; [CE] bad operand types for binary operator '||'  [METHOD]  isValidReturnType [TYPE] boolean [PARAMETER] Class clazz [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Class clazz [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isValidReturnType ( Class clazz ) { if ( method . getReturnType ( ) . isPrimitive ( ) ) { [ATTENTION] return Primitives . primitiveTypeOf ( clazz ) ||method . getParameterTypes ( ) ; } else { return method . getReturnType ( ) . isAssignableFrom ( clazz ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^185^^^^^183^189^
[REPLACE]  return  this  .  method  .  getReturnType  (  )  ==  Void  .  TYPE; 	[BUGGY] return this . method . getParameterTypes ( )  = = Void . TYPE ; [CE] incomparable types: Class<?>[] and Class<Void>  [METHOD]  isVoid [TYPE] boolean [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean isVoid ( ) { [ATTENTION] return this . method . getParameterTypes ( )  = = Void . TYPE ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^192^^^^^191^193^
[REPLACE]  return  method  .  getReturnType  (  )    .  getSimpleName  (  )  ; 	[BUGGY] return method . getParameterTypes ( ) . getSimpleName ( ) ; [CE] cannot find symbol  [METHOD]  printMethodReturnType [TYPE] String [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public String printMethodReturnType ( ) { [ATTENTION] return method . getParameterTypes ( )  . getSimpleName ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^196^^^^^195^197^
[REPLACE]  return  method  .  getName  (  )  ; 	[BUGGY] return method . getReturnType ( )  ; [CE] incompatible types  [METHOD]  getMethodName [TYPE] String [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public String getMethodName ( ) { [ATTENTION] return method . getReturnType ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^200^^^^^199^201^
[REPLACE]  return  method  .  getReturnType  (  )    .  isPrimitive  (  )  ; 	[BUGGY] return method . getReturnType ( ) . getSimpleName ( ) ; [CE] incompatible types  [METHOD]  returnsPrimitive [TYPE] boolean [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public boolean returnsPrimitive ( ) { [ATTENTION] return method . getReturnType ( )  . getSimpleName ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^204^^^^^203^205^
[REPLACE]  return  location; 	[BUGGY] return invocation ; [CE] cannot find symbol invocation  [METHOD]  getLocation [TYPE] Location [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Location getLocation ( ) { [ATTENTION] return invocation ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^208^^^^^207^209^
[REPLACE]  return  arguments  .  length; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getArgumentsCount [TYPE] int [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public int getArgumentsCount ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^212^^^^^211^213^
[REPLACE]  return  this  .  rawArguments; 	[BUGGY] return newArgs ; [CE] cannot find symbol newArgs  [METHOD]  getRawArguments [TYPE] Object[] [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Object[] getRawArguments ( ) { [ATTENTION] return newArgs ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^216^^^^^215^217^
[REPLACE]  return  realMethod  .  invoke  (  mock,  arguments  )  ; 	[BUGGY] return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings ) ; [CE] cannot find symbol matchers  [METHOD]  callRealMethod [TYPE] Object [PARAMETER] [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public Object callRealMethod ( ) throws Throwable { [ATTENTION] return method + matchersPrinter . getArgumentsBlock ( matchers , printSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^220^^^^^219^221^
[REPLACE]  return  toString  (  argumentsToMatchers  (  )  ,  printSettings  )  ; 	[BUGGY] return toString ( argumentsToMatchers ( ) , new PrintSettings ( ) ) ; [FE]   assertContains(  "\n  " , printer.getWanted().toString())   [METHOD]  toString [TYPE] String [PARAMETER] PrintSettings printSettings [CLASS] Invocation  [TYPE] boolean false isVarArgs true verified verifiedInOrder [TYPE] PrintSettings printSettings [TYPE] Object arg mock o [TYPE] Method method [TYPE] RealMethod realMethod [TYPE] int MAX_LINE_LENGTH nonVarArgsCount sequenceNumber varArgsCount [TYPE] Object[] args arguments newArgs rawArguments varArgs [TYPE] Location location  [CONTEXT]  public String toString ( PrintSettings printSettings ) { [ATTENTION] return toString ( argumentsToMatchers ( )  , new PrintSettings ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/Invocation.java^224^^^^^223^225^
[REPLACE]  private  final  Invocation  invocation; 	[BUGGY] private Invocation invocation ; [NO-ERROR]  [CONTEXT]    [CLASS] InvocationMatcher  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^20^^^^^^^
[REPLACE]  this  .  invocation  =  invocation; 	[BUGGY] this . invocation =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation invocation Matcher> matchers [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation , List<Matcher> matchers ) { [ATTENTION] this . invocation = null ; if ( matchers . isEmpty ( ) ) { this . matchers = invocation . argumentsToMatchers ( ) ; } else { this . matchers = matchers ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^24^^^^^23^30^
[REPLACE]  if  (  matchers  .  isEmpty  (  )  )  { 	[BUGGY] if ( false . isEmpty ( ) ) {[CE] boolean cannot be dereferenced  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation invocation Matcher> matchers [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation , List<Matcher> matchers ) { this . invocation = invocation ; [ATTENTION] if ( false . isEmpty ( ) ) { this . matchers = invocation . argumentsToMatchers ( ) ; } else { this . matchers = matchers ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^25^^^^^23^30^
[REPLACE]  this  .  matchers  =  matchers; 	[BUGGY] this . matchers =  this ; [CE] incompatible types  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation invocation Matcher> matchers [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation , List<Matcher> matchers ) { this . invocation = invocation ; if ( matchers . isEmpty ( ) ) { this . matchers = invocation . argumentsToMatchers ( ) ; } else { [ATTENTION] this . matchers = this ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^28^^^^^23^30^
[REPLACE]  this  .  matchers  =  invocation  .  argumentsToMatchers  (  )  ; 	[BUGGY] this . matchers =  null . argumentsToMatchers ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation invocation Matcher> matchers [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation , List<Matcher> matchers ) { this . invocation = invocation ; if ( matchers . isEmpty ( ) ) { [ATTENTION] this . matchers = null . argumentsToMatchers ( )  ; } else { this . matchers = matchers ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^26^^^^^23^30^
[ADD]  this  .  matchers  =  invocation  .  argumentsToMatchers  (  )  ; 	[BUGGY] [CE] variable matchers might not have been initialized  [METHOD]  <init> [TYPE] List) [PARAMETER] Invocation invocation Matcher> matchers [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation , List<Matcher> matchers ) { this . invocation = invocation ; if ( matchers . isEmpty ( ) ) { [ATTENTION] } else { this . matchers = matchers ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^26^^^^^23^30^
[REPLACE]  this  (  invocation,  Collections  .  <Matcher>emptyList  (  )  )  ; 	[BUGGY] return invocation . getMethod ( ) . equals ( candidate . getMethod ( ) ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  <init> [TYPE] Invocation) [PARAMETER] Invocation invocation [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public InvocationMatcher ( Invocation invocation ) { [ATTENTION] return invocation . getMethod ( )  . equals ( candidate . getMethod ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^33^^^^^32^34^
[REPLACE]  return  invocation  .  getMethod  (  )  ; 	[BUGGY] return invocation . getMock ( ) ; [CE] incompatible types  [METHOD]  getMethod [TYPE] Method [PARAMETER] [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public Method getMethod ( ) { [ATTENTION] return invocation . getMock ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^37^^^^^36^38^
[REPLACE]  return  this  .  invocation; 	[BUGGY] return invocation . getMethod ( ) ; [CE] incompatible types  [METHOD]  getInvocation [TYPE] Invocation [PARAMETER] [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public Invocation getInvocation ( ) { [ATTENTION] return invocation . getMethod ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^41^^^^^40^42^
[REPLACE]  return  this  .  matchers; 	[BUGGY] return invocation . toString ( matchers , printSettings ) ; [CE] cannot find symbol printSettings  [METHOD]  getMatchers [TYPE] List [PARAMETER] [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public List<Matcher> getMatchers ( ) { [ATTENTION] return invocation . toString ( matchers , printSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^45^^^^^44^46^
[REPLACE]  return  invocation  .  toString  (  matchers,  new  PrintSettings  (  )  )  ; 	[BUGGY] return invocation . toString ( matchers , printSettings ) ; [CE] cannot find symbol printSettings  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] InvocationMatcher  [TYPE] Invocation invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return invocation . toString ( matchers , printSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^49^^^^^48^50^
[REPLACE]  return  invocation  .  getMock  (  )    .  equals  (  actual  .  getMock  (  )  )  &&  hasSameMethod  (  actual  )  &&  (  argumentsMatch  (  actual  .  getArguments  (  )  )  )  ; 	[BUGGY] return  hasSameMethod ( actual ) && ( argumentsMatch ( actual . getArguments ( ) ) ) ; [FE]   assertContains(  "thirdChunk(  " , e.getMessage())   [METHOD]  matches [TYPE] boolean [PARAMETER] Invocation actual [CLASS] InvocationMatcher  [TYPE] Invocation actual invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public boolean matches ( Invocation actual ) { [ATTENTION] return hasSameMethod ( actual ) && ( argumentsMatch ( actual . getArguments ( ) ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^53^54^55^^^52^56^
[REPLACE]  if  (  actualArgs  .  length  !=  matchers  .  size  (  )  )  { 	[BUGGY] if ( actualArgs . length ! = matchers . isEmpty ( )  / 0 . 5 ) {[CE] bad operand types for binary operator '/'  [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { [ATTENTION] if ( actualArgs . length ! = matchers . isEmpty ( ) /0 . 5 ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^59^^^^^58^68^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  expected same:<null> was not:<mock.simpleMethod()   [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { [ATTENTION] return true ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^60^^^^^58^68^
[REPLACE]  if  (  !matchers  .  get  (  i  )    .  matches  (  actualArgs[i]  )  )  { 	[BUGGY] if ( !matchers . isEmpty ( )  . matches ( actualArgs[i] ) ) {[CE] boolean cannot be dereferenced  [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { [ATTENTION] if ( !matchers . isEmpty ( ) . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^63^^^^^58^68^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(invocation.hasSimilarMethod(overloadedInvocation))   [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { [ATTENTION] return true ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^64^^^^^58^68^
[REPLACE]  for  (  int  i  =  0;  i  <  actualArgs  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < actualArgs . length - 5 ; i++ ) {[FE] NullPointerException assertTrue(invocation.hasSimilarMethod(overloadedInvocation))   [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } [ATTENTION] for ( int i = 0 ; i < actualArgs . length - 5 ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^62^^^^^58^68^
[ADD]  for  (  int  i  =  0;  i  <  actualArgs  .  length;  i++  )  {  if  (  !matchers  .  get  (  i  )    .  matches  (  actualArgs[i]  )  )  {  return  false;  } 	[BUGGY] [CE] illegal start of type  [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } [ATTENTION]   } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^62^63^64^65^^58^68^
[REPLACE]  if  (  !matchers  .  get  (  i  )    .  matches  (  actualArgs[i]  )  )  { 	[BUGGY] if ( matchers . get ( i ) . matches ( actualArgs[i] ) ) {[FE] AssertionFailedError [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { [ATTENTION] if ( matchers . get ( i )  . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^63^^^^^58^68^
[REPLACE]  for  (  int  i  =  0;  i  <  actualArgs  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < actualArgs . length ; i++ ) {[NO-ERROR]  [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } [ATTENTION] for ( int i = 0 ; i < actualArgs . length ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { return false ; } } return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^62^^^^^58^68^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  argumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs [TYPE] int i  [CONTEXT]  private boolean argumentsMatch ( Object[] actualArgs ) { if ( actualArgs . length ! = matchers . size ( ) ) { return false ; } for ( int i = 0 ; i < actualArgs . length ; i++ ) { if ( !matchers . get ( i ) . matches ( actualArgs[i] ) ) { return false ; } } [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^67^^^^^58^68^
[ADD]  try  {  return  argumentsMatch  (  actualArgs  )  ;  }  catch  (  Throwable  t  )  {  return  false;  } 	[BUGGY] return argumentsMatch ( actualArgs ) ; return false ; [CE] unreachable statement  [METHOD]  safelyArgumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] Throwable t [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs  [CONTEXT]  private boolean safelyArgumentsMatch ( Object[] actualArgs ) { [ATTENTION] return argumentsMatch ( actualArgs )  ; return false ;   }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^71^72^73^74^75^70^76^
[REPLACE]  return  argumentsMatch  (  actualArgs  )  ; 	[BUGGY] return invocation . toString ( matchers , new PrintSettings ( ) ) ; [CE] incompatible types  [METHOD]  safelyArgumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] Throwable t [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs  [CONTEXT]  private boolean safelyArgumentsMatch ( Object[] actualArgs ) { try { [ATTENTION] return invocation . toString ( matchers , new PrintSettings ( ) )  ; } catch ( Throwable t ) { return false ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^72^^^^^70^76^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] AssertionFailedError [METHOD]  safelyArgumentsMatch [TYPE] boolean [PARAMETER] Object[] actualArgs [CLASS] InvocationMatcher  [TYPE] Throwable t [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual invocation [TYPE] Object[] actualArgs  [CONTEXT]  private boolean safelyArgumentsMatch ( Object[] actualArgs ) { try { return argumentsMatch ( actualArgs ) ; } catch ( Throwable t ) { [ATTENTION] return true ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^74^^^^^70^76^
[REPLACE]  String  wantedMethodName  =  getMethod  (  )    .  getName  (  )  ; 	[BUGGY] String currentMethodName = candidate . getMethod ( ) . getName ( ) ; [CE] variable currentMethodName is already defined in method hasSimilarMethod(Invocation)  [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { [ATTENTION] String currentMethodName = candidate . getMethod ( )  . getName ( )  ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^83^^^^^82^97^
[REPLACE]  String  currentMethodName  =  candidate  .  getMethod  (  )    .  getName  (  )  ; 	[BUGGY] String currentMethodName = invocation . getMethod ( ) . getName ( ) ; [FE] AssertionFailedError [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; [ATTENTION] String currentMethodName = invocation . getMethod ( )  . getName ( )  ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^84^^^^^82^97^
[REPLACE]  final  boolean  methodNameEquals  =  wantedMethodName  .  equals  (  currentMethodName  )  ; 	[BUGGY] final boolean methodNameEquals = wantedMethodName . getName ( )  ; [CE] cannot find symbol  [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  [ATTENTION] final boolean methodNameEquals = wantedMethodName . getName ( ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^86^^^^^82^97^
[REPLACE]  final  boolean  isUnverified  =  !candidate  .  isVerified  (  )  ; 	[BUGGY] final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; [CE] variable mockIsTheSame is already defined in method hasSimilarMethod(Invocation)  [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; [ATTENTION] final boolean mockIsTheSame = getInvocation ( )  . getMock ( ) = = candidate . getMock ( )  ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^87^^^^^82^97^
[ADD]  final  boolean  isUnverified  =  !candidate  .  isVerified  (  )  ;  final  boolean  mockIsTheSame  =  getInvocation  (  )    .  getMock  (  )  ==  candidate  .  getMock  (  )  ;  final  boolean  methodEquals  =  hasSameMethod  (  candidate  )  ;  final  boolean  overloadedButSameArgs  =  !methodEquals  &&  safelyArgumentsMatch  (  candidate  .  getArguments  (  )  )  ; 	[BUGGY] [CE] cannot find symbol isUnverified  [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; [ATTENTION]   if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^87^88^89^90^^82^97^
[REPLACE]  final  boolean  mockIsTheSame  =  getInvocation  (  )    .  getMock  (  )  ==  candidate  .  getMock  (  )  ; 	[BUGGY] final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  && candidate . getMock ( ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; [ATTENTION] final boolean mockIsTheSame = getInvocation ( )  . getMock ( ) &&candidate . getMock ( )  ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^88^^^^^82^97^
[REPLACE]  final  boolean  methodEquals  =  hasSameMethod  (  candidate  )  ; 	[BUGGY] final boolean methodEquals = hasSameMethod ( invocation ) ; [FE] AssertionFailedError [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; [ATTENTION] final boolean methodEquals = hasSameMethod ( invocation )  ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^89^^^^^82^97^
[REPLACE]  final  boolean  overloadedButSameArgs  =  !methodEquals  &&  safelyArgumentsMatch  (  candidate  .  getArguments  (  )  )  ; 	[BUGGY] final boolean overloadedButSameArgs = true ; [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; [ATTENTION] final boolean overloadedButSameArgs = true ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^90^^^^^82^97^
[REPLACE]  if  (  methodNameEquals  &&  isUnverified  &&  mockIsTheSame  &&  !overloadedButSameArgs  )  { 	[BUGGY] if ( methodNameEquals && isUnverified && mockIsTheSame && overloadedButSameArgs ) {[FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  [ATTENTION] if ( methodNameEquals && isUnverified && mockIsTheSame && overloadedButSameArgs ) { return true ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^92^^^^^82^97^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]   assertNotContains(  "stub was not used  " , logger.getLoggedInfo())   [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { [ATTENTION] return false ; } return false ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^93^^^^^82^97^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(simpleMethod.hasSimilarMethod(same))   [METHOD]  hasSimilarMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] List matchers [TYPE] String currentMethodName wantedMethodName [TYPE] boolean false isUnverified methodEquals methodNameEquals mockIsTheSame overloadedButSameArgs true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public boolean hasSimilarMethod ( Invocation candidate ) { String wantedMethodName = getMethod ( ) . getName ( ) ; String currentMethodName = candidate . getMethod ( ) . getName ( ) ;  final boolean methodNameEquals = wantedMethodName . equals ( currentMethodName ) ; final boolean isUnverified = !candidate . isVerified ( ) ; final boolean mockIsTheSame = getInvocation ( ) . getMock ( )  = = candidate . getMock ( ) ; final boolean methodEquals = hasSameMethod ( candidate ) ; final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch ( candidate . getArguments ( ) ) ;  if ( methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs ) { return true ; } [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^96^^^^^82^97^
[REPLACE]  return  invocation  .  getMethod  (  )    .  equals  (  candidate  .  getMethod  (  )  )  ; 	[BUGGY] return invocation . getMethod ( )  . getName ( )  ; [CE] incompatible types  [METHOD]  hasSameMethod [TYPE] boolean [PARAMETER] Invocation candidate [CLASS] InvocationMatcher  [TYPE] Invocation actual candidate invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public boolean hasSameMethod ( Invocation candidate ) { [ATTENTION] return invocation . getMethod ( ) . getName ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^100^^^^^99^101^
[REPLACE]  return  invocation  .  getLocation  (  )  ; 	[BUGGY] return invocation . getMethod ( ) ; [CE] incompatible types  [METHOD]  getLocation [TYPE] Location [PARAMETER] [CLASS] InvocationMatcher  [TYPE] Invocation actual candidate invocation [TYPE] List matchers [TYPE] boolean false true  [CONTEXT]  public Location getLocation ( ) { [ATTENTION] return invocation . getMethod ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^104^^^^^103^105^
[REPLACE]  return  invocation  .  toString  (  matchers,  printSettings  )  ; 	[BUGGY] return invocation . toString ( matchers , new PrintSettings ( ) ) ; [FE]   assertContains(wanted , e.getMessage())   [METHOD]  toString [TYPE] String [PARAMETER] PrintSettings printSettings [CLASS] InvocationMatcher  [TYPE] PrintSettings printSettings [TYPE] List matchers [TYPE] boolean false true [TYPE] Invocation actual candidate invocation  [CONTEXT]  public String toString ( PrintSettings printSettings ) { [ATTENTION] return invocation . toString ( matchers , new PrintSettings ( ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/InvocationMatcher.java^108^^^^^107^109^
[REPLACE]  Set<Invocation>  invocationsInOrder  =  new  TreeSet<Invocation>  (  new  SequenceNumberComparator  (  )  )  ; 	[BUGGY] int comparison = o1 . getSequenceNumber ( ) . compareTo ( o2 . getSequenceNumber ( ) ) ; [CE] cannot find symbol o2  [METHOD]  getAllInvocations [TYPE] List [PARAMETER] Object> mocks [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] Set invocationsInOrder [TYPE] boolean false true [TYPE] List fromSingleMock mocks [TYPE] Object mock  [CONTEXT]  public List<Invocation> getAllInvocations ( List<? extends Object> mocks ) { [ATTENTION] int comparison = o1 . getSequenceNumber ( )  . compareTo ( o2 . getSequenceNumber ( ) )  ; for ( Object mock : mocks ) { List<Invocation> fromSingleMock = new MockUtil ( ) . getMockHandler ( mock ) . getRegisteredInvocations ( ) ; invocationsInOrder . addAll ( fromSingleMock ) ; } return new LinkedList<Invocation> ( invocationsInOrder ) ; }  	None^24^^^^^23^31^
[REPLACE]  for  (  Object  mock  :  mocks  )  { 	[BUGGY] for ( Object mock : mocks ) { List<Invocation> fromSingleMock = new MockUtil ( ) . getMockHandler ( mock ) . getRegisteredInvocations ( ) ; [CE] variable fromSingleMock is already defined in method getAllInvocations(List<? extends Object>)  [METHOD]  getAllInvocations [TYPE] List [PARAMETER] Object> mocks [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] Set invocationsInOrder [TYPE] boolean false true [TYPE] List fromSingleMock mocks [TYPE] Object mock  [CONTEXT]  public List<Invocation> getAllInvocations ( List<? extends Object> mocks ) { Set<Invocation> invocationsInOrder = new TreeSet<Invocation> ( new SequenceNumberComparator ( ) ) ; [ATTENTION] for ( Object mock : mocks ) { List<Invocation> fromSingleMock = new MockUtil ( )  . getMockHandler ( mock )  . getRegisteredInvocations ( )  ; List<Invocation> fromSingleMock = new MockUtil ( ) . getMockHandler ( mock ) . getRegisteredInvocations ( ) ; invocationsInOrder . addAll ( fromSingleMock ) ; } return new LinkedList<Invocation> ( invocationsInOrder ) ; }  	None^25^^^^^23^31^
[REPLACE]  List<Invocation>  fromSingleMock  =  new  MockUtil  (  )    .  getMockHandler  (  mock  )    .  getRegisteredInvocations  (  )  ; 	[BUGGY] List<Invocation> fromSingleMock = new MockUtil ( ) . getMockHandler ( mock )  . compareTo ( )  ; [CE] cannot find symbol  [METHOD]  getAllInvocations [TYPE] List [PARAMETER] Object> mocks [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] Set invocationsInOrder [TYPE] boolean false true [TYPE] List fromSingleMock mocks [TYPE] Object mock  [CONTEXT]  public List<Invocation> getAllInvocations ( List<? extends Object> mocks ) { Set<Invocation> invocationsInOrder = new TreeSet<Invocation> ( new SequenceNumberComparator ( ) ) ; for ( Object mock : mocks ) { [ATTENTION] List<Invocation> fromSingleMock = new MockUtil ( )  . getMockHandler ( mock ) . compareTo ( ) ; invocationsInOrder . addAll ( fromSingleMock ) ; } return new LinkedList<Invocation> ( invocationsInOrder ) ; }  	None^26^^^^^23^31^
[REPLACE]  return  new  LinkedList<Invocation>  (  invocationsInOrder  )  ; 	[BUGGY] return new LinkedList<Invocation> ( true ) ; [CE] no suitable constructor found for LinkedList(boolean)  [METHOD]  getAllInvocations [TYPE] List [PARAMETER] Object> mocks [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] Set invocationsInOrder [TYPE] boolean false true [TYPE] List fromSingleMock mocks [TYPE] Object mock  [CONTEXT]  public List<Invocation> getAllInvocations ( List<? extends Object> mocks ) { Set<Invocation> invocationsInOrder = new TreeSet<Invocation> ( new SequenceNumberComparator ( ) ) ; for ( Object mock : mocks ) { List<Invocation> fromSingleMock = new MockUtil ( ) . getMockHandler ( mock ) . getRegisteredInvocations ( ) ; invocationsInOrder . addAll ( fromSingleMock ) ; } [ATTENTION] return new LinkedList<Invocation> ( true )  ; }  	None^30^^^^^23^31^
[REPLACE]  int  comparison  =  o1  .  getSequenceNumber  (  )    .  compareTo  (  o2  .  getSequenceNumber  (  )  )  ; 	[BUGGY] Set<Invocation> invocationsInOrder = new TreeSet<Invocation> ( new SequenceNumberComparator ( ) ) ; [CE] cannot find symbol comparison  [METHOD]  compare [TYPE] int [PARAMETER] Invocation o1 Invocation o2 [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] boolean false true [TYPE] Invocation o1 o2 [TYPE] int comparison  [CONTEXT]  public int compare ( Invocation o1 , Invocation o2 ) { [ATTENTION] Set<Invocation> invocationsInOrder = new TreeSet<Invocation> ( new SequenceNumberComparator ( ) )  ; assert comparison ! = 0 :   "sequence number has to be globally unique  " ; return comparison ; }  	None^35^^^^^34^38^
[ADD]  int  comparison  =  o1  .  getSequenceNumber  (  )    .  compareTo  (  o2  .  getSequenceNumber  (  )  )  ;  assert  comparison  !=  0  :    "sequence  number  has  to  be  globally  unique  "; 	[BUGGY] [CE] cannot find symbol comparison  [METHOD]  compare [TYPE] int [PARAMETER] Invocation o1 Invocation o2 [CLASS] AllInvocationsFinder SequenceNumberComparator  [TYPE] boolean false true [TYPE] Invocation o1 o2 [TYPE] int comparison  [CONTEXT]  public int compare ( Invocation o1 , Invocation o2 ) { [ATTENTION]  return comparison ; }  	None^35^36^^^^34^38^
[REPLACE]  private  final  RealMethod  realMethod; 	[BUGGY] private RealMethod realMethod ; [NO-ERROR]  [CONTEXT]    [CLASS] FilteredCGLIBProxyRealMethod  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^12^^^^^^^
[REPLACE]  this  (  new  CGLIBProxyRealMethod  (  methodProxy  )  )  ; 	[BUGGY] return ( ( HasCGLIBMethodProxy ) realMethod ) . getMethodProxy ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  <init> [TYPE] MethodProxy) [PARAMETER] MethodProxy methodProxy [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] RealMethod realMethod [TYPE] MethodProxy methodProxy [TYPE] boolean false true  [CONTEXT]  public FilteredCGLIBProxyRealMethod ( MethodProxy methodProxy ) { [ATTENTION] return ( ( HasCGLIBMethodProxy ) realMethod )  . getMethodProxy ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^15^^^^^14^16^
[REPLACE]  this  .  realMethod  =  realMethod; 	[BUGGY] this . realMethod =  null ; [FE] NullPointerException assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  <init> [TYPE] RealMethod) [PARAMETER] RealMethod realMethod [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] RealMethod realMethod [TYPE] boolean false true  [CONTEXT]  public FilteredCGLIBProxyRealMethod ( RealMethod realMethod ) { [ATTENTION] this . realMethod = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^19^^^^^18^20^
[ADD]  try  {  return  realMethod  .  invoke  (  target,  arguments  )  ;  }  catch  (  Throwable  t  )  {  new  ConditionalStackTraceFilter  (  )    .  filter  (  t  )  ;  throw  t; 	[BUGGY] return realMethod . invoke ( target , arguments ) ; new ConditionalStackTraceFilter ( ) . filter ( t ) ; [CE] class , interface , or enum expected  [METHOD]  invoke [TYPE] Object [PARAMETER] Object target Object[] arguments [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] Throwable t [TYPE] Object target [TYPE] boolean false true [TYPE] RealMethod realMethod [TYPE] Object[] arguments  [CONTEXT]  public Object invoke ( Object target , Object[] arguments ) throws Throwable { [ATTENTION] return realMethod . invoke ( target , arguments )  ; new ConditionalStackTraceFilter ( )  . filter ( t )  ;   } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^23^24^25^26^27^22^29^
[REPLACE]  return  realMethod  .  invoke  (  target,  arguments  )  ; 	[BUGGY] return ( ( HasCGLIBMethodProxy ) realMethod ) . getMethodProxy ( ) ; [FE]  org.mockito.cglib.proxy.MethodProxy cannot be cast to java.lang.String assertEquals(  "woof  " , dog.bark())   [METHOD]  invoke [TYPE] Object [PARAMETER] Object target Object[] arguments [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] Throwable t [TYPE] Object target [TYPE] boolean false true [TYPE] RealMethod realMethod [TYPE] Object[] arguments  [CONTEXT]  public Object invoke ( Object target , Object[] arguments ) throws Throwable { try { [ATTENTION] return ( ( HasCGLIBMethodProxy ) realMethod )  . getMethodProxy ( )  ; } catch ( Throwable t ) { new ConditionalStackTraceFilter ( ) . filter ( t ) ; throw t ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^24^^^^^22^29^
[REPLACE]  throw  t; 	[BUGGY] return ; [CE] missing return value  [METHOD]  invoke [TYPE] Object [PARAMETER] Object target Object[] arguments [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] Throwable t [TYPE] Object target [TYPE] boolean false true [TYPE] RealMethod realMethod [TYPE] Object[] arguments  [CONTEXT]  public Object invoke ( Object target , Object[] arguments ) throws Throwable { try { return realMethod . invoke ( target , arguments ) ; } catch ( Throwable t ) { new ConditionalStackTraceFilter ( ) . filter ( t ) ; [ATTENTION] return ; } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^27^^^^^22^29^
[REPLACE]  return  (  (  HasCGLIBMethodProxy  )  realMethod  )    .  getMethodProxy  (  )  ; 	[BUGGY] return realMethod . invoke ( target , arguments ) ; [CE] cannot find symbol target  [METHOD]  getMethodProxy [TYPE] MethodProxy [PARAMETER] [CLASS] FilteredCGLIBProxyRealMethod  [TYPE] RealMethod realMethod [TYPE] boolean false true  [CONTEXT]  public MethodProxy getMethodProxy ( ) { [ATTENTION] return realMethod . invoke ( target , arguments )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java^32^^^^^31^33^
[REPLACE]  private  final  MethodProxy  methodProxy; 	[BUGGY] private MethodProxy methodProxy ; [NO-ERROR]  [CONTEXT]    [CLASS] CGLIBProxyRealMethod  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java^12^^^^^^^
[REPLACE]  this  .  methodProxy  =  methodProxy; 	[BUGGY] this . methodProxy =  null ; [FE]  Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses assertEquals(namingPolicy , MockitoNamingPolicy.INSTANCE)   [METHOD]  <init> [TYPE] MethodProxy) [PARAMETER] MethodProxy methodProxy [CLASS] CGLIBProxyRealMethod  [TYPE] MethodProxy methodProxy [TYPE] boolean false true  [CONTEXT]  public CGLIBProxyRealMethod ( MethodProxy methodProxy ) { [ATTENTION] this . methodProxy = null ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java^15^^^^^14^16^
[REPLACE]  return  methodProxy  .  invokeSuper  (  target,  arguments  )  ; 	[BUGGY] return methodProxy ; [FE]  org.mockito.cglib.proxy.MethodProxy cannot be cast to java.lang.String assertEquals(  "woof  " , dog.bark())   [METHOD]  invoke [TYPE] Object [PARAMETER] Object target Object[] arguments [CLASS] CGLIBProxyRealMethod  [TYPE] MethodProxy methodProxy [TYPE] Object target [TYPE] boolean false true [TYPE] Object[] arguments  [CONTEXT]  public Object invoke ( Object target , Object[] arguments ) throws Throwable { [ATTENTION] return methodProxy ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java^19^^^^^18^20^
[REPLACE]  return  methodProxy; 	[BUGGY] return methodProxy . invokeSuper ( target , arguments ) ; [CE] cannot find symbol target  [METHOD]  getMethodProxy [TYPE] MethodProxy [PARAMETER] [CLASS] CGLIBProxyRealMethod  [TYPE] MethodProxy methodProxy [TYPE] boolean false true  [CONTEXT]  public MethodProxy getMethodProxy ( ) { [ATTENTION] return methodProxy . invokeSuper ( target , arguments )  ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java^23^^^^^22^24^
[REPLACE]  List<Matcher>  lastMatchers  =  argumentMatcherStorage  .  pullMatchers  (  )  ; 	[BUGGY] int recordedMatchersSize = matchers . size ( ) ; [CE] cannot find symbol matchers  [METHOD]  bindMatchers [TYPE] InvocationMatcher [PARAMETER] ArgumentMatcherStorage argumentMatcherStorage Invocation invocation [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocationWithMatchers [TYPE] List lastMatchers [TYPE] ArgumentMatcherStorage argumentMatcherStorage  [CONTEXT]  public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { [ATTENTION] int recordedMatchersSize = matchers . size ( )  ; validateMatchers ( invocation , lastMatchers ) ;  InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , lastMatchers ) ; return invocationWithMatchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^17^^^^^16^22^
[REPLACE]  validateMatchers  (  invocation,  lastMatchers  )  ; 	[BUGGY] validateMatchers ( invocation , this ) ; [CE] method validateMatchers in class MatchersBinder cannot be applied to given types ;  [METHOD]  bindMatchers [TYPE] InvocationMatcher [PARAMETER] ArgumentMatcherStorage argumentMatcherStorage Invocation invocation [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocationWithMatchers [TYPE] List lastMatchers [TYPE] ArgumentMatcherStorage argumentMatcherStorage  [CONTEXT]  public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { List<Matcher> lastMatchers = argumentMatcherStorage . pullMatchers ( ) ; [ATTENTION] validateMatchers ( invocation , this )  ;  InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , lastMatchers ) ; return invocationWithMatchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^18^^^^^16^22^
[REPLACE]  InvocationMatcher  invocationWithMatchers  =  new  InvocationMatcher  (  invocation,  lastMatchers  )  ; 	[BUGGY] InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , this ) ; [CE] no suitable constructor found for InvocationMatcher(Invocation , MatchersBinder)  [METHOD]  bindMatchers [TYPE] InvocationMatcher [PARAMETER] ArgumentMatcherStorage argumentMatcherStorage Invocation invocation [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocationWithMatchers [TYPE] List lastMatchers [TYPE] ArgumentMatcherStorage argumentMatcherStorage  [CONTEXT]  public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { List<Matcher> lastMatchers = argumentMatcherStorage . pullMatchers ( ) ; validateMatchers ( invocation , lastMatchers ) ;  [ATTENTION] InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , this )  ; return invocationWithMatchers ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^20^^^^^16^22^
[ADD]  InvocationMatcher  invocationWithMatchers  =  new  InvocationMatcher  (  invocation,  lastMatchers  )  ;  return  invocationWithMatchers; 	[BUGGY] [CE] missing return statement  [METHOD]  bindMatchers [TYPE] InvocationMatcher [PARAMETER] ArgumentMatcherStorage argumentMatcherStorage Invocation invocation [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] InvocationMatcher invocationWithMatchers [TYPE] List lastMatchers [TYPE] ArgumentMatcherStorage argumentMatcherStorage  [CONTEXT]  public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { List<Matcher> lastMatchers = argumentMatcherStorage . pullMatchers ( ) ; validateMatchers ( invocation , lastMatchers ) ;  [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^20^21^^^^16^22^
[REPLACE]  if  (  !matchers  .  isEmpty  (  )  )  { 	[BUGGY] if ( matchers . isEmpty ( ) ) {[FE] AssertionFailedError [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { [ATTENTION] if ( matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^25^^^^^24^32^
[REPLACE]  if  (  expectedMatchersSize  !=  recordedMatchersSize  )  { 	[BUGGY] if ( expectedMatchersSize  = =  recordedMatchersSize ) {[FE] AssertionFailedError [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; [ATTENTION] if ( expectedMatchersSize = = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^28^^^^^24^32^
[REPLACE]  new  Reporter  (  )    .  invalidUseOfMatchers  (  expectedMatchersSize,  recordedMatchersSize  )  ; 	[BUGGY] int recordedMatchersSize = matchers . size ( ) ; [CE] variable recordedMatchersSize is already defined in method validateMatchers(Invocation , List<Matcher>)  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { [ATTENTION] int recordedMatchersSize = matchers . size ( )  ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^29^^^^^24^32^
[ADD]  new  Reporter  (  )    .  invalidUseOfMatchers  (  expectedMatchersSize,  recordedMatchersSize  )  ; 	[BUGGY] [FE] NullPointerException assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { [ATTENTION] } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^29^^^^^24^32^
[REPLACE]  int  recordedMatchersSize  =  matchers  .  size  (  )  ; 	[BUGGY] int recordedMatchersSize = 0 . isEmpty ( ) ; [CE] ' ; ' expected  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { [ATTENTION] int recordedMatchersSize = 0 . isEmpty ( )  ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^26^^^^^24^32^
[REPLACE]  int  expectedMatchersSize  =  invocation  .  getArgumentsCount  (  )  ; 	[BUGGY] int recordedMatchersSize = matchers . size ( ) ; [CE] variable recordedMatchersSize is already defined in method validateMatchers(Invocation , List<Matcher>)  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; [ATTENTION] int recordedMatchersSize = matchers . size ( )  ; if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^27^^^^^24^32^
[ADD]  if  (  expectedMatchersSize  !=  recordedMatchersSize  )  {  new  Reporter  (  )    .  invalidUseOfMatchers  (  expectedMatchersSize,  recordedMatchersSize  )  ;  } 	[BUGGY] [FE] NullPointerException assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; [ATTENTION]  } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^28^29^30^^^24^32^
[REPLACE]  new  Reporter  (  )    .  invalidUseOfMatchers  (  expectedMatchersSize,  recordedMatchersSize  )  ; 	[BUGGY] new Reporter ( )  . Reporter ( )  ; [CE] cannot find symbol  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { [ATTENTION] new Reporter ( ) . Reporter ( ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^29^^^^^24^32^
[REPLACE]  int  recordedMatchersSize  =  matchers  .  size  (  )  ; 	[BUGGY] int recordedMatchersSize = null . isEmpty ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { [ATTENTION] int recordedMatchersSize = null . isEmpty ( )  ; int expectedMatchersSize = invocation . getArgumentsCount ( ) ; if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^26^^^^^24^32^
[ADD]  int  recordedMatchersSize  =  matchers  .  size  (  )  ;  int  expectedMatchersSize  =  invocation  .  getArgumentsCount  (  )  ; 	[BUGGY] [CE] cannot find symbol expectedMatchersSize  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { [ATTENTION]  if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^26^27^^^^24^32^
[ADD]  int  expectedMatchersSize  =  invocation  .  getArgumentsCount  (  )  ; 	[BUGGY] [CE] cannot find symbol expectedMatchersSize  [METHOD]  validateMatchers [TYPE] void [PARAMETER] Invocation invocation Matcher> matchers [CLASS] MatchersBinder  [TYPE] boolean false true [TYPE] Invocation invocation [TYPE] List matchers [TYPE] int expectedMatchersSize recordedMatchersSize  [CONTEXT]  private void validateMatchers ( Invocation invocation , List<Matcher> matchers ) { if ( !matchers . isEmpty ( ) ) { int recordedMatchersSize = matchers . size ( ) ; [ATTENTION] if ( expectedMatchersSize ! = recordedMatchersSize ) { new Reporter ( ) . invalidUseOfMatchers ( expectedMatchersSize , recordedMatchersSize ) ; } } }  	./Perturbation-Mockito-38/src/org/mockito/internal/invocation/MatchersBinder.java^27^^^^^24^32^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] InvocationMatcher) [PARAMETER] InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] boolean false true  [CONTEXT]  private RemoveNotMatching ( InvocationMatcher wanted ) { [ATTENTION] this . wanted = null ; }  	None^129^^^^^128^130^
[REPLACE]  return  ListUtil  .  filter  (  invocations,  new  RemoveNotMatching  (  wanted  )  )  ; 	[BUGGY] return ListUtil . filter ( unverified , new RemoveNotMatching ( wanted ) ) ; [CE] cannot find symbol unverified  [METHOD]  findInvocations [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public List<Invocation> findInvocations ( List<Invocation> invocations , InvocationMatcher wanted ) { [ATTENTION] return ListUtil . filter ( unverified , new RemoveNotMatching ( wanted ) )  ; }  	None^17^^^^^16^18^
[REPLACE]  List<Invocation>  unverified  =  removeVerifiedInOrder  (  invocations  )  ; 	[BUGGY] List<Invocation> unverified = removeVerifiedInOrder ( null ) ; [FE] AssertionFailedError [METHOD]  findAllMatchingUnverifiedChunks [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true  [CONTEXT]  public List<Invocation> findAllMatchingUnverifiedChunks ( List<Invocation> invocations , InvocationMatcher wanted ) { [ATTENTION] List<Invocation> unverified = removeVerifiedInOrder ( null )  ; return ListUtil . filter ( unverified , new RemoveNotMatching ( wanted ) ) ; }  	None^21^^^^^20^23^
[REPLACE]  return  ListUtil  .  filter  (  unverified,  new  RemoveNotMatching  (  wanted  )  )  ; 	[BUGGY] return ListUtil . filter ( unverified ,  new RemoveUnverifiedInOrder ( )  ) ; [FE] AssertionFailedError [METHOD]  findAllMatchingUnverifiedChunks [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true  [CONTEXT]  public List<Invocation> findAllMatchingUnverifiedChunks ( List<Invocation> invocations , InvocationMatcher wanted ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; [ATTENTION] return ListUtil . filter ( unverified , new RemoveUnverifiedInOrder ( )  )  ; }  	None^22^^^^^20^23^
[REPLACE]  List<Invocation>  unverified  =  removeVerifiedInOrder  (  invocations  )  ; 	[BUGGY] List<Invocation> unverified = removeVerifiedInOrder ( false ) ; [CE] method removeVerifiedInOrder in class InvocationsFinder cannot be applied to given types ;  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION] List<Invocation> unverified = removeVerifiedInOrder ( false )  ; List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ;  if ( wantedCount ! = firstChunk . size ( ) ) { return this . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; } else { return firstChunk ; } }  	None^41^^^^^40^49^
[ADD]  List<Invocation>  unverified  =  removeVerifiedInOrder  (  invocations  )  ;  List<Invocation>  firstChunk  =  getFirstMatchingChunk  (  wanted,  unverified  )  ;  if  (  wantedCount  !=  firstChunk  .  size  (  )  )  {  return  this  .  findAllMatchingUnverifiedChunks  (  invocations,  wanted  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { [ATTENTION]   } else { return firstChunk ; } }  	None^41^42^^44^45^40^49^
[REPLACE]  List<Invocation>  firstChunk  =  getFirstMatchingChunk  (  wanted,  unverified  )  ; 	[BUGGY] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , false ) ; [CE] method getFirstMatchingChunk in class InvocationsFinder cannot be applied to given types ;  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; [ATTENTION] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , false )  ;  if ( wantedCount ! = firstChunk . size ( ) ) { return this . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; } else { return firstChunk ; } }  	None^42^^^^^40^49^
[REPLACE]  if  (  wantedCount  !=  firstChunk  .  size  (  )  )  { 	[BUGGY] if ( wantedCount ! = firstChunk . isEmpty ( )  + 2 ) {[CE] bad operand types for binary operator '+'  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ;  [ATTENTION] if ( wantedCount ! = firstChunk . isEmpty ( ) + 2 ) { return this . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; } else { return firstChunk ; } }  	None^44^^^^^40^49^
[REPLACE]  return  firstChunk; 	[BUGGY] return firstSimilar ; [CE] cannot find symbol firstSimilar  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ;  if ( wantedCount ! = firstChunk . size ( ) ) { return this . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; } else { [ATTENTION] return firstSimilar ; } }  	None^47^^^^^40^49^
[REPLACE]  return  this  .  findAllMatchingUnverifiedChunks  (  invocations,  wanted  )  ; 	[BUGGY] return this . findInvocations ( invocations , wanted ) ; [FE]   assertContains(  "fourthChunk(  " , e.getMessage())   [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ;  if ( wantedCount ! = firstChunk . size ( ) ) { [ATTENTION] return this . findInvocations ( invocations , wanted )  ; } else { return firstChunk ; } }  	None^45^^^^^40^49^
[REPLACE]  return  firstChunk; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  findMatchingChunk [TYPE] List [PARAMETER] Invocation> invocations InvocationMatcher wanted int wantedCount [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk invocations unverified [TYPE] boolean false true [TYPE] int wantedCount  [CONTEXT]  public List<Invocation> findMatchingChunk ( List<Invocation> invocations , InvocationMatcher wanted , int wantedCount ) { List<Invocation> unverified = removeVerifiedInOrder ( invocations ) ; List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ;  if ( wantedCount ! = firstChunk . size ( ) ) { return this . findAllMatchingUnverifiedChunks ( invocations , wanted ) ; } else { [ATTENTION] return false ; } }  	None^47^^^^^40^49^
[REPLACE]  List<Invocation>  firstChunk  =  new  LinkedList<Invocation>  (  )  ; 	[BUGGY] List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [CE] variable unverified is already defined in method getFirstMatchingChunk(InvocationMatcher , List<Invocation>)  [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { [ATTENTION] List<Invocation> unverified = new LinkedList<Invocation> ( )  ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; } else if ( !firstChunk . isEmpty ( ) ) { break ; } } return firstChunk ; }  	None^52^^^^^51^61^
[REPLACE]  if  (  wanted  .  matches  (  invocation  )  )  { 	[BUGGY] if ( wanted . hasSameMethod ( invocation ) ) {[FE]   assertContains(  "thirdChunk(  " , e.getMessage())   [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { [ATTENTION] if ( wanted . hasSameMethod ( invocation ) ) { firstChunk . add ( invocation ) ; } else if ( !firstChunk . isEmpty ( ) ) { break ; } } return firstChunk ; }  	None^54^^^^^51^61^
[REPLACE]  }  else  if  (  !firstChunk  .  isEmpty  (  )  )  { 	[BUGGY]  if ( !firstChunk . add ( ) ) {[CE] no suitable method found for add()  [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; [ATTENTION] }if ( !firstChunk . add ( ) ) { break ; } } return firstChunk ; }  	None^56^^^^^51^61^
[REPLACE]  firstChunk  .  add  (  invocation  )  ; 	[BUGGY] if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; [CE] illegal start of expression  [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { [ATTENTION] if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } else if ( !firstChunk . isEmpty ( ) ) { break ; } } return firstChunk ; }  	None^55^^^^^51^61^
[REPLACE]  }  else  if  (  !firstChunk  .  isEmpty  (  )  )  { 	[BUGGY]  else {[FE] AssertionFailedError [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; [ATTENTION] }else { break ; } } return firstChunk ; }  	None^56^^^^^51^61^
[ADD]  else  if  (  !firstChunk  .  isEmpty  (  )  )  {  break;  } 	[BUGGY]  break ; [FE]  AssertionFailedError  expected:<3> but was:<1> assertThat(chunk , hasExactlyInOrder(simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree))   [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; [ATTENTION] } break ;  } return firstChunk ; }  	None^56^57^58^^^51^61^
[REPLACE]  for  (  Invocation  invocation  :  unverified  )  { 	[BUGGY] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ; [CE] illegal start of type  [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; [ATTENTION] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified )  ; if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; } else if ( !firstChunk . isEmpty ( ) ) { break ; } } return firstChunk ; }  	None^53^^^^^51^61^
[REPLACE]  return  firstChunk; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  getFirstMatchingChunk [TYPE] List [PARAMETER] InvocationMatcher wanted Invocation> unverified [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List firstChunk unverified [TYPE] boolean false true [TYPE] Invocation invocation  [CONTEXT]  private List<Invocation> getFirstMatchingChunk ( InvocationMatcher wanted , List<Invocation> unverified ) { List<Invocation> firstChunk = new LinkedList<Invocation> ( ) ; for ( Invocation invocation : unverified ) { if ( wanted . matches ( invocation ) ) { firstChunk . add ( invocation ) ; } else if ( !firstChunk . isEmpty ( ) ) { break ; } } [ATTENTION] return this ; }  	None^60^^^^^51^61^
[REPLACE]  Invocation  firstSimilar  =  null; 	[BUGGY] Invocation firstSimilar = this ; [CE] incompatible types  [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { [ATTENTION] Invocation firstSimilar = this ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^64^^^^^63^78^
[REPLACE]  if  (  !wanted  .  hasSimilarMethod  (  invocation  )  )  { 	[BUGGY] if ( !wanted . hasSameMethod ( invocation )  ) {[FE]  expected same:<null> was not:<mock.simpleMethod()   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { [ATTENTION] if ( !wanted . hasSameMethod ( invocation )  ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^66^^^^^63^78^
[ADD]  if  (  !wanted  .  hasSimilarMethod  (  invocation  )  )  {  continue;  } 	[BUGGY] [FE]   assertEquals(  "stubbed  " , three.varargsObject(5 ,   "first arg  " ,   "second arg  "))   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { [ATTENTION]  if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^66^67^68^^^63^78^
[REPLACE]  if  (  firstSimilar  ==  null  )  { 	[BUGGY] if (invocation ! = null ) {[FE]  expected same:<mock.simpleMethod()   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } [ATTENTION] if ( invocation ! = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^69^^^^^63^78^
[REPLACE]  firstSimilar  =  invocation; 	[BUGGY] firstSimilar =  null ; [FE]  expected same:<null> was not:<mock.simpleMethod()   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { [ATTENTION] firstSimilar = null ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^70^^^^^63^78^
[REPLACE]  if  (  wanted  .  hasSameMethod  (  invocation  )  )  { 	[BUGGY] if ( wanted . hasSimilarMethod ( invocation )  ) {[FE]   assertContains(  "bar  " , e.getMessage())   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } [ATTENTION] if ( wanted . hasSimilarMethod ( invocation )  ) { return invocation ; } } return firstSimilar ; }  	None^72^^^^^63^78^
[REPLACE]  return  invocation; 	[BUGGY] return firstSimilar ; [FE]   assertContains(  "bar  " , e.getMessage())   [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { [ATTENTION] return firstSimilar ; } } return firstSimilar ; }  	None^73^^^^^63^78^
[REPLACE]  for  (  Invocation  invocation  :  invocations  )  { 	[BUGGY] List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [CE] illegal start of type  [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; [ATTENTION] List<Invocation> unverified = new LinkedList<Invocation> ( )  ; if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } return firstSimilar ; }  	None^65^^^^^63^78^
[REPLACE]  return  firstSimilar; 	[BUGGY] return invocation ; [CE] cannot find symbol invocation  [METHOD]  findSimilarInvocation [TYPE] Invocation [PARAMETER] Invocation> invocations InvocationMatcher wanted [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation firstSimilar invocation  [CONTEXT]  public Invocation findSimilarInvocation ( List<Invocation> invocations , InvocationMatcher wanted ) { Invocation firstSimilar = null ; for ( Invocation invocation : invocations ) { if ( !wanted . hasSimilarMethod ( invocation ) ) { continue ; } if ( firstSimilar = = null ) { firstSimilar = invocation ; } if ( wanted . hasSameMethod ( invocation ) ) { return invocation ; } } [ATTENTION] return invocation ; }  	None^77^^^^^63^78^
[REPLACE]  return  findFirstUnverified  (  invocations,  null  )  ; 	[BUGGY] return findFirstUnverified ( invocations , false ) ; [FE]  expected same:<mock.simpleMethod()   [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true  [CONTEXT]  public Invocation findFirstUnverified ( List<Invocation> invocations ) { [ATTENTION] return findFirstUnverified ( invocations , false )  ; }  	None^81^^^^^80^82^
[REPLACE]  if  (  !i  .  isVerified  (  )  &&  mockIsValid  )  { 	[BUGGY] if ( i . isVerified ( ) && mockIsValid ) {[FE]  expected same:<mock.simpleMethod()   [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { for ( Invocation i : invocations ) { boolean mockIsValid = mock = = null || mock = = i . getMock ( ) ; [ATTENTION] if ( i . isVerified ( ) && mockIsValid ) { return i ; } } return null ; }  	None^87^^^^^84^92^
[ADD]  if  (  !i  .  isVerified  (  )  &&  mockIsValid  )  {  return  i;  } 	[BUGGY] [FE]  expected same:<mock.simpleMethod()   [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { for ( Invocation i : invocations ) { boolean mockIsValid = mock = = null || mock = = i . getMock ( ) ; [ATTENTION]  } return null ; }  	None^87^88^89^^^84^92^
[REPLACE]  return  i; 	[BUGGY] return firstSimilar ; [CE] cannot find symbol firstSimilar  [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { for ( Invocation i : invocations ) { boolean mockIsValid = mock = = null || mock = = i . getMock ( ) ; if ( !i . isVerified ( ) && mockIsValid ) { [ATTENTION] return firstSimilar ; } } return null ; }  	None^88^^^^^84^92^
[REPLACE]  for  (  Invocation  i  :  invocations  )  { 	[BUGGY] List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [CE] illegal start of type  [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { [ATTENTION] List<Invocation> unverified = new LinkedList<Invocation> ( )  ; boolean mockIsValid = mock = = null || mock = = i . getMock ( ) ; if ( !i . isVerified ( ) && mockIsValid ) { return i ; } } return null ; }  	None^85^^^^^84^92^
[ADD]  for  (  Invocation  i  :  invocations  )  {  boolean  mockIsValid  =  mock  ==  null  ||  mock  ==  i  .  getMock  (  )  ;  if  (  !i  .  isVerified  (  )  &&  mockIsValid  )  {  return  i;  } 	[BUGGY] [CE] illegal start of type  [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { [ATTENTION]   } return null ; }  	None^85^86^87^88^89^84^92^
[REPLACE]  boolean  mockIsValid  =  mock  ==  null  ||  mock  ==  i  .  getMock  (  )  ; 	[BUGGY] boolean mockIsValid = mock = = false  = =  mock = = i . getMock ( ) ; [CE] incomparable types: Object and boolean  [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { for ( Invocation i : invocations ) { [ATTENTION] boolean mockIsValid = mock = = false = = mock = = i . getMock ( )  ; if ( !i . isVerified ( ) && mockIsValid ) { return i ; } } return null ; }  	None^86^^^^^84^92^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  findFirstUnverified [TYPE] Invocation [PARAMETER] Invocation> invocations Object mock [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] Object mock [TYPE] boolean false mockIsValid true [TYPE] Invocation i  [CONTEXT]  Invocation findFirstUnverified ( List<Invocation> invocations , Object mock ) { for ( Invocation i : invocations ) { boolean mockIsValid = mock = = null || mock = = i . getMock ( ) ; if ( !i . isVerified ( ) && mockIsValid ) { return i ; } } [ATTENTION] return true ; }  	None^91^^^^^84^92^
[REPLACE]  if  (  invocations  .  isEmpty  (  )  )  { 	[BUGGY] if ( wanted . matches ( invocation ) ) {[CE] cannot find symbol invocation  [METHOD]  getLastLocation [TYPE] Location [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation last  [CONTEXT]  public Location getLastLocation ( List<Invocation> invocations ) { [ATTENTION] if ( wanted . matches ( invocation ) ) { return null ; } else { Invocation last = invocations . get ( invocations . size ( ) - 1 ) ; return last . getLocation ( ) ; } }  	None^95^^^^^94^101^
[REPLACE]  return  last  .  getLocation  (  )  ; 	[BUGGY] return last . getMock ( ) ; [CE] incompatible types  [METHOD]  getLastLocation [TYPE] Location [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation last  [CONTEXT]  public Location getLastLocation ( List<Invocation> invocations ) { if ( invocations . isEmpty ( ) ) { return null ; } else { Invocation last = invocations . get ( invocations . size ( ) - 1 ) ; [ATTENTION] return last . getMock ( )  ; } }  	None^99^^^^^94^101^
[REPLACE]  Invocation  last  =  invocations  .  get  (  invocations  .  size  (  )  -  1  )  ; 	[BUGGY] Invocation last = invocations . get ( invocations . length ( ) - 1 ) ; [CE] cannot find symbol  [METHOD]  getLastLocation [TYPE] Location [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation last  [CONTEXT]  public Location getLastLocation ( List<Invocation> invocations ) { if ( invocations . isEmpty ( ) ) { return null ; } else { [ATTENTION] Invocation last = invocations . get ( invocations . length ( ) - 1 )  ; return last . getLocation ( ) ; } }  	None^98^^^^^94^101^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  getLastLocation [TYPE] Location [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation last  [CONTEXT]  public Location getLastLocation ( List<Invocation> invocations ) { if ( invocations . isEmpty ( ) ) { [ATTENTION] return this ; } else { Invocation last = invocations . get ( invocations . size ( ) - 1 ) ; return last . getLocation ( ) ; } }  	None^96^^^^^94^101^
[REPLACE]  Invocation  last  =  invocations  .  get  (  invocations  .  size  (  )  -  1  )  ; 	[BUGGY] Invocation last = invocations . get ( invocations . size ( ) * 2 - 0 ) ; [FE]  IndexOutOfBoundsException Index: 6 , Size: 3 assertSame(differentMethodInvocation.getLocation() , last)   [METHOD]  getLastLocation [TYPE] Location [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] Invocation last  [CONTEXT]  public Location getLastLocation ( List<Invocation> invocations ) { if ( invocations . isEmpty ( ) ) { return null ; } else { [ATTENTION] Invocation last = invocations . get ( invocations . size ( ) *2 - 0 )  ; return last . getLocation ( ) ; } }  	None^98^^^^^94^101^
[REPLACE]  LinkedList<Invocation>  verifiedOnly  =  ListUtil  .  filter  (  invocations,  new  RemoveUnverifiedInOrder  (  )  )  ; 	[BUGGY] LinkedList<Invocation> verifiedOnly = ListUtil . filter ( true , new RemoveUnverifiedInOrder ( ) ) ; [CE] method filter in class ListUtil cannot be applied to given types ;  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { [ATTENTION] LinkedList<Invocation> verifiedOnly = ListUtil . filter ( true , new RemoveUnverifiedInOrder ( ) )  ;  if ( verifiedOnly . isEmpty ( ) ) { return null ; } else { return verifiedOnly . getLast ( ) ; } }  	None^104^^^^^103^111^
[ADD]  LinkedList<Invocation>  verifiedOnly  =  ListUtil  .  filter  (  invocations,  new  RemoveUnverifiedInOrder  (  )  )  ;  if  (  verifiedOnly  .  isEmpty  (  )  )  {  return  null; 	[BUGGY] [CE] illegal start of type  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { [ATTENTION]   } else { return verifiedOnly . getLast ( ) ; } }  	None^104^105^106^107^^103^111^
[REPLACE]  if  (  verifiedOnly  .  isEmpty  (  )  )  { 	[BUGGY] if ( this . isEmpty ( ) ) {[CE] cannot find symbol  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { LinkedList<Invocation> verifiedOnly = ListUtil . filter ( invocations , new RemoveUnverifiedInOrder ( ) ) ;  [ATTENTION] if ( this . isEmpty ( ) ) { return null ; } else { return verifiedOnly . getLast ( ) ; } }  	None^106^^^^^103^111^
[REPLACE]  return  verifiedOnly  .  getLast  (  )  ; 	[BUGGY] return verifiedOnly . LinkedList ( )  ; [CE] cannot find symbol  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { LinkedList<Invocation> verifiedOnly = ListUtil . filter ( invocations , new RemoveUnverifiedInOrder ( ) ) ;  if ( verifiedOnly . isEmpty ( ) ) { return null ; } else { [ATTENTION] return verifiedOnly . LinkedList ( ) ; } }  	None^109^^^^^103^111^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { LinkedList<Invocation> verifiedOnly = ListUtil . filter ( invocations , new RemoveUnverifiedInOrder ( ) ) ;  if ( verifiedOnly . isEmpty ( ) ) { [ATTENTION] return this ; } else { return verifiedOnly . getLast ( ) ; } }  	None^107^^^^^103^111^
[REPLACE]  return  verifiedOnly  .  getLast  (  )  ; 	[BUGGY] return null . LinkedList ( )  ; [CE] <null> cannot be dereferenced  [METHOD]  findPreviousVerifiedInOrder [TYPE] Invocation [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations [TYPE] boolean false true [TYPE] LinkedList verifiedOnly  [CONTEXT]  public Invocation findPreviousVerifiedInOrder ( List<Invocation> invocations ) { LinkedList<Invocation> verifiedOnly = ListUtil . filter ( invocations , new RemoveUnverifiedInOrder ( ) ) ;  if ( verifiedOnly . isEmpty ( ) ) { return null ; } else { [ATTENTION] return null . LinkedList ( ) ; } }  	None^109^^^^^103^111^
[REPLACE]  List<Invocation>  unverified  =  new  LinkedList<Invocation>  (  )  ; 	[BUGGY] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified ) ; [CE] cannot find symbol wanted  [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { [ATTENTION] List<Invocation> firstChunk = getFirstMatchingChunk ( wanted , unverified )  ; for ( Invocation i : invocations ) { if ( i . isVerifiedInOrder ( ) ) { unverified . clear ( ) ; } else { unverified . add ( i ) ; } } return unverified ; }  	None^114^^^^^113^123^
[REPLACE]  if  (  i  .  isVerifiedInOrder  (  )  )  { 	[BUGGY] if ( wanted . matches ( invocation ) ) {[CE] cannot find symbol invocation  [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { List<Invocation> unverified = new LinkedList<Invocation> ( ) ; for ( Invocation i : invocations ) { [ATTENTION] if ( wanted . matches ( invocation ) ) { unverified . clear ( ) ; } else { unverified . add ( i ) ; } } return unverified ; }  	None^116^^^^^113^123^
[REPLACE]  unverified  .  clear  (  )  ; 	[BUGGY] unverified . get ( )  ; [CE] method get in interface List<E> cannot be applied to given types ;  [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { List<Invocation> unverified = new LinkedList<Invocation> ( ) ; for ( Invocation i : invocations ) { if ( i . isVerifiedInOrder ( ) ) { [ATTENTION] unverified . get ( ) ; } else { unverified . add ( i ) ; } } return unverified ; }  	None^117^^^^^113^123^
[REPLACE]  for  (  Invocation  i  :  invocations  )  { 	[BUGGY] List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [CE] illegal start of type  [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [ATTENTION] List<Invocation> unverified = new LinkedList<Invocation> ( )  ; if ( i . isVerifiedInOrder ( ) ) { unverified . clear ( ) ; } else { unverified . add ( i ) ; } } return unverified ; }  	None^115^^^^^113^123^
[ADD]  for  (  Invocation  i  :  invocations  )  {  if  (  i  .  isVerifiedInOrder  (  )  )  {  unverified  .  clear  (  )  ;  }  else  {  unverified  .  add  (  i  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { List<Invocation> unverified = new LinkedList<Invocation> ( ) ; [ATTENTION]   } } return unverified ; }  	None^115^116^117^118^119^113^123^
[REPLACE]  return  unverified; 	[BUGGY] return null ; [FE] AssertionFailedError [METHOD]  removeVerifiedInOrder [TYPE] List [PARAMETER] Invocation> invocations [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] InvocationMatcher wanted [TYPE] List invocations unverified [TYPE] boolean false true [TYPE] Invocation i  [CONTEXT]  private List<Invocation> removeVerifiedInOrder ( List<Invocation> invocations ) { List<Invocation> unverified = new LinkedList<Invocation> ( ) ; for ( Invocation i : invocations ) { if ( i . isVerifiedInOrder ( ) ) { unverified . clear ( ) ; } else { unverified . add ( i ) ; } } [ATTENTION] return null ; }  	None^122^^^^^113^123^
[REPLACE]  return  !wanted  .  matches  (  invocation  )  ; 	[BUGGY] return firstSimilar ; [CE] cannot find symbol firstSimilar  [METHOD]  isOut [TYPE] boolean [PARAMETER] Invocation invocation [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] Invocation invocation [TYPE] InvocationMatcher wanted [TYPE] boolean false true  [CONTEXT]  public boolean isOut ( Invocation invocation ) { [ATTENTION] return firstSimilar ; }  	None^133^^^^^132^134^
[REPLACE]  return  !invocation  .  isVerifiedInOrder  (  )  ; 	[BUGGY] return !invocation . isVerified ( )  ; [NO-ERROR]  [METHOD]  isOut [TYPE] boolean [PARAMETER] Invocation invocation [CLASS] InvocationsFinder RemoveNotMatching RemoveUnverifiedInOrder  [TYPE] Invocation invocation [TYPE] InvocationMatcher wanted [TYPE] boolean false true  [CONTEXT]  public boolean isOut ( Invocation invocation ) { [ATTENTION] return !invocation . isVerified ( ) ; }  	None^139^^^^^138^140^
[REPLACE]  this  .  wanted  =  wanted; 	[BUGGY] this . wanted =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] InvocationMatcher) [PARAMETER] InvocationMatcher wanted [CLASS] RemoveNotMatching  [TYPE] InvocationMatcher wanted [TYPE] boolean false true  [CONTEXT]  private RemoveNotMatching ( InvocationMatcher wanted ) { [ATTENTION] this . wanted = null ; }  	None^129^^^^^128^130^
[REPLACE]  private  IMockitoConfiguration  config  =  new  GlobalConfiguration  (  )  ; 	[BUGGY] private IMockitoConfiguration config ; [FE] [CONTEXT]    [CLASS] ConditionalStackTraceFilter  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java^12^^^^^^^
[REPLACE]  private  StackTraceFilter  filter  =  new  StackTraceFilter  (  )  ; 	[BUGGY] private StackTraceFilter filter  = null ; [FE] NullPointerException assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.test.MockitoSampleTest  "))   [CONTEXT]    [CLASS] ConditionalStackTraceFilter  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java^13^^^^^^^
[REPLACE]  if  (  !config  .  cleansStackTrace  (  )  )  { 	[BUGGY] if ( config . cleansStackTrace ( ) ) {[FE]  Number of classes does not match. assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.mockito.Mockito  " ,   "org.test.MockitoSampleTest  "))   [METHOD]  filter [TYPE] void [PARAMETER] Throwable throwable [CLASS] ConditionalStackTraceFilter  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] IMockitoConfiguration config [TYPE] StackTraceElement[] filtered  [CONTEXT]  public void filter ( Throwable throwable ) { [ATTENTION] if ( config . cleansStackTrace ( ) ) { return ; } StackTraceElement[] filtered = filter . filter ( throwable . getStackTrace ( ) , true ) ; throwable . setStackTrace ( filtered ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java^16^^^^^15^21^
[REPLACE]  StackTraceElement[]  filtered  =  filter  .  filter  (  throwable  .  getStackTrace  (  )  ,  true  )  ; 	[BUGGY] StackTraceElement[] filtered = filter . filter ( throwable . getStackTrace ( ) , false ) ; [FE]  Method at index: 0 assertThat(e , hasMethodInStackTraceAt(0 ,   "throwSomething  "))   [METHOD]  filter [TYPE] void [PARAMETER] Throwable throwable [CLASS] ConditionalStackTraceFilter  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] IMockitoConfiguration config [TYPE] StackTraceElement[] filtered  [CONTEXT]  public void filter ( Throwable throwable ) { if ( !config . cleansStackTrace ( ) ) { return ; } [ATTENTION] StackTraceElement[] filtered = filter . filter ( throwable . getStackTrace ( )  , false )  ; throwable . setStackTrace ( filtered ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java^19^^^^^15^21^
[REPLACE]  throwable  .  setStackTrace  (  filtered  )  ; 	[BUGGY] if ( !config . cleansStackTrace ( ) ) { return ; [CE] reached end of file while parsing  [METHOD]  filter [TYPE] void [PARAMETER] Throwable throwable [CLASS] ConditionalStackTraceFilter  [TYPE] Throwable throwable [TYPE] boolean false true [TYPE] StackTraceFilter filter [TYPE] IMockitoConfiguration config [TYPE] StackTraceElement[] filtered  [CONTEXT]  public void filter ( Throwable throwable ) { if ( !config . cleansStackTrace ( ) ) { return ; } StackTraceElement[] filtered = filter . filter ( throwable . getStackTrace ( ) , true ) ; [ATTENTION] if ( !config . cleansStackTrace ( ) ) { return ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java^20^^^^^15^21^
[REPLACE]  boolean  fromMockObject  =  e  .  getClassName  (  )    .  contains  (    "$$EnhancerByMockitoWithCGLIB$$  "  )  ; 	[BUGGY] boolean fromMockObject = e . getClassName ( ) . startsWith (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; [FE]  Number of classes does not match. assertThat(filtered , hasOnlyThoseClasses(  "MockitoExampleTest  "))   [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { [ATTENTION] boolean fromMockObject = e . getClassName ( )  . startsWith (   "$$EnhancerByMockitoWithCGLIB$$  " )  ; boolean fromOrgMockito = e . getClassName ( ) . startsWith (   "org . mockito .   " ) ; boolean isRunner = e . getClassName ( ) . startsWith (   "org . mockito . runners .   " ) ; boolean isInternalRunner = e . getClassName ( ) . startsWith (   "org . mockito . internal . runners .   " ) ; return ( fromMockObject || fromOrgMockito ) && !isRunner && !isInternalRunner ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^15^^^^^14^20^
[REPLACE]  boolean  fromOrgMockito  =  e  .  getClassName  (  )    .  startsWith  (    "org  .  mockito  .    "  )  ; 	[BUGGY] boolean fromOrgMockito = e . getClassName ( ) . contains (   "org . mockito .   " ) ; [NO-ERROR]  [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; [ATTENTION] boolean fromOrgMockito = e . getClassName ( )  . contains (   "org . mockito .   " )  ; boolean isRunner = e . getClassName ( ) . startsWith (   "org . mockito . runners .   " ) ; boolean isInternalRunner = e . getClassName ( ) . startsWith (   "org . mockito . internal . runners .   " ) ; return ( fromMockObject || fromOrgMockito ) && !isRunner && !isInternalRunner ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^16^^^^^14^20^
[REPLACE]  boolean  isRunner  =  e  .  getClassName  (  )    .  startsWith  (    "org  .  mockito  .  runners  .    "  )  ; 	[BUGGY] boolean isRunner = e . getClassName ( ) . contains (   "org . mockito . runners .   " ) ; [NO-ERROR]  [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; boolean fromOrgMockito = e . getClassName ( ) . startsWith (   "org . mockito .   " ) ; [ATTENTION] boolean isRunner = e . getClassName ( )  . contains (   "org . mockito . runners .   " )  ; boolean isInternalRunner = e . getClassName ( ) . startsWith (   "org . mockito . internal . runners .   " ) ; return ( fromMockObject || fromOrgMockito ) && !isRunner && !isInternalRunner ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^17^^^^^14^20^
[REPLACE]  boolean  isInternalRunner  =  e  .  getClassName  (  )    .  startsWith  (    "org  .  mockito  .  internal  .  runners  .    "  )  ; 	[BUGGY] boolean isInternalRunner = e . getClassName ( ) . contains (   "org . mockito . internal . runners .   " ) ; [NO-ERROR]  [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; boolean fromOrgMockito = e . getClassName ( ) . startsWith (   "org . mockito .   " ) ; boolean isRunner = e . getClassName ( ) . startsWith (   "org . mockito . runners .   " ) ; [ATTENTION] boolean isInternalRunner = e . getClassName ( )  . contains (   "org . mockito . internal . runners .   " )  ; return ( fromMockObject || fromOrgMockito ) && !isRunner && !isInternalRunner ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^18^^^^^14^20^
[ADD]  boolean  isInternalRunner  =  e  .  getClassName  (  )    .  startsWith  (    "org  .  mockito  .  internal  .  runners  .    "  )  ;  return  (  fromMockObject  ||  fromOrgMockito  )  &&  !isRunner  &&  !isInternalRunner; 	[BUGGY] [CE] missing return statement  [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; boolean fromOrgMockito = e . getClassName ( ) . startsWith (   "org . mockito .   " ) ; boolean isRunner = e . getClassName ( ) . startsWith (   "org . mockito . runners .   " ) ; [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^18^19^^^^14^20^
[REPLACE]  return  (  fromMockObject  ||  fromOrgMockito  )  &&  !isRunner  &&  !isInternalRunner; 	[BUGGY] return ( fromMockObject || fromOrgMockito )  ; [FE]  Number of classes does not match. assertThat(filtered , hasOnlyThoseClasses(  "org.test.MockitoSampleTest  " ,   "org.mockito.internal.runners.Runner  "))   [METHOD]  isBad [TYPE] boolean [PARAMETER] StackTraceElement e [CLASS] StackTraceFilter  [TYPE] boolean false fromMockObject fromOrgMockito isInternalRunner isRunner true [TYPE] StackTraceElement e  [CONTEXT]  public boolean isBad ( StackTraceElement e ) { boolean fromMockObject = e . getClassName ( ) . contains (   "$$EnhancerByMockitoWithCGLIB$$  " ) ; boolean fromOrgMockito = e . getClassName ( ) . startsWith (   "org . mockito .   " ) ; boolean isRunner = e . getClassName ( ) . startsWith (   "org . mockito . runners .   " ) ; boolean isInternalRunner = e . getClassName ( ) . startsWith (   "org . mockito . internal . runners .   " ) ; [ATTENTION] return ( fromMockObject || fromOrgMockito ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^19^^^^^14^20^
[REPLACE]  List<StackTraceElement>  unfilteredStackTrace  =  Arrays  .  asList  (  target  )  ; 	[BUGGY] List<StackTraceElement> unfilteredStackTrace =  target  ; [CE] incompatible types  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  [ATTENTION] List<StackTraceElement> unfilteredStackTrace = target ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^29^^^^^27^54^
[ADD]  List<StackTraceElement>  unfilteredStackTrace  =  Arrays  .  asList  (  target  )  ; 	[BUGGY] [CE] cannot find symbol unfilteredStackTrace  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  [ATTENTION]  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^29^^^^^27^54^
[REPLACE]  int  lastBad  =  -1; 	[BUGGY] int lastBad = -1 - 3 ; [FE]  fromIndex = -3 assertEquals(0 , filtered.length)   [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  [ATTENTION] int lastBad = -1 - 3 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^31^^^^^27^54^
[REPLACE]  int  firstBad  =  -1; 	[BUGGY] int firstBad = -4 ; [FE]  fromIndex(0) > toIndex(-4) assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.test.MockitoSampleTest  "))   [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; [ATTENTION] int firstBad = -4 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^32^^^^^27^54^
[REPLACE]  if  (  !this  .  isBad  (  unfilteredStackTrace  .  get  (  i  )  )  )  { 	[BUGGY] if ( !this . isBad ( false . toArray ( i ) ) ) {[CE] boolean cannot be dereferenced  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { [ATTENTION] if ( !this . isBad ( false . toArray ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^34^^^^^27^54^
[ADD]  if  (  !this  .  isBad  (  unfilteredStackTrace  .  get  (  i  )  )  )  {  continue;  } 	[BUGGY] continue ; [CE] unreachable statement  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { [ATTENTION] continue ;  lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^34^35^36^^^27^54^
[REPLACE]  if  (  firstBad  ==  -1  )  { 	[BUGGY] if ( firstBad && -1 ) {[CE] bad operand types for binary operator '&&'  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; [ATTENTION] if ( firstBad&&-1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^38^^^^^27^54^
[REPLACE]  firstBad  =  i; 	[BUGGY] lastBad = i ;  ; [FE] AssertionFailedError [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { [ATTENTION] lastBad = i ;  ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^39^^^^^27^54^
[REPLACE]  for  (  int  i  =  0;  i  <  unfilteredStackTrace  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < unfilteredStackTrace . size ( ) - 3 ; i++ ) {[FE]  Number of classes does not match. assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.test.MockitoSampleTest  "))   [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; [ATTENTION] for ( int i = 0 ; i < unfilteredStackTrace . size ( ) - 3 ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^33^^^^^27^54^
[REPLACE]  if  (  !this  .  isBad  (  unfilteredStackTrace  .  get  (  i  )  )  )  { 	[BUGGY] if ( !this . isBad ( unfilteredStackTrace . toArray ( firstBad ) ) ) {[CE] no suitable method found for toArray(int)  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { [ATTENTION] if ( !this . isBad ( unfilteredStackTrace . toArray ( firstBad ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^34^^^^^27^54^
[REPLACE]  if  (  firstBad  ==  -1  )  { 	[BUGGY] if ( firstBad && lastBad ) {[CE] bad operand types for binary operator '&&'  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; [ATTENTION] if ( firstBad&& lastBad ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^38^^^^^27^54^
[REPLACE]  lastBad  =  i; 	[BUGGY] firstBad = i ;  ; [FE]  Number of classes does not match. assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.test.MockitoSampleTest  "))   [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } [ATTENTION] firstBad = i ;  ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^37^^^^^27^54^
[ADD]  lastBad  =  i; 	[BUGGY] [FE]  Number of classes does not match. assertThat(t , hasOnlyThoseClassesInStackTrace(  "org.test.MockitoSampleTest  "))   [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } [ATTENTION] if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^37^^^^^27^54^
[ADD]  firstBad  =  i; 	[BUGGY] [FE] AssertionFailedError [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { [ATTENTION] } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^39^^^^^27^54^
[REPLACE]  for  (  int  i  =  0;  i  <  unfilteredStackTrace  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) {[NO-ERROR]  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; [ATTENTION] for ( int i = 0 ; i < unfilteredStackTrace . size ( )  ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^33^^^^^27^54^
[REPLACE]  List<StackTraceElement>  top; 	[BUGGY] List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ; [CE] variable unfilteredStackTrace is already defined in method filter(StackTraceElement[] , boolean)  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } [ATTENTION] List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target )  ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^43^^^^^27^54^
[REPLACE]  if  (  keepTop  &&  firstBad  !=  -1  )  { 	[BUGGY] if ( keepTop ) {[NO-ERROR]  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; [ATTENTION] if ( keepTop ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^44^^^^^27^54^
[REPLACE]  top  =  new  LinkedList<StackTraceElement>  (  )  ; 	[BUGGY] top =  new StackTraceElement> ( top )  ; [CE] '(' or '[' expected  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { [ATTENTION] top = new StackTraceElement> ( top ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^47^^^^^44^48^
[REPLACE]  top  =  unfilteredStackTrace  .  subList  (  0,  firstBad  )  ; 	[BUGGY] top = unfilteredStackTrace . subList ( 0L , firstBad ) ; [CE] method subList in interface List<E> cannot be applied to given types ;  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { [ATTENTION] top = unfilteredStackTrace . subList ( 0L , firstBad )  ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^45^^^^^27^54^
[REPLACE]  top  =  new  LinkedList<StackTraceElement>  (  )  ; 	[BUGGY] top =  new StackTraceElement> ( top )  ; [CE] '(' or '[' expected  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { [ATTENTION] top = new StackTraceElement> ( top ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^47^^^^^27^54^
[REPLACE]  List<StackTraceElement>  bottom  =  unfilteredStackTrace  .  subList  (  lastBad  +  1,  unfilteredStackTrace  .  size  (  )  )  ; 	[BUGGY] List<StackTraceElement> bottom = unfilteredStackTrace . subList ( firstBad + 0 , unfilteredStackTrace . size ( ) % 2 ) ; [FE] AssertionFailedError [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } [ATTENTION] List<StackTraceElement> bottom = unfilteredStackTrace . subList ( firstBad + 0 , unfilteredStackTrace . size ( ) %2 )  ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^50^^^^^27^54^
[ADD]  List<StackTraceElement>  bottom  =  unfilteredStackTrace  .  subList  (  lastBad  +  1,  unfilteredStackTrace  .  size  (  )  )  ; 	[BUGGY] [CE] cannot find symbol bottom  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } [ATTENTION] List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^50^^^^^27^54^
[REPLACE]  List<StackTraceElement>  filtered  =  new  ArrayList<StackTraceElement>  (  top  )  ; 	[BUGGY] List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( false ) ; [CE] no suitable constructor found for ArrayList(boolean)  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; [ATTENTION] List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( false )  ; filtered . addAll ( bottom ) ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^51^^^^^27^54^
[REPLACE]  filtered  .  addAll  (  bottom  )  ; 	[BUGGY] filtered . addAll ( this ) ; [CE] no suitable method found for addAll(StackTraceFilter)  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; [ATTENTION] filtered . addAll ( this )  ; return filtered . toArray ( new StackTraceElement[]{} ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^52^^^^^27^54^
[REPLACE]  return  filtered  .  toArray  (  new  StackTraceElement[]{}  )  ; 	[BUGGY] return null . addAll ( 1 )  ; [CE] <null> cannot be dereferenced  [METHOD]  filter [TYPE] StackTraceElement[] [PARAMETER] StackTraceElement[] target boolean keepTop [CLASS] StackTraceFilter  [TYPE] boolean false keepTop true [TYPE] StackTraceElement[] target [TYPE] List bottom filtered top unfilteredStackTrace [TYPE] int firstBad i lastBad  [CONTEXT]  public StackTraceElement[] filter ( StackTraceElement[] target , boolean keepTop ) {  List<StackTraceElement> unfilteredStackTrace = Arrays . asList ( target ) ;  int lastBad = -1 ; int firstBad = -1 ; for ( int i = 0 ; i < unfilteredStackTrace . size ( ) ; i++ ) { if ( !this . isBad ( unfilteredStackTrace . get ( i ) ) ) { continue ; } lastBad = i ; if ( firstBad = = -1 ) { firstBad = i ; } } List<StackTraceElement> top ; if ( keepTop && firstBad ! = -1 ) { top = unfilteredStackTrace . subList ( 0 , firstBad ) ; } else { top = new LinkedList<StackTraceElement> ( ) ; } List<StackTraceElement> bottom = unfilteredStackTrace . subList ( lastBad + 1 , unfilteredStackTrace . size ( ) ) ; List<StackTraceElement> filtered = new ArrayList<StackTraceElement> ( top ) ; filtered . addAll ( bottom ) ; [ATTENTION] return null . addAll ( 1 ) ; }  	./Perturbation-Mockito-38/src/org/mockito/internal/exceptions/base/StackTraceFilter.java^53^^^^^27^54^
[REPLACE]  private  static  MockingProgress  mockingProgress  =  new  ThreadSafeMockingProgress  (  )  ; 	[BUGGY] private static MockingProgress mockingProgress  = null ; [FE] [CONTEXT]    [CLASS] Matchers  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^104^^^^^^^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnFalse  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  anyBoolean [TYPE] boolean [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static boolean anyBoolean ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^114^^^^^113^115^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anyByte [TYPE] byte [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static byte anyByte ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^125^^^^^124^126^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnChar  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anyChar [TYPE] char [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static char anyChar ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^136^^^^^135^137^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anyInt [TYPE] int [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static int anyInt ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^147^^^^^146^148^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . returnMap ( ) ; [CE] incompatible types  [METHOD]  anyLong [TYPE] long [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static long anyLong ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . returnMap ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^158^^^^^157^159^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . returnMap ( ) ; [CE] incompatible types  [METHOD]  anyFloat [TYPE] float [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float anyFloat ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . returnMap ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^169^^^^^168^170^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY )  . returnSet ( )  ; [CE] incompatible types  [METHOD]  anyDouble [TYPE] double [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static double anyDouble ( ) { [ATTENTION] return reportMatcher ( Any . ANY ) . returnSet ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^180^^^^^179^181^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anyShort [TYPE] short [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static short anyShort ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^191^^^^^190^192^
[REPLACE]  return  (  T  )  reportMatcher  (  Any  .  ANY  )    .  returnNull  (  )  ; 	[BUGGY] return ( T ) reportMatcher ( Any . ANY )  . returnFalse ( )  ; [CE] inconvertible types  [METHOD]  anyObject [TYPE] <T> [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T anyObject ( ) { [ATTENTION] return ( T ) reportMatcher ( Any . ANY ) . returnFalse ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^202^^^^^201^203^
[REPLACE]  return  (  T  )  anyObject  (  )  ; 	[BUGGY] return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; [CE] incompatible types  [METHOD]  any [TYPE] <T> [PARAMETER] Class<T> clazz [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static <T> T any ( Class<T> clazz ) { [ATTENTION] return ( Set ) reportMatcher ( Any . ANY )  . returnSet ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^218^^^^^217^219^
[REPLACE]  return  (  T  )  anyObject  (  )  ; 	[BUGGY] return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; [CE] incompatible types  [METHOD]  any [TYPE] <T> [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T any ( ) { [ATTENTION] return ( Set ) reportMatcher ( Any . ANY )  . returnSet ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^231^^^^^230^232^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnString  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  anyString [TYPE] String [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static String anyString ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^242^^^^^241^243^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnList  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  anyList [TYPE] List [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static List anyList ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^253^^^^^252^254^
[REPLACE]  return  (  List  )  reportMatcher  (  Any  .  ANY  )    .  returnList  (  )  ; 	[BUGGY] return ( List ) reportMatcher ( Any . ANY )  . returnSet ( )  ; [FE]  java.util.HashSet cannot be cast to java.util.List assertEquals(  "list  " , mock.listArgMethod(new LinkedList<String>()))   [METHOD]  anyListOf [TYPE] <T> [PARAMETER] Class<T> clazz [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static <T> List<T> anyListOf ( Class<T> clazz ) { [ATTENTION] return ( List ) reportMatcher ( Any . ANY ) . returnSet ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^267^^^^^266^268^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnSet  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anySet [TYPE] Set [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Set anySet ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^278^^^^^277^279^
[REPLACE]  return  (  Set  )  reportMatcher  (  Any  .  ANY  )    .  returnSet  (  )  ; 	[BUGGY] return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; [CE] incompatible types  [METHOD]  anySetOf [TYPE] <T> [PARAMETER] Class<T> clazz [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static <T> Set<T> anySetOf ( Class<T> clazz ) { [ATTENTION] return ( T ) reportMatcher ( Any . ANY )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^292^^^^^291^293^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnMap  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . returnChar ( ) ; [CE] cannot find symbol matcher  [METHOD]  anyMap [TYPE] Map [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Map anyMap ( ) { [ATTENTION] return reportMatcher ( matcher )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^303^^^^^302^304^
[REPLACE]  return  reportMatcher  (  Any  .  ANY  )    .  returnList  (  )  ; 	[BUGGY] return reportMatcher ( Any . ANY ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  anyCollection [TYPE] Collection [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Collection anyCollection ( ) { [ATTENTION] return reportMatcher ( Any . ANY )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^314^^^^^313^315^
[REPLACE]  return  (  Collection  )  reportMatcher  (  Any  .  ANY  )    .  returnList  (  )  ; 	[BUGGY] return ( Collection ) reportMatcher ( Any . ANY )  . returnSet ( )  ; [NO-ERROR]  [METHOD]  anyCollectionOf [TYPE] <T> [PARAMETER] Class<T> clazz [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static <T> Collection<T> anyCollectionOf ( Class<T> clazz ) { [ATTENTION] return ( Collection ) reportMatcher ( Any . ANY ) . returnSet ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^328^^^^^327^329^
[REPLACE]  return  reportMatcher  (  new  InstanceOf  (  clazz  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . <T>returnNull ( ) ; [CE] cannot find symbol suffix  [METHOD]  isA [TYPE] <T> [PARAMETER] Class<T> clazz [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Class clazz [TYPE] boolean false true  [CONTEXT]  public static <T> T isA ( Class<T> clazz ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^343^^^^^342^344^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnFalse  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnFalse ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] boolean [PARAMETER] boolean value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true value  [CONTEXT]  public static boolean eq ( boolean value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnFalse ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^356^^^^^355^357^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Equals ( value ) )  . returnSet ( )  ; [CE] incompatible types  [METHOD]  eq [TYPE] byte [PARAMETER] byte value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] byte value [TYPE] boolean false true  [CONTEXT]  public static byte eq ( byte value ) { [ATTENTION] return reportMatcher ( new Equals ( value ) ) . returnSet ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^369^^^^^368^370^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnChar  (  )  ; 	[BUGGY] return reportMatcher ( new Equals ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  eq [TYPE] char [PARAMETER] char value [CLASS] Matchers  [TYPE] char value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static char eq ( char value ) { [ATTENTION] return reportMatcher ( new Equals ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^382^^^^^381^383^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnZero ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] double [PARAMETER] double value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] double value [TYPE] boolean false true  [CONTEXT]  public static double eq ( double value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^395^^^^^394^396^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnZero ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] float [PARAMETER] float value [CLASS] Matchers  [TYPE] float value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float eq ( float value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^408^^^^^407^409^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnZero ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] int [PARAMETER] int value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] int value [TYPE] boolean false true  [CONTEXT]  public static int eq ( int value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^421^^^^^420^422^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnZero ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] long [PARAMETER] long value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] long value [TYPE] boolean false true  [CONTEXT]  public static long eq ( long value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^434^^^^^433^435^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnZero ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] short [PARAMETER] short value [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] short value [TYPE] boolean false true  [CONTEXT]  public static short eq ( short value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^447^^^^^446^448^
[REPLACE]  return  reportMatcher  (  new  Equals  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . <T>returnNull ( ) ; [CE] cannot find symbol suffix  [METHOD]  eq [TYPE] <T> [PARAMETER] T value [CLASS] Matchers  [TYPE] T value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T eq ( T value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^460^^^^^459^461^
[REPLACE]  return  reportMatcher  (  new  ReflectionEquals  (  value,  excludeFields  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; [CE] incompatible types  [METHOD]  refEq [TYPE] <T> [PARAMETER] T value excludeFields [CLASS] Matchers  [TYPE] String[] excludeFields [TYPE] boolean false true [TYPE] T value [TYPE] MockingProgress mockingProgress  [CONTEXT]  public static <T> T refEq ( T value , String . . . excludeFields ) { [ATTENTION] return ( Set ) reportMatcher ( Any . ANY )  . returnSet ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^482^^^^^481^483^
[REPLACE]  return  reportMatcher  (  new  Same  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . <T>returnNull ( ) ; [CE] cannot find symbol suffix  [METHOD]  same [TYPE] <T> [PARAMETER] T value [CLASS] Matchers  [TYPE] T value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T same ( T value ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^497^^^^^496^498^
[REPLACE]  return  reportMatcher  (  Null  .  NULL  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( NotNull . NOT_NULL ) . returnNull ( ) ; [FE]  AssertionFailedError  expected:<1> but was:<2> assertEquals(  "1  " , mock.threeArgumentMethod(1 , null ,   "  "))   [METHOD]  isNull [TYPE] Object [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Object isNull ( ) { [ATTENTION] return reportMatcher ( NotNull . NOT_NULL )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^508^^^^^507^509^
[REPLACE]  return  reportMatcher  (  NotNull  .  NOT_NULL  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( Null . NULL ) . returnNull ( ) ; [FE]  AssertionFailedError  expected:<1> but was:<2> assertEquals(  "1  " , mock.threeArgumentMethod(1 , new Object() ,   "  "))   [METHOD]  notNull [TYPE] Object [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Object notNull ( ) { [ATTENTION] return reportMatcher ( Null . NULL )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^521^^^^^520^522^
[REPLACE]  return  notNull  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . returnChar ( ) ; [CE] cannot find symbol matcher  [METHOD]  isNotNull [TYPE] Object [PARAMETER] [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static Object isNotNull ( ) { [ATTENTION] return reportMatcher ( matcher )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^534^^^^^533^535^
[REPLACE]  return  reportMatcher  (  new  Contains  (  substring  )  )    .  returnString  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnString ( ) ; [CE] cannot find symbol suffix  [METHOD]  contains [TYPE] String [PARAMETER] String substring [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] String substring [TYPE] boolean false true  [CONTEXT]  public static String contains ( String substring ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnString ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^547^^^^^546^548^
[REPLACE]  return  reportMatcher  (  new  Matches  (  regex  )  )    .  returnString  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix )  ) . returnString ( ) ; [CE] cannot find symbol suffix  [METHOD]  matches [TYPE] String [PARAMETER] String regex [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public static String matches ( String regex ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix )  )  . returnString ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^560^^^^^559^561^
[REPLACE]  return  reportMatcher  (  new  EndsWith  (  suffix  )  )    .  returnString  (  )  ; 	[BUGGY] return reportMatcher ( new EndsWith ( suffix ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  endsWith [TYPE] String [PARAMETER] String suffix [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] String suffix [TYPE] boolean false true  [CONTEXT]  public static String endsWith ( String suffix ) { [ATTENTION] return reportMatcher ( new EndsWith ( suffix ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^573^^^^^572^574^
[REPLACE]  return  reportMatcher  (  new  StartsWith  (  prefix  )  )    .  returnString  (  )  ; 	[BUGGY] return reportMatcher ( new StartsWith ( prefix ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  startsWith [TYPE] String [PARAMETER] String prefix [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] String prefix [TYPE] boolean false true  [CONTEXT]  public static String startsWith ( String prefix ) { [ATTENTION] return reportMatcher ( new StartsWith ( prefix ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^586^^^^^585^587^
[REPLACE]  return  reportMatcher  (  matcher  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . returnChar ( ) ; [CE] incompatible types  [METHOD]  argThat [TYPE] <T> [PARAMETER] Matcher<T> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static <T> T argThat ( Matcher<T> matcher ) { [ATTENTION] return reportMatcher ( matcher )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^598^^^^^597^599^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnChar  (  )  ; 	[BUGGY] return reportMatcher ( null ) . returnChar ( ) ; [FE] NullPointerException assertEquals(  "foo  " , mock.oneArg('s'))   [METHOD]  charThat [TYPE] char [PARAMETER] Character> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static char charThat ( Matcher<Character> matcher ) { [ATTENTION] return reportMatcher ( null )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^610^^^^^609^611^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnFalse  (  )  ; 	[BUGGY] return reportMatcher ( this ) . returnFalse ( ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  booleanThat [TYPE] boolean [PARAMETER] Boolean> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static boolean booleanThat ( Matcher<Boolean> matcher ) { [ATTENTION] return reportMatcher ( this )  . returnFalse ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^622^^^^^621^623^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  byteThat [TYPE] byte [PARAMETER] Byte> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static byte byteThat ( Matcher<Byte> matcher ) { [ATTENTION] return reportMatcher ( matcher )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^634^^^^^633^635^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( this ) . returnZero ( ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  shortThat [TYPE] short [PARAMETER] Short> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static short shortThat ( Matcher<Short> matcher ) { [ATTENTION] return reportMatcher ( this )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^646^^^^^645^647^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . returnChar ( ) ; [NO-ERROR]  [METHOD]  intThat [TYPE] int [PARAMETER] Integer> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static int intThat ( Matcher<Integer> matcher ) { [ATTENTION] return reportMatcher ( matcher )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^658^^^^^657^659^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( true ) . reportMatcher ( ) ; [CE] method reportMatcher in class Matchers cannot be applied to given types ;  [METHOD]  longThat [TYPE] long [PARAMETER] Long> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static long longThat ( Matcher<Long> matcher ) { [ATTENTION] return reportMatcher ( true )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^670^^^^^669^671^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( matcher ) . returnChar ( ) ; [NO-ERROR]  [METHOD]  floatThat [TYPE] float [PARAMETER] Float> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static float floatThat ( Matcher<Float> matcher ) { [ATTENTION] return reportMatcher ( matcher )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^682^^^^^681^683^
[REPLACE]  return  reportMatcher  (  matcher  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( null ) . returnZero ( ) ; [FE] NullPointerException assertEquals(  "byte  " , mock.oneArg((byte) 0))   [METHOD]  doubleThat [TYPE] double [PARAMETER] Double> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  public static double doubleThat ( Matcher<Double> matcher ) { [ATTENTION] return reportMatcher ( null )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^694^^^^^693^695^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportMatcher  (  matcher  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( true ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  reportMatcher [TYPE] HandyReturnValues [PARAMETER] Matcher<?> matcher [CLASS] Matchers  [TYPE] MockingProgress mockingProgress [TYPE] Matcher matcher [TYPE] boolean false true  [CONTEXT]  private static HandyReturnValues reportMatcher ( Matcher<?> matcher ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Matchers.java^698^^^^^697^699^
[REPLACE]  private  static  MockingProgress  mockingProgress  =  new  ThreadSafeMockingProgress  (  )  ; 	[BUGGY] private static MockingProgress mockingProgress  = null ; [FE] NullPointerException assertContains(  "No matchers found for Not(?).  " , e.getMessage())   [CONTEXT]    [CLASS] AdditionalMatchers  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^43^^^^^^^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<T>  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . <T>returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  geq [TYPE] <T [PARAMETER] Comparable<T> value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public static <T extends Comparable<T>> T geq ( Comparable<T> value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^55^^^^^54^56^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Byte>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterOrEqual<Byte> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  geq [TYPE] byte [PARAMETER] byte value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte value [TYPE] boolean false true  [CONTEXT]  public static byte geq ( byte value ) { [ATTENTION] return reportMatcher ( new GreaterOrEqual<Byte> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^68^^^^^67^69^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Double>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  geq [TYPE] double [PARAMETER] double value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double value [TYPE] boolean false true  [CONTEXT]  public static double geq ( double value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^81^^^^^80^82^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Float>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  geq [TYPE] float [PARAMETER] float value [CLASS] AdditionalMatchers  [TYPE] float value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float geq ( float value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^94^^^^^93^95^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Integer>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterOrEqual<Integer> ( value ) )  . returnNull ( )  ; [FE] NullPointerException assertEquals(  "< 7  " , mock.oneArg(5))   [METHOD]  geq [TYPE] int [PARAMETER] int value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int value [TYPE] boolean false true  [CONTEXT]  public static int geq ( int value ) { [ATTENTION] return reportMatcher ( new GreaterOrEqual<Integer> ( value ) ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^107^^^^^106^108^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Long>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . reportMatcher ( ) ; [CE] '(' or '[' expected  [METHOD]  geq [TYPE] long [PARAMETER] long value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long value [TYPE] boolean false true  [CONTEXT]  public static long geq ( long value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^120^^^^^119^121^
[REPLACE]  return  reportMatcher  (  new  GreaterOrEqual<Short>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterOrEqual<Short> ( value ) )  . returnNull ( )  ; [FE] NullPointerException assertEquals(  "1  " , mock.oneArg((byte) 2))   [METHOD]  geq [TYPE] short [PARAMETER] short value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short value [TYPE] boolean false true  [CONTEXT]  public static short geq ( short value ) { [ATTENTION] return reportMatcher ( new GreaterOrEqual<Short> ( value ) ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^133^^^^^132^134^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<T>  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new LessOrEqual<Float> ( value ) ) . returnZero ( ) ; [CE] constructor LessOrEqual in class LessOrEqual<T#2> cannot be applied to given types ;  [METHOD]  leq [TYPE] <T [PARAMETER] Comparable<T> value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public static <T extends Comparable<T>> T leq ( Comparable<T> value ) { [ATTENTION] return reportMatcher ( new LessOrEqual<Float> ( value ) )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^146^^^^^145^147^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Byte>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  leq [TYPE] byte [PARAMETER] byte value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte value [TYPE] boolean false true  [CONTEXT]  public static byte leq ( byte value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^159^^^^^158^160^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Double>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  )  . returnNull ( )  ; [CE] '(' or '[' expected  [METHOD]  leq [TYPE] double [PARAMETER] double value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double value [TYPE] boolean false true  [CONTEXT]  public static double leq ( double value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^172^^^^^171^173^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Float>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new LessOrEqual<T> ( value ) ) . <T>returnNull ( ) ; [CE] cannot find symbol  [METHOD]  leq [TYPE] float [PARAMETER] float value [CLASS] AdditionalMatchers  [TYPE] float value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float leq ( float value ) { [ATTENTION] return reportMatcher ( new LessOrEqual<T> ( value ) )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^185^^^^^184^186^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Integer>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  leq [TYPE] int [PARAMETER] int value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int value [TYPE] boolean false true  [CONTEXT]  public static int leq ( int value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^198^^^^^197^199^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Long>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . reportMatcher ( ) ; [CE] '(' or '[' expected  [METHOD]  leq [TYPE] long [PARAMETER] long value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long value [TYPE] boolean false true  [CONTEXT]  public static long leq ( long value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^211^^^^^210^212^
[REPLACE]  return  reportMatcher  (  new  LessOrEqual<Short>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterOrEqual<T> ( value )  ) . returnZero ( ) ; [CE] cannot find symbol  [METHOD]  leq [TYPE] short [PARAMETER] short value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short value [TYPE] boolean false true  [CONTEXT]  public static short leq ( short value ) { [ATTENTION] return reportMatcher ( new GreaterOrEqual<T> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^224^^^^^223^225^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<T>  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . <T>returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  gt [TYPE] <T [PARAMETER] Comparable<T> value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public static <T extends Comparable<T>> T gt ( Comparable<T> value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^237^^^^^236^238^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Byte>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  gt [TYPE] byte [PARAMETER] byte value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte value [TYPE] boolean false true  [CONTEXT]  public static byte gt ( byte value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^250^^^^^249^251^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Double>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterThan<Double> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  gt [TYPE] double [PARAMETER] double value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double value [TYPE] boolean false true  [CONTEXT]  public static double gt ( double value ) { [ATTENTION] return reportMatcher ( new GreaterThan<Double> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^263^^^^^262^264^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Float>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterThan<Float> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  gt [TYPE] float [PARAMETER] float value [CLASS] AdditionalMatchers  [TYPE] float value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float gt ( float value ) { [ATTENTION] return reportMatcher ( new GreaterThan<Float> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^276^^^^^275^277^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Integer>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterThan<Integer> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  gt [TYPE] int [PARAMETER] int value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int value [TYPE] boolean false true  [CONTEXT]  public static int gt ( int value ) { [ATTENTION] return reportMatcher ( new GreaterThan<Integer> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^289^^^^^288^290^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Long>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  gt [TYPE] long [PARAMETER] long value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long value [TYPE] boolean false true  [CONTEXT]  public static long gt ( long value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^302^^^^^301^303^
[REPLACE]  return  reportMatcher  (  new  GreaterThan<Short>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  gt [TYPE] short [PARAMETER] short value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short value [TYPE] boolean false true  [CONTEXT]  public static short gt ( short value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^315^^^^^314^316^
[REPLACE]  return  reportMatcher  (  new  LessThan<T>  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . <T>returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  lt [TYPE] <T [PARAMETER] Comparable<T> value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public static <T extends Comparable<T>> T lt ( Comparable<T> value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^328^^^^^327^329^
[REPLACE]  return  reportMatcher  (  new  LessThan<Byte>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  lt [TYPE] byte [PARAMETER] byte value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte value [TYPE] boolean false true  [CONTEXT]  public static byte lt ( byte value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^341^^^^^340^342^
[REPLACE]  return  reportMatcher  (  new  LessThan<Double>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  lt [TYPE] double [PARAMETER] double value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double value [TYPE] boolean false true  [CONTEXT]  public static double lt ( double value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^354^^^^^353^355^
[REPLACE]  return  reportMatcher  (  new  LessThan<Float>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new LessThan<Float> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  lt [TYPE] float [PARAMETER] float value [CLASS] AdditionalMatchers  [TYPE] float value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float lt ( float value ) { [ATTENTION] return reportMatcher ( new LessThan<Float> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^367^^^^^366^368^
[REPLACE]  return  reportMatcher  (  new  LessThan<Integer>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnZero ( ) ; [CE] '(' or '[' expected  [METHOD]  lt [TYPE] int [PARAMETER] int value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int value [TYPE] boolean false true  [CONTEXT]  public static int lt ( int value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^380^^^^^379^381^
[REPLACE]  return  reportMatcher  (  new  LessThan<Long>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new LessThan<Long> ( value ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  lt [TYPE] long [PARAMETER] long value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long value [TYPE] boolean false true  [CONTEXT]  public static long lt ( long value ) { [ATTENTION] return reportMatcher ( new LessThan<Long> ( value ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^393^^^^^392^394^
[REPLACE]  return  reportMatcher  (  new  LessThan<Short>  (  value  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterOrEqual<Float> ( value ) ) . returnZero ( ) ; [CE] constructor GreaterOrEqual in class GreaterOrEqual<T> cannot be applied to given types ;  [METHOD]  lt [TYPE] short [PARAMETER] short value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short value [TYPE] boolean false true  [CONTEXT]  public static short lt ( short value ) { [ATTENTION] return reportMatcher ( new GreaterOrEqual<Float> ( value ) )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^406^^^^^405^407^
[REPLACE]  return  reportMatcher  (  new  CompareEqual<T>  (  value  )  )    .  <T>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . <T>returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  cmpEq [TYPE] <T [PARAMETER] Comparable<T> value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] Comparable value [TYPE] boolean false true  [CONTEXT]  public static <T extends Comparable<T>> T cmpEq ( Comparable<T> value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^420^^^^^419^421^
[REPLACE]  return  reportMatcher  (  new  Find  (  regex  )  )    .  <String>returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new GreaterThan<T> ( value )  ) . <String>returnNull ( ) ; [CE] cannot find symbol  [METHOD]  find [TYPE] String [PARAMETER] String regex [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] String regex [TYPE] boolean false true  [CONTEXT]  public static String find ( String regex ) { [ATTENTION] return reportMatcher ( new GreaterThan<T> ( value )  )  . <String>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^432^^^^^431^433^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new LessOrEqual<T> ( value ) ) . <T>returnNull ( ) ; [CE] type argument T#1 is not within bounds of type-variable T#2  [METHOD]  aryEq [TYPE] <T> [PARAMETER] T[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] T[] value [TYPE] boolean false true  [CONTEXT]  public static <T> T[] aryEq ( T[] value ) { [ATTENTION] return reportMatcher ( new LessOrEqual<T> ( value ) )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^448^^^^^447^449^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] short[] [PARAMETER] short[] value [CLASS] AdditionalMatchers  [TYPE] short[] value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static short[] aryEq ( short[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^462^^^^^461^463^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] long[] [PARAMETER] long[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long[] value [TYPE] boolean false true  [CONTEXT]  public static long[] aryEq ( long[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^476^^^^^475^477^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] int[] [PARAMETER] int[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int[] value [TYPE] boolean false true  [CONTEXT]  public static int[] aryEq ( int[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^490^^^^^489^491^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . reportMatcher ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] float[] [PARAMETER] float[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] float[] value [TYPE] boolean false true  [CONTEXT]  public static float[] aryEq ( float[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^504^^^^^503^505^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . reportMatcher ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] double[] [PARAMETER] double[] value [CLASS] AdditionalMatchers  [TYPE] double[] value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static double[] aryEq ( double[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^518^^^^^517^519^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . reportMatcher ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] char[] [PARAMETER] char[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] char[] value [TYPE] boolean false true  [CONTEXT]  public static char[] aryEq ( char[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^532^^^^^531^533^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new Short> ( value )  ) . returnNull ( ) ; [CE] '(' or '[' expected  [METHOD]  aryEq [TYPE] byte[] [PARAMETER] byte[] value [CLASS] AdditionalMatchers  [TYPE] byte[] value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static byte[] aryEq ( byte[] value ) { [ATTENTION] return reportMatcher ( new Short> ( value )  )  . returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^546^^^^^545^547^
[REPLACE]  return  reportMatcher  (  new  ArrayEquals  (  value  )  )    .  returnNull  (  )  ; 	[BUGGY] return reportMatcher ( new LessOrEqual<T> ( value ) ) . <T>returnNull ( ) ; [CE] cannot find symbol  [METHOD]  aryEq [TYPE] boolean[] [PARAMETER] boolean[] value [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean[] value [TYPE] boolean false true  [CONTEXT]  public static boolean[] aryEq ( boolean[] value ) { [ATTENTION] return reportMatcher ( new LessOrEqual<T> ( value ) )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^560^^^^^559^561^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnFalse  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  and [TYPE] boolean [PARAMETER] boolean first boolean second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false first second true  [CONTEXT]  public static boolean and ( boolean first , boolean second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^575^^^^^574^576^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( )  . returnNull ( )  ; [FE] NullPointerException assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  and [TYPE] byte [PARAMETER] byte first byte second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte first second [TYPE] boolean false true  [CONTEXT]  public static byte and ( byte first , byte second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^590^^^^^589^591^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnChar  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( matcher ) ; [CE] cannot find symbol matcher  [METHOD]  and [TYPE] char [PARAMETER] char first char second [CLASS] AdditionalMatchers  [TYPE] char first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static char and ( char first , char second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( matcher )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^605^^^^^604^606^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( )  . returnNull ( )  ; [FE] NullPointerException assertEquals(  "0  " , mock.oneArg(false))   [METHOD]  and [TYPE] double [PARAMETER] double first double second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double first second [TYPE] boolean false true  [CONTEXT]  public static double and ( double first , double second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^620^^^^^619^621^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  and [TYPE] float [PARAMETER] float first float second [CLASS] AdditionalMatchers  [TYPE] float first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float and ( float first , float second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^635^^^^^634^636^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( ) . returnZero ( ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  and [TYPE] int [PARAMETER] int first int second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int first second [TYPE] boolean false true  [CONTEXT]  public static int and ( int first , int second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^650^^^^^649^651^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . <T>returnNull ( ) ; [CE] cannot find symbol  [METHOD]  and [TYPE] long [PARAMETER] long first long second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long first second [TYPE] boolean false true  [CONTEXT]  public static long and ( long first , long second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^665^^^^^664^666^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . <T>returnNull ( ) ; [CE] cannot find symbol  [METHOD]  and [TYPE] short [PARAMETER] short first short second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short first second [TYPE] boolean false true  [CONTEXT]  public static short and ( short first , short second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . <T>returnNull ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^680^^^^^679^681^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportAnd  (  )    .  <T>returnNull  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  and [TYPE] <T> [PARAMETER] T first T second [CLASS] AdditionalMatchers  [TYPE] T first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T and ( T first , T second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^697^^^^^696^698^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnFalse  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  or [TYPE] boolean [PARAMETER] boolean first boolean second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false first second true  [CONTEXT]  public static boolean or ( boolean first , boolean second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^712^^^^^711^713^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  <T>returnNull  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  or [TYPE] <T> [PARAMETER] T first T second [CLASS] AdditionalMatchers  [TYPE] T first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T or ( T first , T second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^729^^^^^728^730^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportOr ( ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  or [TYPE] short [PARAMETER] short first short second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short first second [TYPE] boolean false true  [CONTEXT]  public static short or ( short first , short second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportOr ( )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^744^^^^^743^745^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  AssertionFailedError  expected:<6> but was:<null> assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  or [TYPE] long [PARAMETER] long first long second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long first second [TYPE] boolean false true  [CONTEXT]  public static long or ( long first , long second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^759^^^^^758^760^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportOr ( ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  or [TYPE] int [PARAMETER] int first int second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int first second [TYPE] boolean false true  [CONTEXT]  public static int or ( int first , int second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportOr ( )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^774^^^^^773^775^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  AssertionFailedError  expected:<4> but was:<null> assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  or [TYPE] float [PARAMETER] float first float second [CLASS] AdditionalMatchers  [TYPE] float first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float or ( float first , float second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^789^^^^^788^790^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  AssertionFailedError  expected:<3> but was:<null> assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  or [TYPE] double [PARAMETER] double first double second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double first second [TYPE] boolean false true  [CONTEXT]  public static double or ( double first , double second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^804^^^^^803^805^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnChar  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( )  . reportNot ( )  . returnChar ( ) ; [FE]   assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  or [TYPE] char [PARAMETER] char first char second [CLASS] AdditionalMatchers  [TYPE] char first second [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static char or ( char first , char second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( ) . reportNot ( ) . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^819^^^^^818^820^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportOr  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( ) . returnZero ( ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  or [TYPE] byte [PARAMETER] byte first byte second [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte first second [TYPE] boolean false true  [CONTEXT]  public static byte or ( byte first , byte second ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^834^^^^^833^835^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  <T>returnNull  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  not [TYPE] <T> [PARAMETER] T first [CLASS] AdditionalMatchers  [TYPE] T first [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static <T> T not ( T first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^849^^^^^848^850^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  2 matchers expected , 1 recorded. assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  not [TYPE] short [PARAMETER] short first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] short first [TYPE] boolean false true  [CONTEXT]  public static short not ( short first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^862^^^^^861^863^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( ) . returnZero ( ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  not [TYPE] int [PARAMETER] int first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] int first [TYPE] boolean false true  [CONTEXT]  public static int not ( int first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^875^^^^^874^876^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( ) . returnZero ( ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  not [TYPE] long [PARAMETER] long first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] long first [TYPE] boolean false true  [CONTEXT]  public static long not ( long first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^888^^^^^887^889^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportNot ( )  . returnNull ( )  ; [FE] NullPointerException assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  not [TYPE] float [PARAMETER] float first [CLASS] AdditionalMatchers  [TYPE] float first [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float not ( float first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportNot ( ) . returnNull ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^901^^^^^900^902^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  2 matchers expected , 1 recorded. assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  not [TYPE] double [PARAMETER] double first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double first [TYPE] boolean false true  [CONTEXT]  public static double not ( double first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^914^^^^^913^915^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnChar  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( ) . returnChar ( ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  not [TYPE] char [PARAMETER] char first [CLASS] AdditionalMatchers  [TYPE] char first [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static char not ( char first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( )  . returnChar ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^927^^^^^926^928^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnFalse  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [CE] incompatible types  [METHOD]  not [TYPE] boolean [PARAMETER] boolean first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] boolean false first true  [CONTEXT]  public static boolean not ( boolean first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^940^^^^^939^941^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportNot  (  )    .  returnZero  (  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportAnd ( ) . returnZero ( ) ; [FE]  2 matchers expected , 1 recorded. assertEquals(  "0  " , mock.oneArg(true))   [METHOD]  not [TYPE] byte [PARAMETER] byte first [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] byte first [TYPE] boolean false true  [CONTEXT]  public static byte not ( byte first ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportAnd ( )  . returnZero ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^953^^^^^952^954^
[REPLACE]  return  reportMatcher  (  new  EqualsWithDelta  (  value,  delta  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EqualsWithDelta ( value , delta ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  eq [TYPE] double [PARAMETER] double value double delta [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] double delta value [TYPE] boolean false true  [CONTEXT]  public static double eq ( double value , double delta ) { [ATTENTION] return reportMatcher ( new EqualsWithDelta ( value , delta ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^969^^^^^968^970^
[REPLACE]  return  reportMatcher  (  new  EqualsWithDelta  (  value,  delta  )  )    .  returnZero  (  )  ; 	[BUGGY] return reportMatcher ( new EqualsWithDelta ( value , delta ) ) . reportMatcher ( ) ; [CE] cannot find symbol  [METHOD]  eq [TYPE] float [PARAMETER] float value float delta [CLASS] AdditionalMatchers  [TYPE] float delta value [TYPE] MockingProgress mockingProgress [TYPE] boolean false true  [CONTEXT]  public static float eq ( float value , float delta ) { [ATTENTION] return reportMatcher ( new EqualsWithDelta ( value , delta ) )  . reportMatcher ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^985^^^^^984^986^
[REPLACE]  return  mockingProgress  .  getArgumentMatcherStorage  (  )    .  reportMatcher  (  matcher  )  ; 	[BUGGY] return mockingProgress . getArgumentMatcherStorage ( ) . reportMatcher ( true ) ; [CE] method reportMatcher in interface ArgumentMatcherStorage cannot be applied to given types ;  [METHOD]  reportMatcher [TYPE] HandyReturnValues [PARAMETER] ArgumentMatcher<?> matcher [CLASS] AdditionalMatchers  [TYPE] MockingProgress mockingProgress [TYPE] ArgumentMatcher matcher [TYPE] boolean false true  [CONTEXT]  private static HandyReturnValues reportMatcher ( ArgumentMatcher<?> matcher ) { [ATTENTION] return mockingProgress . getArgumentMatcherStorage ( )  . reportMatcher ( true )  ; }  	./Perturbation-Mockito-38/src/org/mockito/AdditionalMatchers.java^989^^^^^988^990^
[REPLACE]  super  (  klass  )  ; 	[BUGGY] super ( this ) ; [CE] cannot reference this before supertype constructor has been called  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] MockitoJUnit44Runner  [TYPE] boolean false true [TYPE] Class klass  [CONTEXT]  public MockitoJUnit44Runner ( Class<?> klass ) { [ATTENTION] super ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/runners/MockitoJUnit44Runner.java^52^^^^^51^53^
[REPLACE]  private  final  RunnerImpl  runner; 	[BUGGY] private RunnerImpl runner ; [NO-ERROR]  [CONTEXT]    [CLASS] MockitoJUnitRunner  	./Perturbation-Mockito-38/src/org/mockito/runners/MockitoJUnitRunner.java^49^^^^^^^
[REPLACE]  runner  =  new  RunnerFactory  (  )    .  create  (  klass  )  ; 	[BUGGY] runner =  new RunnerFactory ( ) . create ( null ) ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] MockitoJUnitRunner  [TYPE] RunnerImpl runner [TYPE] Class klass [TYPE] boolean false true  [CONTEXT]  public MockitoJUnitRunner ( Class<?> klass ) { [ATTENTION] runner = new RunnerFactory ( )  . create ( null )  ; }  	./Perturbation-Mockito-38/src/org/mockito/runners/MockitoJUnitRunner.java^52^^^^^51^53^
[REPLACE]  runner  .  run  (  notifier  )  ; 	[BUGGY] runner . filter ( notifier ) ; [CE] method filter in interface Filterable cannot be applied to given types ;  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] MockitoJUnitRunner  [TYPE] RunnerImpl runner [TYPE] RunNotifier notifier [TYPE] boolean false true  [CONTEXT]  public void run ( final RunNotifier notifier ) { [ATTENTION] runner . filter ( notifier )  ; }  	./Perturbation-Mockito-38/src/org/mockito/runners/MockitoJUnitRunner.java^57^^^^^56^58^
[REPLACE]  runner  .  filter  (  filter  )  ; 	[BUGGY] runner . run ( filter ) ; [CE] method run in interface RunnerImpl cannot be applied to given types ;  [METHOD]  filter [TYPE] void [PARAMETER] Filter filter [CLASS] MockitoJUnitRunner  [TYPE] Filter filter [TYPE] RunnerImpl runner [TYPE] boolean false true  [CONTEXT]  public void filter ( org . junit . runner . manipulation . Filter filter ) throws org . junit . runner . manipulation . NoTestsRemainException {  [ATTENTION] runner . run ( filter )  ; }  	./Perturbation-Mockito-38/src/org/mockito/runners/MockitoJUnitRunner.java^66^^^^^64^67^
[REPLACE]  private  final  MockitoLogger  logger; 	[BUGGY] private MockitoLogger logger ; [NO-ERROR]  [CONTEXT]    [CLASS] ConsoleSpammingMockitoJUnitRunner 1  	None^91^^^^^^^
[REPLACE]  this  (  klass,  new  MockitoLoggerImpl  (  )  ,  new  RunnerFactory  (  )    .  create  (  klass  )  )  ; 	[BUGGY] this ( null , new MockitoLoggerImpl ( ) , new RunnerFactory ( ) . create ( klass ) ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Class) [PARAMETER] Class<?> klass [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerImpl runner [TYPE] MockitoLogger logger  [CONTEXT]  public ConsoleSpammingMockitoJUnitRunner ( Class<?> klass ) { [ATTENTION] this ( null , new MockitoLoggerImpl ( )  , new RunnerFactory ( )  . create ( klass ) )  ; }  	None^95^^^^^94^96^
[REPLACE]  this  .  runner  =  runnerImpl; 	[BUGGY] this . runner =  runner ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RunnerImpl) [PARAMETER] Class<?> klass MockitoLogger logger RunnerImpl runnerImpl [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  ConsoleSpammingMockitoJUnitRunner ( Class<?> klass , MockitoLogger logger , RunnerImpl runnerImpl ) { [ATTENTION] this . runner = runner ; this . logger = logger ; }  	None^99^^^^^98^101^
[REPLACE]  this  .  logger  =  logger; 	[BUGGY] this . logger =  null ; [FE] AssertionFailedError [METHOD]  <init> [TYPE] RunnerImpl) [PARAMETER] Class<?> klass MockitoLogger logger RunnerImpl runnerImpl [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] Class klass [TYPE] boolean false true [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  ConsoleSpammingMockitoJUnitRunner ( Class<?> klass , MockitoLogger logger , RunnerImpl runnerImpl ) { this . runner = runnerImpl ; [ATTENTION] this . logger = null ; }  	None^100^^^^^98^101^
[REPLACE]  MockingProgress  progress  =  new  ThreadSafeMockingProgress  (  )  ; 	[BUGGY] RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception {[CE] reached end of file while parsing  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] DebuggingInfo debuggingInfo [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockingProgress progress [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  public void run ( RunNotifier notifier ) { [ATTENTION] RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception { DebuggingInfo debuggingInfo = progress . getDebuggingInfo ( ) ;  beforeRun ( notifier , debuggingInfo ) ;  runner . run ( notifier ) ;  afterRun ( debuggingInfo ) ; }  	None^105^^^^^104^113^
[REPLACE]  DebuggingInfo  debuggingInfo  =  progress  .  getDebuggingInfo  (  )  ; 	[BUGGY] MockingProgress progress = new ThreadSafeMockingProgress ( ) ; [CE] variable progress is already defined in method run(RunNotifier)  [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] DebuggingInfo debuggingInfo [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockingProgress progress [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  public void run ( RunNotifier notifier ) { MockingProgress progress = new ThreadSafeMockingProgress ( ) ; [ATTENTION] MockingProgress progress = new ThreadSafeMockingProgress ( )  ;  beforeRun ( notifier , debuggingInfo ) ;  runner . run ( notifier ) ;  afterRun ( debuggingInfo ) ; }  	None^106^^^^^104^113^
[REPLACE]  afterRun  (  debuggingInfo  )  ; 	[BUGGY] beforeRun ( notifier , debuggingInfo ) ; [FE] AssertionFailedError [METHOD]  run [TYPE] void [PARAMETER] RunNotifier notifier [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] DebuggingInfo debuggingInfo [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockingProgress progress [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  public void run ( RunNotifier notifier ) { MockingProgress progress = new ThreadSafeMockingProgress ( ) ; DebuggingInfo debuggingInfo = progress . getDebuggingInfo ( ) ;  beforeRun ( notifier , debuggingInfo ) ;  runner . run ( notifier ) ;  [ATTENTION] beforeRun ( notifier , debuggingInfo )  ; }  	None^112^^^^^104^113^
[REPLACE]  debuggingInfo  .  clearData  (  )  ; 	[BUGGY] debuggingInfo . collectData ( ) ; [FE] AssertionFailedError [METHOD]  afterRun [TYPE] void [PARAMETER] DebuggingInfo debuggingInfo [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] DebuggingInfo debuggingInfo [TYPE] boolean false true [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger  [CONTEXT]  private void afterRun ( final DebuggingInfo debuggingInfo ) { [ATTENTION] debuggingInfo . collectData ( )  ; }  	None^116^^^^^115^117^
[REPLACE]  debuggingInfo  .  collectData  (  )  ; 	[BUGGY] debuggingInfo . clearData ( ) ; [FE] AssertionFailedError [METHOD]  beforeRun [TYPE] void [PARAMETER] RunNotifier notifier DebuggingInfo debuggingInfo [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockitoLogger logger [TYPE] DebuggingInfo debuggingInfo [TYPE] RunnerImpl runner runnerImpl [TYPE] Failure failure [TYPE] RunListener listener  [CONTEXT]  private void beforeRun ( RunNotifier notifier , final DebuggingInfo debuggingInfo ) { [ATTENTION] debuggingInfo . clearData ( )  ;  RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception { debuggingInfo . printWarnings ( logger ) ; } } ;  notifier . addListener ( listener ) ; }  	None^120^^^^^119^129^
[ADD]  debuggingInfo  .  collectData  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  beforeRun [TYPE] void [PARAMETER] RunNotifier notifier DebuggingInfo debuggingInfo [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockitoLogger logger [TYPE] DebuggingInfo debuggingInfo [TYPE] RunnerImpl runner runnerImpl [TYPE] Failure failure [TYPE] RunListener listener  [CONTEXT]  private void beforeRun ( RunNotifier notifier , final DebuggingInfo debuggingInfo ) { [ATTENTION]  RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception { debuggingInfo . printWarnings ( logger ) ; } } ;  notifier . addListener ( listener ) ; }  	None^120^^^^^119^129^
[REPLACE]  RunListener  listener  =  new  RunListener  (  )  { 	[BUGGY] RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception {[CE] ' ; ' expected  [METHOD]  beforeRun [TYPE] void [PARAMETER] RunNotifier notifier DebuggingInfo debuggingInfo [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockitoLogger logger [TYPE] DebuggingInfo debuggingInfo [TYPE] RunnerImpl runner runnerImpl [TYPE] Failure failure [TYPE] RunListener listener  [CONTEXT]  private void beforeRun ( RunNotifier notifier , final DebuggingInfo debuggingInfo ) { debuggingInfo . collectData ( ) ;  [ATTENTION] RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception { @Override public void testFailure ( Failure failure ) throws Exception { debuggingInfo . printWarnings ( logger ) ; } } ;  notifier . addListener ( listener ) ; }  	None^122^^^^^119^129^
[ADD]  notifier  .  addListener  (  listener  )  ;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  beforeRun [TYPE] void [PARAMETER] RunNotifier notifier DebuggingInfo debuggingInfo [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] RunNotifier notifier [TYPE] boolean false true [TYPE] MockitoLogger logger [TYPE] DebuggingInfo debuggingInfo [TYPE] RunnerImpl runner runnerImpl [TYPE] Failure failure [TYPE] RunListener listener  [CONTEXT]  private void beforeRun ( RunNotifier notifier , final DebuggingInfo debuggingInfo ) { debuggingInfo . collectData ( ) ;  RunListener listener = new RunListener ( ) { @Override public void testFailure ( Failure failure ) throws Exception { debuggingInfo . printWarnings ( logger ) ; } } ;  [ATTENTION]   	None^128^129^^^^119^129^
[REPLACE]  debuggingInfo  .  printWarnings  (  logger  )  ; 	[BUGGY] debuggingInfo . clearData ( )  ; [FE] AssertionFailedError [METHOD]  testFailure [TYPE] void [PARAMETER] Failure failure [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] boolean false true [TYPE] RunnerImpl runner runnerImpl [TYPE] Failure failure [TYPE] MockitoLogger logger  [CONTEXT]  @Override public void testFailure ( Failure failure ) throws Exception { [ATTENTION] debuggingInfo . clearData ( ) ; }  	None^124^^^^^123^125^
[REPLACE]  return  runner  .  getDescription  (  )  ; 	[BUGGY] return runner . run ( this )  ; [CE] method run in interface RunnerImpl cannot be applied to given types ;  [METHOD]  getDescription [TYPE] Description [PARAMETER] [CLASS] ConsoleSpammingMockitoJUnitRunner 1  [TYPE] RunnerImpl runner runnerImpl [TYPE] MockitoLogger logger [TYPE] boolean false true  [CONTEXT]  public Description getDescription ( ) { [ATTENTION] return runner . run ( this ) ; }  	None^133^^^^^132^134^
[REPLACE]  private  CapturingMatcher<T>  capturingMatcher  =  new  CapturingMatcher<T>  (  )  ; 	[BUGGY] private CapturingMatcher<T> capturingMatcher  = null ; [FE] NullPointerException assertContains(  "<Capturing argument>  " , e.getMessage())   [CONTEXT]    [CLASS] ArgumentCaptor  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^42^^^^^^^
[REPLACE]  Mockito  .  argThat  (  capturingMatcher  )  ; 	[BUGGY] capturingMatcher  ; [CE] not a statement  [METHOD]  capture [TYPE] T [PARAMETER] [CLASS] ArgumentCaptor  [TYPE] CapturingMatcher capturingMatcher [TYPE] boolean false true  [CONTEXT]  public T capture ( ) { [ATTENTION] capturingMatcher ; return null ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^55^^^^^54^57^
[ADD]  Mockito  .  argThat  (  capturingMatcher  )  ; 	[BUGGY] [FE]   assertContains(  "<Capturing argument>  " , e.getMessage())   [METHOD]  capture [TYPE] T [PARAMETER] [CLASS] ArgumentCaptor  [TYPE] CapturingMatcher capturingMatcher [TYPE] boolean false true  [CONTEXT]  public T capture ( ) { [ATTENTION] return null ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^55^^^^^54^57^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  capture [TYPE] T [PARAMETER] [CLASS] ArgumentCaptor  [TYPE] CapturingMatcher capturingMatcher [TYPE] boolean false true  [CONTEXT]  public T capture ( ) { Mockito . argThat ( capturingMatcher ) ; [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^56^^^^^54^57^
[REPLACE]  return  this  .  capturingMatcher  .  getLastValue  (  )  ; 	[BUGGY] return this . capturingMatcher . getAllValues ( ) ; [CE] incompatible types  [METHOD]  getValue [TYPE] T [PARAMETER] [CLASS] ArgumentCaptor  [TYPE] CapturingMatcher capturingMatcher [TYPE] boolean false true  [CONTEXT]  public T getValue ( ) { [ATTENTION] return this . capturingMatcher . getAllValues ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^69^^^^^68^70^
[REPLACE]  return  this  .  capturingMatcher  .  getAllValues  (  )  ; 	[BUGGY] return this . capturingMatcher . getLastValue ( ) ; [CE] incompatible types  [METHOD]  getAllValues [TYPE] List [PARAMETER] [CLASS] ArgumentCaptor  [TYPE] CapturingMatcher capturingMatcher [TYPE] boolean false true  [CONTEXT]  public List<T> getAllValues ( ) { [ATTENTION] return this . capturingMatcher . getLastValue ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentCaptor.java^89^^^^^88^90^
[REPLACE]  private  static  final  MockitoCore  MOCKITO_CORE  =  new  MockitoCore  (  )  ; 	[BUGGY] private static final MockitoCore MOCKITO_CORE ; [CE] variable MOCKITO_CORE might not have been initialized  [CONTEXT]    [CLASS] Mockito  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^570^^^^^^^
[REPLACE]  public  static  final  Answer<Object>  RETURNS_DEFAULTS  =  new  GloballyConfiguredAnswer  (  )  ; 	[BUGGY] public static final Answer<Object> RETURNS_DEFAULTS  = null ; [FE] [CONTEXT]    [CLASS] Mockito  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^581^^^^^^^
[REPLACE]  public  static  final  Answer<Object>  RETURNS_SMART_NULLS  =  new  ReturnsSmartNulls  (  )  ; 	[BUGGY] public static final Answer<Object> RETURNS_SMART_NULLS ; [CE] variable RETURNS_SMART_NULLS might not have been initialized  [CONTEXT]    [CLASS] Mockito  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^613^^^^^^^
[REPLACE]  public  static  final  Answer<Object>  RETURNS_MOCKS  =  new  ReturnsMocks  (  )  ; 	[BUGGY] public static final Answer<Object> RETURNS_MOCKS  = null ; [FE] NullPointerException assertNotNull(mock.iMethodsReturningMethod())   [CONTEXT]    [CLASS] Mockito  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^626^^^^^^^
[REPLACE]  public  static  final  Answer<Object>  CALLS_REAL_METHODS  =  new  CallsRealMethods  (  )  ; 	[BUGGY] public static Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods ( ) ; [NO-ERROR]  [CONTEXT]    [CLASS] Mockito  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^660^^^^^^^
[REPLACE]  return  mock  (  classToMock,  withSettings  (  )    .  defaultAnswer  (  RETURNS_DEFAULTS  )  )  ; 	[BUGGY] return mock ( 0 , withSettings ( ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; [CE] no suitable method found for mock(int , MockSettings)  [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS [TYPE] MockitoCore MOCKITO_CORE [TYPE] Class classToMock [TYPE] boolean false true  [CONTEXT]  public static <T> T mock ( Class<T> classToMock ) { [ATTENTION] return mock ( 0 , withSettings ( )  . defaultAnswer ( RETURNS_DEFAULTS ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^671^^^^^670^672^
[REPLACE]  return  mock  (  classToMock,  withSettings  (  )    .  name  (  name  )    .  defaultAnswer  (  RETURNS_DEFAULTS  )  )  ; 	[BUGGY] return mock ( classToMock , withSettings ( ) . spiedInstance ( name ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; [FE] AssertionFailedError [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock String name [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS [TYPE] MockitoCore MOCKITO_CORE [TYPE] Class classToMock [TYPE] String name [TYPE] boolean false true  [CONTEXT]  public static <T> T mock ( Class<T> classToMock , String name ) { [ATTENTION] return mock ( classToMock , withSettings ( )  . spiedInstance ( name )  . defaultAnswer ( RETURNS_DEFAULTS ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^689^690^691^^^688^692^
[REPLACE]  return  mock  (  classToMock,  withSettings  (  )    .  defaultAnswer  (  new  AnswerReturnValuesAdapter  (  returnValues  )  )  )  ; 	[BUGGY] return mock ( this , withSettings ( ) . defaultAnswer ( new AnswerReturnValuesAdapter ( returnValues ) ) ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock ReturnValues returnValues [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS [TYPE] MockitoCore MOCKITO_CORE [TYPE] Class classToMock [TYPE] boolean false true [TYPE] ReturnValues returnValues  [CONTEXT]  public static <T> T mock ( Class<T> classToMock , ReturnValues returnValues ) { [ATTENTION] return mock ( this , withSettings ( )  . defaultAnswer ( new AnswerReturnValuesAdapter ( returnValues ) ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^725^^^^^724^726^
[REPLACE]  return  mock  (  classToMock,  withSettings  (  )    .  defaultAnswer  (  defaultAnswer  )  )  ; 	[BUGGY] return mock ( classToMock , withSettings ( ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; [FE] NullPointerException assertNotNull(mock.iMethodsReturningMethod())   [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock Answer defaultAnswer [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] Class classToMock [TYPE] boolean false true  [CONTEXT]  public static <T> T mock ( Class<T> classToMock , Answer defaultAnswer ) { [ATTENTION] return mock ( classToMock , withSettings ( )  . defaultAnswer ( RETURNS_DEFAULTS ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^748^^^^^747^749^
[REPLACE]  return  MOCKITO_CORE  .  mock  (  classToMock,  mockSettings  )  ; 	[BUGGY] return MOCKITO_CORE . verify ( null , mockSettings ) ; [CE] method verify in class MockitoCore cannot be applied to given types ;  [METHOD]  mock [TYPE] <T> [PARAMETER] Class<T> classToMock MockSettings mockSettings [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] Class classToMock [TYPE] MockSettings mockSettings [TYPE] boolean false true  [CONTEXT]  public static <T> T mock ( Class<T> classToMock , MockSettings mockSettings ) { [ATTENTION] return MOCKITO_CORE . verify ( null , mockSettings )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^775^^^^^774^776^
[REPLACE]  return  MOCKITO_CORE  .  mock  (  (  Class<T>  )  object  .  getClass  (  )  ,  withSettings  (  )    .  spiedInstance  (  object  )    .  defaultAnswer  (  CALLS_REAL_METHODS  )  )  ; 	[BUGGY] return MOCKITO_CORE . MockitoCore ( ( Class<T> ) object . getClass ( ) , withSettings ( ) . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) ) ; [CE] cannot find symbol  [METHOD]  spy [TYPE] <T> [PARAMETER] T object [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T object  [CONTEXT]  public static <T> T spy ( T object ) { [ATTENTION] return MOCKITO_CORE . MockitoCore ( ( Class<T> ) object . getClass ( )  , withSettings ( )  . spiedInstance ( object )  . defaultAnswer ( CALLS_REAL_METHODS ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^845^846^847^^^844^848^
[REPLACE]  return  MOCKITO_CORE  .  stub  (  methodCall  )  ; 	[BUGGY] return MOCKITO_CORE . stubVoid ( methodCall ) ; [CE] incompatible types  [METHOD]  stub [TYPE] <T> [PARAMETER] T methodCall [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T methodCall  [CONTEXT]  public static <T> DeprecatedOngoingStubbing<T> stub ( T methodCall ) { [ATTENTION] return MOCKITO_CORE . stubVoid ( methodCall )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^878^^^^^877^879^
[REPLACE]  return  MOCKITO_CORE  .  when  (  methodCall  )  ; 	[BUGGY] return MOCKITO_CORE . stub ( methodCall ) ; [CE] incompatible types  [METHOD]  when [TYPE] <T> [PARAMETER] T methodCall [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T methodCall  [CONTEXT]  public static <T> OngoingStubbing<T> when ( T methodCall ) { [ATTENTION] return MOCKITO_CORE . stub ( methodCall )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^941^^^^^940^942^
[REPLACE]  return  MOCKITO_CORE  .  verify  (  mock,  times  (  1  )  )  ; 	[BUGGY] return MOCKITO_CORE . verify ( mock , times ( 0 ) ) ; [FE] AssertionFailedError [METHOD]  verify [TYPE] <T> [PARAMETER] T mock [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T mock  [CONTEXT]  public static <T> T verify ( T mock ) { [ATTENTION] return MOCKITO_CORE . verify ( mock , times ( 0 ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^970^^^^^969^971^
[REPLACE]  MOCKITO_CORE  .  reset  (  mocks  )  ; 	[BUGGY] MOCKITO_CORE . doAnswer ( this )  ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  reset [TYPE] <T> [PARAMETER] mocks [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T[] mocks  [CONTEXT]  public static <T> void reset ( T . . . mocks ) { [ATTENTION] MOCKITO_CORE . doAnswer ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1001^^^^^1000^1002^
[REPLACE]  return  MOCKITO_CORE  .  verify  (  mock,  mode  )  ; 	[BUGGY] return MOCKITO_CORE . mock ( mock , mode ) ; [CE] method mock in class MockitoCore cannot be applied to given types ;  [METHOD]  verify [TYPE] <T> [PARAMETER] T mock VerificationMode mode [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T mock [TYPE] VerificationMode mode  [CONTEXT]  public static <T> T verify ( T mock , VerificationMode mode ) { [ATTENTION] return MOCKITO_CORE . mock ( mock , mode )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1025^^^^^1024^1026^
[REPLACE]  MOCKITO_CORE  .  verifyNoMoreInteractions  (  mocks  )  ; 	[BUGGY] MOCKITO_CORE . inOrder ( mocks ) ; [FE] AssertionFailedError [METHOD]  verifyNoMoreInteractions [TYPE] void [PARAMETER] mocks [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] Object[] mocks  [CONTEXT]  public static void verifyNoMoreInteractions ( Object . . . mocks ) { [ATTENTION] MOCKITO_CORE . inOrder ( mocks )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1070^^^^^1069^1071^
[REPLACE]  MOCKITO_CORE  .  verifyNoMoreInteractions  (  mocks  )  ; 	[BUGGY] MOCKITO_CORE . inOrder ( mocks ) ; [FE] AssertionFailedError [METHOD]  verifyZeroInteractions [TYPE] void [PARAMETER] mocks [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] Object[] mocks  [CONTEXT]  public static void verifyZeroInteractions ( Object . . . mocks ) { [ATTENTION] MOCKITO_CORE . inOrder ( mocks )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1089^^^^^1088^1090^
[REPLACE]  return  MOCKITO_CORE  .  stubVoid  (  mock  )  ; 	[BUGGY] return MOCKITO_CORE . stub ( mock ) ; [CE] incompatible types  [METHOD]  stubVoid [TYPE] <T> [PARAMETER] T mock [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] T mock  [CONTEXT]  public static <T> VoidMethodStubbable<T> stubVoid ( T mock ) { [ATTENTION] return MOCKITO_CORE . stub ( mock )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1125^^^^^1124^1126^
[REPLACE]  return  MOCKITO_CORE  .  doAnswer  (  new  ThrowsException  (  toBeThrown  )  )  ; 	[BUGGY] return MOCKITO_CORE . when ( methodCall ) ; [CE] cannot find symbol methodCall  [METHOD]  doThrow [TYPE] Stubber [PARAMETER] Throwable toBeThrown [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] Throwable toBeThrown [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static Stubber doThrow ( Throwable toBeThrown ) { [ATTENTION] return MOCKITO_CORE . when ( methodCall )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1143^^^^^1142^1144^
[REPLACE]  return  MOCKITO_CORE  .  doAnswer  (  new  CallsRealMethods  (  )  )  ; 	[BUGGY] return MOCKITO_CORE . reset ( this )  ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  doCallRealMethod [TYPE] Stubber [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static Stubber doCallRealMethod ( ) { [ATTENTION] return MOCKITO_CORE . reset ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1177^^^^^1176^1178^
[REPLACE]  return  MOCKITO_CORE  .  doAnswer  (  answer  )  ; 	[BUGGY] return MOCKITO_CORE . doAnswer ( defaultAnswer ) ; [CE] cannot find symbol defaultAnswer  [METHOD]  doAnswer [TYPE] Stubber [PARAMETER] Answer answer [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static Stubber doAnswer ( Answer answer ) { [ATTENTION] return MOCKITO_CORE . doAnswer ( defaultAnswer )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1203^^^^^1202^1204^
[REPLACE]  return  MOCKITO_CORE  .  doAnswer  (  new  DoesNothing  (  )  )  ; 	[BUGGY] return MOCKITO_CORE . when ( methodCall ) ; [CE] cannot find symbol methodCall  [METHOD]  doNothing [TYPE] Stubber [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static Stubber doNothing ( ) { [ATTENTION] return MOCKITO_CORE . when ( methodCall )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1242^^^^^1241^1243^
[REPLACE]  return  MOCKITO_CORE  .  doAnswer  (  new  Returns  (  toBeReturned  )  )  ; 	[BUGGY] return MOCKITO_CORE . doAnswer ( new CallsRealMethods ( )  ) ; [FE]  java.lang.Object.simpleMethod(Ljava/lang/String   [METHOD]  doReturn [TYPE] Stubber [PARAMETER] Object toBeReturned [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] Object toBeReturned [TYPE] boolean false true  [CONTEXT]  public static Stubber doReturn ( Object toBeReturned ) { [ATTENTION] return MOCKITO_CORE . doAnswer ( new CallsRealMethods ( )  )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1288^^^^^1287^1289^
[REPLACE]  return  MOCKITO_CORE  .  inOrder  (  mocks  )  ; 	[BUGGY] return MOCKITO_CORE . mock ( mocks ) ; [CE] method mock in class MockitoCore cannot be applied to given types ;  [METHOD]  inOrder [TYPE] InOrder [PARAMETER] mocks [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] Object[] mocks  [CONTEXT]  public static InOrder inOrder ( Object . . . mocks ) { [ATTENTION] return MOCKITO_CORE . mock ( mocks )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1313^^^^^1312^1314^
[REPLACE]  return  VerificationModeFactory  .  times  (  wantedNumberOfInvocations  )  ; 	[BUGGY] return VerificationModeFactory . atMost ( wantedNumberOfInvocations ) ; [FE] AssertionFailedError [METHOD]  times [TYPE] VerificationMode [PARAMETER] int wantedNumberOfInvocations [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] int wantedNumberOfInvocations  [CONTEXT]  public static VerificationMode times ( int wantedNumberOfInvocations ) { [ATTENTION] return VerificationModeFactory . atMost ( wantedNumberOfInvocations )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1329^^^^^1328^1330^
[REPLACE]  return  times  (  0  )  ; 	[BUGGY] return times ( 0 + 3 ) ; [FE]   assertContains(  "Never wanted here:  " , e.getMessage())   [METHOD]  never [TYPE] VerificationMode [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static VerificationMode never ( ) { [ATTENTION] return times ( 0 + 3 )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1350^^^^^1349^1351^
[REPLACE]  return  VerificationModeFactory  .  atLeastOnce  (  )  ; 	[BUGGY] return VerificationModeFactory . atLeast ( null )  ; [CE] method atLeast in class VerificationModeFactory cannot be applied to given types ;  [METHOD]  atLeastOnce [TYPE] VerificationMode [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static VerificationMode atLeastOnce ( ) { [ATTENTION] return VerificationModeFactory . atLeast ( null ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1365^^^^^1364^1366^
[REPLACE]  return  VerificationModeFactory  .  atLeast  (  minNumberOfInvocations  )  ; 	[BUGGY] return VerificationModeFactory . times ( wantedNumberOfInvocations ) ; [CE] cannot find symbol wantedNumberOfInvocations  [METHOD]  atLeast [TYPE] VerificationMode [PARAMETER] int minNumberOfInvocations [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] int minNumberOfInvocations  [CONTEXT]  public static VerificationMode atLeast ( int minNumberOfInvocations ) { [ATTENTION] return VerificationModeFactory . times ( wantedNumberOfInvocations )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1381^^^^^1380^1382^
[REPLACE]  return  VerificationModeFactory  .  atMost  (  maxNumberOfInvocations  )  ; 	[BUGGY] return VerificationModeFactory . atLeast ( maxNumberOfInvocations ) ; [FE] AssertionFailedError [METHOD]  atMost [TYPE] VerificationMode [PARAMETER] int maxNumberOfInvocations [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true [TYPE] int maxNumberOfInvocations  [CONTEXT]  public static VerificationMode atMost ( int maxNumberOfInvocations ) { [ATTENTION] return VerificationModeFactory . atLeast ( maxNumberOfInvocations )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1397^^^^^1396^1398^
[REPLACE]  MOCKITO_CORE  .  validateMockitoUsage  (  )  ; 	[BUGGY] MOCKITO_CORE . MockitoCore ( ) ; [CE] cannot find symbol  [METHOD]  validateMockitoUsage [TYPE] void [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static void validateMockitoUsage ( ) { [ATTENTION] MOCKITO_CORE . MockitoCore ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1446^^^^^1445^1447^
[REPLACE]  return  new  MockSettingsImpl  (  )    .  defaultAnswer  (  RETURNS_DEFAULTS  )  ; 	[BUGGY] return new MockSettingsImpl ( )  . spiedInstance ( this )  ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  withSettings [TYPE] MockSettings [PARAMETER] [CLASS] Mockito  [TYPE] Answer CALLS_REAL_METHODS RETURNS_DEFAULTS RETURNS_MOCKS RETURNS_SMART_NULLS answer defaultAnswer [TYPE] MockitoCore MOCKITO_CORE [TYPE] boolean false true  [CONTEXT]  public static MockSettings withSettings ( ) { [ATTENTION] return new MockSettingsImpl ( ) . spiedInstance ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/Mockito.java^1480^^^^^1479^1481^
[REPLACE]  throw  new  RuntimeException  (    "\n  "  +    "This  method  should  not  be  used  by  the  framework  because  it  was  deprecated  "  +    "\n  "  +    "Please  report  the  failure  to  the  Mockito  mailing  list  "  )  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  getReturnValues [TYPE] ReturnValues [PARAMETER] [CLASS] DefaultMockitoConfiguration  [TYPE] boolean false true  [CONTEXT]  public ReturnValues getReturnValues ( ) { [ATTENTION] return ;  }  	./Perturbation-Mockito-38/src/org/mockito/configuration/DefaultMockitoConfiguration.java^27^28^^^^26^29^
[REPLACE]  return  new  ReturnsEmptyValues  (  )  ; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  getDefaultAnswer [TYPE] Answer [PARAMETER] [CLASS] DefaultMockitoConfiguration  [TYPE] boolean false true  [CONTEXT]  public Answer<Object> getDefaultAnswer ( ) { [ATTENTION] return true ; }  	./Perturbation-Mockito-38/src/org/mockito/configuration/DefaultMockitoConfiguration.java^32^^^^^31^33^
[REPLACE]  return  new  DefaultAnnotationEngine  (  )  ; 	[BUGGY] return new ReturnsEmptyValues ( ) ; [CE] incompatible types  [METHOD]  getAnnotationEngine [TYPE] AnnotationEngine [PARAMETER] [CLASS] DefaultMockitoConfiguration  [TYPE] boolean false true  [CONTEXT]  public AnnotationEngine getAnnotationEngine ( ) { [ATTENTION] return new ReturnsEmptyValues ( )  ; }  	./Perturbation-Mockito-38/src/org/mockito/configuration/DefaultMockitoConfiguration.java^39^^^^^38^40^
[REPLACE]  return  true; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  cleansStackTrace [TYPE] boolean [PARAMETER] [CLASS] DefaultMockitoConfiguration  [TYPE] boolean false true  [CONTEXT]  public boolean cleansStackTrace ( ) { [ATTENTION] return false ; }  	./Perturbation-Mockito-38/src/org/mockito/configuration/DefaultMockitoConfiguration.java^46^^^^^45^47^
[REPLACE]  if  (  testClass  ==  null  )  { 	[BUGGY] if ( testClass ! = null ) {[FE] AssertionFailedError [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { [ATTENTION] if ( testClass ! = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^81^^^^^80^90^
[ADD]  if  (  testClass  ==  null  )  {  throw  new  MockitoException  (  "    ")  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { [ATTENTION]   Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^81^82^83^^^80^90^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { [ATTENTION] return ; } Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^82^^^^^80^90^
[REPLACE]  Class<?>  clazz  =  testClass  .  getClass  (  )  ; 	[BUGGY] Field[] fields = clazz . getDeclaredFields ( ) ; [CE] cannot find symbol clazz  [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } [ATTENTION] Field[] fields = clazz . getDeclaredFields ( )  ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^85^^^^^80^90^
[REPLACE]  while  (  clazz  !=  Object  .  class  )  { 	[BUGGY] while ( clazz  = =  Object . class ) {[FE] AssertionFailedError [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } Class<?> clazz = testClass . getClass ( ) ; [ATTENTION] while ( clazz = = Object . class ) { scan ( testClass , clazz ) ; clazz = clazz . getSuperclass ( ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^86^^^^^80^90^
[REPLACE]  clazz  =  clazz  .  getSuperclass  (  )  ; 	[BUGGY] clazz =  null . getSuperclass ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; [ATTENTION] clazz = null . getSuperclass ( )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^88^^^^^80^90^
[ADD]  clazz  =  clazz  .  getSuperclass  (  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; [ATTENTION] } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^88^^^^^80^90^
[REPLACE]  clazz  =  clazz  .  getSuperclass  (  )  ; 	[BUGGY] clazz =  this . getSuperclass ( ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  initMocks [TYPE] void [PARAMETER] Object testClass [CLASS] MockitoAnnotations  [TYPE] boolean false true [TYPE] Object testClass [TYPE] Class clazz  [CONTEXT]  public static void initMocks ( Object testClass ) { if ( testClass = = null ) { throw new MockitoException (   "testClass cannot be null . For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class  " ) ; } Class<?> clazz = testClass . getClass ( ) ; while ( clazz ! = Object . class ) { scan ( testClass , clazz ) ; [ATTENTION] clazz = this . getSuperclass ( )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^88^^^^^80^90^
[REPLACE]  AnnotationEngine  annotationEngine  =  new  GlobalConfiguration  (  )    .  getAnnotationEngine  (  )  ; 	[BUGGY] Object mock = annotationEngine . createMockFor ( annotation , field ) ; [CE] cannot find symbol annotation  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { [ATTENTION] Object mock = annotationEngine . createMockFor ( annotation , field )  ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^93^^^^^92^111^
[REPLACE]  Field[]  fields  =  clazz  .  getDeclaredFields  (  )  ; 	[BUGGY] Field[] fields = null . getDeclaredFields ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; [ATTENTION] Field[] fields = null . getDeclaredFields ( )  ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^94^^^^^92^111^
[REPLACE]  if  (  mock  !=  null  )  { 	[BUGGY] if ( mock = = testClass ) {[FE] AssertionFailedError [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; [ATTENTION] if ( mock = = testClass ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^98^^^^^92^111^
[ADD]  try  {  field  .  set  (  testClass,  mock  )  ;  }  catch  (  IllegalAccessException  e  )  {  throw  new  MockitoException  (  "    ")  ;  }  finally  { 	[BUGGY] field . set ( testClass , mock ) ; [CE] class , interface , or enum expected  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; [ATTENTION] field . set ( testClass , mock )  ;   field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^101^102^103^104^105^92^111^
[REPLACE]  field  .  set  (  testClass,  mock  )  ; 	[BUGGY] field . set ( testClass , testClass ) ; [FE] AssertionFailedError [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { [ATTENTION] field . set ( testClass , testClass )  ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^102^^^^^92^111^
[REPLACE]  boolean  wasAccessible  =  field  .  isAccessible  (  )  ; 	[BUGGY] boolean wasAccessible = field . getAnnotations ( ) ; [CE] incompatible types  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { [ATTENTION] boolean wasAccessible = field . getAnnotations ( )  ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^99^^^^^92^111^
[REPLACE]  throw  new  MockitoException  (  "    ")  ; 	[BUGGY] return ; [NO-ERROR]  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { [ATTENTION] return ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^104^^^^^92^111^
[REPLACE]  field  .  set  (  testClass,  mock  )  ; 	[BUGGY] field . setAccessible ( true ) ; [CE] exception IllegalAccessException is never thrown in body of corresponding try statement  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { [ATTENTION] field . setAccessible ( true )  ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^102^^^^^92^111^
[REPLACE]  for  (  Field  field  :  fields  )  { 	[BUGGY] Field[] fields = clazz . getDeclaredFields ( ) ; [CE] class , interface , or enum expected  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; [ATTENTION] Field[] fields = clazz . getDeclaredFields ( )  ; for ( Annotation annotation : field . getAnnotations ( ) ) { Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^95^^^^^92^111^
[ADD]  for  (  Field  field  :  fields  )  {  for  (  Annotation  annotation  :  field  .  getAnnotations  (  )  )  {  Object  mock  =  annotationEngine  .  createMockFor  (  annotation,  field  )  ;  if  (  mock  !=  null  )  {  boolean  wasAccessible  =  field  .  isAccessible  (  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; [ATTENTION]   field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^95^96^97^98^99^92^111^
[REPLACE]  for  (  Annotation  annotation  :  field  .  getAnnotations  (  )  )  { 	[BUGGY] AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; [CE] class , interface , or enum expected  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { [ATTENTION] AnnotationEngine annotationEngine = new GlobalConfiguration ( )  . getAnnotationEngine ( )  ; Object mock = annotationEngine . createMockFor ( annotation , field ) ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^96^^^^^92^111^
[REPLACE]  Object  mock  =  annotationEngine  .  createMockFor  (  annotation,  field  )  ; 	[BUGGY] AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; [CE] variable annotationEngine is already defined in method scan(Object , Class<?>)  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { [ATTENTION] AnnotationEngine annotationEngine = new GlobalConfiguration ( )  . getAnnotationEngine ( )  ; if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^97^^^^^92^111^
[ADD]  Object  mock  =  annotationEngine  .  createMockFor  (  annotation,  field  )  ; 	[BUGGY] [CE] cannot find symbol mock  [METHOD]  scan [TYPE] void [PARAMETER] Object testClass Class<?> clazz [CLASS] MockitoAnnotations  [TYPE] Field field [TYPE] boolean false true wasAccessible [TYPE] AnnotationEngine annotationEngine [TYPE] Object mock testClass [TYPE] Class clazz [TYPE] Field[] fields [TYPE] Annotation annotation [TYPE] IllegalAccessException e  [CONTEXT]  private static void scan ( Object testClass , Class<?> clazz ) { AnnotationEngine annotationEngine = new GlobalConfiguration ( ) . getAnnotationEngine ( ) ; Field[] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getAnnotations ( ) ) { [ATTENTION] if ( mock ! = null ) { boolean wasAccessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; try { field . set ( testClass , mock ) ; } catch ( IllegalAccessException e ) { throw new MockitoException (   "Problems initiating mocks annotated with   " + annotation , e ) ; } finally { field . setAccessible ( wasAccessible ) ; } } } } }  	./Perturbation-Mockito-38/src/org/mockito/MockitoAnnotations.java^97^^^^^92^111^
[REPLACE]  description  .  appendText  (  Decamelizer  .  decamelizeMatcher  (  className  )  )  ; 	[BUGGY] description . appendText (  className  ) ; [FE]   assertContains(  "<custom argument matcher>  " , e.getMessage())   [METHOD]  describeTo [TYPE] void [PARAMETER] Description description [CLASS] ArgumentMatcher  [TYPE] Description description [TYPE] boolean false true [TYPE] String className  [CONTEXT]  public void describeTo ( Description description ) { String className = getClass ( ) . getSimpleName ( ) ; [ATTENTION] description . appendText ( className )  ; }  	./Perturbation-Mockito-38/src/org/mockito/ArgumentMatcher.java^88^^^^^86^89^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] MockitoException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^12^^^^^^^
[REPLACE]  super  (  message,  t  )  ; 	[BUGGY] super ( message ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Throwable) [PARAMETER] String message Throwable t [CLASS] MockitoException  [TYPE] Throwable t [TYPE] String message [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoException ( String message , Throwable t ) { [ATTENTION] super ( message )  ; filterStackTrace ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^17^^^^^16^19^
[REPLACE]  filterStackTrace  (  )  ; 	[BUGGY] filter . filter ( this ) ; [CE] cannot find symbol filter  [METHOD]  <init> [TYPE] Throwable) [PARAMETER] String message Throwable t [CLASS] MockitoException  [TYPE] Throwable t [TYPE] String message [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoException ( String message , Throwable t ) { super ( message , t ) ; [ATTENTION] filter . filter ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^18^^^^^16^19^
[REPLACE]  super  (  message  )  ; 	[BUGGY] super ( message , t ) ; [CE] cannot find symbol t  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoException  [TYPE] String message [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoException ( String message ) { [ATTENTION] super ( message , t )  ; filterStackTrace ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^22^^^^^21^24^
[REPLACE]  filterStackTrace  (  )  ; 	[BUGGY] filter . filter ( this ) ; [CE] cannot find symbol filter  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoException  [TYPE] String message [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoException ( String message ) { super ( message ) ; [ATTENTION] filter . filter ( this )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^23^^^^^21^24^
[REPLACE]  unfilteredStackTrace  =  getStackTrace  (  )  ; 	[BUGGY] unfilteredStackTrace  =  unfilteredStackTrace ; [FE] NullPointerException assertEquals(  "throwIt  " , e.getUnfilteredStackTrace()[0].getMethodName())   [METHOD]  filterStackTrace [TYPE] void [PARAMETER] [CLASS] MockitoException  [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  private void filterStackTrace ( ) { [ATTENTION] unfilteredStackTrace = unfilteredStackTrace ;  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^27^^^^^26^31^
[ADD]  unfilteredStackTrace  =  getStackTrace  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "throwIt  " , e.getUnfilteredStackTrace()[0].getMethodName())   [METHOD]  filterStackTrace [TYPE] void [PARAMETER] [CLASS] MockitoException  [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  private void filterStackTrace ( ) { [ATTENTION]  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^27^^^^^26^31^
[ADD]  ConditionalStackTraceFilter  filter  =  new  ConditionalStackTraceFilter  (  )  ;  filter  .  filter  (  this  )  ; 	[BUGGY] filter . filter ( this ) ; [CE] cannot find symbol filter  [METHOD]  filterStackTrace [TYPE] void [PARAMETER] [CLASS] MockitoException  [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  private void filterStackTrace ( ) { unfilteredStackTrace = getStackTrace ( ) ;  [ATTENTION] filter . filter ( this )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^29^30^^^^26^31^
[REPLACE]  filter  .  filter  (  this  )  ; 	[BUGGY] filter . ConditionalStackTraceFilter ( )  ; [CE] cannot find symbol  [METHOD]  filterStackTrace [TYPE] void [PARAMETER] [CLASS] MockitoException  [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  private void filterStackTrace ( ) { unfilteredStackTrace = getStackTrace ( ) ;  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; [ATTENTION] filter . ConditionalStackTraceFilter ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoException.java^30^^^^^26^31^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] MockitoAssertionError  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoAssertionError.java^13^^^^^^^
[REPLACE]  super  (  message  )  ; 	[BUGGY] filter . filter ( this ) ; [CE] cannot find symbol filter  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoAssertionError  [TYPE] String message [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoAssertionError ( String message ) { [ATTENTION] filter . filter ( this )  ;  unfilteredStackTrace = getStackTrace ( ) ;  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoAssertionError.java^17^^^^^16^23^
[REPLACE]  unfilteredStackTrace  =  getStackTrace  (  )  ; 	[BUGGY] unfilteredStackTrace  =  unfilteredStackTrace ; [FE] NullPointerException assertEquals(  "throwIt  " , e.getUnfilteredStackTrace()[0].getMethodName())   [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoAssertionError  [TYPE] String message [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoAssertionError ( String message ) { super ( message ) ;  [ATTENTION] unfilteredStackTrace = unfilteredStackTrace ;  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoAssertionError.java^19^^^^^16^23^
[REPLACE]  filter  .  filter  (  this  )  ; 	[BUGGY] super ( message ) ; [CE] call to super must be first statement in constructor  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoAssertionError  [TYPE] String message [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public MockitoAssertionError ( String message ) { super ( message ) ;  unfilteredStackTrace = getStackTrace ( ) ;  ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; [ATTENTION] super ( message )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/base/MockitoAssertionError.java^22^^^^^16^23^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private final long serialVersionUID = 1L ; [NO-ERROR]  [CONTEXT]    [CLASS] TooManyActualInvocations  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/TooManyActualInvocations.java^11^^^^^^^
[ADD]  super  (  message  )  ; 	[BUGGY] [CE] constructor MockitoAssertionError in class MockitoAssertionError cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] TooManyActualInvocations  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public TooManyActualInvocations ( String message ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/TooManyActualInvocations.java^14^^^^^13^15^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] TooLittleActualInvocations  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/TooLittleActualInvocations.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static  short serialVersionUID = 1L ; [CE] possible loss of precision  [CONTEXT]    [CLASS] WantedButNotInvoked  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/WantedButNotInvoked.java^11^^^^^^^
[ADD]  super  (  message  )  ; 	[BUGGY] [CE] constructor MockitoAssertionError in class MockitoAssertionError cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] WantedButNotInvoked  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public WantedButNotInvoked ( String message ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/WantedButNotInvoked.java^14^^^^^13^15^
[REPLACE]  private  static  boolean  hasJUnit; 	[BUGGY] private boolean hasJUnit ; [CE] non-static variable hasJUnit cannot be referenced from a static context  [CONTEXT]    [CLASS] JUnitTool  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^11^^^^^^^
[REPLACE]  return  hasJUnit; 	[BUGGY] return throwable ; [CE] cannot find symbol throwable  [METHOD]  hasJUnit [TYPE] boolean [PARAMETER] [CLASS] JUnitTool  [TYPE] boolean false hasJUnit true  [CONTEXT]  public static boolean hasJUnit ( ) { [ATTENTION] return throwable ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^23^^^^^22^24^
[ADD]  try  {  Class<?>  clazz  =  Class  .  forName  (    "org  .  mockito  .  exceptions  .  verification  .  junit  .  ArgumentsAreDifferent  "  )  ;  AssertionError  throwable  =  (  AssertionError  )  clazz  .  getConstructors  (  )  [0]  .  newInstance  (  message,  wanted,  actual  )  ;  return  throwable;  }  catch  (  Throwable  t  )  { 	[BUGGY] Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; [CE] class , interface , or enum expected  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { [ATTENTION] Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " )  ;    return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^27^28^29^30^31^26^35^
[REPLACE]  return  throwable; 	[BUGGY] return hasJUnit ; [CE] incompatible types  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; AssertionError throwable =  ( AssertionError ) clazz . getConstructors ( ) [0] . newInstance ( message , wanted , actual ) ; [ATTENTION] return hasJUnit ; } catch ( Throwable t ) {  return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^30^^^^^26^35^
[REPLACE]  Class<?>  clazz  =  Class  .  forName  (    "org  .  mockito  .  exceptions  .  verification  .  junit  .  ArgumentsAreDifferent  "  )  ; 	[BUGGY]   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  "  ; [CE] not a statement  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { [ATTENTION]   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ; AssertionError throwable =  ( AssertionError ) clazz . getConstructors ( ) [0] . newInstance ( message , wanted , actual ) ; return throwable ; } catch ( Throwable t ) {  return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^28^^^^^26^35^
[REPLACE]  AssertionError  throwable  =  (  AssertionError  )  clazz  .  getConstructors  (  )  [0]  .  newInstance  (  message,  wanted,  actual  )  ; 	[BUGGY] AssertionError throwable =  ( AssertionError ) clazz . getConstructors ( ) [1] . newInstance ( message , wanted , actual ) ; [FE] AssertionFailedError [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; [ATTENTION] AssertionError throwable = ( AssertionError ) clazz . getConstructors ( ) [1] . newInstance ( message , wanted , actual )  ; return throwable ; } catch ( Throwable t ) {  return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^29^^^^^26^35^
[REPLACE]  return  new  ArgumentsAreDifferent  (  message  )  ; 	[BUGGY] return new ArgumentsAreDifferent ( actual ) ; [NO-ERROR]  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; AssertionError throwable =  ( AssertionError ) clazz . getConstructors ( ) [0] . newInstance ( message , wanted , actual ) ; return throwable ; } catch ( Throwable t ) {  [ATTENTION] return new ArgumentsAreDifferent ( actual )  ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^33^^^^^26^35^
[REPLACE]  AssertionError  throwable  =  (  AssertionError  )  clazz  .  getConstructors  (  )  [0]  .  newInstance  (  message,  wanted,  actual  )  ; 	[BUGGY] AssertionError throwable =  ( AssertionError ) clazz . getConstructors ( ) [0 % 3] . newInstance ( message , wanted , actual ) ; [NO-ERROR]  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; [ATTENTION] AssertionError throwable = ( AssertionError ) clazz . getConstructors ( ) [0 % 3] . newInstance ( message , wanted , actual )  ; return throwable ; } catch ( Throwable t ) {  return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^29^^^^^26^35^
[ADD]  AssertionError  throwable  =  (  AssertionError  )  clazz  .  getConstructors  (  )  [0]  .  newInstance  (  message,  wanted,  actual  )  ;  return  throwable; 	[BUGGY] [CE] missing return statement  [METHOD]  createArgumentsAreDifferentException [TYPE] AssertionError [PARAMETER] String message String wanted String actual [CLASS] JUnitTool  [TYPE] Throwable t [TYPE] Class clazz [TYPE] boolean false hasJUnit true [TYPE] String actual message wanted [TYPE] AssertionError throwable  [CONTEXT]  public static AssertionError createArgumentsAreDifferentException ( String message , String wanted , String actual ) { try { Class<?> clazz = Class . forName (   "org . mockito . exceptions . verification . junit . ArgumentsAreDifferent  " ) ; [ATTENTION]  } catch ( Throwable t ) {  return new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/JUnitTool.java^29^30^^^^26^35^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static long serialVersionUID = 1L ; [NO-ERROR]  [CONTEXT]    [CLASS] ArgumentsAreDifferent  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^14^^^^^^^
[REPLACE]  super  (  message,  wanted,  actual  )  ; 	[BUGGY] super ( actual , wanted , actual ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { [ATTENTION] super ( actual , wanted , actual )  ; this . message = message ;  unfilteredStackTrace = getStackTrace ( ) ; ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^19^^^^^18^25^
[ADD]  super  (  message,  wanted,  actual  )  ;  this  .  message  =  message; 	[BUGGY] [CE] constructor ComparisonFailure in class ComparisonFailure cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { [ATTENTION]  unfilteredStackTrace = getStackTrace ( ) ; ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^19^20^^^^18^25^
[REPLACE]  this  .  message  =  message; 	[BUGGY] this . message =  actual ; [FE]   assertContains(  "<custom argument matcher>  " , e.getMessage())   [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { super ( message , wanted , actual ) ; [ATTENTION] this . message = actual ;  unfilteredStackTrace = getStackTrace ( ) ; ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^20^^^^^18^25^
[REPLACE]  unfilteredStackTrace  =  getStackTrace  (  )  ; 	[BUGGY] unfilteredStackTrace  = null ; [NO-ERROR]  [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { super ( message , wanted , actual ) ; this . message = message ;  [ATTENTION] unfilteredStackTrace = null ; ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^22^^^^^18^25^
[ADD]  ConditionalStackTraceFilter  filter  =  new  ConditionalStackTraceFilter  (  )  ; 	[BUGGY] [CE] cannot find symbol filter  [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { super ( message , wanted , actual ) ; this . message = message ;  unfilteredStackTrace = getStackTrace ( ) ; [ATTENTION] filter . filter ( this ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^23^^^^^18^25^
[REPLACE]  filter  .  filter  (  this  )  ; 	[BUGGY] filter . ConditionalStackTraceFilter ( )  ; [CE] cannot find symbol  [METHOD]  <init> [TYPE] String) [PARAMETER] String message String wanted String actual [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] ConditionalStackTraceFilter filter [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public ArgumentsAreDifferent ( String message , String wanted , String actual ) { super ( message , wanted , actual ) ; this . message = message ;  unfilteredStackTrace = getStackTrace ( ) ; ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter ( ) ; [ATTENTION] filter . ConditionalStackTraceFilter ( ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^24^^^^^18^25^
[REPLACE]  return  message; 	[BUGGY] return unfilteredStackTrace ; [CE] incompatible types  [METHOD]  getMessage [TYPE] String [PARAMETER] [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public String getMessage ( ) { [ATTENTION] return unfilteredStackTrace ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^29^^^^^28^30^
[REPLACE]  return  unfilteredStackTrace; 	[BUGGY] return message ; [CE] incompatible types  [METHOD]  getUnfilteredStackTrace [TYPE] StackTraceElement[] [PARAMETER] [CLASS] ArgumentsAreDifferent  [TYPE] String actual message wanted [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] StackTraceElement[] unfilteredStackTrace  [CONTEXT]  public StackTraceElement[] getUnfilteredStackTrace ( ) { [ATTENTION] return message ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java^33^^^^^32^34^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] ArgumentsAreDifferent  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java^11^^^^^^^
[ADD]  super  (  message  )  ; 	[BUGGY] [CE] constructor MockitoAssertionError in class MockitoAssertionError cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] ArgumentsAreDifferent  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public ArgumentsAreDifferent ( String message ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java^14^^^^^13^15^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID ; [CE] variable serialVersionUID might not have been initialized  [CONTEXT]    [CLASS] SmartNullPointerException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/SmartNullPointerException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] NoInteractionsWanted  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/NoInteractionsWanted.java^14^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] NeverWantedButInvoked  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/NeverWantedButInvoked.java^11^^^^^^^
[ADD]  super  (  message  )  ; 	[BUGGY] [CE] constructor MockitoAssertionError in class MockitoAssertionError cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] NeverWantedButInvoked  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public NeverWantedButInvoked ( String message ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/NeverWantedButInvoked.java^14^^^^^13^15^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static  short serialVersionUID = 1L ; [CE] possible loss of precision  [CONTEXT]    [CLASS] VerificationInOrderFailure  	./Perturbation-Mockito-38/src/org/mockito/exceptions/verification/VerificationInOrderFailure.java^11^^^^^^^
[REPLACE]  throw  new  MockitoException  (  join  (    "Checked  exception  is  invalid  for  this  method!  ",    "Invalid:    "  +  t  )  )  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  checkedExceptionInvalid [TYPE] void [PARAMETER] Throwable t [CLASS] Reporter  [TYPE] boolean false true [TYPE] Throwable t  [CONTEXT]  public void checkedExceptionInvalid ( Throwable t ) { [ATTENTION] return ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^46^47^48^49^^45^50^
[REPLACE]  throw  new  MockitoException  (  join  (    "Checked  exception  is  invalid  for  this  method!  ",    "Invalid:    "  +  t  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "Checked exception is invalid for this method  " , true + t ) ) ; [CE] bad operand types for binary operator  [METHOD]  checkedExceptionInvalid [TYPE] void [PARAMETER] Throwable t [CLASS] Reporter  [TYPE] boolean false true [TYPE] Throwable t  [CONTEXT]  public void checkedExceptionInvalid ( Throwable t ) { [ATTENTION] throw new MockitoException ( join (   "Checked exception is invalid for this method  " , true + t ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^46^47^48^49^^45^50^
[REPLACE]  throw  new  MockitoException  (  join  (    "Cannot  stub  with  null  throwable!  "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( ) ,  ; [CE] illegal start of expression  [METHOD]  cannotStubWithNullThrowable [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void cannotStubWithNullThrowable ( ) { [ATTENTION] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( )  ,  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^53^54^55^^^52^57^
[REPLACE]  throw  new  MockitoException  (  join  (    "Cannot  stub  with  null  throwable!  "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "Cannot stub with false throwable!  " ) ) ; [NO-ERROR]  [METHOD]  cannotStubWithNullThrowable [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void cannotStubWithNullThrowable ( ) { [ATTENTION] throw new MockitoException ( join (   "Cannot stub with false throwable!  " ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^53^54^55^^^52^57^
[REPLACE]  throw  new  UnfinishedStubbingException  (  join  (    "Unfinished  stubbing  detected  here:  ",  location,    "  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  unfinishedStubbing [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] Location location  [CONTEXT]  public void unfinishedStubbing ( Location location ) { [ATTENTION] return ;     "E . g . thenReturn ( ) may be missing .   " ,   "Examples of correct stubbing:  " ,   "when ( mock . isOk ( ) ) . thenReturn ( true ) ;   " ,   "when ( mock . isOk ( ) ) . thenThrow ( exception ) ;   " ,   "doThrow ( exception ) . when ( mock ) . someVoidMethod ( ) ;   " ,   "Hints:  " ,   " 1 . missing thenReturn ( )   " ,   " 2 . although stubbed methods may return mocks , you cannot inline mock creation ( mock ( ) ) call inside a thenReturn method ( see issue 53 )   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^60^61^62^63^^59^74^
[REPLACE]  throw  new  MissingMethodInvocationException  (  join  (    "when  (  )  requires  an  argument  which  has  to  be  a  method  call  on  a  mock  .    ",    "For  example:  ",    "    when  (  mock  .  getArticles  (  )  )    .  thenReturn  (  articles  )  ;  ", 	[BUGGY] throw new MissingMethodInvocationException ( join (   "when ( ) requires an argument which has to be a method call on a mock .   " ,  ; [CE] illegal start of expression  [METHOD]  missingMethodInvocation [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void missingMethodInvocation ( ) { [ATTENTION] throw new MissingMethodInvocationException ( join (   "when ( ) requires an argument which has to be a method call on a mock .   " ,  ;     "  " ,   "Also , this error might show up because you stub final/private/equals ( ) or hashCode ( ) method .   " ,   "Those methods *cannot* be stubbed/verified .   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^77^78^79^80^^76^86^
[ADD]  UnfinishedVerificationException  exception  =  new  UnfinishedVerificationException  (  join  (    "Missing  method  call  for  verify  (  mock  )  here:  ",  location,    "  ",    "Example  of  correct  verification:  ", 	[BUGGY] [CE] not a statement  [METHOD]  unfinishedVerificationException [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] UnfinishedVerificationException exception [TYPE] Location location  [CONTEXT]  public void unfinishedVerificationException ( Location location ) { [ATTENTION]     "verify ( mock ) . doSomething ( )   " ,   "  " ,   "Also , this error might show up because you verify final/private/equals ( ) or hashCode ( ) method .   " ,   "Those methods *cannot* be stubbed/verified .   " ,   "  " ) ) ;  throw exception ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^89^90^91^92^93^88^102^
[REPLACE]  throw  exception; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  unfinishedVerificationException [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] UnfinishedVerificationException exception [TYPE] Location location  [CONTEXT]  public void unfinishedVerificationException ( Location location ) { UnfinishedVerificationException exception = new UnfinishedVerificationException ( join (   "Missing method call for verify ( mock ) here:  " , location ,   "  " ,   "Example of correct verification:  " ,   "verify ( mock ) . doSomething ( )   " ,   "  " ,   "Also , this error might show up because you verify final/private/equals ( ) or hashCode ( ) method .   " ,   "Those methods *cannot* be stubbed/verified .   " ,   "  " ) ) ;  [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^101^^^^^88^102^
[REPLACE]  throw  new  NotAMockException  (  join  (    "Argument  passed  to  verify  (  )  is  not  a  mock!  ",    "Examples  of  correct  verifications:  ",    "    verify  (  mock  )    .  someMethod  (  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  notAMockPassedToVerify [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedToVerify ( ) { [ATTENTION] return ;     "verify ( mock , times ( 10 ) ) . someMethod ( ) ;   " ,   "verify ( mock , atLeastOnce ( ) ) . someMethod ( ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^105^106^107^108^^104^112^
[ADD]  throw  new  NotAMockException  (  join  (    "Argument  passed  to  verify  (  )  is  not  a  mock!  ",    "Examples  of  correct  verifications:  ", 	[BUGGY] [CE] not a statement  [METHOD]  notAMockPassedToVerify [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedToVerify ( ) { [ATTENTION]    "verify ( mock ) . someMethod ( ) ;   " ,   "verify ( mock , times ( 10 ) ) . someMethod ( ) ;   " ,   "verify ( mock , atLeastOnce ( ) ) . someMethod ( ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^105^106^107^^^104^112^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  passed  to  verify  (  )  is  null!  ",    "Examples  of  correct  verifications:  ",    "    verify  (  mock  )    .  someMethod  (  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  nullPassedToVerify [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToVerify ( ) { [ATTENTION] return ;     "verify ( mock , times ( 10 ) ) . someMethod ( ) ;   " ,   "verify ( mock , atLeastOnce ( ) ) . someMethod ( ) ;   " ,   "Also , if you use @Mock annotation don't miss initMocks ( )   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^115^116^117^118^^114^123^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  passed  to  verify  (  )  is  null!  ",    "Examples  of  correct  verifications:  ",    "    verify  (  mock  )    .  someMethod  (  )  ;  ", 	[BUGGY] throw new NullInsteadOfMockException ( join (   "Argument passed to verify ( ) is false!  " ,   "Examples of correct verifications:  " ,   "  verify ( mock ) . someMethod ( ) ;   " , [NO-ERROR]  [METHOD]  nullPassedToVerify [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToVerify ( ) { [ATTENTION] throw new NullInsteadOfMockException ( join (   "Argument passed to verify ( ) is false!  " ,   "Examples of correct verifications:  " ,   "verify ( mock )  . someMethod ( )  ;   " ,     "verify ( mock , times ( 10 ) ) . someMethod ( ) ;   " ,   "verify ( mock , atLeastOnce ( ) ) . someMethod ( ) ;   " ,   "Also , if you use @Mock annotation don't miss initMocks ( )   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^115^116^117^118^^114^123^
[REPLACE]  throw  new  NotAMockException  (  join  (    "Argument  passed  to  when  (  )  is  not  a  mock!  ",    "Example  of  correct  stubbing:  ",    "    doThrow  (  new  RuntimeException  (  )  )    .  when  (  mock  )    .  someMethod  (  )  ;  " 	[BUGGY] return ; [CE] illegal start of expression  [METHOD]  notAMockPassedToWhenMethod [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedToWhenMethod ( ) { [ATTENTION] return ;   ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^126^127^128^129^^125^131^
[ADD]  throw  new  NotAMockException  (  join  (    "Argument  passed  to  when  (  )  is  not  a  mock!  ",    "Example  of  correct  stubbing:  ", 	[BUGGY] [CE] not a statement  [METHOD]  notAMockPassedToWhenMethod [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedToWhenMethod ( ) { [ATTENTION]    "doThrow ( new RuntimeException ( ) ) . when ( mock ) . someMethod ( ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^126^127^128^^^125^131^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  passed  to  when  (  )  is  null!  ",    "Example  of  correct  stubbing:  ",    "    doThrow  (  new  RuntimeException  (  )  )    .  when  (  mock  )    .  someMethod  (  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  nullPassedToWhenMethod [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToWhenMethod ( ) { [ATTENTION] return ;     "Also , if you use @Mock annotation don't miss initMocks ( )   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^134^135^136^137^^133^140^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  passed  to  when  (  )  is  null!  ",    "Example  of  correct  stubbing:  ",    "    doThrow  (  new  RuntimeException  (  )  )    .  when  (  mock  )    .  someMethod  (  )  ;  ", 	[BUGGY] throw new NullInsteadOfMockException ( join (   "Argument passed to when ( ) is false!  " ,   "Example of correct stubbing:  " ,   "  doThrow ( new RuntimeException ( ) ) . when ( mock ) . someMethod ( ) ;   " , [FE]   assertContains(  "Argument passed to when() is null  " , e.getMessage())   [METHOD]  nullPassedToWhenMethod [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToWhenMethod ( ) { [ATTENTION] throw new NullInsteadOfMockException ( join (   "Argument passed to when ( ) is false!  " ,   "Example of correct stubbing:  " ,   "doThrow ( new RuntimeException ( ) )  . when ( mock )  . someMethod ( )  ;   " ,     "Also , if you use @Mock annotation don't miss initMocks ( )   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^134^135^136^137^^133^140^
[REPLACE]  throw  new  MockitoException  (  join  (    "Method  requires  argument  (  s  )  !  ",    "Pass  mocks  that  should  be  verified,  e  .  g:  ",    "    verifyNoMoreInteractions  (  mockOne,  mockTwo  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  mocksHaveToBePassedToVerifyNoMoreInteractions [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void mocksHaveToBePassedToVerifyNoMoreInteractions ( ) { [ATTENTION] return ;     "verifyZeroInteractions ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^143^144^145^146^^142^149^
[REPLACE]  throw  new  NotAMockException  (  join  (    "Argument  (  s  )  passed  is  not  a  mock!  ",    "Examples  of  correct  verifications:  ",    "    verifyNoMoreInteractions  (  mockOne,  mockTwo  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  notAMockPassedToVerifyNoMoreInteractions [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedToVerifyNoMoreInteractions ( ) { [ATTENTION] return ;     "verifyZeroInteractions ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^152^153^154^155^^151^158^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  (  s  )  passed  is  null!  ",    "Examples  of  correct  verifications:  ",    "    verifyNoMoreInteractions  (  mockOne,  mockTwo  )  ;  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  nullPassedToVerifyNoMoreInteractions [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToVerifyNoMoreInteractions ( ) { [ATTENTION] return ;     "verifyZeroInteractions ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^161^162^163^164^^160^167^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  (  s  )  passed  is  null!  ",    "Examples  of  correct  verifications:  ",    "    verifyNoMoreInteractions  (  mockOne,  mockTwo  )  ;  ", 	[BUGGY] throw new NullInsteadOfMockException ( join (   "Argument ( s ) passed is false!  " ,   "Examples of correct verifications:  " ,   "  verifyNoMoreInteractions ( mockOne , mockTwo ) ;   " , [NO-ERROR]  [METHOD]  nullPassedToVerifyNoMoreInteractions [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedToVerifyNoMoreInteractions ( ) { [ATTENTION] throw new NullInsteadOfMockException ( join (   "Argument ( s ) passed is false!  " ,   "Examples of correct verifications:  " ,   "verifyNoMoreInteractions ( mockOne , mockTwo )  ;   " ,     "verifyZeroInteractions ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^161^162^163^164^^160^167^
[REPLACE]  throw  new  NotAMockException  (  join  (    "Argument  (  s  )  passed  is  not  a  mock!  ",    "Pass  mocks  that  require  verification  in  order  .    ",    "For  example:  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  notAMockPassedWhenCreatingInOrder [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void notAMockPassedWhenCreatingInOrder ( ) { [ATTENTION] return ;     "InOrder inOrder = inOrder ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^170^171^172^173^^169^176^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  (  s  )  passed  is  null!  ",    "Pass  mocks  that  require  verification  in  order  .    ",    "For  example:  ", 	[BUGGY] throw new NullInsteadOfMockException ( join (   "Argument passed to when ( ) is null!  " ,  ; [CE] illegal start of expression  [METHOD]  nullPassedWhenCreatingInOrder [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedWhenCreatingInOrder ( ) { [ATTENTION] throw new NullInsteadOfMockException ( join (   "Argument passed to when ( ) is null!  " ,  ;     "InOrder inOrder = inOrder ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^179^180^181^182^^178^185^
[REPLACE]  throw  new  NullInsteadOfMockException  (  join  (    "Argument  (  s  )  passed  is  null!  ",    "Pass  mocks  that  require  verification  in  order  .    ",    "For  example:  ", 	[BUGGY] throw new NullInsteadOfMockException ( join (   "Argument ( s ) passed is this!  " ,   "Pass mocks that require verification in order .   " ,   "For example:  " , [NO-ERROR]  [METHOD]  nullPassedWhenCreatingInOrder [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void nullPassedWhenCreatingInOrder ( ) { [ATTENTION] throw new NullInsteadOfMockException ( join (   "Argument ( s ) passed is this!  " ,   "Pass mocks that require verification in order .   " ,   "For example:  " ,     "InOrder inOrder = inOrder ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^179^180^181^182^^178^185^
[REPLACE]  throw  new  MockitoException  (  join  (    "Method  requires  argument  (  s  )  !  ",    "Pass  mocks  that  require  verification  in  order  .    ",    "For  example:  ", 	[BUGGY] throw new MockitoException ( join (   "Method requires argument ( s ) !  " ,  ; [CE] illegal start of expression  [METHOD]  mocksHaveToBePassedWhenCreatingInOrder [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void mocksHaveToBePassedWhenCreatingInOrder ( ) { [ATTENTION] throw new MockitoException ( join (   "Method requires argument ( s ) !  " ,  ;     "InOrder inOrder = inOrder ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^188^189^190^191^^187^194^
[ADD]  throw  new  MockitoException  (  join  (    "Method  requires  argument  (  s  )  !  ",    "Pass  mocks  that  require  verification  in  order  .    ", 	[BUGGY] [CE] not a statement  [METHOD]  mocksHaveToBePassedWhenCreatingInOrder [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void mocksHaveToBePassedWhenCreatingInOrder ( ) { [ATTENTION]    "For example:  " ,   "InOrder inOrder = inOrder ( mockOne , mockTwo ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^188^189^190^^^187^194^
[REPLACE]  throw  new  MockitoException  (  join  (    "InOrder  can  only  verify  mocks  that  were  passed  in  during  creation  of  InOrder  .    ",    "For  example:  ",    "    InOrder  inOrder  =  inOrder  (  mockOne  )  ;  ", 	[BUGGY] throw new MockitoException ( join (   "InOrder can only verify mocks that were passed in during creation of InOrder .   " ,  ; [CE] illegal start of expression  [METHOD]  inOrderRequiresFamiliarMock [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void inOrderRequiresFamiliarMock ( ) { [ATTENTION] throw new MockitoException ( join (   "InOrder can only verify mocks that were passed in during creation of InOrder .   " ,  ;     "inOrder . verify ( mockOne ) . doStuff ( ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^197^198^199^200^^196^203^
[ADD]  throw  new  MockitoException  (  join  (    "InOrder  can  only  verify  mocks  that  were  passed  in  during  creation  of  InOrder  .    ",    "For  example:  ", 	[BUGGY] [CE] not a statement  [METHOD]  inOrderRequiresFamiliarMock [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void inOrderRequiresFamiliarMock ( ) { [ATTENTION]    "InOrder inOrder = inOrder ( mockOne ) ;   " ,   "inOrder . verify ( mockOne ) . doStuff ( ) ;   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^197^198^199^^^196^203^
[REPLACE]  throw  new  InvalidUseOfMatchersException  (  join  (    "Invalid  use  of  argument  matchers!  ",  expectedMatchersCount  +    "  matchers  expected,    "  +  recordedMatchersCount  +    "  recorded  .    ",    "This  exception  may  occur  if  matchers  are  combined  with  raw  values:  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  invalidUseOfMatchers [TYPE] void [PARAMETER] int expectedMatchersCount int recordedMatchersCount [CLASS] Reporter  [TYPE] boolean false true [TYPE] int expectedMatchersCount recordedMatchersCount  [CONTEXT]  public void invalidUseOfMatchers ( int expectedMatchersCount , int recordedMatchersCount ) { [ATTENTION] return ;     "//incorrect:  " ,   "someMethod ( anyObject ( ) , \  "raw String\  " ) ;   " ,   "When using matchers , all arguments have to be provided by matchers .   " ,   "For example:  " ,   "//correct:  " ,   "someMethod ( anyObject ( ) , eq ( \  "String by matcher\  " ) ) ;   " ,   "  " ,   "For more info see javadoc for Matchers class .   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^206^207^208^209^^205^219^
[REPLACE]  throw  new  InvalidUseOfMatchersException  (  join  (    "Invalid  use  of  argument  matchers!  ",  expectedMatchersCount  +    "  matchers  expected,    "  +  recordedMatchersCount  +    "  recorded  .    ",    "This  exception  may  occur  if  matchers  are  combined  with  raw  values:  ", 	[BUGGY] throw new InvalidUseOfMatchersException ( join (   "Invalid use of argument matchers  " , expectedMatchersCount +   " matchers expected ,   " + recordedMatchersCount +   " recorded .   " ,   "This exception may occur if matchers are combined with raw values:  " , [NO-ERROR]  [METHOD]  invalidUseOfMatchers [TYPE] void [PARAMETER] int expectedMatchersCount int recordedMatchersCount [CLASS] Reporter  [TYPE] boolean false true [TYPE] int expectedMatchersCount recordedMatchersCount  [CONTEXT]  public void invalidUseOfMatchers ( int expectedMatchersCount , int recordedMatchersCount ) { [ATTENTION] throw new InvalidUseOfMatchersException ( join (   "Invalid use of argument matchers  " , expectedMatchersCount +   " matchers expected ,   " + recordedMatchersCount +   " recorded .   " ,   "This exception may occur if matchers are combined with raw values:  " ,     "//incorrect:  " ,   "someMethod ( anyObject ( ) , \  "raw String\  " ) ;   " ,   "When using matchers , all arguments have to be provided by matchers .   " ,   "For example:  " ,   "//correct:  " ,   "someMethod ( anyObject ( ) , eq ( \  "String by matcher\  " ) ) ;   " ,   "  " ,   "For more info see javadoc for Matchers class .   " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^206^207^208^209^^205^219^
[REPLACE]  String  message  =  join  (    "Argument  (  s  )  are  different!  Wanted:  ",  wanted,  new  Location  (  )  ,    "Actual  invocation  has  different  arguments:  ", 	[BUGGY] String message = join (   "Argument ( s ) are different! Wanted:  " , actual , new Location ( ) ,   "Actual invocation has different arguments:  " , [FE]   assertContains(  "<custom argument matcher>  " , e.getMessage())   [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { [ATTENTION] String message = join (   "Argument ( s ) are different! Wanted:  " , actual , new Location ( )  ,   "Actual invocation has different arguments:  " ,   actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { throw JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ; } else { throw new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^222^223^224^225^^221^236^
[REPLACE]  if  (  JUnitTool  .  hasJUnit  (  )  )  { 	[BUGGY] if ( invocations . isEmpty ( ) ) {[CE] cannot find symbol invocations  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  [ATTENTION] if ( invocations . isEmpty ( ) ) { throw JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ; } else { throw new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^231^^^^^221^236^
[ADD]  if  (  JUnitTool  .  hasJUnit  (  )  )  {  throw  JUnitTool  .  createArgumentsAreDifferentException  (  "    ")  ;  }  else  {  throw  new  ArgumentsAreDifferent  (  message  )  ;  } 	[BUGGY] [FE] AssertionFailedError [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  [ATTENTION]   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^231^232^233^234^235^221^236^
[REPLACE]  throw  new  ArgumentsAreDifferent  (  message  )  ; 	[BUGGY] return ; [NO-ERROR]  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { throw JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ; } else { [ATTENTION] return ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^234^^^^^221^236^
[REPLACE]  throw  JUnitTool  .  createArgumentsAreDifferentException  (  "    ")  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { [ATTENTION] return ; } else { throw new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^232^^^^^221^236^
[REPLACE]  throw  JUnitTool  .  createArgumentsAreDifferentException  (  "    ")  ; 	[BUGGY] throw new ArgumentsAreDifferent ( message ) ;  ; [CE] unreachable statement  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { [ATTENTION] throw new ArgumentsAreDifferent ( message )  ;  ; } else { throw new ArgumentsAreDifferent ( message ) ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^232^^^^^221^236^
[ADD]  throw  JUnitTool  .  createArgumentsAreDifferentException  (  "    ")  ;  }  else  {  throw  new  ArgumentsAreDifferent  (  message  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { [ATTENTION]   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^232^233^234^235^^221^236^
[REPLACE]  throw  new  ArgumentsAreDifferent  (  message  )  ; 	[BUGGY] throw new TooLittleActualInvocations ( message ) ;  ; [CE] unreachable statement  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { throw JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ; } else { [ATTENTION] throw new TooLittleActualInvocations ( message )  ;  ; } }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^234^^^^^221^236^
[ADD]  throw  new  ArgumentsAreDifferent  (  message  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  argumentsAreDifferent [TYPE] void [PARAMETER] String wanted String actual Location actualLocation [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actual message wanted [TYPE] Location actualLocation  [CONTEXT]  public void argumentsAreDifferent ( String wanted , String actual , Location actualLocation ) { String message = join (   "Argument ( s ) are different! Wanted:  " , wanted , new Location ( ) ,   "Actual invocation has different arguments:  " , actual , actualLocation ,   "  " ) ;  if ( JUnitTool . hasJUnit ( ) ) { throw JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ; } else { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^234^235^^^^221^236^
[REPLACE]  throw  new  WantedButNotInvoked  (  createWantedButNotInvokedMessage  (  wanted  )  )  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted ) { [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^239^^^^^238^240^
[REPLACE]  throw  new  WantedButNotInvoked  (  createWantedButNotInvokedMessage  (  wanted  )  )  ; 	[BUGGY] String message = createWantedButNotInvokedMessage ( wanted ) ; [FE] AssertionFailedError [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted ) { [ATTENTION] String message = createWantedButNotInvokedMessage ( wanted )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^239^^^^^238^240^
[REPLACE]  String  allInvocations; 	[BUGGY] for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; [CE] illegal start of expression  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { [ATTENTION] for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) )  ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^243^^^^^242^257^
[ADD]  String  allInvocations; 	[BUGGY] [CE] cannot find symbol allInvocations  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { [ATTENTION] if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^243^^^^^242^257^
[REPLACE]  if  (  invocations  .  isEmpty  (  )  )  { 	[BUGGY] if ( JUnitTool . hasJUnit ( ) ) {[FE]   assertContains(  "firstInteraction(  " , e.getMessage())   [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; [ATTENTION] if ( JUnitTool . hasJUnit ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^244^^^^^242^257^
[ADD]  if  (  invocations  .  isEmpty  (  )  )  {  allInvocations  =    "Actually,  there  were  zero  interactions  with  this  mock  .  \n  ";  }  else  {  StringBuilder  sb  =  new  StringBuilder  (    "\nHowever,  there  were  other  interactions  with  this  mock:\n  "  )  ; 	[BUGGY] allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; [CE] illegal start of type  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; [ATTENTION] allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " )  ;   for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^244^245^246^247^^242^257^
[REPLACE]  allInvocations  =  sb  .  toString  (  )  ; 	[BUGGY] allInvocations =  null . toString ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } [ATTENTION] allInvocations = null . toString ( )  ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^252^^^^^242^257^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (    "\nHowever,  there  were  other  interactions  with  this  mock:\n  "  )  ; 	[BUGGY] String allInvocations ; [CE] variable allInvocations is already defined in method wantedButNotInvoked(PrintableInvocation , List<? extends PrintableInvocation>)  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { [ATTENTION] String allInvocations ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^247^^^^^242^257^
[REPLACE]  for  (  PrintableInvocation  i  :  invocations  )  { 	[BUGGY] for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; [NO-ERROR]  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; [ATTENTION] for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) )  ; sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^248^^^^^242^257^
[REPLACE]  allInvocations  =    "Actually,  there  were  zero  interactions  with  this  mock  .  \n  "; 	[BUGGY] allInvocations ; [CE] not a statement  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { [ATTENTION] allInvocations ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^245^^^^^242^257^
[REPLACE]  allInvocations  =    "Actually,  there  were  zero  interactions  with  this  mock  .  \n  "; 	[BUGGY] allInvocations  =  allInvocations ; [CE] variable allInvocations might not have been initialized  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { [ATTENTION] allInvocations = allInvocations ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^245^^^^^242^257^
[ADD]  for  (  PrintableInvocation  i  :  invocations  )  {  sb  .  append  (  i  .  getLocation  (  )  )  ;  sb  .  append  (    "\n  "  )  ;  } 	[BUGGY] [FE]   assertContains(  "firstInteraction(  " , e.getMessage())   [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; [ATTENTION]   allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^248^249^250^251^^242^257^
[REPLACE]  String  message  =  createWantedButNotInvokedMessage  (  wanted  )  ; 	[BUGGY] String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation ) ; [CE] cannot find symbol discrepancy  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } [ATTENTION] String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation )  ; throw new WantedButNotInvoked ( message + allInvocations ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^255^^^^^242^257^
[REPLACE]  throw  new  WantedButNotInvoked  (  message  +  allInvocations  )  ; 	[BUGGY] throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ;  ; [CE] unreachable statement  [METHOD]  wantedButNotInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation> invocations [CLASS] Reporter  [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] PrintableInvocation i wanted [TYPE] List invocations [TYPE] String allInvocations message  [CONTEXT]  public void wantedButNotInvoked ( PrintableInvocation wanted , List<? extends PrintableInvocation> invocations ) { String allInvocations ; if ( invocations . isEmpty ( ) ) { allInvocations =   "Actually , there were zero interactions with this mock . \n  " ; } else { StringBuilder sb = new StringBuilder (   "\nHowever , there were other interactions with this mock:\n  " ) ; for ( PrintableInvocation i : invocations ) { sb . append ( i . getLocation ( ) ) ; sb . append (   "\n  " ) ; } allInvocations = sb . toString ( ) ; } String message = createWantedButNotInvokedMessage ( wanted ) ; [ATTENTION] throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) )  ;  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^256^^^^^242^257^
[REPLACE]  return  join  (    "Wanted  but  not  invoked:  ",  wanted  .  toString  (  )  ,  new  Location  (  )  , 	[BUGGY] return join (   "Wanted but not invoked:  " , wanted . getLocation ( ) , new Location ( ) , [FE]   assertContains(  "<Capturing argument>  " , e.getMessage())   [METHOD]  createWantedButNotInvokedMessage [TYPE] String [PARAMETER] PrintableInvocation wanted [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted  [CONTEXT]  private String createWantedButNotInvokedMessage ( PrintableInvocation wanted ) { [ATTENTION] return join (   "Wanted but not invoked:  " , wanted . getLocation ( )  , new Location ( )  ,     "  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^260^261^262^263^^259^266^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure  ",    "Wanted  but  not  invoked:  ",  wanted  .  toString  (  )  , 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ; [CE]  [METHOD]  wantedButNotInvokedInOrder [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation previous [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation previous wanted  [CONTEXT]  public void wantedButNotInvokedInOrder ( PrintableInvocation wanted , PrintableInvocation previous ) { [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ;   new Location ( ) ,   "Wanted anywhere AFTER following interaction:  " , previous . toString ( ) , previous . getLocation ( ) ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^269^270^271^272^^268^279^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure  ",    "Wanted  but  not  invoked:  ",  wanted  .  toString  (  )  , 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure  " ,   "Wanted but not invoked:  " , wanted . getLocation ( ) , [FE]   assertContains(expected , e.getMessage())   [METHOD]  wantedButNotInvokedInOrder [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation previous [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation previous wanted  [CONTEXT]  public void wantedButNotInvokedInOrder ( PrintableInvocation wanted , PrintableInvocation previous ) { [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure  " ,   "Wanted but not invoked:  " , wanted . getLocation ( )  ,   new Location ( ) ,   "Wanted anywhere AFTER following interaction:  " , previous . toString ( ) , previous . getLocation ( ) ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^269^270^271^272^^268^279^
[REPLACE]  wanted  .  toString  (  )  ,  new  Location  (  )  ,    "Wanted  anywhere  AFTER  following  interaction:  ",  previous  .  toString  (  )  , 	[BUGGY] wanted . getLocation ( ) , new Location ( ) ,   "Wanted anywhere AFTER following interaction:  " , previous . toString ( ) , [FE]   assertContains(expected , e.getMessage())   [METHOD]  wantedButNotInvokedInOrder [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation previous [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation previous wanted  [CONTEXT]  public void wantedButNotInvokedInOrder ( PrintableInvocation wanted , PrintableInvocation previous ) { throw new VerificationInOrderFailure ( join (   "Verification in order failure  " ,   "Wanted but not invoked:  " , [ATTENTION] wanted . getLocation ( )  , new Location ( )  ,   "Wanted anywhere AFTER following interaction:  " , previous . toString ( )  ,   previous . getLocation ( ) ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^272^273^274^275^^268^279^
[REPLACE]  previous  .  toString  (  )  ,  previous  .  getLocation  (  )  ,    "  "  )  )  ; 	[BUGGY] previous . getLocation ( ) , previous . getLocation ( ) ,   "  " ) ) ; [FE]   assertContains(expected , e.getMessage())   [METHOD]  wantedButNotInvokedInOrder [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation previous [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation previous wanted  [CONTEXT]  public void wantedButNotInvokedInOrder ( PrintableInvocation wanted , PrintableInvocation previous ) { throw new VerificationInOrderFailure ( join (   "Verification in order failure  " ,   "Wanted but not invoked:  " , wanted . toString ( ) , new Location ( ) ,   "Wanted anywhere AFTER following interaction:  " , [ATTENTION] previous . getLocation ( )  , previous . getLocation ( )  ,   "  " ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^275^276^277^278^^268^279^
[REPLACE]  previous  .  getLocation  (  )  ,    "  "  )  )  ; 	[BUGGY] previous . toString ( ) ,   "  " ) ) ; [FE]   assertContains(  "thirdChunk(  " , e.getMessage())   [METHOD]  wantedButNotInvokedInOrder [TYPE] void [PARAMETER] PrintableInvocation wanted PrintableInvocation previous [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation previous wanted  [CONTEXT]  public void wantedButNotInvokedInOrder ( PrintableInvocation wanted , PrintableInvocation previous ) { throw new VerificationInOrderFailure ( join (   "Verification in order failure  " ,   "Wanted but not invoked:  " , wanted . toString ( ) , new Location ( ) ,   "Wanted anywhere AFTER following interaction:  " , previous . toString ( ) , [ATTENTION] previous . toString ( )  ,   "  " ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^276^277^278^^^268^279^
[REPLACE]  String  message  =  createTooManyInvocationsMessage  (  wantedCount,  actualCount,  wanted,  firstUndesired  )  ; 	[BUGGY] String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation ) ; [CE] cannot find symbol discrepancy  [METHOD]  tooManyActualInvocations [TYPE] void [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  public void tooManyActualInvocations ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { [ATTENTION] String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation )  ; throw new TooManyActualInvocations ( message ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^282^^^^^281^284^
[REPLACE]  throw  new  TooManyActualInvocations  (  message  )  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  tooManyActualInvocations [TYPE] void [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  public void tooManyActualInvocations ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { String message = createTooManyInvocationsMessage ( wantedCount , actualCount , wanted , firstUndesired ) ; [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^283^^^^^281^284^
[REPLACE]  return  join  (  wanted  .  toString  (  )  ,    "Wanted    "  +  Pluralizer  .  pluralize  (  wantedCount  )  +    ":  ",  new  Location  (  )  , 	[BUGGY] return join ( wanted . toString ( ) ,   "Wanted   "  ; [CE]  [METHOD]  createTooManyInvocationsMessage [TYPE] String [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  private String createTooManyInvocationsMessage ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { [ATTENTION] return join ( wanted . toString ( )  ,   "Wanted   " ;     "But was   " + pluralize ( actualCount ) +   " . Undesired invocation:  " , firstUndesired ,   "  " ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^288^289^290^291^^286^296^
[REPLACE]  throw  new  NeverWantedButInvoked  (  join  (  wanted  .  toString  (  )  ,    "Never  wanted  here:  ",  new  Location  (  )  , 	[BUGGY] return ; [CE] not a statement  [METHOD]  neverWantedButInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] Location firstUndesired  [CONTEXT]  public void neverWantedButInvoked ( PrintableInvocation wanted , Location firstUndesired ) { [ATTENTION] return ;     "But invoked here:  " , firstUndesired ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^299^300^301^302^^298^307^
[REPLACE]  throw  new  NeverWantedButInvoked  (  join  (  wanted  .  toString  (  )  ,    "Never  wanted  here:  ",  new  Location  (  )  , 	[BUGGY] throw new NeverWantedButInvoked ( join ( wanted . getLocation ( ) ,   "Never wanted here:  " , new Location ( ) , [NO-ERROR]  [METHOD]  neverWantedButInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] Location firstUndesired  [CONTEXT]  public void neverWantedButInvoked ( PrintableInvocation wanted , Location firstUndesired ) { [ATTENTION] throw new NeverWantedButInvoked ( join ( wanted . getLocation ( )  ,   "Never wanted here:  " , new Location ( )  ,     "But invoked here:  " , firstUndesired ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^299^300^301^302^^298^307^
[REPLACE]  wanted  .  toString  (  )  ,    "Never  wanted  here:  ",  new  Location  (  )  ,    "But  invoked  here:  ", 	[BUGGY] wanted . getLocation ( ) ,   "Never wanted here:  " , new Location ( ) ,   "But invoked here:  " , [NO-ERROR]  [METHOD]  neverWantedButInvoked [TYPE] void [PARAMETER] PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] Location firstUndesired  [CONTEXT]  public void neverWantedButInvoked ( PrintableInvocation wanted , Location firstUndesired ) { throw new NeverWantedButInvoked ( join ( [ATTENTION] wanted . getLocation ( )  ,   "Never wanted here:  " , new Location ( )  ,   "But invoked here:  " ,   firstUndesired ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^300^301^302^303^^298^307^
[REPLACE]  String  message  =  createTooManyInvocationsMessage  (  wantedCount,  actualCount,  wanted,  firstUndesired  )  ; 	[BUGGY] String message = createTooManyInvocationsMessage ( wantedCount , wantedCount , wanted , firstUndesired ) ; [FE]   assertContains(  "Wanted 1 time  " , e.getMessage())   [METHOD]  tooManyActualInvocationsInOrder [TYPE] void [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  public void tooManyActualInvocationsInOrder ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { [ATTENTION] String message = createTooManyInvocationsMessage ( wantedCount , wantedCount , wanted , firstUndesired )  ; throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^310^^^^^309^314^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure:  "  +  message  )  )  ; 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ; [CE]  [METHOD]  tooManyActualInvocationsInOrder [TYPE] void [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  public void tooManyActualInvocationsInOrder ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { String message = createTooManyInvocationsMessage ( wantedCount , actualCount , wanted , firstUndesired ) ; [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^311^312^313^^^309^314^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure:  "  +  message  )  )  ; 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  "  = =  message ) ) ; [FE]   assertContains(  "Wanted 1 time  " , e.getMessage())   [METHOD]  tooManyActualInvocationsInOrder [TYPE] void [PARAMETER] int wantedCount int actualCount PrintableInvocation wanted Location firstUndesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] int actualCount wantedCount [TYPE] Location firstUndesired  [CONTEXT]  public void tooManyActualInvocationsInOrder ( int wantedCount , int actualCount , PrintableInvocation wanted , Location firstUndesired ) { String message = createTooManyInvocationsMessage ( wantedCount , actualCount , wanted , firstUndesired ) ; [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " = = message ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^311^312^313^^^309^314^
[REPLACE]  String  ending  =  (  lastActualInvocation  !=  null  )  ?  lastActualInvocation  +    "\n  "  :    "\n  "; 	[BUGGY] String ending  =  lastActualInvocation +   "\n  " ; [NO-ERROR]  [METHOD]  createTooLittleInvocationsMessage [TYPE] String [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualInvocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String ending message [TYPE] Location lastActualInvocation  [CONTEXT]  private String createTooLittleInvocationsMessage ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualInvocation ) { [ATTENTION] String ending = lastActualInvocation +   "\n  " ;  String message = join ( wanted . toString ( ) ,   "Wanted   " + discrepancy . getPluralizedWantedCount ( ) +   ":  " , new Location ( ) ,   "But was   " + discrepancy . getPluralizedActualCount ( ) +   ":  " , ending ) ; return message ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^318^319^^^^316^329^
[ADD]  String  ending  =  (  lastActualInvocation  !=  null  )  ?  lastActualInvocation  +    "\n  "  :    "\n  "; 	[BUGGY] [CE] cannot find symbol ending  [METHOD]  createTooLittleInvocationsMessage [TYPE] String [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualInvocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String ending message [TYPE] Location lastActualInvocation  [CONTEXT]  private String createTooLittleInvocationsMessage ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualInvocation ) { [ATTENTION]  String message = join ( wanted . toString ( ) ,   "Wanted   " + discrepancy . getPluralizedWantedCount ( ) +   ":  " , new Location ( ) ,   "But was   " + discrepancy . getPluralizedActualCount ( ) +   ":  " , ending ) ; return message ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^318^319^^^^316^329^
[REPLACE]  String  message  =  join  (  wanted  .  toString  (  )  ,    "Wanted    "  +  discrepancy  .  getPluralizedWantedCount  (  )  +    ":  ",  new  Location  (  )  , 	[BUGGY] String message = join ( wanted . toString ( ) ,   "Wanted   " < =  discrepancy . getPluralizedWantedCount ( )  < =    ":  " , new Location ( ) , [CE] bad operand types for binary operator  [METHOD]  createTooLittleInvocationsMessage [TYPE] String [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualInvocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String ending message [TYPE] Location lastActualInvocation  [CONTEXT]  private String createTooLittleInvocationsMessage ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualInvocation ) { String ending =  ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ;  [ATTENTION] String message = join ( wanted . toString ( )  ,   "Wanted   "< = discrepancy . getPluralizedWantedCount ( ) < =   ":  " , new Location ( )  ,     "But was   " + discrepancy . getPluralizedActualCount ( ) +   ":  " , ending ) ; return message ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^321^322^323^324^^316^329^
[REPLACE]  return  message; 	[BUGGY] return ending ; [FE]   assertContains(  "Wanted 4 times  " , e.getMessage())   [METHOD]  createTooLittleInvocationsMessage [TYPE] String [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualInvocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String ending message [TYPE] Location lastActualInvocation  [CONTEXT]  private String createTooLittleInvocationsMessage ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualInvocation ) { String ending =  ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ;  String message = join ( wanted . toString ( ) ,   "Wanted   " + discrepancy . getPluralizedWantedCount ( ) +   ":  " , new Location ( ) ,   "But was   " + discrepancy . getPluralizedActualCount ( ) +   ":  " , ending ) ; [ATTENTION] return ending ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^328^^^^^316^329^
[REPLACE]  String  message  =  createTooLittleInvocationsMessage  (  discrepancy,  wanted,  lastActualLocation  )  ; 	[BUGGY] String ending = ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ; [CE] cannot find symbol lastActualInvocation  [METHOD]  tooLittleActualInvocations [TYPE] void [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualLocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] Location lastActualLocation  [CONTEXT]  public void tooLittleActualInvocations ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualLocation ) { [ATTENTION] String ending =  ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ;  throw new TooLittleActualInvocations ( message ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^332^^^^^331^335^
[REPLACE]  throw  new  TooLittleActualInvocations  (  message  )  ; 	[BUGGY] throw new TooManyActualInvocations ( message ) ;  ; [CE] unreachable statement  [METHOD]  tooLittleActualInvocations [TYPE] void [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualLocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] Location lastActualLocation  [CONTEXT]  public void tooLittleActualInvocations ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualLocation ) { String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation ) ;  [ATTENTION] throw new TooManyActualInvocations ( message )  ;  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^334^^^^^331^335^
[REPLACE]  String  message  =  createTooLittleInvocationsMessage  (  discrepancy,  wanted,  lastActualLocation  )  ; 	[BUGGY] String ending = ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ; [CE] cannot find symbol lastActualInvocation  [METHOD]  tooLittleActualInvocationsInOrder [TYPE] void [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualLocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] Location lastActualLocation  [CONTEXT]  public void tooLittleActualInvocationsInOrder ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualLocation ) { [ATTENTION] String ending =  ( lastActualInvocation ! = null ) ? lastActualInvocation +   "\n  " :   "\n  " ;  throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^338^^^^^337^343^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure:  "  +  message  )  )  ; 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ; [CE]  [METHOD]  tooLittleActualInvocationsInOrder [TYPE] void [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualLocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] Location lastActualLocation  [CONTEXT]  public void tooLittleActualInvocationsInOrder ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualLocation ) { String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation ) ;  [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " + message ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^340^341^342^^^337^343^
[REPLACE]  throw  new  VerificationInOrderFailure  (  join  (    "Verification  in  order  failure:  "  +  message  )  )  ; 	[BUGGY] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  " | message ) ) ; [CE] bad operand types for binary operator  [METHOD]  tooLittleActualInvocationsInOrder [TYPE] void [PARAMETER] Discrepancy discrepancy PrintableInvocation wanted Location lastActualLocation [CLASS] Reporter  [TYPE] Discrepancy discrepancy [TYPE] boolean false true [TYPE] PrintableInvocation wanted [TYPE] String message [TYPE] Location lastActualLocation  [CONTEXT]  public void tooLittleActualInvocationsInOrder ( Discrepancy discrepancy , PrintableInvocation wanted , Location lastActualLocation ) { String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualLocation ) ;  [ATTENTION] throw new VerificationInOrderFailure ( join (   "Verification in order failure:  "|message ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^340^341^342^^^337^343^
[REPLACE]  throw  new  NoInteractionsWanted  (  join  (    "No  interactions  wanted  here:  ",  new  Location  (  )  ,    "But  found  this  interaction:  ", 	[BUGGY] throw new NoInteractionsWanted ( join (   "No interactions wanted here:  " ,  ; [CE] illegal start of expression  [METHOD]  noMoreInteractionsWanted [TYPE] void [PARAMETER] PrintableInvocation undesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation undesired  [CONTEXT]  public void noMoreInteractionsWanted ( PrintableInvocation undesired ) { [ATTENTION] throw new NoInteractionsWanted ( join (   "No interactions wanted here:  " ,  ;   undesired . getLocation ( ) ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^346^347^348^349^^345^353^
[REPLACE]  undesired  .  getLocation  (  )  ,    "  "  )  )  ; 	[BUGGY] undesired . toString ( ) ,   "  " ) ) ; [FE]   assertContains(  "undesiredInteraction(  " , e.getMessage())   [METHOD]  noMoreInteractionsWanted [TYPE] void [PARAMETER] PrintableInvocation undesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation undesired  [CONTEXT]  public void noMoreInteractionsWanted ( PrintableInvocation undesired ) { throw new NoInteractionsWanted ( join (   "No interactions wanted here:  " , new Location ( ) ,   "But found this interaction:  " , [ATTENTION] undesired . toString ( )  ,   "  " ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^350^351^352^^^345^353^
[ADD]  undesired  .  getLocation  (  )  ,    "  "  )  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  noMoreInteractionsWanted [TYPE] void [PARAMETER] PrintableInvocation undesired [CLASS] Reporter  [TYPE] boolean false true [TYPE] PrintableInvocation undesired  [CONTEXT]  public void noMoreInteractionsWanted ( PrintableInvocation undesired ) { throw new NoInteractionsWanted ( join (   "No interactions wanted here:  " , new Location ( ) ,   "But found this interaction:  " , [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^350^351^352^^^345^353^
[REPLACE]  throw  new  MockitoException  (  join  (    "Cannot  mock/spy    "  +  clazz  .  toString  (  )  ,    "Mockito  cannot  mock/spy  following:  ",    "  -  final  classes  ", 	[BUGGY] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( ) ,  ; [CE] illegal start of expression  [METHOD]  cannotMockFinalClass [TYPE] void [PARAMETER] Class<?> clazz [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class clazz  [CONTEXT]  public void cannotMockFinalClass ( Class<?> clazz ) { [ATTENTION] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( )  ,  ;     "- anonymous classes  " ,   "- primitive types  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^356^357^358^359^^355^363^
[REPLACE]  throw  new  MockitoException  (  join  (    "Cannot  mock/spy    "  +  clazz  .  toString  (  )  ,    "Mockito  cannot  mock/spy  following:  ",    "  -  final  classes  ", 	[BUGGY] throw new MockitoException ( join (this + clazz . toString ( ) ,   "Mockito cannot mock/spy following:  " ,   " - final classes  " , [FE]   assertContains(  "Cannot mock/spy  " , e.getMessage())   [METHOD]  cannotMockFinalClass [TYPE] void [PARAMETER] Class<?> clazz [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class clazz  [CONTEXT]  public void cannotMockFinalClass ( Class<?> clazz ) { [ATTENTION] throw new MockitoException ( join ( this + clazz . toString ( )  ,   "Mockito cannot mock/spy following:  " ,   "- final classes  " ,     "- anonymous classes  " ,   "- primitive types  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^356^357^358^359^^355^363^
[ADD]  throw  new  MockitoException  (  join  (    "Cannot  mock/spy    "  +  clazz  .  toString  (  )  ,    "Mockito  cannot  mock/spy  following:  ", 	[BUGGY] [CE] not a statement  [METHOD]  cannotMockFinalClass [TYPE] void [PARAMETER] Class<?> clazz [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class clazz  [CONTEXT]  public void cannotMockFinalClass ( Class<?> clazz ) { [ATTENTION]    "- final classes  " ,   "- anonymous classes  " ,   "- primitive types  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^356^357^358^^^355^363^
[REPLACE]    "Cannot  mock/spy    "  +  clazz  .  toString  (  )  ,    "Mockito  cannot  mock/spy  following:  ",    "  -  final  classes  ",    "  -  anonymous  classes  ", 	[BUGGY]   "Cannot mock/spy   " + this . toString ( ) ,   "Mockito cannot mock/spy following:  " ,   " - final classes  " ,   " - anonymous classes  " , [NO-ERROR]  [METHOD]  cannotMockFinalClass [TYPE] void [PARAMETER] Class<?> clazz [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class clazz  [CONTEXT]  public void cannotMockFinalClass ( Class<?> clazz ) { throw new MockitoException ( join ( [ATTENTION]   "Cannot mock/spy   " + this . toString ( )  ,   "Mockito cannot mock/spy following:  " ,   "- final classes  " ,   "- anonymous classes  " ,     "- primitive types  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^357^358^359^360^^355^363^
[REPLACE]  throw  new  MockitoException  (  join  (    "Cannot  stub  a  void  method  with  a  return  value!  ",    "Voids  are  usually  stubbed  with  Throwables:  ",    "    doThrow  (  exception  )    .  when  (  mock  )    .  someVoidMethod  (  )  ;  " 	[BUGGY] return ; [CE] illegal start of expression  [METHOD]  cannotStubVoidMethodWithAReturnValue [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void cannotStubVoidMethodWithAReturnValue ( ) { [ATTENTION] return ;   ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^366^367^368^369^^365^371^
[REPLACE]  throw  new  MockitoException  (  join  (    "Only  void  methods  can  doNothing  (  )  !  ",    "Example  of  correct  use  of  doNothing  (  )  :  ",    "    doNothing  (  )    .    ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  onlyVoidMethodsCanBeSetToDoNothing [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void onlyVoidMethodsCanBeSetToDoNothing ( ) { [ATTENTION] return ;     "doThrow ( new RuntimeException ( ) )   " ,   " . when ( mock ) . someVoidMethod ( ) ;   " ,   "Above means:  " ,   "someVoidMethod ( ) does nothing the 1st time but throws an exception the 2nd time is called  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^374^375^376^377^^373^383^
[ADD]  throw  new  MockitoException  (  join  (    "Only  void  methods  can  doNothing  (  )  !  ",    "Example  of  correct  use  of  doNothing  (  )  :  ", 	[BUGGY] [CE] not a statement  [METHOD]  onlyVoidMethodsCanBeSetToDoNothing [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void onlyVoidMethodsCanBeSetToDoNothing ( ) { [ATTENTION]    "doNothing ( ) .   " ,   "doThrow ( new RuntimeException ( ) )   " ,   " . when ( mock ) . someVoidMethod ( ) ;   " ,   "Above means:  " ,   "someVoidMethod ( ) does nothing the 1st time but throws an exception the 2nd time is called  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^374^375^376^^^373^383^
[REPLACE]  throw  new  WrongTypeOfReturnValue  (  join  (  actualType  +    "  cannot  be  returned  by    "  +  methodName  +    "  (  )    ",  methodName  +    "  (  )  should  return    "  +  expectedType  )  )  ; 	[BUGGY] throw new WrongTypeOfReturnValue ( join ( actualType +   " cannot be returned by   " + methodName +   " ( )   " ,  ; [CE] illegal start of expression  [METHOD]  wrongTypeOfReturnValue [TYPE] void [PARAMETER] String expectedType String actualType String methodName [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actualType expectedType methodName  [CONTEXT]  public void wrongTypeOfReturnValue ( String expectedType , String actualType , String methodName ) { [ATTENTION] throw new WrongTypeOfReturnValue ( join ( actualType +   " cannot be returned by   " + methodName +   " ( )   " ,  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^386^387^388^389^^385^390^
[REPLACE]  throw  new  WrongTypeOfReturnValue  (  join  (  actualType  +    "  cannot  be  returned  by    "  +  methodName  +    "  (  )    ",  methodName  +    "  (  )  should  return    "  +  expectedType  )  )  ; 	[BUGGY] throw new WrongTypeOfReturnValue ( join ( actualType +   " cannot be returned by   " + expectedType +   " ( )   " , methodName +   " ( ) should return   " + expectedType ) ) ; [FE]   assertContains(  "null cannot be returned by intReturningMethod  " , e.getMessage())   [METHOD]  wrongTypeOfReturnValue [TYPE] void [PARAMETER] String expectedType String actualType String methodName [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actualType expectedType methodName  [CONTEXT]  public void wrongTypeOfReturnValue ( String expectedType , String actualType , String methodName ) { [ATTENTION] throw new WrongTypeOfReturnValue ( join ( actualType +   " cannot be returned by   " + expectedType +   " ( )   " , methodName +   " ( ) should return   " + expectedType ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^386^387^388^389^^385^390^
[ADD]  throw  new  WrongTypeOfReturnValue  (  join  (  actualType  +    "  cannot  be  returned  by    "  +  methodName  +    "  (  )    ",  methodName  +    "  (  )  should  return    "  +  expectedType 	[BUGGY] [CE] illegal start of expression  [METHOD]  wrongTypeOfReturnValue [TYPE] void [PARAMETER] String expectedType String actualType String methodName [CLASS] Reporter  [TYPE] boolean false true [TYPE] String actualType expectedType methodName  [CONTEXT]  public void wrongTypeOfReturnValue ( String expectedType , String actualType , String methodName ) { [ATTENTION]   ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^386^387^388^^^385^390^
[REPLACE]  throw  new  MockitoAssertionError  (  join  (    "Wanted  at  most    "  +  pluralize  (  maxNumberOfInvocations  )  +    "  but  was    "  +  foundSize  )  )  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  wantedAtMostX [TYPE] void [PARAMETER] int maxNumberOfInvocations int foundSize [CLASS] Reporter  [TYPE] boolean false true [TYPE] int foundSize maxNumberOfInvocations  [CONTEXT]  public void wantedAtMostX ( int maxNumberOfInvocations , int foundSize ) { [ATTENTION] return ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^393^^^^^392^394^
[REPLACE]  throw  new  MockitoAssertionError  (  join  (    "Wanted  at  most    "  +  pluralize  (  maxNumberOfInvocations  )  +    "  but  was    "  +  foundSize  )  )  ; 	[BUGGY] throw new MockitoAssertionError ( join (   "Wanted at most   " > =  pluralize ( maxNumberOfInvocations )  > =    " but was   " > =  foundSize ) ) ; [CE] bad operand types for binary operator  [METHOD]  wantedAtMostX [TYPE] void [PARAMETER] int maxNumberOfInvocations int foundSize [CLASS] Reporter  [TYPE] boolean false true [TYPE] int foundSize maxNumberOfInvocations  [CONTEXT]  public void wantedAtMostX ( int maxNumberOfInvocations , int foundSize ) { [ATTENTION] throw new MockitoAssertionError ( join (   "Wanted at most   "> = pluralize ( maxNumberOfInvocations ) > =   " but was   "> = foundSize ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^393^^^^^392^394^
[ADD]  throw  new  MockitoAssertionError  (  join  (    "Wanted  at  most    "  +  pluralize  (  maxNumberOfInvocations  )  +    "  but  was    "  +  foundSize  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  wantedAtMostX [TYPE] void [PARAMETER] int maxNumberOfInvocations int foundSize [CLASS] Reporter  [TYPE] boolean false true [TYPE] int foundSize maxNumberOfInvocations  [CONTEXT]  public void wantedAtMostX ( int maxNumberOfInvocations , int foundSize ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^393^^^^^392^394^
[REPLACE]  throw  new  MockitoAssertionError  (  join  (    "Wanted  at  most    "  +  pluralize  (  maxNumberOfInvocations  )  +    "  but  was    "  +  foundSize  )  )  ; 	[BUGGY] throw new MockitoAssertionError ( join (   "Wanted at most   " + pluralize ( foundSize ) +   " but was   " + foundSize ) ) ; [FE]  expected:< assertEquals(  "\nWanted at most 1 time but was 2  " , e.getMessage())   [METHOD]  wantedAtMostX [TYPE] void [PARAMETER] int maxNumberOfInvocations int foundSize [CLASS] Reporter  [TYPE] boolean false true [TYPE] int foundSize maxNumberOfInvocations  [CONTEXT]  public void wantedAtMostX ( int maxNumberOfInvocations , int foundSize ) { [ATTENTION] throw new MockitoAssertionError ( join (   "Wanted at most   " + pluralize ( foundSize ) +   " but was   " + foundSize ) )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^393^^^^^392^394^
[REMOVE]   	[BUGGY] throw new MockitoException ( join (   "InOrder can only verify mocks that were passed in during creation of InOrder .   " , [CE] illegal start of expression  [METHOD]  wantedAtMostX [TYPE] void [PARAMETER] int maxNumberOfInvocations int foundSize [CLASS] Reporter  [TYPE] boolean false true [TYPE] int foundSize maxNumberOfInvocations  [CONTEXT]  public void wantedAtMostX ( int maxNumberOfInvocations , int foundSize ) { [ATTENTION] throw new MockitoAssertionError ( join (   "Wanted at most   " + pluralize ( maxNumberOfInvocations ) +   " but was   " + foundSize ) ) ;   	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^393^^^^^392^394^
[REPLACE]  throw  new  InvalidUseOfMatchersException  (  join  (    "Misplaced  argument  matcher  detected  here:  ",  location,    "  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  misplacedArgumentMatcher [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] Location location  [CONTEXT]  public void misplacedArgumentMatcher ( Location location ) { [ATTENTION] return ;     "You cannot use argument matchers outside of verification or stubbing .   " ,   "Examples of correct usage of argument matchers:  " ,   "when ( mock . get ( anyInt ( ) ) ) . thenReturn ( null ) ;   " ,   "doThrow ( new RuntimeException ( ) ) . when ( mock ) . someVoidMethod ( anyObject ( ) ) ;   " ,   "verify ( mock ) . someMethod ( contains ( \  "foo\  " ) )   " ,   "  " ,   "Also , this error might show up because you use argument matchers with methods that cannot be mocked .   " ,   "Following methods *cannot* be stubbed/verified: final/private/equals ( ) /hashCode ( ) methods .   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^397^398^399^400^^396^411^
[ADD]  throw  new  InvalidUseOfMatchersException  (  join  (    "Misplaced  argument  matcher  detected  here:  ",  location, 	[BUGGY] [CE] not a statement  [METHOD]  misplacedArgumentMatcher [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] Location location  [CONTEXT]  public void misplacedArgumentMatcher ( Location location ) { [ATTENTION]    "  " ,   "You cannot use argument matchers outside of verification or stubbing .   " ,   "Examples of correct usage of argument matchers:  " ,   "when ( mock . get ( anyInt ( ) ) ) . thenReturn ( null ) ;   " ,   "doThrow ( new RuntimeException ( ) ) . when ( mock ) . someVoidMethod ( anyObject ( ) ) ;   " ,   "verify ( mock ) . someMethod ( contains ( \  "foo\  " ) )   " ,   "  " ,   "Also , this error might show up because you use argument matchers with methods that cannot be mocked .   " ,   "Following methods *cannot* be stubbed/verified: final/private/equals ( ) /hashCode ( ) methods .   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^397^398^399^^^396^411^
[REPLACE]  throw  new  SmartNullPointerException  (  join  (    "You  have  a  NullPointerException  here:  ",  new  Location  (  )  ,    "Because  this  method  was  *not*  stubbed  correctly:  ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  smartNullPointerException [TYPE] void [PARAMETER] Location location [CLASS] Reporter  [TYPE] boolean false true [TYPE] Location location  [CONTEXT]  public void smartNullPointerException ( Location location ) { [ATTENTION] return ;   location ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^414^415^416^417^^413^421^
[REPLACE]  throw  new  MockitoException  (  join  (    "No  argument  value  was  captured!  ",    "You  might  have  forgotten  to  use  argument  .  capture  (  )  in  verify  (  )    .    .    .    ",    "  .    .    .  or  you  used  capture  (  )  in  stubbing  but  stubbed  method  was  not  called  .    ", 	[BUGGY] return ; [CE] not a statement  [METHOD]  noArgumentValueWasCaptured [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void noArgumentValueWasCaptured ( ) { [ATTENTION] return ;     "Be aware that it is recommended to use capture ( ) only with verify ( )   " ,   "  " ,   "Examples of correct argument capturing:  " ,   "Argument<Person> argument = new Argument<Person> ( ) ;   " ,   "verify ( mock ) . doSomething ( argument . capture ( ) ) ;   " ,   "assertEquals ( \  "John\  " , argument . getValue ( ) . getName ( ) ) ;   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^424^425^426^427^^423^436^
[ADD]  throw  new  MockitoException  (  join  (    "No  argument  value  was  captured!  ",    "You  might  have  forgotten  to  use  argument  .  capture  (  )  in  verify  (  )    .    .    .    ", 	[BUGGY] [CE] not a statement  [METHOD]  noArgumentValueWasCaptured [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void noArgumentValueWasCaptured ( ) { [ATTENTION]    " . . . or you used capture ( ) in stubbing but stubbed method was not called .   " ,   "Be aware that it is recommended to use capture ( ) only with verify ( )   " ,   "  " ,   "Examples of correct argument capturing:  " ,   "Argument<Person> argument = new Argument<Person> ( ) ;   " ,   "verify ( mock ) . doSomething ( argument . capture ( ) ) ;   " ,   "assertEquals ( \  "John\  " , argument . getValue ( ) . getName ( ) ) ;   " ,   "  " ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^424^425^426^^^423^436^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  does  not  accept  null  parameters  .    "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( ) ,  ; [CE] illegal start of expression  [METHOD]  extraInterfacesDoesNotAcceptNullParameters [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void extraInterfacesDoesNotAcceptNullParameters ( ) { [ATTENTION] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( )  ,  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^439^440^441^^^438^442^
[ADD]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  does  not  accept  null  parameters  .    "  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  extraInterfacesDoesNotAcceptNullParameters [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void extraInterfacesDoesNotAcceptNullParameters ( ) { [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^439^440^441^^^438^442^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  does  not  accept  null  parameters  .    "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "extraInterfaces ( ) does not accept false parameters .   " ) ) ; [FE]   assertContains(  "extraInterfaces() does not accept null parameters  " , e.getMessage())   [METHOD]  extraInterfacesDoesNotAcceptNullParameters [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void extraInterfacesDoesNotAcceptNullParameters ( ) { [ATTENTION] throw new MockitoException ( join (   "extraInterfaces ( ) does not accept false parameters .   " ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^439^440^441^^^438^442^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  accepts  only  interfaces  .    ",    "You  passed  following  type:    "  +  wrongType  .  getSimpleName  (  )  +    "  which  is  not  an  interface  .    "  )  )  ; 	[BUGGY] return ; [FE] AssertionFailedError [METHOD]  extraInterfacesAcceptsOnlyInterfaces [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesAcceptsOnlyInterfaces ( Class<?> wrongType ) { [ATTENTION] return ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^445^446^447^448^^444^449^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  accepts  only  interfaces  .    ",    "You  passed  following  type:    "  +  wrongType  .  getSimpleName  (  )  +    "  which  is  not  an  interface  .    "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "extraInterfaces ( ) accepts only interfaces .   " ,   "You passed following type:   "  = =  null . getSimpleName ( )  = =    " which is not an interface .   " ) ) ; [CE] <null> cannot be dereferenced  [METHOD]  extraInterfacesAcceptsOnlyInterfaces [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesAcceptsOnlyInterfaces ( Class<?> wrongType ) { [ATTENTION] throw new MockitoException ( join (   "extraInterfaces ( ) accepts only interfaces .   " ,   "You passed following type:   " = = null . getSimpleName ( )  = =   " which is not an interface .   " ) )  ;   }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^445^446^447^448^^444^449^
[REPLACE]    "You  passed  following  type:    "  +  wrongType  .  getSimpleName  (  )  +    "  which  is  not  an  interface  .    "  )  )  ; 	[BUGGY]   "You passed following type:   " + null . getSimpleName ( ) +   " which is not an interface .   " ) ) ; [CE] <null> cannot be dereferenced  [METHOD]  extraInterfacesAcceptsOnlyInterfaces [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesAcceptsOnlyInterfaces ( Class<?> wrongType ) { throw new MockitoException ( join (   "extraInterfaces ( ) accepts only interfaces .   " , [ATTENTION]   "You passed following type:   " + null . getSimpleName ( ) +   " which is not an interface .   " ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^447^448^^^^444^449^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  does  not  accept  the  same  type  as  the  mocked  type  .    ",    "You  mocked  following  type:    "  +  wrongType  .  getSimpleName  (  )  ,    "and  you  passed  the  same  very  interface  to  the  extraInterfaces  (  )    " 	[BUGGY] return ; [CE] illegal start of expression  [METHOD]  extraInterfacesCannotContainMockedType [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesCannotContainMockedType ( Class<?> wrongType ) { [ATTENTION] return ;   ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^452^453^454^455^^451^457^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  does  not  accept  the  same  type  as  the  mocked  type  .    ",    "You  mocked  following  type:    "  +  wrongType  .  getSimpleName  (  )  ,    "and  you  passed  the  same  very  interface  to  the  extraInterfaces  (  )    " 	[BUGGY] throw new MockitoException ( join (   "extraInterfaces ( ) does not accept the same type as the mocked type .   " ,   "You mocked following type:   " +null ( ) ,   "and you passed the same very interface to the extraInterfaces ( )   "[CE]  [METHOD]  extraInterfacesCannotContainMockedType [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesCannotContainMockedType ( Class<?> wrongType ) { [ATTENTION] throw new MockitoException ( join (   "extraInterfaces ( ) does not accept the same type as the mocked type .   " ,   "You mocked following type:   " +null ( )  ,   "and you passed the same very interface to the extraInterfaces ( )   "   ) ) ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^452^453^454^455^^451^457^
[REPLACE]    "You  mocked  following  type:    "  +  wrongType  .  getSimpleName  (  )  ,    "and  you  passed  the  same  very  interface  to  the  extraInterfaces  (  )    "  )  )  ; 	[BUGGY]   "You mocked following type:   " + wrongType . toString ( )  ,   "and you passed the same very interface to the extraInterfaces ( )   " ) ) ; [FE]   assertContains(  "You mocked following type: IMethods  " , e.getMessage())   [METHOD]  extraInterfacesCannotContainMockedType [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesCannotContainMockedType ( Class<?> wrongType ) { throw new MockitoException ( join (   "extraInterfaces ( ) does not accept the same type as the mocked type .   " , [ATTENTION]   "You mocked following type:   " + wrongType . toString ( ) ,   "and you passed the same very interface to the extraInterfaces ( )   " ) )  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^454^455^456^^^451^457^
[ADD]    "You  mocked  following  type:    "  +  wrongType  .  getSimpleName  (  )  ,    "and  you  passed  the  same  very  interface  to  the  extraInterfaces  (  )    "  )  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  extraInterfacesCannotContainMockedType [TYPE] void [PARAMETER] Class<?> wrongType [CLASS] Reporter  [TYPE] boolean false true [TYPE] Class wrongType  [CONTEXT]  public void extraInterfacesCannotContainMockedType ( Class<?> wrongType ) { throw new MockitoException ( join (   "extraInterfaces ( ) does not accept the same type as the mocked type .   " , [ATTENTION]  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^454^455^456^^^451^457^
[REPLACE]  throw  new  MockitoException  (  join  (    "extraInterfaces  (  )  requires  at  least  one  interface  .    "  )  )  ; 	[BUGGY] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( ) ,  ; [CE] illegal start of expression  [METHOD]  extraInterfacesRequiresAtLeastOneInterface [TYPE] void [PARAMETER] [CLASS] Reporter  [TYPE] boolean false true  [CONTEXT]  public void extraInterfacesRequiresAtLeastOneInterface ( ) { [ATTENTION] throw new MockitoException ( join (   "Cannot mock/spy   " + clazz . toString ( )  ,  ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Reporter.java^460^461^462^^^459^463^
[REPLACE]  private  final  int  wantedCount; 	[BUGGY] private int wantedCount ; [NO-ERROR]  [CONTEXT]    [CLASS] Discrepancy  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^9^^^^^^^
[REPLACE]  this  .  wantedCount  =  wantedCount; 	[BUGGY] this . wantedCount =  actualCount ; [FE]  AssertionFailedError  expected:<100> but was:<1> assertEquals(1 , reporterStub.actualCount)   [METHOD]  <init> [TYPE] Discrepancy(int , int) [PARAMETER] int wantedCount int actualCount [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public Discrepancy ( int wantedCount , int actualCount ) { [ATTENTION] this . wantedCount = actualCount ; this . actualCount = actualCount ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^13^^^^^12^15^
[ADD]  this  .  wantedCount  =  wantedCount;  this  .  actualCount  =  actualCount; 	[BUGGY] this . actualCount = actualCount ; [CE] variable wantedCount might not have been initialized  [METHOD]  <init> [TYPE] Discrepancy(int , int) [PARAMETER] int wantedCount int actualCount [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public Discrepancy ( int wantedCount , int actualCount ) { [ATTENTION] this . actualCount = actualCount ;  }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^13^14^^^^12^15^
[REPLACE]  this  .  actualCount  =  actualCount; 	[BUGGY] this . actualCount =  wantedCount ; [FE]  AssertionFailedError  expected:<1> but was:<100> assertEquals(1 , reporterStub.actualCount)   [METHOD]  <init> [TYPE] Discrepancy(int , int) [PARAMETER] int wantedCount int actualCount [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public Discrepancy ( int wantedCount , int actualCount ) { this . wantedCount = wantedCount ; [ATTENTION] this . actualCount = wantedCount ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^14^^^^^12^15^
[REPLACE]  return  wantedCount; 	[BUGGY] return Pluralizer . pluralize ( actualCount ) ; [CE] incompatible types  [METHOD]  getWantedCount [TYPE] int [PARAMETER] [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public int getWantedCount ( ) { [ATTENTION] return Pluralizer . pluralize ( actualCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^18^^^^^17^19^
[REPLACE]  return  Pluralizer  .  pluralize  (  wantedCount  )  ; 	[BUGGY] return  wantedCount  ; [CE] incompatible types  [METHOD]  getPluralizedWantedCount [TYPE] String [PARAMETER] [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public String getPluralizedWantedCount ( ) { [ATTENTION] return wantedCount ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^22^^^^^21^23^
[REPLACE]  return  actualCount; 	[BUGGY] return Pluralizer . pluralize ( actualCount ) ; [CE] incompatible types  [METHOD]  getActualCount [TYPE] int [PARAMETER] [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public int getActualCount ( ) { [ATTENTION] return Pluralizer . pluralize ( actualCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^26^^^^^25^27^
[REPLACE]  return  Pluralizer  .  pluralize  (  actualCount  )  ; 	[BUGGY] return Pluralizer . pluralize ( wantedCount ) ; [FE]   assertContains(  "Wanted 4 times  " , e.getMessage())   [METHOD]  getPluralizedActualCount [TYPE] String [PARAMETER] [CLASS] Discrepancy  [TYPE] int actualCount wantedCount [TYPE] boolean false true  [CONTEXT]  public String getPluralizedActualCount ( ) { [ATTENTION] return Pluralizer . pluralize ( wantedCount )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Discrepancy.java^30^^^^^29^31^
[REPLACE]  return  number  ==  1  ?    "1  time  "  :  number  +    "  times  "; 	[BUGGY] return number +   " times  " ; [FE]  AssertionFailedError  expected:<1 time[]> but was:<1 time[s]> assertEquals(  "0 times  " , Pluralizer.pluralize(0))   [METHOD]  pluralize [TYPE] String [PARAMETER] int number [CLASS] Pluralizer  [TYPE] boolean false true [TYPE] int number  [CONTEXT]  public static String pluralize ( int number ) { [ATTENTION] return number +   " times  " ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/Pluralizer.java^10^^^^^9^11^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID ; [CE] variable serialVersionUID might not have been initialized  [CONTEXT]    [CLASS] UnfinishedStubbingException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/UnfinishedStubbingException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static long serialVersionUID = 1L ; [NO-ERROR]  [CONTEXT]    [CLASS] WrongTypeOfReturnValue  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/WrongTypeOfReturnValue.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final short serialVersionUID = 1L ; [CE] possible loss of precision  [CONTEXT]    [CLASS] NullInsteadOfMockException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/NullInsteadOfMockException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID ; [CE] variable serialVersionUID might not have been initialized  [CONTEXT]    [CLASS] InvalidUseOfMatchersException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java^11^^^^^^^
[ADD]  super  (  message  )  ; 	[BUGGY] [CE] no suitable constructor found for MockitoException()  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] InvalidUseOfMatchersException  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public InvalidUseOfMatchersException ( String message ) { [ATTENTION] }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java^14^^^^^13^15^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID = 1 ; [NO-ERROR]  [CONTEXT]    [CLASS] NotAMockException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/NotAMockException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final short serialVersionUID = 1L ; [CE] possible loss of precision  [CONTEXT]    [CLASS] UnfinishedVerificationException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/UnfinishedVerificationException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static final long serialVersionUID ; [CE] variable serialVersionUID might not have been initialized  [CONTEXT]    [CLASS] MissingMethodInvocationException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/MissingMethodInvocationException.java^11^^^^^^^
[REPLACE]  private  static  final  long  serialVersionUID  =  1L; 	[BUGGY] private static long serialVersionUID = 1 ; [NO-ERROR]  [CONTEXT]    [CLASS] MockitoConfigurationException  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/MockitoConfigurationException.java^11^^^^^^^
[REPLACE]  super  (  message  )  ; 	[BUGGY] super ( message , cause ) ; [CE] cause has private access in Throwable  [METHOD]  <init> [TYPE] String) [PARAMETER] String message [CLASS] MockitoConfigurationException  [TYPE] long serialVersionUID [TYPE] String message [TYPE] boolean false true  [CONTEXT]  public MockitoConfigurationException ( String message ) { [ATTENTION] super ( message , cause )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/MockitoConfigurationException.java^14^^^^^13^15^
[REPLACE]  super  (  message,  cause  )  ; 	[BUGGY] super ( message ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Exception) [PARAMETER] String message Exception cause [CLASS] MockitoConfigurationException  [TYPE] String message [TYPE] boolean false true [TYPE] long serialVersionUID [TYPE] Exception cause  [CONTEXT]  public MockitoConfigurationException ( String message , Exception cause ) { [ATTENTION] super ( message )  ; }  	./Perturbation-Mockito-38/src/org/mockito/exceptions/misusing/MockitoConfigurationException.java^18^^^^^17^19^
