[REPLACE]  Validate  .  isTrue  (  args  .  length  ==  1,    "usage:  supply  url  to  fetch  "  )  ; 	[BUGGY] Validate . isTrue ( args . length * 2 = = 1 ,   "usage: supply url to fetch  " ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { [ATTENTION] Validate . isTrue ( args . length *2 = = 1 ,   "usage: supply url to fetch  " )  ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^17^^^^^16^45^
[REPLACE]  URL  url  =  new  URL  (  args[0]  )  ; 	[BUGGY] URL url = new URL ( args[1] ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; [ATTENTION] URL url = new URL ( args[1] )  ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^18^^^^^16^45^
[REPLACE]  print  (    "Fetching  %s  .    .    .    ",  url  .  toExternalForm  (  )  )  ; 	[BUGGY] print (   " * %s: <%s> %sx%s ( %s )   " , [CE] ')' expected  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; [ATTENTION] print (   " * %s: <%s> %sx%s ( %s )   " ,  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^19^^^^^16^45^
[REPLACE]  Elements  links  =  doc  .  select  (    "a[href]  "  )  ; 	[BUGGY] Elements media = doc . select (   "[src]  " ) ; [CE] variable media is already defined in method main(String[])  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; [ATTENTION] Elements media = doc . select (   "[src]  " )  ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^22^^^^^16^45^
[ADD]  Elements  links  =  doc  .  select  (    "a[href]  "  )  ;  Elements  media  =  doc  .  select  (    "[src]  "  )  ; 	[BUGGY] [CE] cannot find symbol media  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; [ATTENTION]  Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^22^23^^^^16^45^
[REPLACE]  Elements  media  =  doc  .  select  (    "[src]  "  )  ; 	[BUGGY] Elements links = doc . select (   "a[href]  " ) ; [CE] variable links is already defined in method main(String[])  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; [ATTENTION] Elements links = doc . select (   "a[href]  " )  ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^23^^^^^16^45^
[REPLACE]  Elements  imports  =  doc  .  select  (    "link[href]  "  )  ; 	[BUGGY] Elements media = doc . select (   "[src]  " ) ; [CE] variable media is already defined in method main(String[])  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; [ATTENTION] Elements media = doc . select (   "[src]  " )  ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^24^^^^^16^45^
[ADD]  Elements  imports  =  doc  .  select  (    "link[href]  "  )  ; 	[BUGGY] [CE] cannot find symbol imports  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; [ATTENTION]  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^24^^^^^16^45^
[REPLACE]  print  (    "\nMedia:  (  %d  )    ",  media  .  size  (  )  )  ; 	[BUGGY] print (   "\nMedia: ( %d )   " , imports . size ( ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  [ATTENTION] print (   "\nMedia: ( %d )   " , imports . size ( ) )  ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^26^^^^^16^45^
[ADD]  print  (    "\nMedia:  (  %d  )    ",  media  .  size  (  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  [ATTENTION] for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^26^^^^^16^45^
[ADD]  if  (  src  .  tagName  (  )    .  equals  (    "img  "  )  )  print  (    "  *  %s:  <%s>  %sx%s  (  %s  )    ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ;  else 	[BUGGY] [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { [ATTENTION]   print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^28^29^30^31^32^16^45^
[REPLACE]  print  (    "  *  %s:  <%s>  ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  )  ; 	[BUGGY] print (   " * %s: <%s>  " , src . text ( ) , src . attr (   "abs:src  " ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else [ATTENTION] print (   " * %s: <%s>  " , src . text ( )  , src . attr (   "abs:src  " ) )  ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^33^^^^^16^45^
[ADD]  print  (    "  *  %s:  <%s>  ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else [ATTENTION] } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^33^^^^^16^45^
[REPLACE]  print  (    "  *  %s:  <%s>  ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  )  ; 	[BUGGY] print (   " * %s: <%s>  " , src . tagName ( ) , src . tagName ( )  ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else [ATTENTION] print (   " * %s: <%s>  " , src . tagName ( )  , src . tagName ( )  )  ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^33^^^^^16^45^
[REMOVE]   	[BUGGY] print (   " * %s: <%s> %sx%s ( %s )   " , [CE] illegal start of expression  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else [ATTENTION] print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ;  print (   " * %s: <%s> %sx%s ( %s )   " , } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^33^^^^^16^45^
[REPLACE]  print  (    "  *  %s:  <%s>  %sx%s  (  %s  )    ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] print (   " * %s: <%s> %sx%s ( %s )   " , src . text ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) [ATTENTION] print (   " * %s: <%s> %sx%s ( %s )   " , src . text ( )  , src . attr (   "abs:src  " )  , src . attr (   "width  " )  , src . attr (   "height  " )  , trim ( src . attr (   "alt  " )  , 20 ) )  ;  else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^29^30^31^^^16^45^
[ADD]  print  (    "  *  %s:  <%s>  %sx%s  (  %s  )    ",  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) [ATTENTION]  else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^29^30^31^^^16^45^
[REPLACE]  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] src . text ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , [ATTENTION] src . text ( )  , src . attr (   "abs:src  " )  , src . attr (   "width  " )  , src . attr (   "height  " )  , trim ( src . attr (   "alt  " )  , 20 ) )  ;  else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^30^31^^^^16^45^
[REPLACE]  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] src . tagName ( ) , src . tagName ( )  , src[CE] ')' expected  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , [ATTENTION] src . tagName ( )  , src . tagName ( ) , src else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^30^31^^^^16^45^
[ADD]  src  .  tagName  (  )  ,  src  .  attr  (    "abs:src  "  )  ,  src  .  attr  (    "width  "  )  ,  src  .  attr  (    "height  "  )  ,  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , [ATTENTION]  else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^30^31^^^^16^45^
[REPLACE]  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] trim ( src . tagName ( )  , 20 ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , [ATTENTION] trim ( src . tagName ( ) , 20 ) )  ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^31^^^^^16^45^
[REPLACE]  trim  (  src  .  attr  (    "alt  "  )  ,  20  )  )  ; 	[BUGGY] print (   "\nImports: ( %d )   " , imports . size ( ) ) ; [CE]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , [ATTENTION] print (   "\nImports: ( %d )   " , imports . size ( ) )  ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^31^^^^^16^45^
[REPLACE]  for  (  Element  src  :  media  )  { 	[BUGGY] for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) )[NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; [ATTENTION] for ( Element src : media ) { if ( src . tagName ( )  . equals (   "img  " ) ) if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^27^^^^^16^45^
[REPLACE]  print  (    "\nImports:  (  %d  )    ",  imports  .  size  (  )  )  ; 	[BUGGY] print (   "\nImports: ( %d )   " , media . size ( ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } [ATTENTION] print (   "\nImports: ( %d )   " , media . size ( ) )  ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^36^^^^^16^45^
[REPLACE]  for  (  Element  link  :  imports  )  { 	[BUGGY] for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) )[CE] cannot find symbol link  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; [ATTENTION] for ( Element src : media ) { if ( src . tagName ( )  . equals (   "img  " ) ) print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^37^^^^^16^45^
[ADD]  for  (  Element  link  :  imports  )  {  print  (    "  *  %s  <%s>  (  %s  )    ",  link  .  tagName  (  )  ,link  .  attr  (    "abs:href  "  )  ,  link  .  attr  (    "rel  "  )  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; [ATTENTION]   print (   "\nLinks: ( %d )   " , links . size ( ) ) ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^37^38^39^^^16^45^
[REPLACE]  print  (    "\nLinks:  (  %d  )    ",  links  .  size  (  )  )  ; 	[BUGGY] print (   "\nLinks: ( %d )   " , imports . size ( ) ) ; [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } [ATTENTION] print (   "\nLinks: ( %d )   " , imports . size ( ) )  ; for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^41^^^^^16^45^
[ADD]  print  (    "\nLinks:  (  %d  )    ",  links  .  size  (  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } [ATTENTION] for ( Element link : links ) { print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^41^^^^^16^45^
[REPLACE]  for  (  Element  link  :  links  )  { 	[BUGGY] for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) )[CE] cannot find symbol link  [METHOD]  main [TYPE] void [PARAMETER] String[] args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] Element link src [TYPE] String[] args [TYPE] Document doc [TYPE] Elements imports links media [TYPE] URL url  [CONTEXT]  public static void main ( String[] args ) throws IOException { Validate . isTrue ( args . length = = 1 ,   "usage: supply url to fetch  " ) ; URL url = new URL ( args[0] ) ; print (   "Fetching %s . . .   " , url . toExternalForm ( ) ) ;  Document doc = Jsoup . parse ( url , 3*1000 ) ; Elements links = doc . select (   "a[href]  " ) ; Elements media = doc . select (   "[src]  " ) ; Elements imports = doc . select (   "link[href]  " ) ;  print (   "\nMedia: ( %d )   " , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals (   "img  " ) ) print (   " * %s: <%s> %sx%s ( %s )   " , src . tagName ( ) , src . attr (   "abs:src  " ) , src . attr (   "width  " ) , src . attr (   "height  " ) , trim ( src . attr (   "alt  " ) , 20 ) ) ; else print (   " * %s: <%s>  " , src . tagName ( ) , src . attr (   "abs:src  " ) ) ; } print (   "\nImports: ( %d )   " , imports . size ( ) ) ; for ( Element link : imports ) { print (   " * %s <%s> ( %s )   " , link . tagName ( ) , link . attr (   "abs:href  " ) , link . attr (   "rel  " ) ) ; } print (   "\nLinks: ( %d )   " , links . size ( ) ) ; [ATTENTION] for ( Element src : media ) { if ( src . tagName ( )  . equals (   "img  " ) ) print (   " * a: <%s> ( %s )   " , link . attr (   "abs:href  " ) , trim ( link . text ( ) , 35 ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^42^^^^^16^45^
[REPLACE]  System  .  out  .  println  (  String  .  format  (  msg,  args  )  )  ; 	[BUGGY] System . out . println ( String . substring ( null , true )  ) ; [CE] no suitable method found for substring(<null> , boolean)  [METHOD]  print [TYPE] void [PARAMETER] String msg args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String msg [TYPE] Object[] args  [CONTEXT]  private static void print ( String msg , Object . . . args ) { [ATTENTION] System . out . println ( String . substring ( null , true )  )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^48^^^^^47^49^
[REPLACE]  System  .  out  .  println  (  String  .  format  (  msg,  args  )  )  ; 	[BUGGY] System . out . println ( String . substring ( msg , args ) ) ; [CE] no suitable method found for substring(String , Object[])  [METHOD]  print [TYPE] void [PARAMETER] String msg args [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String msg [TYPE] Object[] args  [CONTEXT]  private static void print ( String msg , Object . . . args ) { [ATTENTION] System . out . println ( String . substring ( msg , args ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^48^^^^^47^49^
[REPLACE]  if  (  s  .  length  (  )  >  width  )  return  s  .  substring  (  0,  width-1  )  +    "  .    "; 	[BUGGY] if ( s . length ( ) + 3 > width ) return s . substring ( 0 , width-1 ) +   " .   " ; [NO-ERROR]  [METHOD]  trim [TYPE] String [PARAMETER] String s int width [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String s [TYPE] int width  [CONTEXT]  private static String trim ( String s , int width ) { [ATTENTION] if ( s . length ( ) + 3 > width ) return s . substring ( 0 , width-1 ) +   " .   " ;  else return s ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^52^53^^^^51^56^
[ADD]  if  (  s  .  length  (  )  >  width  )  return  s  .  substring  (  0,  width-1  )  +    "  .    ";  else  return  s;  } 	[BUGGY] return s . substring ( 0 , width-1 ) +   " .   " ; return s ; [CE] reached end of file while parsing  [METHOD]  trim [TYPE] String [PARAMETER] String s int width [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String s [TYPE] int width  [CONTEXT]  private static String trim ( String s , int width ) { [ATTENTION] return s . substring ( 0 , width-1 ) +   " .   " ; return s ;     	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^52^53^54^55^56^51^56^
[REPLACE]  return  s  .  substring  (  0,  width-1  )  +    "  .    "; 	[BUGGY] return s . substring ( 3 , width-1 )  &&   " .   " ; [CE] bad operand types for binary operator  [METHOD]  trim [TYPE] String [PARAMETER] String s int width [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String s [TYPE] int width  [CONTEXT]  private static String trim ( String s , int width ) { if ( s . length ( ) > width ) [ATTENTION] return s . substring ( 3 , width-1 ) &&  " .   " ; else return s ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^53^^^^^51^56^
[REPLACE]  return  s  .  substring  (  0,  width-1  )  +    "  .    "; 	[BUGGY] return s . substring ( 0 , width-1 ) +s ; [NO-ERROR]  [METHOD]  trim [TYPE] String [PARAMETER] String s int width [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String s [TYPE] int width  [CONTEXT]  private static String trim ( String s , int width ) { if ( s . length ( ) > width ) [ATTENTION] return s . substring ( 0 , width-1 ) +s ; else return s ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^53^^^^^51^56^
[REPLACE]  return  s; 	[BUGGY] return s . substring ( 0 , width-1 ) +   " .   " ; [NO-ERROR]  [METHOD]  trim [TYPE] String [PARAMETER] String s int width [CLASS] ListLinks  [TYPE] boolean false true [TYPE] String s [TYPE] int width  [CONTEXT]  private static String trim ( String s , int width ) { if ( s . length ( ) > width ) return s . substring ( 0 , width-1 ) +   " .   " ; else [ATTENTION] return s . substring ( 0 , width-1 ) +   " .   " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/examples/ListLinks.java^55^^^^^51^56^
[REPLACE]  Validate  .  notNull  (  whitelist  )  ; 	[BUGGY] whitelist  ; [CE] not a statement  [METHOD]  <init> [TYPE] Whitelist) [PARAMETER] Whitelist whitelist [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Cleaner ( Whitelist whitelist ) { [ATTENTION] whitelist ; this . whitelist = whitelist ; }  	None^29^^^^^28^31^
[REPLACE]  this  .  whitelist  =  whitelist; 	[BUGGY] this . whitelist =  null ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] Whitelist) [PARAMETER] Whitelist whitelist [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Cleaner ( Whitelist whitelist ) { Validate . notNull ( whitelist ) ; [ATTENTION] this . whitelist = null ; }  	None^30^^^^^28^31^
[REPLACE]  this  .  el  =  el; 	[BUGGY] this . el =  null ; [FE]  The validated object is null assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] Element , int) [PARAMETER] Element el int numAttribsDiscarded [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  ElementMeta ( Element el , int numAttribsDiscarded ) { [ATTENTION] this . el = null ; this . numAttribsDiscarded = numAttribsDiscarded ; }  	None^124^^^^^123^126^
[ADD]  this  .  el  =  el;  this  .  numAttribsDiscarded  =  numAttribsDiscarded; 	[BUGGY] [FE]  The validated object is null assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] Element , int) [PARAMETER] Element el int numAttribsDiscarded [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  ElementMeta ( Element el , int numAttribsDiscarded ) { [ATTENTION]  }  	None^124^125^^^^123^126^
[REPLACE]  this  .  numAttribsDiscarded  =  numAttribsDiscarded; 	[BUGGY] this . numAttribsDiscarded =  null ; [CE] incompatible types  [METHOD]  <init> [TYPE] Element , int) [PARAMETER] Element el int numAttribsDiscarded [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  ElementMeta ( Element el , int numAttribsDiscarded ) { this . el = el ; [ATTENTION] this . numAttribsDiscarded = null ; }  	None^125^^^^^123^126^
[REPLACE]  Validate  .  notNull  (  dirtyDocument  )  ; 	[BUGGY] Validate . notNull ( clean ) ; [CE] cannot find symbol clean  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { [ATTENTION] Validate . notNull ( clean )  ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ;  return clean ; }  	None^40^^^^^39^46^
[ADD]  Validate  .  notNull  (  dirtyDocument  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { [ATTENTION]  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ;  return clean ; }  	None^40^^^^^39^46^
[REPLACE]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ; 	[BUGGY] Document clean = Document . createShell ( dirtyDocument . createShell ( )  ) ; [CE] method createShell in class Document cannot be applied to given types ;  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  [ATTENTION] Document clean = Document . createShell ( dirtyDocument . createShell ( )  )  ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ;  return clean ; }  	None^42^^^^^39^46^
[ADD]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] [CE] cannot find symbol clean  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  [ATTENTION]  return clean ; }  	None^42^43^^^^39^46^
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] copySafeNodes ( dirtyDocument . baseUri ( ) , clean . body ( ) ) ; [CE] method copySafeNodes in class Cleaner cannot be applied to given types ;  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; [ATTENTION] copySafeNodes ( dirtyDocument . baseUri ( )  , clean . body ( ) )  ;  return clean ; }  	None^43^^^^^39^46^
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] copySafeNodes ( clean . body ( ) , clean . body ( ) ) ; [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; [ATTENTION] copySafeNodes ( clean . body ( )  , clean . body ( ) )  ;  return clean ; }  	None^43^^^^^39^46^
[ADD]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; [ATTENTION]  return clean ; }  	None^43^^^^^39^46^
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] copySafeNodes ( dirtyDocument . baseUri ( )  , dirtyDocument[CE] ')' expected  [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; [ATTENTION] copySafeNodes ( dirtyDocument . baseUri ( ) , dirtyDocument return clean ; }  	None^43^^^^^39^46^
[REPLACE]  return  clean; 	[BUGGY] return dirtyDocument ; [FE]  AssertionFailedError  expected:<<img alt =   "  " []/>> but was:<<img alt =   "  " [src =   "  " ]/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  clean [TYPE] Document [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded [TYPE] Element el  [CONTEXT]  public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ;  [ATTENTION] return dirtyDocument ; }  	None^45^^^^^39^46^
[REPLACE]  Validate  .  notNull  (  dirtyDocument  )  ; 	[BUGGY] Validate . notNull ( clean ) ; [CE] cannot find symbol clean  [METHOD]  isValid [TYPE] boolean [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded numDiscarded [TYPE] Element el  [CONTEXT]  public boolean isValid ( Document dirtyDocument ) { [ATTENTION] Validate . notNull ( clean )  ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; }  	None^59^^^^^58^64^
[REPLACE]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ; 	[BUGGY] Document clean = Document . createShell ( dirtyDocument . createShell ( )  ) ; [CE] method createShell in class Document cannot be applied to given types ;  [METHOD]  isValid [TYPE] boolean [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded numDiscarded [TYPE] Element el  [CONTEXT]  public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  [ATTENTION] Document clean = Document . createShell ( dirtyDocument . createShell ( )  )  ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; }  	None^61^^^^^58^64^
[REPLACE]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ; 	[BUGGY] TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; [CE] cannot find symbol sourceText  [METHOD]  isValid [TYPE] boolean [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded numDiscarded [TYPE] Element el  [CONTEXT]  public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; [ATTENTION] TextNode destText = new TextNode ( sourceText . getWholeText ( )  , sourceChild . baseUri ( ) )  ; return numDiscarded = = 0 ; }  	None^62^^^^^58^64^
[REPLACE]  return  numDiscarded  ==  0; 	[BUGGY] return numDiscarded ! =  1 ; ; [CE] unreachable statement  [METHOD]  isValid [TYPE] boolean [PARAMETER] Document dirtyDocument [CLASS] Cleaner ElementMeta  [TYPE] Whitelist whitelist [TYPE] boolean false true [TYPE] Document clean dirtyDocument [TYPE] int numAttribsDiscarded numDiscarded [TYPE] Element el  [CONTEXT]  public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ;  Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; [ATTENTION] return numDiscarded! = 1 ; ; }  	None^63^^^^^58^64^
[REPLACE]  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ; 	[BUGGY] List<Node> sourceElChildren = source . tagName ( )  ; [CE] incompatible types  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { [ATTENTION] List<Node> sourceElChildren = source . tagName ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^73^^^^^72^98^
[REPLACE]  int  numDiscarded  =  0; 	[BUGGY] int numDiscarded = 4 ; [FE] NullPointerException assertTrue(Jsoup.isValid(ok , Whitelist.basic()))   [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; [ATTENTION] int numDiscarded = 4 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^74^^^^^72^98^
[REPLACE]  if  (  sourceChild  instanceof  Element  )  { 	[BUGGY] if ( ! sourceChild instanceof Element ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { [ATTENTION] if ( ! sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^77^^^^^72^98^
[REPLACE]  }  else  if  (  sourceChild  instanceof  TextNode  )  { 	[BUGGY]  if ( ! sourceChild instanceof TextNode ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } [ATTENTION] }if ( ! sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^91^^^^^72^98^
[REPLACE]  TextNode  sourceText  =  (  TextNode  )  sourceChild; 	[BUGGY] for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) {[CE] illegal start of expression  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { [ATTENTION] for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^92^^^^^72^98^
[ADD]  TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ; 	[BUGGY] TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; [CE] cannot find symbol sourceText  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { [ATTENTION] TextNode destText = new TextNode ( sourceText . getWholeText ( )  , sourceChild . baseUri ( ) )  ;  dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^92^93^^^^72^98^
[REPLACE]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ; 	[BUGGY] TextNode destText = new TextNode ( destText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; [CE] variable destText might not have been initialized  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; [ATTENTION] TextNode destText = new TextNode ( destText . getWholeText ( )  , sourceChild . baseUri ( ) )  ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^93^^^^^72^98^
[REPLACE]  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  { 	[BUGGY] if ( whitelist . isSafeTag ( source . tagName ( ) ) ) {[FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  [ATTENTION] if ( whitelist . isSafeTag ( source . tagName ( ) ) ) { ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^80^^^^^72^98^
[ADD]  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el;  dest  .  appendChild  (  destChild  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  [ATTENTION]   numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^80^81^82^83^^72^98^
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ; 	[BUGGY] numDiscarded + = copySafeNodes ( sourceEl , destChild ) ;  ; [CE] cannot find symbol destChild  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; [ATTENTION] numDiscarded + = copySafeNodes ( sourceEl , destChild )  ;  ; }  	None^89^^^^^80^90^
[REPLACE]  numDiscarded  +=  meta  .  numAttribsDiscarded; 	[BUGGY] numDiscarded + =  null . numAttribsDiscarded ; [CE] <null> cannot be dereferenced  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  [ATTENTION] numDiscarded + = null . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^85^^^^^72^98^
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ; 	[BUGGY] numDiscarded + = copySafeNodes ( sourceEl , dest ) ;  ; [FE] AssertionFailedError [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; [ATTENTION] numDiscarded + = copySafeNodes ( sourceEl , dest )  ;  ; } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^86^^^^^72^98^
[ADD]  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; [ATTENTION] } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^86^^^^^72^98^
[REPLACE]  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ; 	[BUGGY] ElementMeta meta = createSafeElement ( el ) ; [CE] cannot find symbol el  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs [ATTENTION] ElementMeta meta = createSafeElement ( el )  ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^81^^^^^72^98^
[REPLACE]  Element  destChild  =  meta  .  el; 	[BUGGY] Element sourceEl =  ( Element ) sourceChild ; [CE] variable sourceEl is already defined in method copySafeNodes(Element , Element)  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; [ATTENTION] Element sourceEl = ( Element ) sourceChild ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^82^^^^^72^98^
[ADD]  Element  destChild  =  meta  .  el;  dest  .  appendChild  (  destChild  )  ; 	[BUGGY] [CE] cannot find symbol destChild  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; [ATTENTION]  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^82^83^^^^72^98^
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ; 	[BUGGY] numDiscarded + = copySafeNodes ( sourceEl , destChild ) ;  ; [CE] cannot find symbol destChild  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; [ATTENTION] numDiscarded + = copySafeNodes ( sourceEl , destChild )  ;  ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^89^^^^^72^98^
[REPLACE]  Element  sourceEl  =  (  Element  )  sourceChild; 	[BUGGY] TextNode sourceText =  ( TextNode ) sourceChild ; [CE] cannot find symbol sourceEl  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { [ATTENTION] TextNode sourceText = ( TextNode ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^78^^^^^72^98^
[ADD]  Element  sourceEl  =  (  Element  )  sourceChild; 	[BUGGY] [CE] cannot find symbol sourceEl  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { [ATTENTION]  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^78^^^^^72^98^
[ADD]  numDiscarded  +=  meta  .  numAttribsDiscarded; 	[BUGGY] [FE] NullPointerException assertTrue(Jsoup.isValid(ok , Whitelist.basic()))   [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  [ATTENTION] numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^85^^^^^72^98^
[REPLACE]  }  else  if  (  sourceChild  instanceof  TextNode  )  { 	[BUGGY]  else {[FE]  org.jsoup.nodes.DataNode cannot be cast to org.jsoup.nodes.TextNode assertEquals(  "  " , cleanHtml)   [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } [ATTENTION] }else { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^91^^^^^72^98^
[REPLACE]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ; 	[BUGGY] TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . createShell ( )  ) ; [CE] cannot find symbol  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; [ATTENTION] TextNode destText = new TextNode ( sourceText . getWholeText ( )  , sourceChild . createShell ( )  )  ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^93^^^^^72^98^
[REPLACE]  for  (  Node  sourceChild  :  sourceChildren  )  { 	[BUGGY] String sourceTag = sourceEl . tagName ( ) ; [CE] illegal start of type  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  [ATTENTION] String sourceTag = sourceEl . tagName ( )  ; if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^76^^^^^72^98^
[REPLACE]  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ; 	[BUGGY] ElementMeta meta = createSafeElement ( source ) ; [FE]  AssertionFailedError  expected:<<[img alt =   "  " /]>> but was:<<[body> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs [ATTENTION] ElementMeta meta = createSafeElement ( source )  ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } return numDiscarded ; }  	None^81^^^^^72^98^
[REPLACE]  return  numDiscarded; 	[BUGGY] return numAttribsDiscarded ; [CE] cannot find symbol numAttribsDiscarded  [METHOD]  copySafeNodes [TYPE] int [PARAMETER] Element source Element dest [CLASS] Cleaner ElementMeta  [TYPE] ElementMeta meta [TYPE] boolean false true [TYPE] Element dest destChild el source sourceEl [TYPE] Node sourceChild [TYPE] Whitelist whitelist [TYPE] List sourceChildren [TYPE] TextNode destText sourceText [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private int copySafeNodes ( Element source , Element dest ) { List<Node> sourceChildren = source . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { Element sourceEl =  ( Element ) sourceChild ;  if ( whitelist . isSafeTag ( sourceEl . tagName ( ) ) ) { // safe , clone and copy safe attrs ElementMeta meta = createSafeElement ( sourceEl ) ; Element destChild = meta . el ; dest . appendChild ( destChild ) ;  numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; // recurs } else { // not a safe tag , but it may have children ( els or text ) that are , so recurse numDiscarded++ ; numDiscarded + = copySafeNodes ( sourceEl , dest ) ; } } else if ( sourceChild instanceof TextNode ) { TextNode sourceText =  ( TextNode ) sourceChild ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , sourceChild . baseUri ( ) ) ; dest . appendChild ( destText ) ; } // else , we don't care about comments , xml proc instructions , etc } [ATTENTION] return numAttribsDiscarded ; }  	None^97^^^^^72^98^
[REPLACE]  String  sourceTag  =  sourceEl  .  tagName  (  )  ; 	[BUGGY] String sourceTag = source . tagName ( ) ; [CE] cannot find symbol source  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { [ATTENTION] String sourceTag = source . tagName ( )  ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^101^^^^^100^117^
[REPLACE]  Attributes  destAttrs  =  new  Attributes  (  )  ; 	[BUGGY] Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; [CE] cannot find symbol destAttrs  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; [ATTENTION] Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag )  ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^102^^^^^100^117^
[REPLACE]  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ; 	[BUGGY] Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , sourceAttrs ) ; [CE] cannot find symbol sourceAttrs  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; [ATTENTION] Element dest = new Element ( Tag . valueOf ( sourceTag )  , sourceEl . baseUri ( )  , sourceAttrs )  ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^103^^^^^100^117^
[REPLACE]  int  numDiscarded  =  0; 	[BUGGY] int numDiscarded = 3 ; [FE] NullPointerException assertTrue(Jsoup.isValid(ok , Whitelist.basic()))   [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; [ATTENTION] int numDiscarded = 3 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^104^^^^^100^117^
[REPLACE]  Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ; 	[BUGGY] Attributes sourceAttrs = sourceEl . childNodes ( )  ; [CE] incompatible types  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  [ATTENTION] Attributes sourceAttrs = sourceEl . childNodes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^106^^^^^100^117^
[REPLACE]  if  (  whitelist  .  isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ; 	[BUGGY] if ( whitelist . isSafeAttribute ( sourceTag , source , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; [CE] cannot find symbol source  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { [ATTENTION] if ( whitelist . isSafeAttribute ( sourceTag , source , sourceAttr ) ) destAttrs . put ( sourceAttr )  ;  else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^108^109^^^^100^117^
[ADD]  if  (  whitelist  .  isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++;  } 	[BUGGY] destAttrs . put ( sourceAttr ) ; numDiscarded++ ; [CE] illegal start of expression  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { [ATTENTION] destAttrs . put ( sourceAttr )  ; numDiscarded++ ;   Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^108^109^110^111^112^100^117^
[REPLACE]  destAttrs  .  put  (  sourceAttr  )  ; 	[BUGGY] destAttrs . addAll ( sourceAttr ) ; [CE] method addAll in class Attributes cannot be applied to given types ;  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) [ATTENTION] destAttrs . addAll ( sourceAttr )  ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^109^^^^^100^117^
[ADD]  destAttrs  .  put  (  sourceAttr  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) [ATTENTION] else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^109^^^^^100^117^
[REPLACE]  for  (  Attribute  sourceAttr  :  sourceAttrs  )  { 	[BUGGY] for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) {[CE] illegal start of expression  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; [ATTENTION] for ( Node sourceChild : sourceChildren ) { if ( sourceChild instanceof Element ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^107^^^^^100^117^
[REPLACE]  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ; 	[BUGGY] Attributes enforcedAttrs = whitelist . isSafeAttribute ( sourceTag , source , sourceAttr )  ; [CE] cannot find symbol source  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } [ATTENTION] Attributes enforcedAttrs = whitelist . isSafeAttribute ( sourceTag , source , sourceAttr ) ; destAttrs . addAll ( enforcedAttrs ) ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^113^^^^^100^117^
[REPLACE]  destAttrs  .  addAll  (  enforcedAttrs  )  ; 	[BUGGY] destAttrs . addAll ( sourceAttrs ) ; [FE]  AssertionFailedError  expected:<<img alt =   "  " []/>> but was:<<img alt =   "  " [src =   "  " ]/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; [ATTENTION] destAttrs . addAll ( sourceAttrs )  ;  return new ElementMeta ( dest , numDiscarded ) ; }  	None^114^^^^^100^117^
[REPLACE]  return  new  ElementMeta  (  dest,  numDiscarded  )  ; 	[BUGGY] return new ElementMeta ( sourceEl , numDiscarded ) ; [FE]  Cannot (yet) move nodes in tree assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] Cleaner ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]  private ElementMeta createSafeElement ( Element sourceEl ) { String sourceTag = sourceEl . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , sourceEl . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ;  Attributes sourceAttrs = sourceEl . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceEl , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded++ ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ;  [ATTENTION] return new ElementMeta ( sourceEl , numDiscarded )  ; }  	None^116^^^^^100^117^
[REPLACE]  int  numAttribsDiscarded; 	[BUGGY] long numAttribsDiscarded ; [NO-ERROR]  [METHOD]  createSafeElement [TYPE] Cleaner$ElementMeta [PARAMETER] Element sourceEl [CLASS] ElementMeta  [TYPE] boolean false true [TYPE] Attribute sourceAttr [TYPE] Element dest destChild el source sourceEl [TYPE] Attributes destAttrs enforcedAttrs sourceAttrs [TYPE] Whitelist whitelist [TYPE] String sourceTag [TYPE] int numAttribsDiscarded numDiscarded  [CONTEXT]   	None^121^^^^^^^
[REPLACE]  this  .  el  =  el; 	[BUGGY] this . el =  null ; [FE]  The validated object is null assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] Element , int) [PARAMETER] Element el int numAttribsDiscarded [CLASS] ElementMeta  [TYPE] int numAttribsDiscarded [TYPE] Element el [TYPE] boolean false true  [CONTEXT]  ElementMeta ( Element el , int numAttribsDiscarded ) { [ATTENTION] this . el = null ; this . numAttribsDiscarded = numAttribsDiscarded ; }  	None^124^^^^^123^126^
[REPLACE]  this  .  numAttribsDiscarded  =  numAttribsDiscarded; 	[BUGGY] this . numAttribsDiscarded =  null ; [CE] incompatible types  [METHOD]  <init> [TYPE] Element , int) [PARAMETER] Element el int numAttribsDiscarded [CLASS] ElementMeta  [TYPE] int numAttribsDiscarded [TYPE] Element el [TYPE] boolean false true  [CONTEXT]  ElementMeta ( Element el , int numAttribsDiscarded ) { this . el = el ; [ATTENTION] this . numAttribsDiscarded = null ; }  	None^125^^^^^123^126^
[REPLACE]  tagNames  =  new  HashSet<TagName>  (  )  ; 	[BUGGY] tagNames =  new Protocol> ( )  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] Whitelist() [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist ( ) { [ATTENTION] tagNames = new Protocol> ( ) ; attributes = new HashMap<TagName , Set<AttributeKey>> ( ) ; enforcedAttributes = new HashMap<TagName , Map<AttributeKey , AttributeValue>> ( ) ; protocols = new HashMap<TagName , Map<AttributeKey , Set<Protocol>>> ( ) ; }  	None^170^^^^^169^174^
[ADD]  tagNames  =  new  HashSet<TagName>  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] Whitelist() [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist ( ) { [ATTENTION] attributes = new HashMap<TagName , Set<AttributeKey>> ( ) ; enforcedAttributes = new HashMap<TagName , Map<AttributeKey , AttributeValue>> ( ) ; protocols = new HashMap<TagName , Map<AttributeKey , Set<Protocol>>> ( ) ; }  	None^170^^^^^169^174^
[REPLACE]  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ; 	[BUGGY] attributes =  new AttributeKey , AttributeValue> ( )  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] Whitelist() [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist ( ) { tagNames = new HashSet<TagName> ( ) ; [ATTENTION] attributes = new AttributeKey , AttributeValue> ( ) ; enforcedAttributes = new HashMap<TagName , Map<AttributeKey , AttributeValue>> ( ) ; protocols = new HashMap<TagName , Map<AttributeKey , Set<Protocol>>> ( ) ; }  	None^171^^^^^169^174^
[REPLACE]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ; 	[BUGGY] enforcedAttributes =  new AttributeKey , AttributeValue> ( )  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] Whitelist() [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist ( ) { tagNames = new HashSet<TagName> ( ) ; attributes = new HashMap<TagName , Set<AttributeKey>> ( ) ; [ATTENTION] enforcedAttributes = new AttributeKey , AttributeValue> ( ) ; protocols = new HashMap<TagName , Map<AttributeKey , Set<Protocol>>> ( ) ; }  	None^172^^^^^169^174^
[REPLACE]  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ; 	[BUGGY] protocols =  new TagName , AttributeKey>> ( )  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] Whitelist() [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist ( ) { tagNames = new HashSet<TagName> ( ) ; attributes = new HashMap<TagName , Set<AttributeKey>> ( ) ; enforcedAttributes = new HashMap<TagName , Map<AttributeKey , AttributeValue>> ( ) ; [ATTENTION] protocols = new TagName , AttributeKey>> ( ) ; }  	None^173^^^^^169^174^
[REPLACE]  super  (  value  )  ; 	[BUGGY] attr . setValue ( value ) ; [CE] constructor TypedValue in class TypedValue cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  TagName ( String value ) { [ATTENTION] attr . setValue ( value )  ; }  	None^348^^^^^347^349^
[REPLACE]  super  (  value  )  ; 	[BUGGY] attr . setValue ( value ) ; [CE] constructor TypedValue in class TypedValue cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  AttributeKey ( String value ) { [ATTENTION] attr . setValue ( value )  ; }  	None^358^^^^^357^359^
[REPLACE]  super  (  value  )  ; 	[BUGGY] attr . setValue ( value ) ; [CE] constructor TypedValue in class TypedValue cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  AttributeValue ( String value ) { [ATTENTION] attr . setValue ( value )  ; }  	None^368^^^^^367^369^
[REPLACE]  super  (  value  )  ; 	[BUGGY] attr . setValue ( value ) ; [CE] constructor TypedValue in class TypedValue cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  Protocol ( String value ) { [ATTENTION] attr . setValue ( value )  ; }  	None^378^^^^^377^379^
[REMOVE]   	[BUGGY] protSet . add ( prot ) ; [CE] cannot find symbol prot  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  Protocol ( String value ) { [ATTENTION] super ( value ) ;   	None^378^^^^^377^379^
[REPLACE]  Validate  .  notNull  (  value  )  ; 	[BUGGY] Validate . notNull ( tags ) ; [CE] cannot find symbol tags  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  TypedValue ( String value ) { [ATTENTION] Validate . notNull ( tags )  ; this . value = value ; }  	None^390^^^^^389^392^
[REPLACE]  this  .  value  =  value; 	[BUGGY] this . value =  null ; [FE]  The validated string is empty assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  TypedValue ( String value ) { Validate . notNull ( value ) ; [ATTENTION] this . value = null ; }  	None^391^^^^^389^392^
[REPLACE]  return  new  Whitelist  (  )  ; 	[BUGGY] return new TagName ( value )  ; [CE] cannot find symbol value  [METHOD]  none [TYPE] Whitelist [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public static Whitelist none ( ) { [ATTENTION] returnnew TagName ( value ) ; }  	None^62^^^^^61^63^
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (    "b  ",    "em  ",    "i  ",    "strong  ",    "u  "  )  ; 	[BUGGY] return new Whitelist ( )  . addProtocols ( value , value , false )  ; [CE] cannot find symbol value  [METHOD]  simpleText [TYPE] Whitelist [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public static Whitelist simpleText ( ) { [ATTENTION] return new Whitelist ( ) . addProtocols ( value , value , false ) ;  }  	None^72^73^74^^^71^75^
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (    "a  ",    "b  ",    "blockquote  ",    "br  ",    "cite  ",    "code  ",    "dd  ",    "dl  ",    "dt  ",    "em  ",    "i  ",    "li  ",    "ol  ",    "p  ",    "pre  ",    "q  ",    "small  ",    "strike  ",    "strong  ",    "sub  ", 	[BUGGY] return new TagName ( value )  . addTags (   "a  " ,   "b  " ,   "blockquote  " ,   "br  " ,   "cite  " ,   "code  " ,   "dd  " ,   "dl  " ,   "dt  " ,   "em  " ,   "i  " ,   "li  " ,   "ol  " ,   "p  " ,   "pre  " ,   "q  " ,   "small  " ,   "strike  " ,   "strong  " ,   "sub  " , [CE] cannot find symbol value  [METHOD]  basic [TYPE] Whitelist [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public static Whitelist basic ( ) { [ATTENTION] returnnew TagName ( value ) . addTags (   "a  " ,   "b  " ,   "blockquote  " ,   "br  " ,   "cite  " ,   "code  " ,   "dd  " ,   "dl  " ,   "dt  " ,   "em  " ,   "i  " ,   "li  " ,   "ol  " ,   "p  " ,   "pre  " ,   "q  " ,   "small  " ,   "strike  " ,   "strong  " ,   "sub  " ,     "sup  " ,   "u  " ,   "ul  " )  . addAttributes (   "a  " ,   "href  " )  . addAttributes (   "blockquote  " ,   "cite  " )  . addAttributes (   "q  " ,   "cite  " )  . addProtocols (   "a  " ,   "href  " ,   "ftp  " ,   "http  " ,   "https  " ,   "mailto  " )  . addProtocols (   "blockquote  " ,   "cite  " ,   "http  " ,   "https  " )  . addProtocols (   "cite  " ,   "cite  " ,   "http  " ,   "https  " )  . addEnforcedAttribute (   "a  " ,   "rel  " ,   "nofollow  " )  ;  }  	None^89^90^91^92^^88^106^
[REPLACE]  return  basic  (  )    .  addTags  (    "img  "  )    .  addAttributes  (    "img  ",    "align  ",    "alt  ",    "height  ",    "src  ",    "title  ",    "width  "  )    .  addProtocols  (    "img  ",    "src  ",    "http  ",    "https  "  ) 	[BUGGY] return basic ( ) . addTags (   "img  " ) . addAttributes (   "img  " ,   "align  " ,   "alt  " ,   "height  " ,   "src  " ,   "title  " ,   "width  " ) . addTags (   "img  " ,   "src  " ,   "http  " ,   "https  " )[FE]  AssertionFailedError  expected:<<img alt =   "  " []/>> but was:<<img alt =   "  " [src =   "unknown = assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  basicWithImages [TYPE] Whitelist [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public static Whitelist basicWithImages ( ) { [ATTENTION] return basic ( )  . addTags (   "img  " )  . addAttributes (   "img  " ,   "align  " ,   "alt  " ,   "height  " ,   "src  " ,   "title  " ,   "width  " )  . addTags (   "img  " ,   "src  " ,   "http  " ,   "https  " )   ; }  	None^115^116^117^118^^114^120^
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (    "a  ",    "b  ",    "blockquote  ",    "br  ",    "caption  ",    "cite  ",    "code  ",    "col  ",    "colgroup  ",    "dd  ",    "div  ",    "dl  ",    "dt  ",    "em  ",    "h1  ",    "h2  ",    "h3  ",    "h4  ",    "h5  ",    "h6  ", 	[BUGGY] return new TagName ( value )  . addTags (   "a  " ,   "b  " ,   "blockquote  " ,   "br  " ,   "caption  " ,   "cite  " ,   "code  " ,   "col  " ,   "colgroup  " ,   "dd  " ,   "div  " ,   "dl  " ,   "dt  " ,   "em  " ,   "h1  " ,   "h2  " ,   "h3  " ,   "h4  " ,   "h5  " ,   "h6  " , [CE] cannot find symbol value  [METHOD]  relaxed [TYPE] Whitelist [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String value [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public static Whitelist relaxed ( ) { [ATTENTION] returnnew TagName ( value ) . addTags (   "a  " ,   "b  " ,   "blockquote  " ,   "br  " ,   "caption  " ,   "cite  " ,   "code  " ,   "col  " ,   "colgroup  " ,   "dd  " ,   "div  " ,   "dl  " ,   "dt  " ,   "em  " ,   "h1  " ,   "h2  " ,   "h3  " ,   "h4  " ,   "h5  " ,   "h6  " ,     "i  " ,   "img  " ,   "li  " ,   "ol  " ,   "p  " ,   "pre  " ,   "q  " ,   "small  " ,   "strike  " ,   "strong  " ,   "sub  " ,   "sup  " ,   "table  " ,   "tbody  " ,   "td  " ,   "tfoot  " ,   "th  " ,   "thead  " ,   "tr  " ,   "u  " ,   "ul  " )  . addAttributes (   "a  " ,   "href  " ,   "title  " )  . addAttributes (   "blockquote  " ,   "cite  " )  . addAttributes (   "col  " ,   "span  " ,   "width  " )  . addAttributes (   "colgroup  " ,   "span  " ,   "width  " )  . addAttributes (   "img  " ,   "align  " ,   "alt  " ,   "height  " ,   "src  " ,   "title  " ,   "width  " )  . addAttributes (   "ol  " ,   "start  " ,   "type  " )  . addAttributes (   "q  " ,   "cite  " )  . addAttributes (   "table  " ,   "summary  " ,   "width  " )  . addAttributes (   "td  " ,   "abbr  " ,   "axis  " ,   "colspan  " ,   "rowspan  " ,   "width  " )  . addAttributes (   "th  " ,   "abbr  " ,   "axis  " ,   "colspan  " ,   "rowspan  " ,   "scope  " ,   "width  " )  . addAttributes (   "ul  " ,   "type  " )  . addProtocols (   "a  " ,   "href  " ,   "ftp  " ,   "http  " ,   "https  " ,   "mailto  " )  . addProtocols (   "blockquote  " ,   "cite  " ,   "http  " ,   "https  " )  . addProtocols (   "img  " ,   "src  " ,   "http  " ,   "https  " )  . addProtocols (   "q  " ,   "cite  " ,   "http  " ,   "https  " )  ; }  	None^132^133^134^135^^131^159^
[REPLACE]  Validate  .  notNull  (  tags  )  ; 	[BUGGY] Validate . notNull ( value ) ; [CE] cannot find symbol value  [METHOD]  addTags [TYPE] Whitelist [PARAMETER] tags [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String tagName value [TYPE] String[] tags [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addTags ( String . . . tags ) { [ATTENTION] Validate . notNull ( value )  ;  for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ; tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; }  	None^183^^^^^182^190^
[REPLACE]  for  (  String  tagName  :  tags  )  { 	[BUGGY] TagName tag = TagName . valueOf ( tagName ) ; [CE] illegal start of type  [METHOD]  addTags [TYPE] Whitelist [PARAMETER] tags [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String tagName value [TYPE] String[] tags [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addTags ( String . . . tags ) { Validate . notNull ( tags ) ;  [ATTENTION] TagName tag = TagName . valueOf ( tagName )  ; Validate . notEmpty ( tagName ) ; tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; }  	None^185^^^^^182^190^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addTags [TYPE] Whitelist [PARAMETER] tags [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set tagNames [TYPE] String tagName value [TYPE] String[] tags [TYPE] boolean false true [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addTags ( String . . . tags ) { Validate . notNull ( tags ) ;  for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ; tagNames . add ( TagName . valueOf ( tagName ) ) ; } [ATTENTION] return null ; }  	None^189^^^^^182^190^
[REPLACE]  Validate  .  notEmpty  (  tag  )  ; 	[BUGGY] Validate . notEmpty ( value ) ; [CE] cannot find symbol value  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { [ATTENTION] Validate . notEmpty ( value )  ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^203^^^^^202^219^
[REPLACE]  Validate  .  notNull  (  keys  )  ; 	[BUGGY] Validate . notNull ( tags ) ; [CE] cannot find symbol tags  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; [ATTENTION] Validate . notNull ( tags )  ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^204^^^^^202^219^
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ; 	[BUGGY] TagName valueName = TagName . TagName ( tag ) ; [CE] cannot find symbol  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  [ATTENTION] TagName valueName = TagName . TagName ( tag )  ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^206^^^^^202^219^
[REPLACE]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ; 	[BUGGY] AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [CE] cannot find symbol key  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; [ATTENTION] AttributeKey attrKey = AttributeKey . valueOf ( key )  ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^207^^^^^202^219^
[REPLACE]  for  (  String  key  :  keys  )  { 	[BUGGY] for ( String key : keys ) { Validate . notEmpty ( key ) ; [NO-ERROR]  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; [ATTENTION] for ( String key : keys ) { Validate . notEmpty ( key )  ; Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^208^^^^^202^219^
[ADD]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<<img [alt =   "  " ]/>> but was:<<img []/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; [ATTENTION]   if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^208^209^210^211^^202^219^
[REPLACE]  if  (  attributes  .  containsKey  (  tagName  )  )  { 	[BUGGY] if ( enforcedAttributes . containsKey ( tagName ) ) {[NO-ERROR]  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } [ATTENTION] if ( enforcedAttributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^212^^^^^202^219^
[REPLACE]  attributes  .  put  (  tagName,  attributeSet  )  ; 	[BUGGY] attributes . get ( null )  ; [FE]  AssertionFailedError  expected:<<img [alt =   "  " ]/>> but was:<<img []/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { [ATTENTION] attributes . get ( null ) ; } return this ; }  	None^216^^^^^202^219^
[ADD]  attributes  .  put  (  tagName,  attributeSet  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<<img [alt =   "  " ]/>> but was:<<img []/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { [ATTENTION] } return this ; }  	None^216^^^^^202^219^
[REPLACE]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ; 	[BUGGY] Set<AttributeKey> currentSet = attributes . containsKey ( tagName ) ; [CE] incompatible types  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { [ATTENTION] Set<AttributeKey> currentSet = attributes . containsKey ( tagName )  ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^213^^^^^202^219^
[ADD]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { [ATTENTION]  } else { attributes . put ( tagName , attributeSet ) ; } return this ; }  	None^213^214^^^^202^219^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addAttributes [TYPE] Whitelist [PARAMETER] String tag keys [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet tagNames [TYPE] String key tag tagName value [TYPE] String[] keys [TYPE] boolean false true [TYPE] TagName tagName [TYPE] Map attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addAttributes ( String tag , String . . . keys ) { Validate . notEmpty ( tag ) ; Validate . notNull ( keys ) ;  TagName tagName = TagName . valueOf ( tag ) ; Set<AttributeKey> attributeSet = new HashSet<AttributeKey> ( ) ; for ( String key : keys ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( attributes . containsKey ( tagName ) ) { Set<AttributeKey> currentSet = attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { attributes . put ( tagName , attributeSet ) ; } [ATTENTION] return null ; }  	None^218^^^^^202^219^
[REPLACE]  Validate  .  notEmpty  (  tag  )  ; 	[BUGGY] Validate . notNull ( null )  ; [FE]  The validated object is null assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { [ATTENTION] Validate . notNull ( null ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^234^^^^^233^250^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [NO-ERROR]  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; [ATTENTION] Validate . notNull ( key )  ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^235^^^^^233^250^
[ADD]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; [ATTENTION] Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^235^^^^^233^250^
[REPLACE]  Validate  .  notEmpty  (  value  )  ; 	[BUGGY] Validate . notNull ( tagName ) ; [CE] cannot find symbol tagName  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; [ATTENTION] Validate . notNull ( tagName )  ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^236^^^^^233^250^
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ; 	[BUGGY] TagName valueName = TagName . valueOf ( tag ) ; [CE] cannot find symbol tagName  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  [ATTENTION] TagName valueName = TagName . valueOf ( tag )  ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^238^^^^^233^250^
[REPLACE]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ; 	[BUGGY] AttributeKey attrKey = AttributeKey . AttributeKey ( key ) ; [CE] cannot find symbol  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; [ATTENTION] AttributeKey attrKey = AttributeKey . AttributeKey ( key )  ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^239^^^^^233^250^
[ADD]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ; 	[BUGGY] [CE] cannot find symbol attrKey  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; [ATTENTION]  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^239^240^^^^233^250^
[REPLACE]  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ; 	[BUGGY] AttributeValue attrVal = AttributeValue . AttributeValue ( tagName ) ; [CE] cannot find symbol  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [ATTENTION] AttributeValue attrVal = AttributeValue . AttributeValue ( tagName )  ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^240^^^^^233^250^
[REPLACE]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  { 	[BUGGY] if ( enforcedAttributes . entrySet ( )  ) {[CE] incompatible types  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  [ATTENTION] if ( enforcedAttributes . entrySet ( )  ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^242^^^^^233^250^
[REPLACE]  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ; 	[BUGGY] AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [CE] variable attrKey is already defined in method addEnforcedAttribute(String , String , String)  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { [ATTENTION] AttributeKey attrKey = AttributeKey . valueOf ( key )  ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^245^^^^^233^250^
[ADD]  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ; 	[BUGGY] [CE] cannot find symbol attrMap  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { [ATTENTION] attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^245^^^^^233^250^
[REPLACE]  enforcedAttributes  .  get  (  tagName  )    .  put  (  attrKey,  attrVal  )  ; 	[BUGGY] enforcedAttributes . get ( tagName ) . get ( attrKey , attrVal ) ; [CE] method get in interface Map<K , V> cannot be applied to given types ;  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { [ATTENTION] enforcedAttributes . get ( tagName )  . get ( attrKey , attrVal )  ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^243^^^^^233^250^
[REPLACE]  enforcedAttributes  .  get  (  tagName  )    .  put  (  attrKey,  attrVal  )  ; 	[BUGGY] enforcedAttributes . put ( null , null )  . put ( attrKey , attrVal ) ; [NO-ERROR]  [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { [ATTENTION] enforcedAttributes . put ( null , null ) . put ( attrKey , attrVal )  ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }  	None^243^^^^^233^250^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addEnforcedAttribute [TYPE] Whitelist [PARAMETER] String tag String key String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] AttributeValue attrVal [TYPE] Set attributeSet currentSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key tag tagName value [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addEnforcedAttribute ( String tag , String key , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ;  if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map<AttributeKey , AttributeValue> attrMap = new HashMap<AttributeKey , AttributeValue> ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } [ATTENTION] return null ; }  	None^249^^^^^233^250^
[REPLACE]  Validate  .  notEmpty  (  tag  )  ; 	[BUGGY] Validate . notNull ( tag ) ; [NO-ERROR]  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { [ATTENTION] Validate . notNull ( tag )  ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^264^^^^^263^291^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [NO-ERROR]  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; [ATTENTION] Validate . notNull ( key )  ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^265^^^^^263^291^
[REPLACE]  Validate  .  notNull  (  protocols  )  ; 	[BUGGY] protSet . add ( prot ) ; [CE] cannot find symbol prot  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; [ATTENTION] protSet . add ( prot )  ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^266^^^^^263^291^
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ; 	[BUGGY] TagName valueName = TagName . TagName ( tag ) ; [CE] cannot find symbol  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  [ATTENTION] TagName valueName = TagName . TagName ( tag )  ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^268^^^^^263^291^
[ADD]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ; 	[BUGGY] [CE] cannot find symbol tagName  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  [ATTENTION]  Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^268^269^^^^263^291^
[REPLACE]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ; 	[BUGGY] AttributeKey attrKey = AttributeKey . TagName ( key )  ; [CE] cannot find symbol  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; [ATTENTION] AttributeKey attrKey = AttributeKey . TagName ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^269^^^^^263^291^
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrMap; 	[BUGGY] Set<AttributeKey> currentSet = attributes . get ( tagName ) ; [CE] cannot find symbol attrMap  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [ATTENTION] Set<AttributeKey> currentSet = attributes . get ( tagName )  ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^270^^^^^263^291^
[REPLACE]  Set<Protocol>  protSet; 	[BUGGY] Map<AttributeKey , Set<Protocol>> attrMap ; [CE] variable attrMap is already defined in method addProtocols(String , String , String...)  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; [ATTENTION] Map<AttributeKey , Set<Protocol>> attrMap ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^271^^^^^263^291^
[REPLACE]  if  (  this  .  protocols  .  containsKey  (  tagName  )  )  { 	[BUGGY] if ( this . protocols . get ( tagName ) ) {[CE] incompatible types  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  [ATTENTION] if ( this . protocols . get ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^273^^^^^263^291^
[REPLACE]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ; 	[BUGGY] attrMap =  new AttributeKey , AttributeValue> ( )  ; [CE] '(' or '[' expected  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { [ATTENTION] attrMap = new AttributeKey , AttributeValue> ( ) ; this . protocols . put ( tagName , attrMap ) ; }  	None^276^^^^^273^278^
[REPLACE]  attrMap  =  this  .  protocols  .  get  (  tagName  )  ; 	[BUGGY] attrMap =  this . protocols . get ( null ) ; [NO-ERROR]  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { [ATTENTION] attrMap = this . protocols . get ( null )  ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^274^^^^^263^291^
[REPLACE]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ; 	[BUGGY] attrMap =  new AttributeKey , AttributeValue> ( )  ; [CE] '(' or '[' expected  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { [ATTENTION] attrMap = new AttributeKey , AttributeValue> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^276^^^^^263^291^
[REPLACE]  if  (  attrMap  .  containsKey  (  attrKey  )  )  { 	[BUGGY] if ( attrMap . entrySet ( )  ) {[CE] incompatible types  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } [ATTENTION] if ( attrMap . entrySet ( )  ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^279^^^^^263^291^
[REPLACE]  protSet  =  new  HashSet<Protocol>  (  )  ; 	[BUGGY] protSet =  new TagName> ( )  ; [CE] '(' or '[' expected  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { [ATTENTION] protSet = new TagName> ( ) ; attrMap . put ( attrKey , protSet ) ; }  	None^282^^^^^279^284^
[REPLACE]  protSet  =  attrMap  .  get  (  attrKey  )  ; 	[BUGGY] protSet =  this . get ( attrKey ) ; [CE] cannot find symbol  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { [ATTENTION] protSet = this . get ( attrKey )  ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^280^^^^^263^291^
[ADD]  protSet  =  attrMap  .  get  (  attrKey  )  ; 	[BUGGY] [CE] variable protSet might not have been initialized  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { [ATTENTION] } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^280^^^^^263^291^
[REPLACE]  protSet  =  attrMap  .  get  (  attrKey  )  ; 	[BUGGY] protSet =  null . get ( attrKey ) ; [CE] <null> cannot be dereferenced  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { [ATTENTION] protSet = null . get ( attrKey )  ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^280^^^^^263^291^
[REPLACE]  protSet  =  new  HashSet<Protocol>  (  )  ; 	[BUGGY] protSet =  new TagName> ( )  ; [CE] '(' or '[' expected  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { [ATTENTION] protSet = new TagName> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^282^^^^^263^291^
[REPLACE]  for  (  String  protocol  :  protocols  )  { 	[BUGGY] for ( String key : keys ) { Validate . notEmpty ( key ) ; [CE] variable key is already defined in method addProtocols(String , String , String...)  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } [ATTENTION] for ( String key : keys ) { Validate . notEmpty ( key )  ; Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }  	None^285^^^^^263^291^
[REPLACE]  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ; 	[BUGGY] Protocol prot = Protocol . valueOf ( tag ) ; [FE] AssertionFailedError [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; [ATTENTION] Protocol prot = Protocol . valueOf ( tag )  ; protSet . add ( prot ) ; } return this ; }  	None^287^^^^^263^291^
[ADD]  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ; 	[BUGGY] [CE] cannot find symbol prot  [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; [ATTENTION] protSet . add ( prot ) ; } return this ; }  	None^287^^^^^263^291^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  addProtocols [TYPE] Whitelist [PARAMETER] String tag String key protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey attrKey [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tagName [TYPE] String key protocol tag tagName value [TYPE] String[] protocols [TYPE] Protocol prot [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  public Whitelist addProtocols ( String tag , String key , String . . . protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( key ) ; Validate . notNull ( protocols ) ;  TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( key ) ; Map<AttributeKey , Set<Protocol>> attrMap ; Set<Protocol> protSet ;  if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap<AttributeKey , Set<Protocol>> ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet<Protocol> ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } [ATTENTION] return null ; }  	None^290^^^^^263^291^
[REPLACE]  return  tagNames  .  contains  (  TagName  .  valueOf  (  tag  )  )  ; 	[BUGGY] return tagNames . addAll ( TagName . valueOf ( tag ) ) ; [CE] no suitable method found for addAll(TagName)  [METHOD]  isSafeTag [TYPE] boolean [PARAMETER] String tag [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] String key protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeTag ( String tag ) { [ATTENTION] return tagNames . addAll ( TagName . valueOf ( tag ) )  ; }  	None^294^^^^^293^295^
[REPLACE]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ; 	[BUGGY] TagName tag = TagName . valueOf ( value ) ; [CE] cannot find symbol value  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { [ATTENTION] TagName tag = TagName . valueOf ( value )  ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^298^^^^^297^315^
[REPLACE]  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ; 	[BUGGY] AttributeKey key = AttributeKey . TagName ( tag )  ; [CE] cannot find symbol  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; [ATTENTION] AttributeKey key = AttributeKey . TagName ( tag ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^299^^^^^297^315^
[REPLACE]  if  (  attributes  .  containsKey  (  tag  )  )  { 	[BUGGY] if ( enforcedAttributes . containsKey ( tagName ) ) {[FE]  AssertionFailedError  expected:<<img [alt =   "  " ]/>> but was:<<img []/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  [ATTENTION] if ( enforcedAttributes . containsKey ( tagName ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^301^^^^^297^315^
[REPLACE]  return  !tagName  .  equals  (    ":all  "  )  &&  isSafeAttribute  (    ":all  ",  el,  attr  )  ; 	[BUGGY] return !tagName . equals (   ":all  " ) || isSafeAttribute (   ":all  " , el , attr ) ; [FE]  AssertionFailedError  expected:<Hello <b[]>there</b>!> but was:<Hello <b[ id =   "bar  "]>there</b>!> assertEquals(  "Hello <b>there</b>!  " , TextUtil.stripNewlines(cleanHtml))   [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag [ATTENTION] return !tagName . equals (   ":all  " ) || isSafeAttribute (   ":all  " , el , attr )  ; } return false ; }  	None^312^^^^^297^315^
[REPLACE]  if  (  attributes  .  get  (  tag  )    .  contains  (  key  )  )  { 	[BUGGY] if ( attributes . get ( tag ) . addAll ( key ) ) {[CE] no suitable method found for addAll(AttributeKey)  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { [ATTENTION] if ( attributes . get ( tag )  . addAll ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^302^^^^^297^315^
[REPLACE]  if  (  protocols  .  containsKey  (  tag  )  )  { 	[BUGGY] if ( attributes . containsKey ( tag ) ) {[NO-ERROR]  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { [ATTENTION] if ( attributes . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^303^^^^^297^315^
[REPLACE]  return  true; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK [ATTENTION] return false ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^308^^^^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return !attrProts . containsKey ( key )  ; [FE] AssertionFailedError [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return !attrProts . containsKey ( key ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ; 	[BUGGY] Map<AttributeKey , Set<Protocol>> attrProts = protocols . containsKey ( tag ) ; [CE] incompatible types  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { [ATTENTION] Map<AttributeKey , Set<Protocol>> attrProts = protocols . containsKey ( tag )  ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^304^^^^^297^315^
[ADD]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ; 	[BUGGY] [CE] cannot find symbol attrProts  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { [ATTENTION]  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^304^^^^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return !attrProts . get ( key ) && testValidProtocol ( el , attr , attrProts . get ( key ) ) ; [CE] bad operand type Set<Protocol> for unary operator '!'  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return !attrProts . get ( key ) && testValidProtocol ( el , attr , attrProts . get ( key ) )  ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ; 	[BUGGY] Map<AttributeKey , Set<Protocol>> attrProts = protocols . put ( null , 1 )  ; [CE] method put in interface Map<K , V> cannot be applied to given types ;  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { [ATTENTION] Map<AttributeKey , Set<Protocol>> attrProts = protocols . put ( null , 1 ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^304^^^^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return !attrProts . get ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; [CE] bad operand type Set<Protocol> for unary operator '!'  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return !attrProts . get ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) )  ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return !attrProts . entrySet ( )  || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; [CE] bad operand type Set<Entry<AttributeKey , Set<Protocol>>> for unary operator '!'  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return !attrProts . entrySet ( ) || testValidProtocol ( el , attr , attrProts . get ( key ) )  ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[REPLACE]  if  (  attributes  .  get  (  tag  )    .  contains  (  key  )  )  { 	[BUGGY] if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) {[CE] cannot find symbol prot  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { [ATTENTION] if ( value . toString ( )  . toLowerCase ( )  . startsWith ( prot ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^302^^^^^297^315^
[ADD]  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { [ATTENTION]   } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^303^304^^306^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return  testValidProtocol ( el , attr , attrProts . get ( key ) ) ; [FE] NullPointerException assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return testValidProtocol ( el , attr , attrProts . get ( key ) )  ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] return attrProts . containsKey ( key )  ; [FE]  AssertionFailedError  expected:<<img [alt =   "]  " />> but was:<<img [src =   "unknown = assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  [ATTENTION] return attrProts . containsKey ( key ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^306^^^^^297^315^
[ADD]  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ; 	[BUGGY] Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ; return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; [CE] illegal start of type  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { [ATTENTION] Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag )  ; return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) )  ;   } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } return false ; }  	None^303^304^^306^^297^315^
[REPLACE]  return  !tagName  .  equals  (    ":all  "  )  &&  isSafeAttribute  (    ":all  ",  el,  attr  )  ; 	[BUGGY] return !tagName . toLowerCase ( )  && isSafeAttribute (   ":all  " , el , attr ) ; [CE] bad operand type String for unary operator  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag [ATTENTION] return !tagName . toLowerCase ( ) && isSafeAttribute (   ":all  " , el , attr )  ; } return false ; }  	None^312^^^^^297^315^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  isSafeAttribute [TYPE] boolean [PARAMETER] String tagName Element el Attribute attr [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] AttributeKey key [TYPE] Set attributeSet currentSet protSet tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attribute attr [TYPE] Element el [TYPE] String key protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) { TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey ( ) ) ;  if ( attributes . containsKey ( tag ) ) { if ( attributes . get ( tag ) . contains ( key ) ) { if ( protocols . containsKey ( tag ) ) { Map<AttributeKey , Set<Protocol>> attrProts = protocols . get ( tag ) ;  return !attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { // attribute found , no protocols defined , so OK return true ; } } } else { // no attributes defined for tag , try :all tag return !tagName . equals (   ":all  " ) && isSafeAttribute (   ":all  " , el , attr ) ; } [ATTENTION] return true ; }  	None^314^^^^^297^315^
[REPLACE]  String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ; 	[BUGGY] String value = el . absUrl ( attr . setValue ( protocol )  ) ; [CE] cannot find symbol protocol  [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   [ATTENTION] String value = el . absUrl ( attr . setValue ( protocol )  )  ; attr . setValue ( value ) ;  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }  	None^320^^^^^317^330^
[ADD]  String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ; 	[BUGGY] [CE] cannot find symbol value  [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   [ATTENTION]  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }  	None^320^321^^^^317^330^
[REPLACE]  attr  .  setValue  (  value  )  ; 	[BUGGY] attr . getKey ( )  ; [FE] AssertionFailedError [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; [ATTENTION] attr . getKey ( ) ;  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }  	None^321^^^^^317^330^
[REPLACE]  if  (  value  .  toString  (  )    .  toLowerCase  (  )    .  startsWith  (  prot  )  )  { 	[BUGGY] if ( value . TypedValue ( key )  . toLowerCase ( ) . startsWith ( protocol ) ) {[CE] cannot find symbol key  [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ;  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; [ATTENTION] if ( value . TypedValue ( key ) . toLowerCase ( )  . startsWith ( protocol ) ) { return true ; } } return false ; }  	None^325^^^^^317^330^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] AssertionFailedError [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ;  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { [ATTENTION] return false ; } } return false ; }  	None^326^^^^^317^330^
[REPLACE]  for  (  Protocol  protocol  :  protocols  )  { 	[BUGGY] for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; [CE] variable prot is already defined in method testValidProtocol(Element , Attribute , Set<Protocol>)  [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ;  [ATTENTION] for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }  	None^323^^^^^317^330^
[REPLACE]  String  prot  =  protocol  .  toString  (  )  +    ":  "; 	[BUGGY] String prot = value ( ) +   ":  " ; [CE] cannot find symbol  [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ;  for ( Protocol protocol : protocols ) { [ATTENTION] String prot = value ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }  	None^324^^^^^317^330^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<<img alt =   "  " []/>> but was:<<img alt =   "  " [src =   "  " ]/>> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  testValidProtocol [TYPE] boolean [PARAMETER] Element el Attribute attr Protocol> protocols [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] Attribute attr [TYPE] Element el [TYPE] String key prot protocol tag tagName value [TYPE] Protocol protocol [TYPE] Map attrMap attrProts attributes enforcedAttributes protocols  [CONTEXT]  private boolean testValidProtocol ( Element el , Attribute attr , Set<Protocol> protocols ) {   String value = el . absUrl ( attr . getKey ( ) ) ; attr . setValue ( value ) ;  for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) +   ":  " ; if ( value . toString ( ) . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } [ATTENTION] return true ; }  	None^329^^^^^317^330^
[REPLACE]  Attributes  attrs  =  new  Attributes  (  )  ; 	[BUGGY] AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [CE] cannot find symbol key  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { [ATTENTION] AttributeKey attrKey = AttributeKey . valueOf ( key )  ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^333^^^^^332^342^
[REPLACE]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ; 	[BUGGY] TagName tag = TagName . valueOf ( value ) ; [CE] cannot find symbol value  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; [ATTENTION] TagName tag = TagName . valueOf ( value )  ; if ( enforcedAttributes . containsKey ( tag ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^334^^^^^332^342^
[ADD]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ; 	[BUGGY] [CE] cannot find symbol tag  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; [ATTENTION] if ( enforcedAttributes . containsKey ( tag ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^334^^^^^332^342^
[REPLACE]  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  { 	[BUGGY] if ( enforcedAttributes . containsKey ( tagName ) ) {[FE] AssertionFailedError [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; [ATTENTION] if ( enforcedAttributes . containsKey ( tagName ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^335^^^^^332^342^
[REPLACE]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ; 	[BUGGY] Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . containsKey ( tag ) ; [CE] incompatible types  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { [ATTENTION] Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . containsKey ( tag )  ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^336^^^^^332^342^
[REPLACE]  for  (  Map  .  Entry<AttributeKey,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  { 	[BUGGY] AttributeKey attrKey = AttributeKey . valueOf ( key ) ; [CE] illegal start of type  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; [ATTENTION] AttributeKey attrKey = AttributeKey . valueOf ( key )  ; attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^337^^^^^332^342^
[REPLACE]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ; 	[BUGGY] Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . put ( null , false )  ; [CE] method put in interface Map<K , V> cannot be applied to given types ;  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { [ATTENTION] Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . put ( null , false ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }  	None^336^^^^^332^342^
[REPLACE]  return  attrs; 	[BUGGY] return new AttributeValue ( value ) ; [CE] cannot find symbol value  [METHOD]  getEnforcedAttributes [TYPE] Attributes [PARAMETER] String tagName [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Entry entry [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] boolean false true [TYPE] TagName tag [TYPE] Attributes attrs [TYPE] String key prot protocol tag tagName value [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map<AttributeKey , AttributeValue> keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry<AttributeKey , AttributeValue> entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } [ATTENTION] return new AttributeValue ( value )  ; }  	None^341^^^^^332^342^
[REPLACE]  return  new  TagName  (  value  )  ; 	[BUGGY] return new AttributeKey ( tagName )  ; [CE] cannot find symbol tagName  [METHOD]  valueOf [TYPE] Whitelist$TagName [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  static TagName valueOf ( String value ) { [ATTENTION] returnnew AttributeKey ( tagName ) ; }  	None^352^^^^^351^353^
[REPLACE]  return  new  AttributeKey  (  value  )  ; 	[BUGGY] return new TagName ( value )  ; [CE] incompatible types  [METHOD]  valueOf [TYPE] Whitelist$AttributeKey [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  static AttributeKey valueOf ( String value ) { [ATTENTION] returnnew TagName ( value ) ; }  	None^362^^^^^361^363^
[REPLACE]  return  new  AttributeValue  (  value  )  ; 	[BUGGY] return new AttributeKey ( value ) ; [CE] incompatible types  [METHOD]  valueOf [TYPE] Whitelist$AttributeValue [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  static AttributeValue valueOf ( String value ) { [ATTENTION] return new AttributeKey ( value )  ; }  	None^372^^^^^371^373^
[REPLACE]  return  new  Protocol  (  value  )  ; 	[BUGGY] return new TagName ( value )  ; [CE] incompatible types  [METHOD]  valueOf [TYPE] Whitelist$Protocol [PARAMETER] String value [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  static Protocol valueOf ( String value ) { [ATTENTION] returnnew TagName ( value ) ; }  	None^382^^^^^381^383^
[REPLACE]  final  int  prime  =  31; 	[BUGGY] final int prime = 30 ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] int prime result  [CONTEXT]  public int hashCode ( ) { [ATTENTION] final int prime = 30 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }  	None^396^^^^^395^400^
[REPLACE]  int  result  =  1; 	[BUGGY] int result = 3 ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] int prime result  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; [ATTENTION] int result = 3 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }  	None^397^^^^^395^400^
[REPLACE]  result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value  .  hashCode  (  )  )  ; 	[BUGGY] result  =  0 ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] int prime result  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; int result = 1 ; [ATTENTION] result = 0 ; return result ; }  	None^398^^^^^395^400^
[REPLACE]  return  result; 	[BUGGY] return new Protocol ( value ) ; [CE] incompatible types  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] int prime result  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; [ATTENTION] return new Protocol ( value )  ; }  	None^399^^^^^395^400^
[REPLACE]  if  (  this  ==  obj  )  return  true; 	[BUGGY] if ( this && obj ) return false ; [CE] bad operand types for binary operator '&&'  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { [ATTENTION] if ( this&&obj ) return false ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^404^^^^^403^412^
[REPLACE]  if  (  this  ==  obj  )  return  true; 	[BUGGY] if ( this = = obj ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { [ATTENTION] if ( this = = obj ) return false ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^404^^^^^403^412^
[REPLACE]  if  (  obj  ==  null  )  return  false; 	[BUGGY] if ( obj ! = null ) return false ; [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION] if ( obj ! = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^^^^^403^412^
[ADD]  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj;  if  (  value  ==  null  )  {  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] [CE] illegal start of type  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION]   } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^406^407^408^409^403^412^
[REPLACE]  if  (  obj  ==  null  )  return  false; 	[BUGGY] if ( obj = = null ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION] if ( obj = = null ) return true ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^^^^^403^412^
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false; 	[BUGGY] if ( 0 ( )  = =  obj . getClass ( ) ) return false ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; [ATTENTION] if ( 0 ( )  = = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^406^^^^^403^412^
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false; 	[BUGGY] if ( getClass ( ) ! = obj . getClass ( ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; [ATTENTION] if ( getClass ( ) ! = obj . getClass ( ) ) return true ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^406^^^^^403^412^
[REPLACE]  TypedValue  other  =  (  TypedValue  )  obj; 	[BUGGY] AttributeValue attrVal = AttributeValue . valueOf ( value ) ; [CE] cannot find symbol other  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; [ATTENTION] AttributeValue attrVal = AttributeValue . valueOf ( value )  ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^407^^^^^403^412^
[REPLACE]  if  (  value  ==  null  )  { 	[BUGGY] if (tagName ! = null ) {[CE] cannot find symbol tagName  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; [ATTENTION] if ( tagName ! = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^408^^^^^403^412^
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false; 	[BUGGY]  if ( !value . equals ( other . value ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; [ATTENTION] }if ( !value . equals ( other . value ) ) return true ; return true ; }  	None^410^^^^^403^412^
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false; 	[BUGGY] else if ( !value . equals ( other . value ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; [ATTENTION] } else if ( !value . equals ( other . value ) ) return true ; return true ; }  	None^410^^^^^403^412^
[REPLACE]  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] if ( other . value = = value ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value = = value ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^409^^^^^403^412^
[REPLACE]  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] if ( other . value ! = null ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value ! = null ) return true ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^409^^^^^403^412^
[REPLACE]  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] if ( other . value = = tag ) return false ; [CE] cannot find symbol tag  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value = = tag ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^409^^^^^403^412^
[ADD]  if  (  other  .  value  !=  null  )  return  false;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;  return  true;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION]    	None^409^410^411^412^^403^412^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Object obj [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; [ATTENTION] return false ; }  	None^411^^^^^403^412^
[REPLACE]  return  value; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue  [TYPE] Set attributeSet currentSet protSet protocols tagNames [TYPE] String key prot protocol tag tagName value [TYPE] boolean false true [TYPE] Map attrMap attrProts attributes enforcedAttributes keyVals protocols  [CONTEXT]  public String toString ( ) { [ATTENTION] return false ; }  	None^416^^^^^415^417^
[ADD]  super  (  value  )  ; 	[BUGGY] [CE] constructor TypedValue in class TypedValue cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] TagName  [TYPE] boolean false true [TYPE] String value  [CONTEXT]  TagName ( String value ) { [ATTENTION] }  	None^348^^^^^347^349^
[REPLACE]  Validate  .  notNull  (  value  )  ; 	[BUGGY] value  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] TypedValue  [TYPE] String value [TYPE] boolean false true  [CONTEXT]  TypedValue ( String value ) { [ATTENTION] value ; this . value = value ; }  	None^390^^^^^389^392^
[ADD]  Validate  .  notNull  (  value  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] TypedValue  [TYPE] String value [TYPE] boolean false true  [CONTEXT]  TypedValue ( String value ) { [ATTENTION] this . value = value ; }  	None^390^^^^^389^392^
[REPLACE]  this  .  value  =  value; 	[BUGGY] this . value =  null ; [FE]  The validated string is empty assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] TypedValue  [TYPE] String value [TYPE] boolean false true  [CONTEXT]  TypedValue ( String value ) { Validate . notNull ( value ) ; [ATTENTION] this . value = null ; }  	None^391^^^^^389^392^
[ADD]  this  .  value  =  value; 	[BUGGY] [FE]  The validated string is empty assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  <init> [TYPE] String) [PARAMETER] String value [CLASS] TypedValue  [TYPE] String value [TYPE] boolean false true  [CONTEXT]  TypedValue ( String value ) { Validate . notNull ( value ) ; [ATTENTION] }  	None^391^^^^^389^392^
[REPLACE]  final  int  prime  =  31; 	[BUGGY] final int prime = 31 >>> 1 ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] TypedValue  [TYPE] int prime result [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { [ATTENTION] final int prime = 31 >>> 1 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }  	None^396^^^^^395^400^
[REPLACE]  int  result  =  1; 	[BUGGY] int result = 1L ; [CE] possible loss of precision  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] TypedValue  [TYPE] int prime result [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; [ATTENTION] int result = 1L ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }  	None^397^^^^^395^400^
[REPLACE]  result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value  .  hashCode  (  )  )  ; 	[BUGGY] result = prime * result + ( ( value ! = this ) ? 0 : value . hashCode ( ) ) ; [CE] incomparable types: String and TypedValue  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] TypedValue  [TYPE] int prime result [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; int result = 1 ; [ATTENTION] result = prime * result + ( ( value ! = this ) ? 0 : value . hashCode ( ) )  ; return result ; }  	None^398^^^^^395^400^
[REPLACE]  return  result; 	[BUGGY] return value ; [CE] incompatible types  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] TypedValue  [TYPE] int prime result [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; [ATTENTION] return value ; }  	None^399^^^^^395^400^
[REPLACE]  if  (  this  ==  obj  )  return  true; 	[BUGGY] if ( this && obj ) return false ; [CE] bad operand types for binary operator '&&'  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { [ATTENTION] if ( this&&obj ) return false ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^404^^^^^403^412^
[ADD]  if  (  this  ==  obj  )  return  true;  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj; 	[BUGGY] [CE] cannot find symbol other  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { [ATTENTION]   if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^404^405^406^407^^403^412^
[REPLACE]  if  (  this  ==  obj  )  return  true; 	[BUGGY] if ( this = = obj ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { [ATTENTION] if ( this = = obj ) return false ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^404^^^^^403^412^
[REPLACE]  if  (  obj  ==  null  )  return  false; 	[BUGGY] if ( obj ! = null ) return false ; [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION] if ( obj ! = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^^^^^403^412^
[ADD]  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj;  if  (  value  ==  null  )  {  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] [CE] illegal start of type  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION]   } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^406^407^408^409^403^412^
[REPLACE]  if  (  obj  ==  null  )  return  false; 	[BUGGY] if ( obj = = null ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; [ATTENTION] if ( obj = = null ) return true ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^405^^^^^403^412^
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false; 	[BUGGY] if ( getClass ( )  = =  obj . getClass ( ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; [ATTENTION] if ( getClass ( )  = = obj . getClass ( ) ) return true ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^406^^^^^403^412^
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false; 	[BUGGY] if ( getClass ( ) ! = obj . getClass ( ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; [ATTENTION] if ( getClass ( ) ! = obj . getClass ( ) ) return true ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^406^^^^^403^412^
[REPLACE]  TypedValue  other  =  (  TypedValue  )  obj; 	[BUGGY] int result = 1 ; [CE] cannot find symbol other  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; [ATTENTION] int result = 1 ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^407^^^^^403^412^
[ADD]  TypedValue  other  =  (  TypedValue  )  obj; 	[BUGGY] [CE] cannot find symbol other  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; [ATTENTION] if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^407^^^^^403^412^
[REPLACE]  if  (  value  ==  null  )  { 	[BUGGY] if ( value ! = this ) {[CE] incomparable types: String and TypedValue  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; [ATTENTION] if ( value ! = this ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^408^^^^^403^412^
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false; 	[BUGGY] else if ( !value . equals ( other . value ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; [ATTENTION] } else if ( !value . equals ( other . value ) ) return true ; return true ; }  	None^410^^^^^403^412^
[ADD]  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;  return  true;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; [ATTENTION] }   	None^410^411^412^^^403^412^
[REPLACE]  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] if ( other . value = = null ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value = = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^409^^^^^403^412^
[REPLACE]  if  (  other  .  value  !=  null  )  return  false; 	[BUGGY] if ( other . value ! = null ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value ! = null ) return true ; } else if ( !value . equals ( other . value ) ) return false ; return true ; }  	None^409^^^^^403^412^
[REMOVE]   	[BUGGY] if ( ( getClass ( ) ) ! =  ( obj . getClass ( ) ) )   return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { [ATTENTION] if ( other . value ! = null ) return false ;  if ( ( getClass ( ) ) ! = ( obj . getClass ( ) ) ) return false ; } else if ( !value . equals ( other . value ) ) return false ; return true ;   	None^409^^^^^403^412^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<[<img alt =   "  " />]> but was:<[]> assertEquals(  "<img alt = \  "\  " />  " , cleanHtml)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object obj [CLASS] TypedValue  [TYPE] Object obj [TYPE] String value [TYPE] boolean false true [TYPE] TypedValue other  [CONTEXT]  public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; TypedValue other =  ( TypedValue ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( !value . equals ( other . value ) ) return false ; [ATTENTION] return false ; }  	None^411^^^^^403^412^
[REPLACE]  return  value; 	[BUGGY] if ( obj = = null ) return false ; [CE] cannot find symbol obj  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] TypedValue  [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] if ( obj = = null ) return false ; }  	None^416^^^^^415^417^
[REPLACE]  Elements  elements  =  new  Elements  (  )  ; 	[BUGGY] for ( Element child: element . children ( ) ) accumulateMatches ( eval , elements , child ) ; [CE] cannot find symbol element  [METHOD]  collect [TYPE] Elements [PARAMETER] Evaluator eval Element root [CLASS] Collector  [TYPE] boolean false true [TYPE] Element root [TYPE] Evaluator eval [TYPE] Elements elements  [CONTEXT]  public static Elements collect ( Evaluator eval , Element root ) { [ATTENTION] for ( Element child: element . children ( ) ) accumulateMatches ( eval , elements , child )  ; accumulateMatches ( eval , elements , root ) ; return elements ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Collector.java^22^^^^^21^25^
[ADD]  Elements  elements  =  new  Elements  (  )  ;  accumulateMatches  (  eval,  elements,  root  )  ; 	[BUGGY] [CE] cannot find symbol elements  [METHOD]  collect [TYPE] Elements [PARAMETER] Evaluator eval Element root [CLASS] Collector  [TYPE] boolean false true [TYPE] Element root [TYPE] Evaluator eval [TYPE] Elements elements  [CONTEXT]  public static Elements collect ( Evaluator eval , Element root ) { [ATTENTION]  return elements ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Collector.java^22^23^^^^21^25^
[REPLACE]  accumulateMatches  (  eval,  elements,  root  )  ; 	[BUGGY] accumulateMatches ( eval , elements , child ) ; [CE] cannot find symbol child  [METHOD]  collect [TYPE] Elements [PARAMETER] Evaluator eval Element root [CLASS] Collector  [TYPE] boolean false true [TYPE] Element root [TYPE] Evaluator eval [TYPE] Elements elements  [CONTEXT]  public static Elements collect ( Evaluator eval , Element root ) { Elements elements = new Elements ( ) ; [ATTENTION] accumulateMatches ( eval , elements , child )  ; return elements ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Collector.java^23^^^^^21^25^
[REPLACE]  elements  .  add  (  element  )  ; 	[BUGGY] accumulateMatches ( eval , elements , root ) ; [CE] cannot find symbol root  [METHOD]  accumulateMatches [TYPE] void [PARAMETER] Evaluator eval Element> elements Element element [CLASS] Collector  [TYPE] boolean false true [TYPE] Element child element [TYPE] List elements [TYPE] Evaluator eval  [CONTEXT]  private static void accumulateMatches ( Evaluator eval , List<Element> elements , Element element ) { if ( eval . matches ( element ) ) [ATTENTION] accumulateMatches ( eval , elements , root )  ; for ( Element child: element . children ( ) ) accumulateMatches ( eval , elements , child ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Collector.java^29^^^^^27^32^
[REMOVE]   	[BUGGY] accumulateMatches ( eval , elements , root ) ; [CE] cannot find symbol root  [METHOD]  accumulateMatches [TYPE] void [PARAMETER] Evaluator eval Element> elements Element element [CLASS] Collector  [TYPE] boolean false true [TYPE] Element child element [TYPE] List elements [TYPE] Evaluator eval  [CONTEXT]  private static void accumulateMatches ( Evaluator eval , List<Element> elements , Element element ) { if ( eval . matches ( element ) ) [ATTENTION] elements . add ( element ) ;  accumulateMatches ( eval , elements , root )  ; for ( Element child: element . children ( ) ) accumulateMatches ( eval , elements , child ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Collector.java^29^^^^^27^32^
[REPLACE]  private  final  static  String[]  combinators  =  {  ",  ",    ">  ",    "+  ",    "~  ",    "    "}; 	[BUGGY] private final static String[] combinators ; [CE] variable combinators might not have been initialized  [CONTEXT]    [CLASS] Selector SelectorParseException  	None^48^^^^^^^
[REPLACE]  private  final  LinkedHashSet<Element>  elements; 	[BUGGY] private LinkedHashSet<Element> elements ; [NO-ERROR]  [CONTEXT]    [CLASS] Selector SelectorParseException  	None^50^^^^^^^
[REPLACE]  private  final  TokenQueue  tq; 	[BUGGY] private TokenQueue tq ; [NO-ERROR]  [CONTEXT]    [CLASS] Selector SelectorParseException  	None^52^^^^^^^
[REPLACE]  Validate  .  notNull  (  query  )  ; 	[BUGGY] Validate . notEmpty ( query )  ; [NO-ERROR]  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { [ATTENTION] Validate . notEmpty ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^55^^^^^54^64^
[REPLACE]  query  =  query  .  trim  (  )  ; 	[BUGGY] query =  null . trim ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; [ATTENTION] query = null . trim ( )  ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^56^^^^^54^64^
[ADD]  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ; 	[BUGGY] Validate . notEmpty ( query ) ; [NO-ERROR]  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; [ATTENTION] Validate . notEmpty ( query )  ;  Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^56^57^^^^54^64^
[REPLACE]  Validate  .  notEmpty  (  query  )  ; 	[BUGGY] Validate . isTrue ( query ) ; [CE] no suitable method found for isTrue(String)  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; [ATTENTION] Validate . isTrue ( query )  ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^57^^^^^54^64^
[REPLACE]  Validate  .  notNull  (  root  )  ; 	[BUGGY] Validate . notNull ( roots ) ; [CE] cannot find symbol roots  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; [ATTENTION] Validate . notNull ( roots )  ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^58^^^^^54^64^
[ADD]  Validate  .  notNull  (  root  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; [ATTENTION]  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^58^^^^^54^64^
[REPLACE]  this  .  elements  =  new  LinkedHashSet<Element>  (  )  ; 	[BUGGY] this . elements  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  [ATTENTION] this . elements = null ; this . query = query ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^60^^^^^54^64^
[REPLACE]  this  .  query  =  query; 	[BUGGY] this . query =  null ; [NO-ERROR]  [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; [ATTENTION] this . query = null ; this . root = root ; this . tq = new TokenQueue ( query ) ; }  	None^61^^^^^54^64^
[REPLACE]  this  .  root  =  root; 	[BUGGY] this . root =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; [ATTENTION] this . root = null ; this . tq = new TokenQueue ( query ) ; }  	None^62^^^^^54^64^
[REPLACE]  this  .  tq  =  new  TokenQueue  (  query  )  ; 	[BUGGY] this . tq =  new TokenQueue ( null ) ; [FE]  The validated object is null assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Element) [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Selector ( String query , Element root ) { Validate . notNull ( query ) ; query = query . trim ( ) ; Validate . notEmpty ( query ) ; Validate . notNull ( root ) ;  this . elements = new LinkedHashSet<Element> ( ) ; this . query = query ; this . root = root ; [ATTENTION] this . tq = new TokenQueue ( null )  ; }  	None^63^^^^^54^64^
[REPLACE]  super  (  s  )  ; 	[BUGGY] query = query . trim ( ) ; [CE] non-static variable query cannot be referenced from a static context  [METHOD]  <init> [TYPE] String) [PARAMETER] String s [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query s [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  public SelectorParseException ( String s ) { [ATTENTION] query = query . trim ( )  ; }  	None^333^^^^^332^334^
[ADD]  super  (  s  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  <init> [TYPE] String) [PARAMETER] String s [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query s [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  public SelectorParseException ( String s ) { [ATTENTION] }  	None^333^^^^^332^334^
[REPLACE]  return  new  Selector  (  query,  root  )    .  select  (  )  ; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element root [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String query s [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  public static Elements select ( String query , Element root ) { [ATTENTION] return byTag ( )  ; }  	None^73^^^^^72^74^
[REPLACE]  Validate  .  notEmpty  (  query  )  ; 	[BUGGY] query  ; [CE] not a statement  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { [ATTENTION] query ; Validate . notNull ( roots ) ; LinkedHashSet<Element> elements = new LinkedHashSet<Element> ( ) ;  for ( Element root : roots ) { elements . addAll ( select ( query , root ) ) ; } return new Elements ( elements ) ; }  	None^83^^^^^82^91^
[REPLACE]  Validate  .  notNull  (  roots  )  ; 	[BUGGY] Validate . notEmpty ( this ) ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { Validate . notEmpty ( query ) ; [ATTENTION] Validate . notEmpty ( this )  ; LinkedHashSet<Element> elements = new LinkedHashSet<Element> ( ) ;  for ( Element root : roots ) { elements . addAll ( select ( query , root ) ) ; } return new Elements ( elements ) ; }  	None^84^^^^^82^91^
[REPLACE]  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] non-static method findElements() cannot be referenced from a static context  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; [ATTENTION] Elements candidates = findElements ( )  ;  for ( Element root : roots ) { elements . addAll ( select ( query , root ) ) ; } return new Elements ( elements ) ; }  	None^85^^^^^82^91^
[REPLACE]  for  (  Element  root  :  roots  )  { 	[BUGGY] for ( Element root : roots ) { elements . addAll ( select ( query , root ) ) ; [NO-ERROR]  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; LinkedHashSet<Element> elements = new LinkedHashSet<Element> ( ) ;  [ATTENTION] for ( Element root : roots ) { elements . addAll ( select ( query , root ) )  ; elements . addAll ( select ( query , root ) ) ; } return new Elements ( elements ) ; }  	None^87^^^^^82^91^
[ADD]  for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query,  root  )  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; LinkedHashSet<Element> elements = new LinkedHashSet<Element> ( ) ;  [ATTENTION]  return new Elements ( elements ) ; }  	None^87^88^89^^^82^91^
[REPLACE]  return  new  Elements  (  elements  )  ; 	[BUGGY] return new Elements ( true ) ; [CE] no suitable constructor found for Elements(boolean)  [METHOD]  select [TYPE] Elements [PARAMETER] String query Element> roots [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Iterable roots [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s  [CONTEXT]  public static Elements select ( String query , Iterable<Element> roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; LinkedHashSet<Element> elements = new LinkedHashSet<Element> ( ) ;  for ( Element root : roots ) { elements . addAll ( select ( query , root ) ) ; } [ATTENTION] return new Elements ( true )  ; }  	None^90^^^^^82^91^
[REPLACE]  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] tq . consumeWord ( ) ; [FE]  Could not parse query html assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { [ATTENTION] tq . consumeWord ( )  ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^94^^^^^93^122^
[REPLACE]  if  (  tq  .  matchesAny  (  combinators  )  )  { 	[BUGGY] else if ( tq . matchesAny ( combinators ) ) {[CE] illegal start of type  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  [ATTENTION] } else if ( tq . matchesAny ( combinators ) ) { elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^96^^^^^93^122^
[REPLACE]  addElements  (  findElements  (  )  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { [ATTENTION] Elements candidates = findElements ( )  ; }  	None^100^^^^^96^101^
[ADD]  addElements  (  findElements  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { [ATTENTION] }  	None^100^^^^^96^101^
[REPLACE]  elements  .  add  (  root  )  ; 	[BUGGY] elements . addAll ( root ) ; [CE] method addAll in class AbstractCollection<E> cannot be applied to given types ;  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements [ATTENTION] elements . addAll ( root )  ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^97^^^^^93^122^
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ; 	[BUGGY] combinator ( tq . consume ( ) . equals ( ) ) ; [CE] no suitable method found for equals()  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; [ATTENTION] combinator ( tq . consume ( )  . equals ( ) )  ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^98^^^^^93^122^
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ; 	[BUGGY] combinator ( tq . consumeWord ( ) . toString ( ) ) ; [FE]  Unknown combinator: assertEquals(2 , spans.size())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; [ATTENTION] combinator ( tq . consumeWord ( )  . toString ( ) )  ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^98^^^^^93^122^
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . chompTo ( s )  ) {[CE] cannot find symbol s  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } [ATTENTION] while ( !tq . chompTo ( s )  ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^103^^^^^93^122^
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . chompTo ( ) ) {[CE] method chompTo in class TokenQueue cannot be applied to given types ;  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or [ATTENTION] while ( !tq . chompTo ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^108^^^^^93^122^
[REPLACE]  String  subQuery  =  tq  .  chompTo  (    ",  "  )  ; 	[BUGGY] String subQuery = tq . consumeToAny ( combinators ) ; [FE]  The validated string is empty assertEquals(5 , els.size())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { [ATTENTION] String subQuery = tq . consumeToAny ( combinators )  ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^109^^^^^93^122^
[REPLACE]  if  (  tq  .  matchChomp  (    ",  "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   " .   " ) ) {[CE]  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  [ATTENTION] } else if ( tq . matchChomp (   " .   " ) ) { while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^107^^^^^93^122^
[REPLACE]  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } [ATTENTION] }else { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^112^^^^^93^122^
[ADD]  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (    "    "  )  ; 	[BUGGY]  combinator (   "   " ) ; [CE]  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } [ATTENTION] } combinator (   "   " )  ;   } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^112^113^114^115^^93^122^
[REPLACE]  }  else  if  (  seenWhite  )  { 	[BUGGY] else if ( true ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] } else if ( true ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^114^^^^^93^122^
[ADD]  else  if  (  seenWhite  )  {  combinator  (    "    "  )  ;  }  else  {  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ; 	[BUGGY]  combinator (   "   " ) ; Elements candidates = findElements ( ) ; intersectElements ( filterForSelf ( elements , candidates ) ) ; [CE] illegal start of type  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] } combinator (   "   " )  ; Elements candidates = findElements ( )  ; intersectElements ( filterForSelf ( elements , candidates ) )  ;   } } return new Elements ( elements ) ; }  	None^114^115^116^117^118^93^122^
[REPLACE]  Elements  candidates  =  findElements  (  )  ; 	[BUGGY] Elements output = new Elements ( ) ; [CE] cannot find symbol candidates  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND [ATTENTION] Elements output = new Elements ( )  ; intersectElements ( filterForSelf ( elements , candidates ) ) ; }  	None^117^^^^^114^119^
[REPLACE]  combinator  (    "    "  )  ; 	[BUGGY] Validate . notNull ( root ) ; [FE]  AssertionFailedError  expected:<[Brace yourself for Metro meltdown]> but was:<[]> assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { [ATTENTION] Validate . notNull ( root )  ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^115^^^^^93^122^
[REPLACE]  Elements  candidates  =  findElements  (  )  ; 	[BUGGY] Elements output = new Elements ( ) ; [CE] cannot find symbol candidates  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND [ATTENTION] Elements output = new Elements ( )  ; intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^117^^^^^93^122^
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ; 	[BUGGY] combinator ( tq . consumeWord ( )  . toString ( ) ) ; [FE]  Unknown combinator: assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { [ATTENTION] combinator ( tq . consumeWord ( ) . toString ( ) )  ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^113^^^^^93^122^
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ; 	[BUGGY] combinator ( tq . consume ( ) . equals ( ) ) ; [CE] no suitable method found for equals()  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { [ATTENTION] combinator ( tq . consume ( )  . equals ( ) )  ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^113^^^^^93^122^
[REPLACE]  }  else  if  (  seenWhite  )  { 	[BUGGY]  if ( seenWhite ) {[FE]  The validated string is empty assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] }if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^114^^^^^93^122^
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND [ATTENTION]  }  	None^117^118^^^^114^119^
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . chompTo ( s )  ) {[CE] cannot find symbol s  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or [ATTENTION] while ( !tq . chompTo ( s )  ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^108^^^^^93^122^
[REPLACE]  String  subQuery  =  tq  .  chompTo  (    ",  "  )  ; 	[BUGGY] String subQuery = tq . isEmpty ( )  ; [CE] incompatible types  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { [ATTENTION] String subQuery = tq . isEmpty ( ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^109^^^^^93^122^
[ADD]  String  subQuery  =  tq  .  chompTo  (    ",  "  )  ;  elements  .  addAll  (  select  (  subQuery,  root  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { [ATTENTION]  } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^109^110^^^^93^122^
[REPLACE]  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  { 	[BUGGY]  if ( tq . matchesAny ( combinators ) ) {[FE]  Could not parse query p , div , [title] assertEquals(5 , els.size())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } [ATTENTION] }if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^112^^^^^93^122^
[ADD]  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (    "    "  )  ; 	[BUGGY]  combinator ( tq . consume ( ) . toString ( ) ) ; combinator (   "   " ) ; [CE]  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } [ATTENTION] } combinator ( tq . consume ( )  . toString ( ) )  ; combinator (   "   " )  ;   } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^112^113^114^115^^93^122^
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND [ATTENTION]  } } return new Elements ( elements ) ; }  	None^117^118^^^^93^122^
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ; 	[BUGGY] combinator ( tq . consumeWord ( ) . toString ( ) ) ; [FE]  Unknown combinator: assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { [ATTENTION] combinator ( tq . consumeWord ( )  . toString ( ) )  ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^113^^^^^93^122^
[REPLACE]  }  else  if  (  seenWhite  )  { 	[BUGGY]  if ( true ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] }if ( true ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^114^^^^^93^122^
[REPLACE]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] boolean seenWhite = tq . consumeWord ( ) ; [CE] incompatible types  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  [ATTENTION] boolean seenWhite = tq . consumeWord ( )  ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^105^^^^^93^122^
[ADD]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] [CE] cannot find symbol seenWhite  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  [ATTENTION]  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^105^^^^^93^122^
[REPLACE]  }  else  if  (  seenWhite  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] }else { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^114^^^^^93^122^
[ADD]  else  if  (  seenWhite  )  {  combinator  (    "    "  )  ;  }  else  {  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ; 	[BUGGY]  Elements candidates = findElements ( ) ; intersectElements ( filterForSelf ( elements , candidates ) ) ; [CE] illegal start of type  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; [ATTENTION] } Elements candidates = findElements ( )  ; intersectElements ( filterForSelf ( elements , candidates ) )  ;   } } return new Elements ( elements ) ; }  	None^114^115^116^117^118^93^122^
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ; 	[BUGGY] intersectElements ( filterForSelf ( elements , candidates ) ) ; [CE] cannot find symbol candidates  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND [ATTENTION] intersectElements ( filterForSelf ( elements , candidates ) )  ;  }  	None^117^118^^^^114^119^
[REMOVE]   	[BUGGY] Validate . notNull ( root ) ; [NO-ERROR]  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { [ATTENTION] combinator (   "   " ) ;  Validate . notNull ( root )  ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ;   	None^115^^^^^93^122^
[ADD]  combinator  (    "    "  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[Brace yourself for Metro meltdown]> but was:<[]> assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { [ATTENTION] } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^115^^^^^93^122^
[REPLACE]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] boolean seenWhite = tq . consumeToAny ( combinators )  ; [CE] incompatible types  [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  [ATTENTION] boolean seenWhite = tq . consumeToAny ( combinators ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; }  	None^105^^^^^93^122^
[REPLACE]  return  new  Elements  (  elements  )  ; 	[BUGGY] return byTag ( ) ; [FE]  The validated string is empty assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  select [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false seenWhite true [TYPE] Element root [TYPE] String[] combinators [TYPE] String query s subQuery [TYPE] Elements candidates  [CONTEXT]  private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { // if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; // chomp first element matcher off queue } while ( !tq . isEmpty ( ) ) {  boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp (   " ,   " ) ) { // group or while ( !tq . isEmpty ( ) ) { String subQuery = tq . chompTo (   " ,   " ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator (   "   " ) ; } else { // E . class , E#id , E[attr] etc . AND Elements candidates = findElements ( ) ; // take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } [ATTENTION] return byTag ( )  ; }  	None^121^^^^^93^122^
[REPLACE]  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] tq . consumeWord ( ) ; [FE]  The validated string is empty assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { [ATTENTION] tq . consumeWord ( )  ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^125^^^^^124^141^
[REPLACE]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ; 	[BUGGY] String subQuery = tq . matchesAny ( combinators ) ; [CE] incompatible types  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; [ATTENTION] String subQuery = tq . matchesAny ( combinators )  ;  Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^126^^^^^124^141^
[ADD]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ; 	[BUGGY] [CE] cannot find symbol subQuery  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; [ATTENTION]  Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^126^^^^^124^141^
[REPLACE]  Elements  output; 	[BUGGY] Elements output = new Elements ( ) ; [NO-ERROR]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs [ATTENTION] Elements output = new Elements ( )  ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^128^^^^^124^141^
[REPLACE]  if  (  combinator  .  equals  (    ">  "  )  )  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ; 	[BUGGY] else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; [ATTENTION] else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) )  ;  else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^129^130^^^^124^141^
[REPLACE]  else  if  (  combinator  .  equals  (    "    "  )  )  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ; 	[BUGGY] if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; [FE]  Unknown combinator: > assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; [ATTENTION] if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) )  ;  else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^131^132^^^^124^141^
[ADD]  else  if  (  combinator  .  equals  (    "    "  )  )  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ;  else  if  (  combinator  .  equals  (    "+  "  )  )  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  if  (  combinator  .  equals  (    "~  "  )  ) 	[BUGGY] output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [CE] 'else' without 'if'  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; [ATTENTION] output = filterForDescendants ( elements , select ( subQuery , elements ) )  ; output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) )  ;   output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^131^132^133^134^135^124^141^
[REPLACE]  else  if  (  combinator  .  equals  (    "~  "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; [FE]  Unknown combinator: > assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [ATTENTION] if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;  else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^135^136^^^^124^141^
[REPLACE]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] return ; [NO-ERROR]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else [ATTENTION] return ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^138^^^^^124^141^
[REPLACE]  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] output = filterForDescendants ( elements , select ( subQuery , elements ) ) ;  ; [CE] 'else' without 'if'  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) [ATTENTION] output = filterForDescendants ( elements , select ( subQuery , elements ) )  ;  ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^136^^^^^124^141^
[ADD]  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) [ATTENTION] else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^136^^^^^124^141^
[REPLACE]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] throw new SelectorParseException (  "   ")  ;  ; [NO-ERROR]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else [ATTENTION] throw new SelectorParseException (   "   " ) ;  ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^138^^^^^124^141^
[ADD]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] [CE] variable output might not have been initialized  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else [ATTENTION]  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^138^^^^^124^141^
[REPLACE]  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ;  ; [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) [ATTENTION] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;  ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^134^^^^^124^141^
[ADD]  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) [ATTENTION] else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^134^^^^^124^141^
[REPLACE]  else  if  (  combinator  .  equals  (    "~  "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( s , root ) ) ; [CE] cannot find symbol s  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [ATTENTION] if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( s , root ) )  ;  else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^135^136^^^^124^141^
[REPLACE]  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ; 	[BUGGY] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ;  ; [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) [ATTENTION] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;  ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^132^^^^^124^141^
[REPLACE]  else  if  (  combinator  .  equals  (    "~  "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ; 	[BUGGY] if (subQuery . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; [FE]  Unknown combinator: > assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [ATTENTION] if ( subQuery . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;  else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^135^136^^^^124^141^
[REPLACE]  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ; 	[BUGGY] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ;  ; [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) [ATTENTION] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;  ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^130^^^^^124^141^
[ADD]  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ; 	[BUGGY] [CE]  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) [ATTENTION] else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  elements . clear ( ) ; elements . addAll ( output ) ; }  	None^130^^^^^124^141^
[ADD]  else  if  (  combinator  .  equals  (    "~  "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [ATTENTION] output = filterForGeneralSiblings ( elements , select ( subQuery , root ) )  ;   elements . clear ( ) ; elements . addAll ( output ) ; }  	None^135^136^137^138^^124^141^
[ADD]  else  if  (  combinator  .  equals  (    "~  "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] [CE] variable output might not have been initialized  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; [ATTENTION]   elements . clear ( ) ; elements . addAll ( output ) ; }  	None^135^136^137^138^^124^141^
[REPLACE]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ; 	[BUGGY] elements . addAll ( )  ; elements . addAll ( output ) ; [CE] method addAll in class AbstractCollection<E> cannot be applied to given types ;  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  [ATTENTION] elements . addAll ( ) ; elements . addAll ( output )  ; }  	None^140^^^^^124^141^
[ADD]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<[http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA]> but was:<[]> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  [ATTENTION] }  	None^140^^^^^124^141^
[REPLACE]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ; 	[BUGGY] elements . clear ( ) ; elements . add ( output ) ; [CE] no suitable method found for add(Elements)  [METHOD]  combinator [TYPE] void [PARAMETER] String combinator [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] Elements output  [CONTEXT]  private void combinator ( String combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; // support multi > childs Elements output ; if ( combinator . equals (   ">  " ) ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "   " ) ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( combinator . equals (   "+  " ) ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( combinator . equals (   "~  " ) ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException (   "Unknown combinator:   " + combinator ) ;  [ATTENTION] elements . clear ( )  ; elements . add ( output )  ; }  	None^140^^^^^124^141^
[REPLACE]  if  (  tq  .  matchChomp  (    "#  "  )  )  { 	[BUGGY] if ( tq . matchChomp (   " ,   " ) ) {[FE]  Could not parse query #foo assertEquals(1 , els.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { [ATTENTION] if ( tq . matchChomp (   " ,   " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^144^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "  .    "  )  )  { 	[BUGGY] else if ( tq . matchesWord ( ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; [ATTENTION] } else if ( tq . matchesWord ( ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^146^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchesWord  (  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; [ATTENTION] }else { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^148^^^^^143^163^
[ADD]  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (    "[  "  )  )  {  return  byAttribute  (  )  ; 	[BUGGY]  return byAttribute ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; [ATTENTION] } return byAttribute ( )  ;   } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^148^149^150^151^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "[  "  )  )  { 	[BUGGY] else if ( tq . matchesWord ( ) ) {[FE]  Could not parse query a[href = t/2322m2] assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; [ATTENTION] } else if ( tq . matchesWord ( ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^150^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    "[  "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  {  return  allElements  (  )  ; 	[BUGGY]  return allElements ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; [ATTENTION] } return allElements ( )  ;   } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^150^151^152^153^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   "*  " ) ) {[NO-ERROR]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; [ATTENTION] }if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^152^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":lt  (    "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   " .   " ) ) {[FE]  Could not parse query p:gt(0 assertEquals(1 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] } else if ( tq . matchChomp (   " .   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^154^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] }else { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  {  return  indexEquals  (  )  ; 	[BUGGY]  return indexEquals ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] } return indexEquals ( )  ;   } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^157^158^159^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] }else { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[REPLACE]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled [ATTENTION] return ; } }  	None^161^^^^^143^163^
[REPLACE]  return  indexEquals  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  Could not parse query p:eq(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { [ATTENTION] return byTag ( )  ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^159^^^^^143^163^
[REPLACE]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] throw new IllegalStateException (  "   ")  ;  ; [CE] unreachable statement  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled [ATTENTION] throw new IllegalStateException (   "   " ) ;  ; } }  	None^161^^^^^143^163^
[REPLACE]  return  indexGreaterThan  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  Could not parse query p:gt(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^157^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   ":eq (   " ) ) {[FE]  Could not parse query p:eq(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] }if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[REMOVE]   	[BUGGY] if ( tq . matchChomp (   "* =   " ) )   return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; else   throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) ) ; [CE] cannot find symbol key  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] } else if ( tq . matchChomp (   ":eq (   " ) ) { if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ; else throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) )  ; return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; }  	None^158^^^^^143^163^
[REPLACE]  return  indexLessThan  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  Could not parse query p:gt(0 assertEquals(1 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^155^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   " .   " ) ) {[FE]  Could not parse query p:gt(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] } else if ( tq . matchChomp (   " .   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  {  return  indexEquals  (  )  ;  }  else  {  throw  new  SelectorParseException  (  "    ")  ;  } 	[BUGGY]  return indexEquals ( ) ; [FE]  Index must be numeric assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] } return indexEquals ( )  ;   }  	None^158^159^160^161^162^143^163^
[ADD]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] [CE] missing return statement  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled [ATTENTION] } }  	None^161^^^^^143^163^
[REPLACE]  return  allElements  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  The validated string is empty assertEquals(  "The board’s next fear: the female quota  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^153^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":lt  (    "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   ":lt (   " ) ) {[FE]  Could not parse query p:gt(0 assertEquals(1 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] }if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^154^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    ":lt  (    "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  {  return  indexGreaterThan  (  )  ; 	[BUGGY]  return indexLessThan ( ) ; return indexGreaterThan ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] } return indexLessThan ( )  ; return indexGreaterThan ( )  ;   } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^154^155^156^157^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY]  if ( tq . matchesAny (   ":eq (   " ) ) {[FE]  Could not parse query p:eq(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] }if ( tq . matchesAny (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  {  return  indexEquals  (  )  ; 	[BUGGY]  return indexGreaterThan ( ) ; return indexEquals ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] } return indexGreaterThan ( )  ; return indexEquals ( )  ;   } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^157^158^159^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  {  return  indexEquals  (  )  ;  }  else  {  throw  new  SelectorParseException  (  "    ")  ;  } 	[BUGGY] [CE] missing return statement  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] }   }  	None^158^159^160^161^162^143^163^
[REPLACE]  return  byAttribute  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  Could not parse query a[href = t/2322m2] assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^151^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; [ATTENTION] }else { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^152^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY] else if ( tq . matchesAny (   ":eq (   " ) ) {[FE]  Could not parse query p:eq(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] } else if ( tq . matchesAny (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   ":gt (   " ) ) {[FE]  Could not parse query p:gt(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] }if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":lt  (    "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] }else { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^154^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   " .   " ) ) {[FE]  Could not parse query p:eq(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] } else if ( tq . matchChomp (   " .   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[REPLACE]  return  byTag  (  )  ; 	[BUGGY] return byId ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { [ATTENTION] return byId ( )  ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^149^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "[  "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   "[  " ) ) {[NO-ERROR]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; [ATTENTION] }if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^150^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  { 	[BUGGY]  if ( tq . matchesAny (   "*  " ) ) {[FE] AssertionFailedError [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; [ATTENTION] }if ( tq . matchesAny (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^152^^^^^143^163^
[REMOVE]   	[BUGGY] if ( tq . matchChomp (   "* =   " ) )   return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; else   throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) ) ; [CE] cannot find symbol key  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] } else if ( tq . matchChomp (   ":gt (   " ) ) { if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ; else throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) )  ; return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; }  	None^156^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":eq  (    "  )  )  { 	[BUGGY]  if ( tq . matchesWord ( )  {[CE] ')' expected  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; [ATTENTION] }if ( tq . matchesWord ( ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^158^^^^^143^163^
[REPLACE]  return  byClass  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^147^^^^^143^163^
[ADD]  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (    "[  "  )  )  {  return  byAttribute  (  )  ; 	[BUGGY]  return byTag ( ) ; return byAttribute ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; [ATTENTION] } return byTag ( )  ; return byAttribute ( )  ;   } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^148^149^150^151^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY]  if ( tq . matchesAny (   ":gt (   " ) ) {[FE]  Could not parse query p:gt(0) assertEquals(2 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] }if ( tq . matchesAny (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "[  "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; [ATTENTION] }else { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^150^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  { 	[BUGGY] else if ( tq . matchesWord ( ) ) {[FE]  Could not parse query * assertEquals(  "The board’s next fear: the female quota  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; [ATTENTION] } else if ( tq . matchesWord ( ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^152^^^^^143^163^
[REPLACE]  return  byId  (  )  ; 	[BUGGY] return byTag ( ) ; [FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , els.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { [ATTENTION] return byTag ( )  ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^145^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "  .    "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   " .   " ) ) {[NO-ERROR]  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; [ATTENTION] }if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^146^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  { 	[BUGGY]  if ( tq . matchesWord ( )  ) {[FE]  Could not parse query * assertEquals(  "The board’s next fear: the female quota  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; [ATTENTION] }if ( tq . matchesWord ( )  ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^152^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY] else if ( tq . matchesWord ( )  {[CE] ')' expected  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] } else if ( tq . matchesWord ( ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[REMOVE]   	[BUGGY] if ( tq . matchChomp (   "* =   " ) )   return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; else   throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) ) ; [CE] cannot find symbol key  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] } else if ( tq . matchChomp (   ":lt (   " ) ) { if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ; else throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) )  ; return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; }  	None^154^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":gt  (    "  )  )  { 	[BUGGY]  if ( tq . matchesWord ( )  {[CE] ')' expected  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; [ATTENTION] }if ( tq . matchesWord ( ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^156^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchesWord  (  )  )  { 	[BUGGY] else if ( tq . matchChomp (   " .   " ) ) {[FE]  Could not parse query html assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; [ATTENTION] } else if ( tq . matchChomp (   " .   " ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^148^^^^^143^163^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (    ":lt  (    "  )  )  { 	[BUGGY]  if ( tq . matchesAny (   ":lt (   " ) ) {[FE]  Could not parse query p:gt(0 assertEquals(1 , ps.size())   [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; } else if ( tq . matchChomp (   "[  " ) ) { return byAttribute ( ) ; } else if ( tq . matchChomp (   "*  " ) ) { return allElements ( ) ; [ATTENTION] }if ( tq . matchesAny (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^154^^^^^143^163^
[ADD]  else  if  (  tq  .  matchChomp  (    "[  "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (    "*  "  )  )  {  return  allElements  (  )  ; 	[BUGGY]  return byAttribute ( ) ; return allElements ( ) ; [CE] illegal start of type  [METHOD]  findElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String combinator query s subQuery [TYPE] boolean false true [TYPE] Element root  [CONTEXT]  private Elements findElements ( ) { if ( tq . matchChomp (   "#  " ) ) { return byId ( ) ; } else if ( tq . matchChomp (   " .   " ) ) { return byClass ( ) ; } else if ( tq . matchesWord ( ) ) { return byTag ( ) ; [ATTENTION] } return byAttribute ( )  ; return allElements ( )  ;   } else if ( tq . matchChomp (   ":lt (   " ) ) { return indexLessThan ( ) ; } else if ( tq . matchChomp (   ":gt (   " ) ) { return indexGreaterThan ( ) ; } else if ( tq . matchChomp (   ":eq (   " ) ) { return indexEquals ( ) ; } else { // unhandled throw new SelectorParseException (   "Could not parse query   " + query ) ; } }  	None^150^151^152^153^^143^163^
[REPLACE]  elements  .  addAll  (  add  )  ; 	[BUGGY] elements . addAll ( true ) ; [CE] method addAll in class AbstractCollection<E> cannot be applied to given types ;  [METHOD]  addElements [TYPE] void [PARAMETER] Element> add [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] Collection add [TYPE] String[] combinators [TYPE] String combinator query s subQuery  [CONTEXT]  private void addElements ( Collection<Element> add ) { [ATTENTION] elements . addAll ( true )  ; }  	None^166^^^^^165^167^
[REPLACE]  elements  .  retainAll  (  intersect  )  ; 	[BUGGY] elements . addAll ( )  ; [CE] method addAll in class AbstractCollection<E> cannot be applied to given types ;  [METHOD]  intersectElements [TYPE] void [PARAMETER] Element> intersect [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element root [TYPE] Collection intersect [TYPE] String[] combinators [TYPE] String combinator query s subQuery  [CONTEXT]  private void intersectElements ( Collection<Element> intersect ) { [ATTENTION] elements . addAll ( ) ; }  	None^170^^^^^169^171^
[REPLACE]  String  id  =  tq  .  consumeCssIdentifier  (  )  ; 	[BUGGY] String id = tq . consumeWhitespace ( )  ; [CE] incompatible types  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { [ATTENTION] String id = tq . consumeWhitespace ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) byId . add ( found ) ; return byId ; }  	None^174^^^^^173^182^
[REPLACE]  Validate  .  notEmpty  (  id  )  ; 	[BUGGY] Validate . notEmpty ( combinator ) ; [CE] cannot find symbol combinator  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; [ATTENTION] Validate . notEmpty ( combinator )  ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) byId . add ( found ) ; return byId ; }  	None^175^^^^^173^182^
[REPLACE]  Element  found  =  root  .  getElementById  (  id  )  ; 	[BUGGY] Element found = root . getElementById ( combinator ) ; [CE] cannot find symbol combinator  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  [ATTENTION] Element found = root . getElementById ( combinator )  ; Elements byId = new Elements ( ) ; if ( found ! = null ) byId . add ( found ) ; return byId ; }  	None^177^^^^^173^182^
[REPLACE]  Elements  byId  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] cannot find symbol byId  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; [ATTENTION] Elements candidates = findElements ( )  ; if ( found ! = null ) byId . add ( found ) ; return byId ; }  	None^178^^^^^173^182^
[REPLACE]  if  (  found  !=  null  )  byId  .  add  (  found  )  ; 	[BUGGY] if ( found = = null ) byId . add ( found ) ; [FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , els.size())   [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; [ATTENTION] if ( found = = null ) byId . add ( found )  ;  return byId ; }  	None^179^180^^^^173^182^
[REPLACE]  byId  .  add  (  found  )  ; 	[BUGGY] byId . addAll ( )  ; [CE] no suitable method found for addAll()  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) [ATTENTION] byId . addAll ( ) ; return byId ; }  	None^180^^^^^173^182^
[REMOVE]   	[BUGGY] Validate . notNull ( root ) ; [NO-ERROR]  [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) [ATTENTION] byId . add ( found ) ;  Validate . notNull ( root )  ; return byId ;   	None^180^^^^^173^182^
[REPLACE]  return  byId; 	[BUGGY] return byTag ( ) ; [FE]  The validated string is empty assertEquals(1 , els.size())   [METHOD]  byId [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String combinator id query s subQuery [TYPE] Elements byId  [CONTEXT]  private Elements byId ( ) { String id = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( id ) ;  Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) byId . add ( found ) ; [ATTENTION] return byTag ( )  ; }  	None^181^^^^^173^182^
[REPLACE]  String  className  =  tq  .  consumeCssIdentifier  (  )  ; 	[BUGGY] String className = tq . consumeWhitespace ( )  ; [CE] incompatible types  [METHOD]  byClass [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byClass ( ) { [ATTENTION] String className = tq . consumeWhitespace ( ) ; Validate . notEmpty ( className ) ;  return root . getElementsByClass ( className ) ; }  	None^185^^^^^184^189^
[REPLACE]  Validate  .  notEmpty  (  className  )  ; 	[BUGGY] Validate . notEmpty ( s ) ; [CE] cannot find symbol s  [METHOD]  byClass [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byClass ( ) { String className = tq . consumeCssIdentifier ( ) ; [ATTENTION] Validate . notEmpty ( s )  ;  return root . getElementsByClass ( className ) ; }  	None^186^^^^^184^189^
[ADD]  Validate  .  notEmpty  (  className  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  byClass [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byClass ( ) { String className = tq . consumeCssIdentifier ( ) ; [ATTENTION]  return root . getElementsByClass ( className ) ; }  	None^186^^^^^184^189^
[REPLACE]  return  root  .  getElementsByClass  (  className  )  ; 	[BUGGY] return root . getElementsByTag ( s )  ; [CE] cannot find symbol s  [METHOD]  byClass [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byClass ( ) { String className = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( className ) ;  [ATTENTION] return root . getElementsByTag ( s ) ; }  	None^188^^^^^184^189^
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ; 	[BUGGY] String tagName = tq . consume ( ) ; [CE] incompatible types  [METHOD]  byTag [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byTag ( ) { [ATTENTION] String tagName = tq . consume ( )  ; Validate . notEmpty ( tagName ) ;  return root . getElementsByTag ( tagName ) ; }  	None^192^^^^^191^196^
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ; 	[BUGGY] Validate . isTrue ( combinator ) ; [CE] cannot find symbol combinator  [METHOD]  byTag [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byTag ( ) { String tagName = tq . consumeWord ( ) ; [ATTENTION] Validate . isTrue ( combinator )  ;  return root . getElementsByTag ( tagName ) ; }  	None^193^^^^^191^196^
[REPLACE]  return  root  .  getElementsByTag  (  tagName  )  ; 	[BUGGY] return root . getElementsByClass ( className ) ; [CE] cannot find symbol className  [METHOD]  byTag [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byTag ( ) { String tagName = tq . consumeWord ( ) ; Validate . notEmpty ( tagName ) ;  [ATTENTION] return root . getElementsByClass ( className )  ; }  	None^195^^^^^191^196^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notEmpty ( subQuery ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) [ATTENTION] Validate . notEmpty ( subQuery )  ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^200^^^^^198^223^
[REPLACE]  if  (  tq  .  matchChomp  (    "]  "  )  )  { 	[BUGGY] if ( tq . matchChomp (   " ,   " ) ) {[FE]  Could not parse attribute query p[title] assertEquals(2 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  [ATTENTION] if ( tq . matchChomp (   " ,   " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^202^^^^^198^223^
[ADD]  if  (  tq  .  matchChomp  (    "]  "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (    "=  "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttribute ( key ) ; return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ; [CE]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  [ATTENTION] return root . getElementsByAttribute ( key )  ; return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) )  ;    else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^202^203^204^205^206^198^223^
[REPLACE]  if  (  tq  .  matchChomp  (    "=  "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ; [CE]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { [ATTENTION] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^205^206^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "!=  "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^208^209^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchesAny (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [FE] NullPointerException assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchesAny (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] throw new IllegalStateException (  "   ")  ;  ; [CE] unreachable statement  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else [ATTENTION] throw new IllegalStateException (   "   " ) ;  ; } }  	None^221^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( subQuery , tq . matchChomp (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( subQuery , tq . matchChomp (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( key , tq . matchChomp (   "]  " ) ) ; [CE] method getElementsByAttributeValueContaining in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( key , tq . matchChomp (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else [ATTENTION] return ; } }  	None^221^^^^^198^223^
[ADD]  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else [ATTENTION] } }  	None^221^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueEnding ( key , tq . isEmpty ( )  ) ; [CE] method getElementsByAttributeValueEnding in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueEnding ( key , tq . isEmpty ( )  )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ; [FE] NullPointerException assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueEnding ( key , tq . matchChomp (   "]  " ) ) ; [CE] method getElementsByAttributeValueEnding in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueEnding ( key , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( tagName )  ; [CE] cannot find symbol tagName  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( tagName ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^212^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [NO-ERROR]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[ADD]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ;  else  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] [CE] missing return statement  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION]   } }  	None^217^218^^220^221^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [NO-ERROR]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^212^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ; [FE]  AssertionFailedError  expected:<2> but was:<0> assertEquals(4 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueNot ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) [ATTENTION] return root . getElementsByAttributeValueNot ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^209^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ; [FE]  Could not parse attribute query [title$ = am] assertEquals(4 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^^^198^223^
[ADD]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ;  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] [FE]  Could not parse attribute query a[href* = naughty-corners-are-a-bad-idea] assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION]    else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^217^218^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( key , tq . isEmpty ( )  ) ; [CE] method getElementsByAttributeValueContaining in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( key , tq . isEmpty ( )  )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[ADD]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ;  else  throw  new  SelectorParseException  (  "    ")  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [FE] NullPointerException assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;   } }  	None^217^218^^220^221^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( key , tq . matchChomp (   "]  " ) ) ; [CE] method getElementsByAttributeValueStarting in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( key , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^212^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueNot ( key )  ; [CE] method getElementsByAttributeValueNot in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) [ATTENTION] return root . getElementsByAttributeValueNot ( key ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^206^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "!=  "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchesAny (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ; [FE]  AssertionFailedError  expected:<5> but was:<6> assertEquals(4 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchesAny (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^208^209^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ; [NO-ERROR]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( combinator )  ; [CE] cannot find symbol combinator  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( combinator ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchesWord ( )  ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchesWord ( )  ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ; [NO-ERROR]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^206^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueNot ( key , tq . matchChomp (   "]  " ) ) ; [CE] method getElementsByAttributeValueNot in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) [ATTENTION] return root . getElementsByAttributeValueNot ( key , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^209^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( id )  ; [CE] cannot find symbol id  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( id ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttribute  (  key  )  ; 	[BUGGY] return root . getElementsByAttributeValue ( key ) ; [CE] method getElementsByAttributeValue in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { [ATTENTION] return root . getElementsByAttributeValue ( key )  ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^203^^^^^198^223^
[ADD]  if  (  tq  .  matchChomp  (    "=  "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ;  else  if  (  tq  .  matchChomp  (    "!=  "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ; return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ; [CE]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { [ATTENTION] return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) )  ; return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) )  ;    else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^205^206^^208^209^198^223^
[REMOVE]   	[BUGGY] if ( tq . matchChomp (   "* =   " ) )   return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; else   throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) ) ; [CE]  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchChomp (   "^ =   " ) )  if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ; else throw new SelectorParseException ( (   "Could not parse attribute query   " + ( query ) ) )  ; return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; }  	None^211^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] if ( tq . matchesAny (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ; [FE]  AssertionFailedError  expected:<2> but was:<0> assertEquals(4 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] if ( tq . matchesAny (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( subQuery , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( className )  ; [CE] cannot find symbol className  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( className ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[ADD]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ;  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ; return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [CE] 'else' without 'if'  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) )  ; return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;    else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^217^218^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( subQuery )  ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( subQuery ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ; [FE]  Could not parse attribute query a[href* = naughty-corners-are-a-bad-idea] assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "*=  "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchesWord ( )  ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ; [FE]  Could not parse attribute query a[href* = naughty-corners-are-a-bad-idea] assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchesWord ( )  ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^217^218^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( tagName )  ; [CE] cannot find symbol tagName  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( tagName ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( s )  ; [CE] cannot find symbol s  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( s ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValue ( query )  ; [CE] method getElementsByAttributeValue in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) [ATTENTION] return root . getElementsByAttributeValue ( query ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^209^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( subQuery , tq . matchChomp (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( subQuery , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^212^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValue ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) [ATTENTION] return root . getElementsByAttributeValue ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^206^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( query )  ; [CE] method getElementsByAttributeValueStarting in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( query ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueEnding ( subQuery , tq . matchChomp (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) [ATTENTION] return root . getElementsByAttributeValueEnding ( subQuery , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^215^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueNot ( subQuery , tq . matchChomp (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) [ATTENTION] return root . getElementsByAttributeValueNot ( subQuery , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^209^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( subQuery )  ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( subQuery ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueContaining ( subQuery , tq . isEmpty ( )  ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) [ATTENTION] return root . getElementsByAttributeValueContaining ( subQuery , tq . isEmpty ( )  )  ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^218^^^^^198^223^
[REPLACE]  else  if  (  tq  .  matchChomp  (    "$=  "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] else if ( tq . matchesAny (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) ) ; [CE] cannot find symbol subQuery  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  [ATTENTION] else if ( tq . matchesAny (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( subQuery , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^214^215^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValue ( key , tq . matchChomp (   "]  " ) ) ; [CE] method getElementsByAttributeValue in class Element cannot be applied to given types ;  [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) [ATTENTION] return root . getElementsByAttributeValue ( key , tq . matchChomp (   "]  " ) )  ;  else if ( tq . matchChomp (   "! =   " ) ) return root . getElementsByAttributeValueNot ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^206^^^^^198^223^
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (    "]  "  )  )  ; 	[BUGGY] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ; [FE]  AssertionFailedError  expected:<5> but was:<1> assertEquals(4 , withTitle.size())   [METHOD]  byAttribute [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements byAttribute ( ) { String key = tq . consumeToAny (   " =   " ,   "! =   " ,   "^ =   " ,   "$ =   " ,   "* =   " ,   "]  " ) ; // eq , not , start , end , contain ,  ( no val ) Validate . notEmpty ( key ) ;  if ( tq . matchChomp (   "]  " ) ) { return root . getElementsByAttribute ( key ) ; } else { if ( tq . matchChomp (   " =   " ) ) return root . getElementsByAttributeValue ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "! =   " ) ) [ATTENTION] return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) )  ;  else if ( tq . matchChomp (   "^ =   " ) ) return root . getElementsByAttributeValueStarting ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "$ =   " ) ) return root . getElementsByAttributeValueEnding ( key , tq . chompTo (   "]  " ) ) ;  else if ( tq . matchChomp (   "* =   " ) ) return root . getElementsByAttributeValueContaining ( key , tq . chompTo (   "]  " ) ) ;  else throw new SelectorParseException (   "Could not parse attribute query   " + query ) ; } }  	None^209^^^^^198^223^
[REPLACE]  return  root  .  getAllElements  (  )  ; 	[BUGGY] return root . getElementById ( subQuery )  ; [CE] cannot find symbol subQuery  [METHOD]  allElements [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements allElements ( ) { [ATTENTION] return root . getElementById ( subQuery ) ; }  	None^226^^^^^225^227^
[REPLACE]  return  root  .  getElementsByIndexLessThan  (  consumeIndex  (  )  )  ; 	[BUGGY] return root . getElementsByIndexGreaterThan ( consumeIndex ( ) ) ; [FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , ps.size())   [METHOD]  indexLessThan [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements indexLessThan ( ) { [ATTENTION] return root . getElementsByIndexGreaterThan ( consumeIndex ( ) )  ; }  	None^231^^^^^230^232^
[REPLACE]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )  ; 	[BUGGY] return root . getElementsByIndexEquals ( consumeIndex ( ) ) ; [FE]  AssertionFailedError  expected:<[Two]> but was:<[One]> assertEquals(2 , ps.size())   [METHOD]  indexGreaterThan [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements indexGreaterThan ( ) { [ATTENTION] return root . getElementsByIndexEquals ( consumeIndex ( ) )  ; }  	None^235^^^^^234^236^
[REPLACE]  return  root  .  getElementsByIndexEquals  (  consumeIndex  (  )  )  ; 	[BUGGY] return root . getElementsByIndexGreaterThan ( consumeIndex ( ) ) ; [FE]  AssertionFailedError  expected:<[One]> but was:<[Two]> assertEquals(2 , ps.size())   [METHOD]  indexEquals [TYPE] Elements [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] String[] combinators [TYPE] String className combinator id key query s subQuery tagName [TYPE] boolean false true [TYPE] Element found root  [CONTEXT]  private Elements indexEquals ( ) { [ATTENTION] return root . getElementsByIndexGreaterThan ( consumeIndex ( ) )  ; }  	None^239^^^^^238^240^
[REPLACE]  String  indexS  =  tq  .  chompTo  (    "  )    "  )    .  trim  (  )  ; 	[BUGGY] String indexS = tq . matchChomp (   " )   " ) . trim ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { [ATTENTION] String indexS = tq . matchChomp (   " )   " )  . trim ( )  ; Validate . isTrue ( StringUtils . isNumeric ( indexS ) ,   "Index must be numeric  " ) ; int index = Integer . parseInt ( indexS ) ;  return index ; }  	None^243^^^^^242^248^
[ADD]  String  indexS  =  tq  .  chompTo  (    "  )    "  )    .  trim  (  )  ;  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,    "Index  must  be  numeric  "  )  ; 	[BUGGY] [CE] cannot find symbol indexS  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { [ATTENTION]  int index = Integer . parseInt ( indexS ) ;  return index ; }  	None^243^244^^^^242^248^
[REPLACE]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,    "Index  must  be  numeric  "  )  ; 	[BUGGY] Validate . isTrue ( StringUtils . isNumeric ( subQuery ) ,   "Index must be numeric  " ) ; [CE] cannot find symbol subQuery  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { String indexS = tq . chompTo (   " )   " ) . trim ( ) ; [ATTENTION] Validate . isTrue ( StringUtils . isNumeric ( subQuery )  ,   "Index must be numeric  " )  ; int index = Integer . parseInt ( indexS ) ;  return index ; }  	None^244^^^^^242^248^
[ADD]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,    "Index  must  be  numeric  "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ; 	[BUGGY] [CE] cannot find symbol index  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { String indexS = tq . chompTo (   " )   " ) . trim ( ) ; [ATTENTION]  return index ; }  	None^244^245^^^^242^248^
[ADD]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,    "Index  must  be  numeric  "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ; 	[BUGGY] int index = Integer . parseInt ( indexS ) ; [NO-ERROR]  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { String indexS = tq . chompTo (   " )   " ) . trim ( ) ; [ATTENTION] int index = Integer . parseInt ( indexS )  ;  return index ; }  	None^244^245^^^^242^248^
[REPLACE]  int  index  =  Integer  .  parseInt  (  indexS  )  ; 	[BUGGY] int index = Integer . parseInt ( subQuery ) ; [CE] cannot find symbol subQuery  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { String indexS = tq . chompTo (   " )   " ) . trim ( ) ; Validate . isTrue ( StringUtils . isNumeric ( indexS ) ,   "Index must be numeric  " ) ; [ATTENTION] int index = Integer . parseInt ( subQuery )  ;  return index ; }  	None^245^^^^^242^248^
[REPLACE]  return  index; 	[BUGGY] return byTag ( ) ; [CE] incompatible types  [METHOD]  consumeIndex [TYPE] int [PARAMETER] [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element found root [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] int index  [CONTEXT]  private int consumeIndex ( ) { String indexS = tq . chompTo (   " )   " ) . trim ( ) ; Validate . isTrue ( StringUtils . isNumeric ( indexS ) ,   "Index must be numeric  " ) ; int index = Integer . parseInt ( indexS ) ;  [ATTENTION] return byTag ( )  ; }  	None^247^^^^^242^248^
[REPLACE]  Elements  children  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] variable candidates is already defined in method filterForChildren(Collection<Element> , Collection<Element>)  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { [ATTENTION] Elements candidates = findElements ( )  ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . parent ( ) ! = null && c . parent ( ) . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^252^^^^^251^262^
[REPLACE]  if  (  c  .  parent  (  )  !=  null  &&  c  .  parent  (  )    .  equals  (  p  )  )  { 	[BUGGY] if ( c . getAllElements ( )  = = this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { [ATTENTION] if ( c . getAllElements ( ) = = this ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^255^^^^^251^262^
[REPLACE]  children  .  add  (  c  )  ; 	[BUGGY] children . addAll ( )  ; [CE] no suitable method found for addAll()  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . parent ( ) ! = null && c . parent ( ) . equals ( p ) ) { [ATTENTION] children . addAll ( ) ; continue CHILD ; } } } return children ; }  	None^256^^^^^251^262^
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [NO-ERROR]  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . parent ( ) ! = null && c . parent ( ) . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^253^^^^^251^262^
[REPLACE]  for  (  Element  p  :  parents  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] label CHILD already in use  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; if ( c . parent ( ) ! = null && c . parent ( ) . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^254^^^^^251^262^
[REPLACE]  return  children; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  filterForChildren [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForChildren ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . parent ( ) ! = null && c . parent ( ) . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } [ATTENTION] return byTag ( )  ; }  	None^261^^^^^251^262^
[REPLACE]  Elements  children  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] variable candidates is already defined in method filterForDescendants(Collection<Element> , Collection<Element>)  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { [ATTENTION] Elements candidates = findElements ( )  ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^267^^^^^266^280^
[ADD]  Elements  children  =  new  Elements  (  )  ; 	[BUGGY] [CE] cannot find symbol children  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^267^^^^^266^280^
[REPLACE]  if  (  c  .  equals  (  p  )  )  { 	[BUGGY] if ( c . getElementsByIndexEquals ( p ) ) {[CE] method getElementsByIndexEquals in class Element cannot be applied to given types ;  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { [ATTENTION] if ( c . getElementsByIndexEquals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^271^^^^^266^280^
[REPLACE]  found  =  true; 	[BUGGY] found = false ; [NO-ERROR]  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { [ATTENTION] found = false ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^272^^^^^266^280^
[REPLACE]  if  (  !found  )  children  .  add  (  c  )  ; 	[BUGGY] if ( found ) children . add ( c ) ; [FE]  AssertionFailedError  expected:<[Brace yourself for Metro meltdown]> but was:<[]> assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } [ATTENTION] if ( found ) children . add ( c )  ;  } return children ; }  	None^276^277^^^^266^280^
[REPLACE]  children  .  add  (  c  )  ; 	[BUGGY] Validate . notNull ( root ) ; [CE] non-static variable root cannot be referenced from a static context  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) [ATTENTION] Validate . notNull ( root )  ; } return children ; }  	None^277^^^^^266^280^
[ADD]  found  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { [ATTENTION] continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^272^^^^^266^280^
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] variable found is already defined in method filterForDescendants(Collection<Element> , Collection<Element>)  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^268^^^^^266^280^
[ADD]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; [ATTENTION]   continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^268^269^270^271^272^266^280^
[REPLACE]  boolean  found  =  false; 	[BUGGY] boolean found = true ; [FE]  AssertionFailedError  expected:<[Brace yourself for Metro meltdown]> but was:<[]> assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { [ATTENTION] boolean found = true ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^269^^^^^266^280^
[ADD]  boolean  found  =  false; 	[BUGGY] [CE] cannot find symbol found  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { [ATTENTION] for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^269^^^^^266^280^
[REPLACE]  for  (  Element  p  :  parents  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] label CHILD already in use  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } return children ; }  	None^270^^^^^266^280^
[ADD]  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true;  continue  CHILD;  } 	[BUGGY] [CE] illegal start of type  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; [ATTENTION]   } if ( !found ) children . add ( c ) ; } return children ; }  	None^270^271^272^273^274^266^280^
[REPLACE]  return  children; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  filterForDescendants [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false found true [TYPE] Element c found p root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForDescendants ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { found = true ; continue CHILD ; } } if ( !found ) children . add ( c ) ; } [ATTENTION] return byTag ( )  ; }  	None^279^^^^^266^280^
[REPLACE]  Elements  siblings  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] variable candidates is already defined in method filterForAdjacentSiblings(Collection<Element> , Collection<Element>)  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { [ATTENTION] Elements candidates = findElements ( )  ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^284^^^^^283^297^
[REPLACE]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue; 	[BUGGY] if ( !e . getAllElements ( )  . equals ( c[CE] ')' expected  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { [ATTENTION] if ( !e . getAllElements ( ) . equals ( c Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^287^288^^^^283^297^
[REPLACE]  if  (  previousSib  !=  null  &&  previousSib  .  equals  (  e  )  )  { 	[BUGGY] if ( previousSib = = null ) {[FE] NullPointerException assertTrue(divs.hasText())   [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; [ATTENTION] if ( previousSib = = null ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^290^^^^^283^297^
[ADD]  if  (  previousSib  !=  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING;  } 	[BUGGY] siblings . add ( c ) ; continue SIBLING ; [FE] NullPointerException assertTrue(divs.hasText())   [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; [ATTENTION] siblings . add ( c )  ; continue SIBLING ;   } } return siblings ; }  	None^290^291^292^293^^283^297^
[REPLACE]  siblings  .  add  (  c  )  ; 	[BUGGY] siblings . addAll ( )  ; [CE] no suitable method found for addAll()  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { [ATTENTION] siblings . addAll ( ) ; continue SIBLING ; } } } return siblings ; }  	None^291^^^^^283^297^
[REPLACE]  SIBLING:  for  (  Element  c:  candidates  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] undefined label: SIBLING  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^285^^^^^283^297^
[REPLACE]  for  (  Element  e:  elements  )  { 	[BUGGY] for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) )[NO-ERROR]  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { [ATTENTION] for ( Element e: elements ) { if ( !e . parent ( )  . equals ( c . parent ( ) ) ) if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^286^^^^^283^297^
[REPLACE]  Element  previousSib  =  c  .  previousElementSibling  (  )  ; 	[BUGGY] Element previousSib = c . getAllElements ( ) ; [CE] incompatible types  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; [ATTENTION] Element previousSib = c . getAllElements ( )  ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } return siblings ; }  	None^289^^^^^283^297^
[REPLACE]  return  siblings; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  filterForAdjacentSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements siblings  [CONTEXT]  private static Elements filterForAdjacentSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements siblings = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; Element previousSib = c . previousElementSibling ( ) ; if ( previousSib ! = null && previousSib . equals ( e ) ) { siblings . add ( c ) ; continue SIBLING ; } } } [ATTENTION] return byTag ( )  ; }  	None^296^^^^^283^297^
[REPLACE]  Elements  output  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] variable candidates is already defined in method filterForGeneralSiblings(Collection<Element> , Collection<Element>)  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { [ATTENTION] Elements candidates = findElements ( )  ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^301^^^^^300^315^
[REPLACE]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue; 	[BUGGY] if ( !e . getAllElements ( ) . equals ( c . parent ( ) ) ) continue ; [FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , els.size())   [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { [ATTENTION] if ( !e . getAllElements ( )  . equals ( c . parent ( ) ) ) continue ;  int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^304^305^^^^300^315^
[ADD]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ; 	[BUGGY] [CE] cannot find symbol cPos  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { [ATTENTION]   if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^304^305^306^307^^300^315^
[REPLACE]  if  (  cPos  >  ePos  )  { 	[BUGGY] if ( cPos < ePos ) {[FE]  AssertionFailedError  expected:<1> but was:<0> assertEquals(1 , els.size())   [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; [ATTENTION] if ( cPos<ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^308^^^^^300^315^
[REPLACE]  output  .  add  (  c  )  ; 	[BUGGY] query = query . trim ( ) ; [CE] non-static variable query cannot be referenced from a static context  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { [ATTENTION] query = query . trim ( )  ; continue SIBLING ; } } } return output ; }  	None^309^^^^^300^315^
[REPLACE]  SIBLING:  for  (  Element  c:  candidates  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] undefined label: SIBLING  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^302^^^^^300^315^
[REPLACE]  for  (  Element  e:  elements  )  { 	[BUGGY] for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) )[NO-ERROR]  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { [ATTENTION] for ( Element e: elements ) { if ( !e . parent ( )  . equals ( c . parent ( ) ) ) if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^303^^^^^300^315^
[REPLACE]  int  ePos  =  e  .  elementSiblingIndex  (  )  ; 	[BUGGY] int previousSibPos = e . elementSiblingIndex ( ) ; [CE] cannot find symbol ePos  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; [ATTENTION] int previousSibPos = e . elementSiblingIndex ( )  ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^306^^^^^300^315^
[REPLACE]  int  cPos  =  c  .  elementSiblingIndex  (  )  ; 	[BUGGY] int cPos = c . getElementsByIndexLessThan ( cPos )  ; [CE] incompatible types  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; [ATTENTION] int cPos = c . getElementsByIndexLessThan ( cPos ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^307^^^^^300^315^
[ADD]  int  cPos  =  c  .  elementSiblingIndex  (  )  ; 	[BUGGY] [CE] cannot find symbol cPos  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; [ATTENTION] if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } return output ; }  	None^307^^^^^300^315^
[REPLACE]  return  output; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  filterForGeneralSiblings [TYPE] Elements [PARAMETER] Element> elements Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates elements [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements output [TYPE] int cPos ePos  [CONTEXT]  private static Elements filterForGeneralSiblings ( Collection<Element> elements , Collection<Element> candidates ) { Elements output = new Elements ( ) ; SIBLING: for ( Element c: candidates ) { for ( Element e: elements ) { if ( !e . parent ( ) . equals ( c . parent ( ) ) ) continue ; int ePos = e . elementSiblingIndex ( ) ; int cPos = c . elementSiblingIndex ( ) ; if ( cPos > ePos ) { output . add ( c ) ; continue SIBLING ; } } } [ATTENTION] return byTag ( )  ; }  	None^314^^^^^300^315^
[REPLACE]  Elements  children  =  new  Elements  (  )  ; 	[BUGGY] Elements candidates = findElements ( ) ; [CE] variable candidates is already defined in method filterForSelf(Collection<Element> , Collection<Element>)  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { [ATTENTION] Elements candidates = findElements ( )  ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^319^^^^^318^329^
[REPLACE]  if  (  c  .  equals  (  p  )  )  { 	[BUGGY] else if ( combinator . equals (   "+  " ) )[CE]  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { [ATTENTION] else if ( combinator . equals (   "+  " ) ) children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^322^^^^^318^329^
[ADD]  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD;  } 	[BUGGY] children . add ( c ) ; continue CHILD ; [NO-ERROR]  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { [ATTENTION] children . add ( c )  ; continue CHILD ;   } } return children ; }  	None^322^323^324^325^^318^329^
[REPLACE]  children  .  add  (  c  )  ; 	[BUGGY] children . addAll ( )  ; [CE] no suitable method found for addAll()  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . equals ( p ) ) { [ATTENTION] children . addAll ( ) ; continue CHILD ; } } } return children ; }  	None^323^^^^^318^329^
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [NO-ERROR]  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; for ( Element p : parents ) { if ( c . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^320^^^^^318^329^
[REPLACE]  for  (  Element  p  :  parents  )  { 	[BUGGY] CHILD: for ( Element c : candidates ) { boolean found = false ; [CE] label CHILD already in use  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { [ATTENTION] CHILD: for ( Element c : candidates ) { boolean found = false ; if ( c . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }  	None^321^^^^^318^329^
[REPLACE]  return  children; 	[BUGGY] return byTag ( ) ; [CE] non-static method byTag() cannot be referenced from a static context  [METHOD]  filterForSelf [TYPE] Elements [PARAMETER] Element> parents Element> candidates [CLASS] Selector SelectorParseException  [TYPE] LinkedHashSet elements [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element c e found p previousSib root [TYPE] Collection candidates parents [TYPE] String[] combinators [TYPE] String className combinator id indexS key query s subQuery tagName [TYPE] Elements children  [CONTEXT]  private static Elements filterForSelf ( Collection<Element> parents , Collection<Element> candidates ) { Elements children = new Elements ( ) ; CHILD: for ( Element c : candidates ) { for ( Element p : parents ) { if ( c . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } [ATTENTION] return byTag ( )  ; }  	None^328^^^^^318^329^
[ADD]  super  (  s  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  <init> [TYPE] String) [PARAMETER] String s [CLASS] SelectorParseException  [TYPE] boolean false true [TYPE] String s  [CONTEXT]  public SelectorParseException ( String s ) { [ATTENTION] }  	None^333^^^^^332^334^
[REPLACE]  contents  =  new  ArrayList<Element>  (  )  ; 	[BUGGY] contents = new ArrayList<Element> ( elements ) ;  ; [CE] cannot find symbol elements  [METHOD]  <init> [TYPE] Elements() [PARAMETER] [CLASS] Elements  [TYPE] List contents [TYPE] boolean false true  [CONTEXT]  public Elements ( ) { [ATTENTION] contents = new ArrayList<Element> ( elements )  ;  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^16^^^^^15^17^
[REPLACE]  contents  =  new  ArrayList<Element>  (  elements  )  ; 	[BUGGY] contents =  new Element> ( )  ;  ; [CE] '(' or '[' expected  [METHOD]  <init> [TYPE] Collection) [PARAMETER] Element> elements [CLASS] Elements  [TYPE] Collection elements [TYPE] List contents [TYPE] boolean false true  [CONTEXT]  public Elements ( Collection<Element> elements ) { [ATTENTION] contents = new Element> ( ) ;  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^20^^^^^19^21^
[REPLACE]  contents  =  elements; 	[BUGGY] contents =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] List) [PARAMETER] Element> elements [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public Elements ( List<Element> elements ) { [ATTENTION] contents = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^24^^^^^23^25^
[REPLACE]  this  (  Arrays  .  asList  (  elements  )  )  ; 	[BUGGY] this (  elements  ) ; [CE] recursive constructor invocation  [METHOD]  <init> [TYPE] Element[]) [PARAMETER] elements [CLASS] Elements  [TYPE] List contents elements [TYPE] Element[] elements [TYPE] boolean false true  [CONTEXT]  public Elements ( Element . . . elements ) { [ATTENTION] this ( elements )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^28^^^^^27^29^
[REPLACE]  if  (  element  .  hasAttr  (  attributeKey  )  )  return  element  .  attr  (  attributeKey  )  ; 	[BUGGY] if ( element . hasAttr ( . hasAttributeKey ) ) return element . attr ( attributeKey ) ; [CE] illegal start of expression  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public String attr ( String attributeKey ) { for ( Element element : contents ) { [ATTENTION] if ( element . hasAttr ( . hasAttributeKey ) ) return element . attr ( attributeKey )  ;  } return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^41^42^^^^39^45^
[REPLACE]  return  element  .  attr  (  attributeKey  )  ; 	[BUGGY] return element . hasAttr ( attributeKey ) ; [CE] incompatible types  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public String attr ( String attributeKey ) { for ( Element element : contents ) { if ( element . hasAttr ( attributeKey ) ) [ATTENTION] return element . hasAttr ( attributeKey )  ; } return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^42^^^^^39^45^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public String attr ( String attributeKey ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( element . hasAttr ( attributeKey ) ) return element . attr ( attributeKey ) ; } return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^40^^^^^39^45^
[REPLACE]  return    "  "; 	[BUGGY] return new Elements ( ) ; [CE] incompatible types  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public String attr ( String attributeKey ) { for ( Element element : contents ) { if ( element . hasAttr ( attributeKey ) ) return element . attr ( attributeKey ) ; } [ATTENTION] return new Elements ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^44^^^^^39^45^
[REPLACE]  if  (  element  .  hasAttr  (  attributeKey  )  )  return  true; 	[BUGGY] if ( element . attr ( attributeKey ) ) return false ; [CE] incompatible types  [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { for ( Element element : contents ) { [ATTENTION] if ( element . attr ( attributeKey ) ) return false ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^54^55^^^^52^58^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(2 , withTitle.size())   [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { for ( Element element : contents ) { if ( element . hasAttr ( attributeKey ) ) [ATTENTION] return false ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^55^^^^^52^58^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( element . hasAttr ( attributeKey ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^53^^^^^52^58^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(2 , withTitle.size())   [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { for ( Element element : contents ) { if ( element . hasAttr ( attributeKey ) ) return true ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^57^^^^^52^58^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  attr [TYPE] Elements [PARAMETER] String attributeKey String attributeValue [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey attributeValue [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements attr ( String attributeKey , String attributeValue ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . attr ( attributeKey , attributeValue ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^67^^^^^66^71^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(2 , withTitle.size())   [METHOD]  attr [TYPE] Elements [PARAMETER] String attributeKey String attributeValue [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey attributeValue [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements attr ( String attributeKey , String attributeValue ) { for ( Element element : contents ) { element . attr ( attributeKey , attributeValue ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^70^^^^^66^71^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  removeAttr [TYPE] Elements [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements removeAttr ( String attributeKey ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . removeAttr ( attributeKey ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^79^^^^^78^83^
[ADD]  for  (  Element  element  :  contents  )  {  element  .  removeAttr  (  attributeKey  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<0> but was:<2> assertEquals(2 , withTitle.size())   [METHOD]  removeAttr [TYPE] Elements [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements removeAttr ( String attributeKey ) { [ATTENTION]  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^79^80^81^^^78^83^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  removeAttr [TYPE] Elements [PARAMETER] String attributeKey [CLASS] Elements  [TYPE] List contents elements [TYPE] String attributeKey [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements removeAttr ( String attributeKey ) { for ( Element element : contents ) { element . removeAttr ( attributeKey ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^82^^^^^78^83^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [NO-ERROR]  [METHOD]  addClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements addClass ( String className ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . addClass ( className ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^91^^^^^90^95^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  addClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements addClass ( String className ) { for ( Element element : contents ) { element . addClass ( className ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^94^^^^^90^95^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [NO-ERROR]  [METHOD]  removeClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements removeClass ( String className ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . removeClass ( className ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^103^^^^^102^107^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  removeClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements removeClass ( String className ) { for ( Element element : contents ) { element . removeClass ( className ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^106^^^^^102^107^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [FE]  AssertionFailedError  expected:<red green blue[ mellow]> but was:<red green blue[]> assertTrue(els.hasClass(  "red  "))   [METHOD]  toggleClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements toggleClass ( String className ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . toggleClass ( className ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^115^^^^^114^119^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  toggleClass [TYPE] Elements [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements toggleClass ( String className ) { for ( Element element : contents ) { element . toggleClass ( className ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^118^^^^^114^119^
[REPLACE]  if  (  element  .  hasClass  (  className  )  )  return  true; 	[BUGGY] if ( element . addClass ( className ) ) return false ; [CE] incompatible types  [METHOD]  hasClass [TYPE] boolean [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasClass ( String className ) { for ( Element element : contents ) { [ATTENTION] if ( element . addClass ( className ) ) return false ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^128^129^^^^126^132^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertTrue(els.hasClass(  "red  "))   [METHOD]  hasClass [TYPE] boolean [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasClass ( String className ) { for ( Element element : contents ) { if ( element . hasClass ( className ) ) [ATTENTION] return false ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^129^^^^^126^132^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [FE] NullPointerException assertTrue(els.hasClass(  "red  "))   [METHOD]  hasClass [TYPE] boolean [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasClass ( String className ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( element . hasClass ( className ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^127^^^^^126^132^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(els.hasClass(  "red  "))   [METHOD]  hasClass [TYPE] boolean [PARAMETER] String className [CLASS] Elements  [TYPE] List contents elements [TYPE] String className [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean hasClass ( String className ) { for ( Element element : contents ) { if ( element . hasClass ( className ) ) return true ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^131^^^^^126^132^
[REPLACE]  if  (  size  (  )  >  0  )  return  first  (  )    .  val  (  )  ; 	[BUGGY] if ( size ( ) - 4 > 0 ) return first ( ) . val ( ) ; [FE]  AssertionFailedError  expected:<[Hello]> but was:<[]> assertEquals(  "Hello  " , els.text())   [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public String val ( ) { [ATTENTION] if ( size ( ) - 4 > 0 ) return first ( )  . val ( )  ;  else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^140^141^^^^139^144^
[REPLACE]  return    "  "; 	[BUGGY] return new Elements ( ) ; [CE] incompatible types  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public String val ( ) { if ( size ( ) > 0 ) return first ( ) . val ( ) ; else [ATTENTION] return new Elements ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^143^^^^^139^144^
[REPLACE]  return  first  (  )    .  val  (  )  ; 	[BUGGY] public int size ( ) {return contents . size ( ) ; }[CE] illegal start of expression  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public String val ( ) { if ( size ( ) > 0 ) [ATTENTION] public int size ( ) {return contents . size ( )  ; } else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^141^^^^^139^144^
[ADD]  for  (  Element  element  :  contents  )  element  .  val  (  value  )  ;  return  this;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  val [TYPE] Elements [PARAMETER] String value [CLASS] Elements  [TYPE] List contents elements [TYPE] String value [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements val ( String value ) { [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^152^153^154^155^^151^155^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  val [TYPE] Elements [PARAMETER] String value [CLASS] Elements  [TYPE] List contents elements [TYPE] String value [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements val ( String value ) { for ( Element element : contents ) element . val ( value ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^154^^^^^151^155^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ; 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] illegal start of expression  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "   " ) ; sb . append ( element . text ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^166^^^^^165^173^
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (    "    "  )  ; 	[BUGGY] if ( sb . length ( ) - 1 ! = 0 ) sb . append (   "   " ) ; [FE]  AssertionFailedError  expected:<[]Hello> but was:<[ ]Hello> assertEquals(  "Hello  " , els.text())   [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { [ATTENTION] if ( sb . length ( ) - 1 ! = 0 ) sb . append (   "   " )  ;  sb . append ( element . text ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^168^169^^^^165^173^
[REPLACE]  sb  .  append  (    "    "  )  ; 	[BUGGY] sb . append (   "\n  " ) ; [FE]  AssertionFailedError  expected:<Hello[ there ]world> but was:<Hello[ assertEquals(  "Hello there world  " , doc.select(  "div > *  ").text())   [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) [ATTENTION] sb . append (   "\n  " )  ; sb . append ( element . text ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^169^^^^^165^173^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( sb . length ( ) ! = 0 ) sb . append (   "   " ) ; sb . append ( element . text ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^167^^^^^165^173^
[ADD]  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (    "    "  )  ;  sb  .  append  (  element  .  text  (  )  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<[Brace yourself for Metro meltdown]> but was:<[]> assertEquals(  "News.com.au | News from Australia and around the world online | NewsComAu  " , doc.title())   [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION]   return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^167^168^169^170^171^165^173^
[REPLACE]  return  sb  .  toString  (  )  ; 	[BUGGY] return sb . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "   " ) ; sb . append ( element . text ( ) ) ; } [ATTENTION] return sb . StringBuilder ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^172^^^^^165^173^
[REPLACE]  if  (  element  .  hasText  (  )  )  return  true; 	[BUGGY] if ( element . hasText ( ) ) return false ; [FE] NullPointerException assertTrue(divs.hasText())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] Element element [TYPE] boolean false true  [CONTEXT]  public boolean hasText ( ) { for ( Element element: contents ) { [ATTENTION] if ( element . hasText ( ) ) return false ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^177^178^^^^175^181^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertTrue(divs.hasText())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] Element element [TYPE] boolean false true  [CONTEXT]  public boolean hasText ( ) { for ( Element element: contents ) { if ( element . hasText ( ) ) [ATTENTION] return false ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^178^^^^^175^181^
[REPLACE]  for  (  Element  element:  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] Element element [TYPE] boolean false true  [CONTEXT]  public boolean hasText ( ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( element . hasText ( ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^176^^^^^175^181^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertTrue(divs.hasText())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] Element element [TYPE] boolean false true  [CONTEXT]  public boolean hasText ( ) { for ( Element element: contents ) { if ( element . hasText ( ) ) return true ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^180^^^^^175^181^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ; 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] illegal start of expression  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String html ( ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^190^^^^^189^197^
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (    "\n  "  )  ; 	[BUGGY] if ( sb . length ( ) * 2 ! = 0 ) sb . append (   "\n  " ) ; [NO-ERROR]  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { [ATTENTION] if ( sb . length ( ) *2 ! = 0 ) sb . append (   "\n  " )  ;  sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^192^193^^^^189^197^
[REPLACE]  sb  .  append  (    "\n  "  )  ; 	[BUGGY] sb . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) [ATTENTION] sb . StringBuilder ( ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^193^^^^^189^197^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . html ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^191^^^^^189^197^
[REPLACE]  return  sb  .  toString  (  )  ; 	[BUGGY] return sb . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String html ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . html ( ) ) ; } [ATTENTION] return sb . StringBuilder ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^196^^^^^189^197^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ; 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . outerHtml ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^206^^^^^205^213^
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (    "\n  "  )  ; 	[BUGGY] if ( sb . length ( ) % 2 ! = 0 ) sb . append (   "\n  " ) ; [NO-ERROR]  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { [ATTENTION] if ( sb . length ( ) %2 ! = 0 ) sb . append (   "\n  " )  ;  sb . append ( element . outerHtml ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^208^209^^^^205^213^
[ADD]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (    "\n  "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  } 	[BUGGY] sb . append (   "\n  " ) ; sb . append ( element . outerHtml ( ) ) ; [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { [ATTENTION] sb . append (   "\n  " )  ; sb . append ( element . outerHtml ( ) )  ;   return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^208^209^210^211^^205^213^
[REPLACE]  sb  .  append  (    "\n  "  )  ; 	[BUGGY] sb . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) [ATTENTION] sb . StringBuilder ( ) ; sb . append ( element . outerHtml ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^209^^^^^205^213^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . outerHtml ( ) ) ; } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^207^^^^^205^213^
[REPLACE]  return  sb  .  toString  (  )  ; 	[BUGGY] return sb . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] Element element  [CONTEXT]  public String outerHtml ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Element element : contents ) { if ( sb . length ( ) ! = 0 ) sb . append (   "\n  " ) ; sb . append ( element . outerHtml ( ) ) ; } [ATTENTION] return sb . StringBuilder ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^212^^^^^205^213^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  html [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements html ( String html ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . html ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^222^^^^^221^226^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  html [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements html ( String html ) { for ( Element element : contents ) { element . html ( html ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^225^^^^^221^226^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  prepend [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements prepend ( String html ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . prepend ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^235^^^^^234^239^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "<p><b>Bold</b>Two<i>Ital</i></p>  " , TextUtil.stripNewlines(ps.get(1).outerHtml()))   [METHOD]  prepend [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements prepend ( String html ) { for ( Element element : contents ) { element . prepend ( html ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^238^^^^^234^239^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  append [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements append ( String html ) { [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . append ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^248^^^^^247^252^
[ADD]  for  (  Element  element  :  contents  )  {  element  .  append  (  html  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<<p><b>Bold</b>Two<[i>Ital</i><]/p>> but was:<<p><b>Bold</b>Two<[]/p>> assertEquals(  "<p><b>Bold</b>Two<i>Ital</i></p>  " , TextUtil.stripNewlines(ps.get(1).outerHtml()))   [METHOD]  append [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements append ( String html ) { [ATTENTION]  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^248^249^250^^^247^252^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  append [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements append ( String html ) { for ( Element element : contents ) { element . append ( html ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^251^^^^^247^252^
[REPLACE]  Validate  .  notEmpty  (  html  )  ; 	[BUGGY] html  ; [CE] not a statement  [METHOD]  wrap [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements wrap ( String html ) { [ATTENTION] html ; for ( Element element : contents ) { element . wrap ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^264^^^^^263^269^
[ADD]  Validate  .  notEmpty  (  html  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  wrap [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements wrap ( String html ) { [ATTENTION] for ( Element element : contents ) { element . wrap ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^264^^^^^263^269^
[REPLACE]  for  (  Element  element  :  contents  )  { 	[BUGGY] for ( Element element : contents ) { element . addClass ( className ) ; [CE] cannot find symbol className  [METHOD]  wrap [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements wrap ( String html ) { Validate . notEmpty ( html ) ; [ATTENTION] for ( Element element : contents ) { element . addClass ( className )  ; element . wrap ( html ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^265^^^^^263^269^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  wrap [TYPE] Elements [PARAMETER] String html [CLASS] Elements  [TYPE] List contents elements [TYPE] String html [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public Elements wrap ( String html ) { Validate . notEmpty ( html ) ; for ( Element element : contents ) { element . wrap ( html ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^268^^^^^263^269^
[REPLACE]  return  Selector  .  select  (  query,  this  )  ; 	[BUGGY] return Selector . select ( query )  ; [CE] no suitable method found for select(String)  [METHOD]  select [TYPE] Elements [PARAMETER] String query [CLASS] Elements  [TYPE] List contents elements [TYPE] String query [TYPE] boolean false true  [CONTEXT]  public Elements select ( String query ) { [ATTENTION] return Selector . select ( query ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^279^^^^^278^280^
[REPLACE]  if  (  contents  .  size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ; 	[BUGGY] if ( contents . size ( ) % 0 . 5 > index ) return new Elements ( get ( index ) ) ; [FE]  AssertionFailedError  expected:<[there]> but was:<[]> assertEquals(  "there  " , doc.select(  "p  ").eq(1).text())   [METHOD]  eq [TYPE] Elements [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]  public Elements eq ( int index ) { [ATTENTION] if ( contents . size ( ) %0 . 5> index ) return new Elements ( get ( index ) )  ;  else return new Elements ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^288^289^^^^287^292^
[REPLACE]  return  new  Elements  (  )  ; 	[BUGGY] return new Elements ( get ( index ) )  ; [NO-ERROR]  [METHOD]  eq [TYPE] Elements [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]  public Elements eq ( int index ) { if ( contents . size ( ) > index ) return new Elements ( get ( index ) ) ; else [ATTENTION] returnnew Elements ( get ( index ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^291^^^^^287^292^
[REPLACE]  return  new  Elements  (  get  (  index  )  )  ; 	[BUGGY] return new Elements ( )  ) ; [CE] ' ; ' expected  [METHOD]  eq [TYPE] Elements [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]  public Elements eq ( int index ) { if ( contents . size ( ) > index ) [ATTENTION] returnnew Elements ( )  )  ; else return new Elements ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^289^^^^^287^292^
[REPLACE]  Elements  children  =  this  .  select  (  query  )  ; 	[BUGGY] Elements children = this . select ( query , children )  ; [CE] method select in class Elements cannot be applied to given types ;  [METHOD]  is [TYPE] boolean [PARAMETER] String query [CLASS] Elements  [TYPE] List contents elements [TYPE] String query [TYPE] boolean false true [TYPE] Elements children  [CONTEXT]  public boolean is ( String query ) { [ATTENTION] Elements children = this . select ( query , children ) ; return !children . isEmpty ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^300^^^^^299^302^
[REPLACE]  return  !children  .  isEmpty  (  )  ; 	[BUGGY] return !children . set ( null , null )  ; [CE] method set in class Elements cannot be applied to given types ;  [METHOD]  is [TYPE] boolean [PARAMETER] String query [CLASS] Elements  [TYPE] List contents elements [TYPE] String query [TYPE] boolean false true [TYPE] Elements children  [CONTEXT]  public boolean is ( String query ) { Elements children = this . select ( query ) ; [ATTENTION] return !children . set ( null , null ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^301^^^^^299^302^
[REPLACE]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  0  )  :  null; 	[BUGGY] return !contents . isEmpty ( ) ? contents . get ( 2 ) : null ; [FE]  IndexOutOfBoundsException Index: 2 , Size: 1 assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  first [TYPE] Element [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public Element first ( ) { [ATTENTION] return !contents . isEmpty ( ) ? contents . get ( 2 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^310^^^^^309^311^
[REPLACE]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  contents  .  size  (  )  -  1  )  :  null; 	[BUGGY] return !contents . isEmpty ( ) ? contents . clear ( contents . size ( ) - 1 ) : null ; [CE] no suitable method found for clear(int)  [METHOD]  last [TYPE] Element [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]  public Element last ( ) { [ATTENTION] return !contents . isEmpty ( ) ? contents . clear ( contents . size ( ) - 1 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^318^^^^^317^319^
[REPLACE]  public  int  size  (  )  {return  contents  .  size  (  )  ;} 	[BUGGY] public int . get ( ) {return contents . size ( ) ; }[CE] <identifier> expected  [METHOD]  size [TYPE] int [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^322^^^^^^^
[REPLACE]  public  boolean  isEmpty  (  )  {return  contents  .  isEmpty  (  )  ;} 	[BUGGY] public boolean . iterator ( ) {return contents . isEmpty ( ) ; }[CE] <identifier> expected  [METHOD]  isEmpty [TYPE] boolean [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^324^^^^^^^
[REPLACE]  public  boolean  contains  (  Object  o  )  {return  contents  .  contains  (  o  )  ;} 	[BUGGY] public boolean . equals ( Object o ) {return contents . contains ( o ) ; }[CE] <identifier> expected  [METHOD]  contains [TYPE] boolean [PARAMETER] Object o [CLASS] Elements  [TYPE] List contents elements [TYPE] Object o [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^326^^^^^^^
[REPLACE]  public  Iterator<Element>  iterator  (  )  {return  contents  .  iterator  (  )  ;} 	[BUGGY] public Iterator<Element> . listIterator ( ) {return contents . iterator ( ) ; }[CE] <identifier> expected  [METHOD]  iterator [TYPE] Iterator [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^328^^^^^^^
[REPLACE]  public  Object[]  toArray  (  )  {return  contents  .  toArray  (  )  ;} 	[BUGGY] public Object[] . isEmpty ( ) {return contents . toArray ( ) ; }[CE] <identifier> expected  [METHOD]  toArray [TYPE] Object[] [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^330^^^^^^^
[REPLACE]  public  <T>  T[]  toArray  (  T[]  a  )  {return  contents  .  toArray  (  a  )  ;} 	[BUGGY] public Object[] toArray ( ) {return contents . toArray ( ) ; }[CE] method toArray() is already defined in class Elements  [METHOD]  toArray [TYPE] <T> [PARAMETER] T[] a [CLASS] Elements  [TYPE] List contents elements [TYPE] T[] a [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^332^^^^^^^
[REPLACE]  public  boolean  add  (  Element  element  )  {return  contents  .  add  (  element  )  ;} 	[BUGGY] public boolean . remove ( Element element ) {return contents . add ( element ) ; }[CE] <identifier> expected  [METHOD]  add [TYPE] boolean [PARAMETER] Element element [CLASS] Elements  [TYPE] List contents elements [TYPE] Element element [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^334^^^^^^^
[REPLACE]  public  boolean  remove  (  Object  o  )  {return  contents  .  remove  (  o  )  ;} 	[BUGGY] public boolean . indexOf ( Object o ) {return contents . remove ( o ) ; }[CE] <identifier> expected  [METHOD]  remove [TYPE] boolean [PARAMETER] Object o [CLASS] Elements  [TYPE] List contents elements [TYPE] Object o [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^336^^^^^^^
[REPLACE]  public  boolean  containsAll  (  Collection<?>  c  )  {return  contents  .  containsAll  (  c  )  ;} 	[BUGGY] public boolean containsAll ( Collection<?> c ) {return contents . contains ( null )  ; }[NO-ERROR]  [METHOD]  containsAll [TYPE] boolean [PARAMETER] Collection<?> c [CLASS] Elements  [TYPE] Collection c [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^338^^^^^^^
[REPLACE]  public  boolean  addAll  (  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  c  )  ;} 	[BUGGY] public boolean . retainAll ( Collection<? extends Element> c ) {return contents . addAll ( c ) ; }[CE] <identifier> expected  [METHOD]  addAll [TYPE] boolean [PARAMETER] Element> c [CLASS] Elements  [TYPE] Collection c [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^340^^^^^^^
[REPLACE]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  index,  c  )  ;} 	[BUGGY] public boolean . add ( int index , Collection<? extends Element> c ) {return contents . addAll ( index , c ) ; }[CE] <identifier> expected  [METHOD]  addAll [TYPE] boolean [PARAMETER] int index Element> c [CLASS] Elements  [TYPE] Collection c [TYPE] List contents elements [TYPE] boolean false true [TYPE] int index  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^342^^^^^^^
[REPLACE]  public  boolean  removeAll  (  Collection<?>  c  )  {return  contents  .  removeAll  (  c  )  ;} 	[BUGGY] public boolean . retainAll ( Collection<?> 1 ) {return contents . removeAll ( c ) ; }[CE] <identifier> expected  [METHOD]  removeAll [TYPE] boolean [PARAMETER] Collection<?> c [CLASS] Elements  [TYPE] Collection c [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^344^^^^^^^
[REPLACE]  public  boolean  retainAll  (  Collection<?>  c  )  {return  contents  .  retainAll  (  c  )  ;} 	[BUGGY] public boolean containsAll ( Collection<?> c ) {return contents . containsAll ( c ) ; }[CE] method containsAll(Collection<?>) is already defined in class Elements  [METHOD]  retainAll [TYPE] boolean [PARAMETER] Collection<?> c [CLASS] Elements  [TYPE] Collection c [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^346^^^^^^^
[REPLACE]  public  void  clear  (  )  {contents  .  clear  (  )  ;} 	[BUGGY] public void . get ( ) {contents . clear ( ) ; }[CE] <identifier> expected  [METHOD]  clear [TYPE] void [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^348^^^^^^^
[REPLACE]  public  boolean  equals  (  Object  o  )  {return  contents  .  equals  (  o  )  ;} 	[BUGGY] public boolean . contains ( Object o ) {return contents . equals ( o ) ; }[CE] <identifier> expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Elements  [TYPE] List contents elements [TYPE] Object o [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^350^^^^^^^
[REPLACE]  public  int  hashCode  (  )  {return  contents  .  hashCode  (  )  ;} 	[BUGGY] public int . size ( ) {return contents . hashCode ( ) ; }[CE] <identifier> expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^352^^^^^^^
[REPLACE]  public  Element  get  (  int  index  )  {return  contents  .  get  (  index  )  ;} 	[BUGGY] public Element remove ( int index ) {return contents . remove ( index ) ; }[CE] method remove(int) is already defined in class Elements  [METHOD]  get [TYPE] Element [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^354^^^^^^^
[REPLACE]  public  Element  set  (  int  index,  Element  element  )  {return  contents  .  set  (  index,  element  )  ;} 	[BUGGY] public Element . add ( int index , Element element ) {return contents . set ( index , element ) ; }[CE] <identifier> expected  [METHOD]  set [TYPE] Element [PARAMETER] int index Element element [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^356^^^^^^^
[REPLACE]  public  void  add  (  int  index,  Element  element  )  {contents  .  add  (  index,  element  )  ;} 	[BUGGY] public void . set ( int index , Element element ) {contents . add ( index , element ) ; }[CE] <identifier> expected  [METHOD]  add [TYPE] void [PARAMETER] int index Element element [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^358^^^^^^^
[REPLACE]  public  Element  remove  (  int  index  )  {return  contents  .  remove  (  index  )  ;} 	[BUGGY] public Element remove ( int index ) {return contents . removeAll ( null )  ; }[CE] incompatible types  [METHOD]  remove [TYPE] Element [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^360^^^^^^^
[REPLACE]  public  int  indexOf  (  Object  o  )  {return  contents  .  indexOf  (  o  )  ;} 	[BUGGY] public int . lastIndexOf ( Object o ) {return contents . indexOf ( o ) ; }[CE] <identifier> expected  [METHOD]  indexOf [TYPE] int [PARAMETER] Object o [CLASS] Elements  [TYPE] List contents elements [TYPE] Object o [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^362^^^^^^^
[REPLACE]  public  int  lastIndexOf  (  Object  o  )  {return  contents  .  lastIndexOf  (  o  )  ;} 	[BUGGY] public int . indexOf ( Object o ) {return contents . lastIndexOf ( o ) ; }[CE] <identifier> expected  [METHOD]  lastIndexOf [TYPE] int [PARAMETER] Object o [CLASS] Elements  [TYPE] List contents elements [TYPE] Object o [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^364^^^^^^^
[REPLACE]  public  ListIterator<Element>  listIterator  (  )  {return  contents  .  listIterator  (  )  ;} 	[BUGGY] public ListIterator<Element> . iterator ( ) {return contents . listIterator ( ) ; }[CE] <identifier> expected  [METHOD]  listIterator [TYPE] ListIterator [PARAMETER] [CLASS] Elements  [TYPE] List contents elements [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^366^^^^^^^
[REPLACE]  public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents  .  listIterator  (  index  )  ;} 	[BUGGY] public ListIterator<Element> listIterator ( int index ) {return contents . iterator ( )  ; }[CE] incompatible types  [METHOD]  listIterator [TYPE] ListIterator [PARAMETER] int index [CLASS] Elements  [TYPE] List contents elements [TYPE] int index [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^368^^^^^^^
[REPLACE]  public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents  .  subList  (  fromIndex,  toIndex  )  ;} 	[BUGGY] public List<Element> . addAll ( int fromIndex , int toIndex ) {return contents . subList ( fromIndex , toIndex ) ; }[CE] <identifier> expected  [METHOD]  subList [TYPE] List [PARAMETER] int fromIndex int toIndex [CLASS] Elements  [TYPE] List contents elements [TYPE] int fromIndex toIndex [TYPE] boolean false true  [CONTEXT]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/select/Elements.java^370^^^^^^^
[REPLACE]  private  static  final  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>  (  )  ; 	[BUGGY] private static final Map<String , Tag> tags  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^13^^^^^^^
[REPLACE]  private  static  final  Tag  defaultAncestor; 	[BUGGY] private static Tag defaultAncestor ; [NO-ERROR]  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^14^^^^^^^
[REPLACE]  private  String  tagName; 	[BUGGY] private byte tagName ; [CE] method put in interface Map<K , V> cannot be applied to given types ;  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^20^^^^^^^
[REPLACE]  private  boolean  isBlock  =  true; 	[BUGGY] private boolean isBlock  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^21^^^^^^^
[REPLACE]  private  boolean  canContainBlock  =  true; 	[BUGGY] private boolean canContainBlock  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^22^^^^^^^
[REPLACE]  private  boolean  canContainInline  =  true; 	[BUGGY] private boolean canContainInline  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^23^^^^^^^
[REPLACE]  private  boolean  optionalClosing  =  false; 	[BUGGY] private boolean optionalClosing ; [NO-ERROR]  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^24^^^^^^^
[REPLACE]  private  boolean  empty  =  false; 	[BUGGY] private boolean empty  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^25^^^^^^^
[REPLACE]  private  boolean  preserveWhitespace  =  false; 	[BUGGY] private boolean preserveWhitespace ; [NO-ERROR]  [CONTEXT]    [CLASS] Tag  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^26^^^^^^^
[REPLACE]  this  .  tagName  =  tagName  .  toLowerCase  (  )  ; 	[BUGGY] this . tagName =  null . toLowerCase ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] String) [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag ( String tagName ) { [ATTENTION] this . tagName = null . toLowerCase ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^30^^^^^29^31^
[REPLACE]  return  tagName; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  getName [TYPE] String [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public String getName ( ) { [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^34^^^^^33^35^
[REPLACE]  Validate  .  notNull  (  tagName  )  ; 	[BUGGY] Validate . notEmpty ( tagName )  ; [NO-ERROR]  [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { [ATTENTION] Validate . notEmpty ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^45^^^^^44^60^
[REPLACE]  tagName  =  tagName  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] tagName =  null . trim ( ) . toLowerCase ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; [ATTENTION] tagName = null . trim ( )  . toLowerCase ( )  ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^46^^^^^44^60^
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ; 	[BUGGY] Validate . notNull ( tagName )  ; [FE] AssertionFailedError [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; [ATTENTION] Validate . notNull ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^47^^^^^44^60^
[ADD]  Validate  .  notEmpty  (  tagName  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; [ATTENTION]  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^47^^^^^44^60^
[REPLACE]  if  (  tag  ==  null  )  { 	[BUGGY] if ( tag ! = null ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; [ATTENTION] if ( tag ! = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^51^^^^^44^60^
[REPLACE]  tag  =  new  Tag  (  tagName  )  ; 	[BUGGY] tag =  new Tag ( null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  [ATTENTION] tag = new Tag ( null )  ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^53^^^^^44^60^
[REPLACE]  tag  .  isBlock  =  false; 	[BUGGY] tag . isBlock = true ; [FE]  AssertionFailedError  expected:<<p><[cust>Test</cust></p><p><cust><cust>Test</cust></cust></p]>> but was:<<p><[/p><cust>Test</cust><p></p><cust><cust>Test</cust></cust]>> assertEquals(h , TextUtil.stripNewlines(out))   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; [ATTENTION] tag . isBlock = true ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^55^^^^^44^60^
[REPLACE]  tag  .  canContainBlock  =  true; 	[BUGGY] tag . canContainBlock = false ; [FE]  The validated object is null assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; [ATTENTION] tag . canContainBlock = false ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^56^^^^^44^60^
[ADD]  tag  =  new  Tag  (  tagName  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  [ATTENTION] tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^53^^^^^44^60^
[ADD]  tag  .  isBlock  =  false; 	[BUGGY] [FE]  AssertionFailedError  expected:<<p><[cust>Test</cust></p><p><cust><cust>Test</cust></cust></p]>> but was:<<p><[/p><cust>Test</cust><p></p><cust><cust>Test</cust></cust]>> assertEquals(h , TextUtil.stripNewlines(out))   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; [ATTENTION] tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^55^^^^^44^60^
[REPLACE]  return  tag; 	[BUGGY] return defaultAncestor ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { Tag tag = tags . get ( tagName ) ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } [ATTENTION] return defaultAncestor ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^58^^^^^44^60^
[REPLACE]  Tag  tag  =  tags  .  get  (  tagName  )  ; 	[BUGGY] int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; [CE] cannot find symbol tag  [METHOD]  valueOf [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public static Tag valueOf ( String tagName ) { Validate . notNull ( tagName ) ; tagName = tagName . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( tagName ) ;  synchronized ( tags ) { [ATTENTION] int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; if ( tag = = null ) {  tag = new Tag ( tagName ) ; tag . setAncestor ( defaultAncestor . tagName ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^50^^^^^44^60^
[REPLACE]  Validate  .  notNull  (  child  )  ; 	[BUGGY] Validate . notNull ( defaultAncestor ) ; [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { [ATTENTION] Validate . notNull ( defaultAncestor )  ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^68^^^^^67^99^
[ADD]  Validate  .  notNull  (  child  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { [ATTENTION]  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^68^^^^^67^99^
[REPLACE]  if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false; 	[BUGGY] if ( defaultAncestor . isBlock && this . canContainBlock ) return true ; [FE]  AssertionFailedError  expected:<...-- comment -->Hello<[/p><p>there]</p></div></body></h...> but was:<...-- comment -->Hello<[p>there</p>]</p></div></body></h...> assertEquals(  "<html><head></head><body><div title = \  "Tags &amp   c.\  "><img src = \  "foo.png\  " /><p><!-- comment -->Hello</p><p>there</p></div></body></html>  " ,  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  [ATTENTION] if ( defaultAncestor . isBlock && this . canContainBlock ) return true ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^70^71^^^^67^99^
[REMOVE]   	[BUGGY] if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) )   return false ; [CE] unreachable statement  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  [ATTENTION] if ( child . isBlock && !this . canContainBlock )  if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) ) return false ; return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^70^^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<First[]> but was:<First[ Ignore Hello]> assertEquals(  "  " , noTitle.title())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) [ATTENTION] return true ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^71^^^^^67^99^
[REPLACE]  if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  return  false; 	[BUGGY] if ( child . isBlock && !this . canContainInline ) return false ; [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  [ATTENTION] if ( child . isBlock && !this . canContainInline ) return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^73^74^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertFalse(img.canContain(img))   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline [ATTENTION] return true ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^74^^^^^67^99^
[REPLACE]  if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false; 	[BUGGY] if ( this . optionalClosing || this . equals ( defaultAncestor ) ) return false ; [FE]  The validated object is null assertEquals(  "<p>Hello</p><p>there</p><p>now</p>  " , TextUtil.stripNewlines(div.html()))   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  [ATTENTION] if ( this . optionalClosing || this . equals ( defaultAncestor ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^76^77^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<2> but was:<1> assertEquals(1 , ol.size())   // one p in first li  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) [ATTENTION] return true ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^77^^^^^67^99^
[REPLACE]  if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false; 	[BUGGY] if ( this . empty &&isBlock ( ) ) return true ; [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  [ATTENTION] if ( this . empty &&isBlock ( ) ) return true ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^79^80^^^^67^99^
[REMOVE]   	[BUGGY] if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) )   return false ; [CE] unreachable statement  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  [ATTENTION] if ( this . empty || this . isData ( ) )  if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) ) return false ; return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^79^^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) [ATTENTION] return true ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^80^^^^^67^99^
[REPLACE]  if  (  this  .  tagName  .  equals  (    "head  "  )  )  { 	[BUGGY] if ( this . tagName . setOptionalClosing ( )  ) {[CE] cannot find symbol  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    [ATTENTION] if ( this . tagName . setOptionalClosing ( )  ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^84^^^^^67^99^
[ADD]  if  (  this  .  tagName  .  equals  (    "head  "  )  )  {  if  (  child  .  tagName  .  equals  (    "base  "  )  ||  child  .  tagName  .  equals  (    "script  "  )  ||  child  .  tagName  .  equals  (    "noscript  "  )  ||  child  .  tagName  .  equals  (    "link  "  )  ||  child  .  tagName  .  equals  (    "meta  "  )  ||  child  .  tagName  .  equals  (    "title  "  )  ||  child  .  tagName  .  equals  (    "style  "  )  ||  child  .  tagName  .  equals  (    "object  "  )  )  {  return  true;  } 	[BUGGY] [CE] illegal start of type  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    [ATTENTION]   return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^84^85^86^87^88^67^99^
[REPLACE]  if  (  child  .  tagName  .  equals  (    "base  "  )  ||  child  .  tagName  .  equals  (    "script  "  )  ||  child  .  tagName  .  equals  (    "noscript  "  )  ||  child  .  tagName  .  equals  (    "link  "  )  ||  child  .  tagName  .  equals  (    "meta  "  )  ||  child  .  tagName  .  equals  (    "title  "  )  ||  child  .  tagName  .  equals  (    "style  "  )  ||  child  .  tagName  .  equals  (    "object  "  )  )  { 	[BUGGY] if ( child . tagName . equals (   "script  " ) && child . tagName . equals (   "noscript  " ) && child . tagName . equals (   "link  " ) && child . tagName . equals (   "meta  " ) && child . tagName . equals (   "title  " ) && child . tagName . equals (   "style  " ) && child . tagName . equals (   "object  " ) ) {[FE]  AssertionFailedError  expected:<2> but was:<4> assertEquals(1 , doc.children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { [ATTENTION] if ( child . tagName . equals (   "script  " ) && child . tagName . equals (   "noscript  " ) && child . tagName . equals (   "link  " ) && child . tagName . equals (   "meta  " ) && child . tagName . equals (   "title  " ) && child . tagName . equals (   "style  " ) && child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^85^86^^^^67^99^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<2> but was:<4> assertEquals(1 , doc.children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^87^^^^^85^88^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<2> but was:<4> assertEquals(1 , doc.children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { [ATTENTION] return false ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^87^^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<2> but was:<1> assertEquals(1 , doc.children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } [ATTENTION] return true ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^89^^^^^67^99^
[REPLACE]  if  (  child  .  tagName  .  equals  (    "base  "  )  ||  child  .  tagName  .  equals  (    "script  "  )  ||  child  .  tagName  .  equals  (    "noscript  "  )  ||  child  .  tagName  .  equals  (    "link  "  )  ||  child  .  tagName  .  equals  (    "meta  "  )  ||  child  .  tagName  .  equals  (    "title  "  )  ||  child  .  tagName  .  equals  (    "style  "  )  ||  child  .  tagName  .  equals  (    "object  "  )  )  { 	[BUGGY] if ( child . tagName . equals (   "base  " ) && child . tagName . equals (   "script  " ) && child . tagName . equals (   "noscript  " ) && child . tagName . equals (   "link  " ) && child . tagName . equals (   "meta  " ) && child . tagName . equals (   "title  " ) && child . tagName . equals (   "style  " ) && child . tagName . equals (   "object  " ) ) {[FE]  AssertionFailedError  expected:<2> but was:<4> assertEquals(1 , doc.children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { [ATTENTION] if ( child . tagName . equals (   "base  " ) && child . tagName . equals (   "script  " ) && child . tagName . equals (   "noscript  " ) && child . tagName . equals (   "link  " ) && child . tagName . equals (   "meta  " ) && child . tagName . equals (   "title  " ) && child . tagName . equals (   "style  " ) && child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^85^86^^^^67^99^
[REPLACE]  if  (  this  .  tagName  .  equals  (    "dt  "  )  &&  child  .  tagName  .  equals  (    "dd  "  )  )  return  false; 	[BUGGY] if ( this . tagName . equals (   "dt  " ) || defaultAncestor . tagName . equals (   "dd  " ) ) return false ; [NO-ERROR]  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  [ATTENTION] if ( this . tagName . equals (   "dt  " ) || defaultAncestor . tagName . equals (   "dd  " ) ) return false ;  if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^93^94^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<4> but was:<2> assertEquals(4 , doc.body().getElementsByTag(  "dl  ").first().children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) [ATTENTION] return true ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^94^^^^^67^99^
[REPLACE]  if  (  this  .  tagName  .  equals  (    "dd  "  )  &&  child  .  tagName  .  equals  (    "dt  "  )  )  return  false; 	[BUGGY] if ( this . tagName . setOptionalClosing ( )  || child . tagName[CE] ')' expected  [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; [ATTENTION] if ( this . tagName . setOptionalClosing ( ) || child . tagName  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^95^96^^^^67^99^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<4> but was:<3> assertEquals(4 , doc.body().getElementsByTag(  "dl  ").first().children().size())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) [ATTENTION] return true ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^96^^^^^67^99^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  The validated object is null assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  canContain [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean canContain ( Tag child ) { Validate . notNull ( child ) ;  if ( child . isBlock && !this . canContainBlock ) return false ;  if ( !child . isBlock && !this . canContainInline ) // not block = = inline return false ;  if ( this . optionalClosing && this . equals ( child ) ) return false ;  if ( this . empty || this . isData ( ) ) return false ;    if ( this . tagName . equals (   "head  " ) ) { if ( child . tagName . equals (   "base  " ) || child . tagName . equals (   "script  " ) || child . tagName . equals (   "noscript  " ) || child . tagName . equals (   "link  " ) || child . tagName . equals (   "meta  " ) || child . tagName . equals (   "title  " ) || child . tagName . equals (   "style  " ) || child . tagName . equals (   "object  " ) ) { return true ; } return false ; }  if ( this . tagName . equals (   "dt  " ) && child . tagName . equals (   "dd  " ) ) return false ; if ( this . tagName . equals (   "dd  " ) && child . tagName . equals (   "dt  " ) ) return false ;  [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^98^^^^^67^99^
[REPLACE]  return  isBlock; 	[BUGGY] return !isBlock ; [FE]  expected:<<pre>[]<code>code assertEquals(  "code\n\ncode  " , doc.text())   [METHOD]  isBlock [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean isBlock ( ) { [ATTENTION] return !isBlock ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^106^^^^^105^107^
[REPLACE]  return  canContainBlock; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  canContainBlock [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean canContainBlock ( ) { [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^114^^^^^113^115^
[REPLACE]  return  !isBlock; 	[BUGGY] return isBlock ; [NO-ERROR]  [METHOD]  isInline [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean isInline ( ) { [ATTENTION] return isBlock ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^122^^^^^121^123^
[REPLACE]  return  !canContainInline  &&  !isEmpty  (  )  ; 	[BUGGY] return canContainInline || !isEmpty ( ) ; [FE]  The validated object is null assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  isData [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean isData ( ) { [ATTENTION] return canContainInline || !isEmpty ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^130^^^^^129^131^
[REPLACE]  return  empty; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  isEmpty [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean isEmpty ( ) { [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^138^^^^^137^139^
[REPLACE]  return  preserveWhitespace; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  preserveWhitespace [TYPE] boolean [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean preserveWhitespace ( ) { [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^146^^^^^145^147^
[REPLACE]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  get  (  0  )  :  null; 	[BUGGY] return ( !ancestors . isEmpty ( ) ) ? ancestors . add ( 0 ) : null ; [CE] no suitable method found for add(int)  [METHOD]  getImplicitParent [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  Tag getImplicitParent ( ) { [ATTENTION] return ( !ancestors . isEmpty ( ) ) ? ancestors . add ( 0 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^150^^^^^149^151^
[REPLACE]  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true; 	[BUGGY] if ( child . ancestors . isEmpty ( ) ) return false ; [NO-ERROR]  [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { [ATTENTION] if ( child . ancestors . isEmpty ( ) ) return false ;  for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^154^155^^^^153^162^
[REPLACE]  return  true; 	[BUGGY] return false ; [NO-ERROR]  [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) [ATTENTION] return false ;  for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^155^^^^^153^162^
[REPLACE]  if  (  this  .  equals  (  tag  )  )  return  true; 	[BUGGY] if ( this . equals ( tag ) ) return false ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; // HTML tag for ( Tag tag : child . ancestors ) { [ATTENTION] if ( this . equals ( tag ) ) return false ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^158^159^^^^153^162^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; // HTML tag for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) [ATTENTION] return false ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^159^^^^^153^162^
[REPLACE]  for  (  Tag  tag  :  child  .  ancestors  )  { 	[BUGGY] for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; [CE] cannot find symbol tagNames  [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; // HTML tag [ATTENTION] for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) )  ; if ( this . equals ( tag ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^157^^^^^153^162^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE]  AssertionFailedError  expected:<[]Replaced> but was:<[Hello ]Replaced> assertEquals(  "Replaced  " , doc.text())   [METHOD]  isValidParent [TYPE] boolean [PARAMETER] Tag child [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  boolean isValidParent ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; // HTML tag for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) return true ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^161^^^^^153^162^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( tag && o ) return true ; [CE] cannot find symbol tag  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( tag&&o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^166^^^^^165^179^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this = = o ) return false ; [FE]  AssertionFailedError  expected:<[Yahoo! JAPAN]> but was:<[]> assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this = = o ) return false ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^166^^^^^165^179^
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )  )  return  false; 	[BUGGY] if ( o ! = true || getClass ( ) ! = o . getClass ( ) ) return false ; [CE] incomparable types: Object and boolean  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( o ! = true || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^167^^^^^165^179^
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )  )  return  false; 	[BUGGY] if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return true ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^167^^^^^165^179^
[REPLACE]  Tag  tag  =  (  Tag  )  o; 	[BUGGY] Tag tag = tags . get ( tagName ) ; [FE] NullPointerException assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  [ATTENTION] Tag tag = tags . get ( tagName )  ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^169^^^^^165^179^
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false; 	[BUGGY] if ( canContainBlock  = = true ) return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  [ATTENTION] if ( canContainBlock = = true ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^171^^^^^165^179^
[REMOVE]   	[BUGGY] if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) )   return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  [ATTENTION] if ( canContainBlock ! = tag . canContainBlock ) return false ;  if ( ( equals (   "dt  " ) ) && ( equals (   "dd  " ) ) ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^171^^^^^165^179^
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false; 	[BUGGY] if ( canContainInline ! = tag . canContainInline ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  [ATTENTION] if ( canContainInline ! = tag . canContainInline ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^171^^^^^165^179^
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false; 	[BUGGY] if ( canContainBlock ! = tag . canContainBlock ) return true ; [FE]  AssertionFailedError  expected:<17> but was:<19> assertEquals(  "The board’s next fear: the female quota  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  [ATTENTION] if ( canContainBlock ! = tag . canContainBlock ) return true ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^171^^^^^165^179^
[REPLACE]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false; 	[BUGGY] if ( canContainInline  = = true ) return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; [ATTENTION] if ( canContainInline = = true ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^172^^^^^165^179^
[ADD]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false;  if  (  empty  !=  tag  .  empty  )  return  false;  if  (  isBlock  !=  tag  .  isBlock  )  return  false;  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false; 	[BUGGY] if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; [ATTENTION] if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;    return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^172^173^174^175^176^165^179^
[REPLACE]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false; 	[BUGGY] if ( canContainInline ! = tag . canContainInline ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; [ATTENTION] if ( canContainInline ! = tag . canContainInline ) return true ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^172^^^^^165^179^
[REPLACE]  if  (  empty  !=  tag  .  empty  )  return  false; 	[BUGGY] if ( empty  = =  defaultAncestor . empty ) return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; [ATTENTION] if ( empty = = defaultAncestor . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^173^^^^^165^179^
[REPLACE]  if  (  empty  !=  tag  .  empty  )  return  false; 	[BUGGY] if ( empty ! = tag . empty ) return true ; [NO-ERROR]  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; [ATTENTION] if ( empty ! = tag . empty ) return true ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^173^^^^^165^179^
[REPLACE]  if  (  isBlock  !=  tag  .  isBlock  )  return  false; 	[BUGGY] if ( isBlock  = = preserveWhitespace ) return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; [ATTENTION] if ( isBlock = = preserveWhitespace ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^174^^^^^165^179^
[ADD]  if  (  isBlock  !=  tag  .  isBlock  )  return  false;  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true; 	[BUGGY] [CE] missing return statement  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; [ATTENTION]   }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^174^175^176^^178^165^179^
[REPLACE]  if  (  isBlock  !=  tag  .  isBlock  )  return  false; 	[BUGGY] if ( isBlock ! = tag . isBlock ) return true ; [FE]  AssertionFailedError  expected:<[]Replaced> but was:<[Hello ]Replaced> assertEquals(  "Replaced  " , doc.text())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; [ATTENTION] if ( isBlock ! = tag . isBlock ) return true ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^174^^^^^165^179^
[REPLACE]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false; 	[BUGGY] if ( optionalClosing  = =  defaultAncestor . optionalClosing ) return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; [ATTENTION] if ( optionalClosing = = defaultAncestor . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^175^^^^^165^179^
[ADD]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true;  } 	[BUGGY] if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ; return true ; [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; [ATTENTION] if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ; return true ;     	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^175^176^^178^179^165^179^
[REPLACE]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false; 	[BUGGY] if ( optionalClosing ! = tag . optionalClosing ) return true ; [FE]  AssertionFailedError  expected:<[Deprecated]> but was:<[]> assertEquals(  "Deprecated  " , a.text())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; [ATTENTION] if ( optionalClosing ! = tag . optionalClosing ) return true ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^175^^^^^165^179^
[REPLACE]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false; 	[BUGGY] if ( tagName ! =  tag . tagName ! = null ) return false ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; [ATTENTION] if ( tagName ! = tag . tagName ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^176^^^^^165^179^
[ADD]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^176^177^178^179^^165^179^
[REPLACE]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false; 	[BUGGY] if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return true ; [FE]  AssertionFailedError  expected:<17> but was:<18> assertEquals(  "The board’s next fear: the female quota  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; [ATTENTION] if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return true ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^176^^^^^165^179^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE]  AssertionFailedError  expected: org.jsoup.parser.Tag<foo> but was: org.jsoup.parser.Tag<foo> assertEquals(foo , foo2)   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Tag  [TYPE] List ancestors [TYPE] Object o [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null || getClass ( ) ! = o . getClass ( ) ) return false ;  Tag tag =  ( Tag ) o ;  if ( canContainBlock ! = tag . canContainBlock ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( optionalClosing ! = tag . optionalClosing ) return false ; if ( tagName ! = null ? !tagName . equals ( tag . tagName ) : tag . tagName ! = null ) return false ;  [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^178^^^^^165^179^
[REPLACE]  int  result  =  tagName  !=  null  ?  tagName  .  hashCode  (  )  :  0; 	[BUGGY] int result  =  tagName . hashCode ( )  ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { [ATTENTION] int result = tagName . hashCode ( ) ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^183^^^^^182^190^
[REPLACE]  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; [ATTENTION] result = 0 )  ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^184^^^^^182^190^
[REPLACE]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; [ATTENTION] result = 0 )  ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^186^^^^^182^190^
[REPLACE]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ; 	[BUGGY] result  =  1 ; [NO-ERROR]  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; [ATTENTION] result = 1 ; result = 31 * result + ( empty ? 1 : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^187^^^^^182^190^
[REPLACE]  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; [ATTENTION] result = 0 )  ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^188^^^^^182^190^
[REPLACE]  return  result; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = tagName ! = null ? tagName . hashCode ( ) : 0 ; result = 31 * result + ( isBlock ? 1 : 0 ) ; result = 31 * result + ( canContainBlock ? 1 : 0 ) ; result = 31 * result + ( canContainInline ? 1 : 0 ) ; result = 31 * result + ( optionalClosing ? 1 : 0 ) ; result = 31 * result + ( empty ? 1 : 0 ) ; [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^189^^^^^182^190^
[REPLACE]  return  tagName; 	[BUGGY] return tag ; [CE] cannot find symbol tag  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  public String toString ( ) { [ATTENTION] return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^193^^^^^192^194^
[REPLACE]  return  register  (  new  Tag  (  tagName  )  )  ; 	[BUGGY] return ( !ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; [CE] non-static variable ancestors cannot be referenced from a static context  [METHOD]  createBlock [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createBlock ( String tagName ) { [ATTENTION] return ( !ancestors . isEmpty ( ) ) ? ancestors . get ( 0 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^315^^^^^314^316^
[REPLACE]  Tag  inline  =  new  Tag  (  tagName  )  ; 	[BUGGY] Tag tag = tags . get ( tagName ) ; [CE] cannot find symbol inline  [METHOD]  createInline [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createInline ( String tagName ) { [ATTENTION] Tag tag = tags . get ( tagName )  ; inline . isBlock = false ; inline . canContainBlock = false ; return register ( inline ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^319^^^^^318^323^
[REPLACE]  inline  .  isBlock  =  false; 	[BUGGY] inline . isBlock = true ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  createInline [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createInline ( String tagName ) { Tag inline = new Tag ( tagName ) ; [ATTENTION] inline . isBlock = true ; inline . canContainBlock = false ; return register ( inline ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^320^^^^^318^323^
[REPLACE]  inline  .  canContainBlock  =  false; 	[BUGGY] inline . canContainBlock = true ; [FE]  expected:<<pre><code>[code assertEquals(  "code\n\ncode  " , doc.text())   [METHOD]  createInline [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createInline ( String tagName ) { Tag inline = new Tag ( tagName ) ; inline . isBlock = false ; [ATTENTION] inline . canContainBlock = true ; return register ( inline ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^321^^^^^318^323^
[ADD]  inline  .  canContainBlock  =  false; 	[BUGGY] [FE]  expected:<<pre><code>[code assertEquals(  "code\n\ncode  " , doc.text())   [METHOD]  createInline [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createInline ( String tagName ) { Tag inline = new Tag ( tagName ) ; inline . isBlock = false ; [ATTENTION] return register ( inline ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^321^^^^^318^323^
[REPLACE]  return  register  (  inline  )  ; 	[BUGGY] return register ( defaultAncestor ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createInline [TYPE] Tag [PARAMETER] String tagName [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag createInline ( String tagName ) { Tag inline = new Tag ( tagName ) ; inline . isBlock = false ; inline . canContainBlock = false ; [ATTENTION] return register ( defaultAncestor )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^322^^^^^318^323^
[REPLACE]  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ; 	[BUGGY] tag . valueOf ( defaultAncestor . tagName ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  register [TYPE] Tag [PARAMETER] Tag tag [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag register ( Tag tag ) { [ATTENTION] tag . valueOf ( defaultAncestor . tagName )  ; synchronized ( tags ) { tags . put ( tag . tagName , tag ) ; } return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^326^^^^^325^331^
[REMOVE]   	[BUGGY] ancestors . add ( Tag . valueOf ( name ) ) ; [CE] cannot find symbol name  [METHOD]  register [TYPE] Tag [PARAMETER] Tag tag [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag register ( Tag tag ) { [ATTENTION] tag . setAncestor ( defaultAncestor . tagName ) ;  ancestors . add ( Tag . valueOf ( name ) )  ; synchronized ( tags ) { tags . put ( tag . tagName , tag ) ; } return tag ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^326^^^^^325^331^
[REPLACE]  tags  .  put  (  tag  .  tagName,  tag  )  ; 	[BUGGY] tags . put ( defaultAncestor . tagName , tag ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  register [TYPE] Tag [PARAMETER] Tag tag [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag register ( Tag tag ) { tag . setAncestor ( defaultAncestor . tagName ) ; synchronized ( tags ) { [ATTENTION] tags . put ( defaultAncestor . tagName , tag )  ; } return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^328^^^^^325^331^
[ADD]  tags  .  put  (  tag  .  tagName,  tag  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  register [TYPE] Tag [PARAMETER] Tag tag [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag register ( Tag tag ) { tag . setAncestor ( defaultAncestor . tagName ) ; synchronized ( tags ) { [ATTENTION] } return tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^328^^^^^325^331^
[REPLACE]  return  tag; 	[BUGGY] return defaultAncestor ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  register [TYPE] Tag [PARAMETER] Tag tag [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private static Tag register ( Tag tag ) { tag . setAncestor ( defaultAncestor . tagName ) ; synchronized ( tags ) { tags . put ( tag . tagName , tag ) ; } [ATTENTION] return defaultAncestor ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^330^^^^^325^331^
[REPLACE]  canContainBlock  =  false; 	[BUGGY] canContainBlock = true ; [FE]  AssertionFailedError  expected:<...-- comment -->Hello<[/p><p>there]</p></div></body></h...> but was:<...-- comment -->Hello<[p>there</p>]</p></div></body></h...> assertEquals(  "<html><head></head><body><div title = \  "Tags &amp   c.\  "><img src = \  "foo.png\  " /><p><!-- comment -->Hello</p><p>there</p></div></body></html>  " ,  [METHOD]  setContainInlineOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainInlineOnly ( ) { [ATTENTION] canContainBlock = true ; canContainInline = true ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^334^^^^^333^337^
[REPLACE]  canContainInline  =  true; 	[BUGGY] canContainInline = false ; [FE]  AssertionFailedError  expected:<12> but was:<0> assertEquals(  "ipod - Google Search  " , doc.title())   assertEquals(  "http://news.google.com/news?hl = en&q = ipod&um = 1&ie = UTF-8&ei = uYlKS4SbBoGg6gPf-5XXCw&sa = X&oi = news_group&ct = title&resnum = 1&ved = 0CCIQsQQwAA  " , assertEquals(  "http://www.apple.com/itunes/  " ,  [METHOD]  setContainInlineOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainInlineOnly ( ) { canContainBlock = false ; [ATTENTION] canContainInline = false ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^335^^^^^333^337^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setContainInlineOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainInlineOnly ( ) { canContainBlock = false ; canContainInline = true ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^336^^^^^333^337^
[REPLACE]  canContainBlock  =  false; 	[BUGGY] canContainBlock = true ; [FE]  AssertionFailedError  expected:<<textarea>[three]</textarea>> but was:<<textarea>[ assertEquals(2 , els.size())   [METHOD]  setContainDataOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainDataOnly ( ) { [ATTENTION] canContainBlock = true ; canContainInline = false ; preserveWhitespace = true ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^340^^^^^339^344^
[REPLACE]  canContainInline  =  false; 	[BUGGY] canContainInline = true ; [FE]  AssertionFailedError  expected:<[font-family: bold]> but was:<[]> assertEquals(  "font-family: bold  " , tels.get(0).data())   [METHOD]  setContainDataOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainDataOnly ( ) { canContainBlock = false ; [ATTENTION] canContainInline = true ; preserveWhitespace = true ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^341^^^^^339^344^
[REPLACE]  preserveWhitespace  =  true; 	[BUGGY] preserveWhitespace = false ; [NO-ERROR]  [METHOD]  setContainDataOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainDataOnly ( ) { canContainBlock = false ; canContainInline = false ; [ATTENTION] preserveWhitespace = false ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^342^^^^^339^344^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  setContainDataOnly [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setContainDataOnly ( ) { canContainBlock = false ; canContainInline = false ; preserveWhitespace = true ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^343^^^^^339^344^
[REPLACE]  canContainBlock  =  false; 	[BUGGY] canContainBlock = true ; [NO-ERROR]  [METHOD]  setEmpty [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setEmpty ( ) { [ATTENTION] canContainBlock = true ; canContainInline = false ; empty = true ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^347^^^^^346^351^
[REPLACE]  canContainInline  =  false; 	[BUGGY] canContainInline = true ; [NO-ERROR]  [METHOD]  setEmpty [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setEmpty ( ) { canContainBlock = false ; [ATTENTION] canContainInline = true ; empty = true ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^348^^^^^346^351^
[REPLACE]  empty  =  true; 	[BUGGY] empty = false ; [FE]  AssertionFailedError  expected:<[Yahoo! JAPAN]> but was:<[]> assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setEmpty [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setEmpty ( ) { canContainBlock = false ; canContainInline = false ; [ATTENTION] empty = false ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^349^^^^^346^351^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  setEmpty [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setEmpty ( ) { canContainBlock = false ; canContainInline = false ; empty = true ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^350^^^^^346^351^
[REPLACE]  optionalClosing  =  true; 	[BUGGY] optionalClosing = false ; [FE]  AssertionFailedError  expected:<2> but was:<1> assertEquals(1 , ol.size())   // one p in first li  [METHOD]  setOptionalClosing [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setOptionalClosing ( ) { [ATTENTION] optionalClosing = false ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^354^^^^^353^356^
[ADD]  optionalClosing  =  true; 	[BUGGY] [FE]  AssertionFailedError  expected:<2> but was:<1> assertEquals(1 , ol.size())   // one p in first li  [METHOD]  setOptionalClosing [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setOptionalClosing ( ) { [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^354^^^^^353^356^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  setOptionalClosing [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setOptionalClosing ( ) { optionalClosing = true ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^355^^^^^353^356^
[REPLACE]  preserveWhitespace  =  true; 	[BUGGY] preserveWhitespace = false ; [FE]  expected:<code[ assertEquals(  "code\n\ncode  " , doc.text())   [METHOD]  setPreserveWhitespace [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setPreserveWhitespace ( ) { [ATTENTION] preserveWhitespace = false ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^359^^^^^358^361^
[REPLACE]  return  this; 	[BUGGY] return null ; [NO-ERROR]  [METHOD]  setPreserveWhitespace [TYPE] Tag [PARAMETER] [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String tagName [TYPE] Map tags  [CONTEXT]  private Tag setPreserveWhitespace ( ) { preserveWhitespace = true ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^360^^^^^358^361^
[REPLACE]  if  (  tagNames  ==  null  )  { 	[BUGGY] if ( tagNames ! = null ) {[FE]  AssertionFailedError  expected:<[]Replaced> but was:<[Hello ]Replaced> assertEquals(  "Replaced  " , doc.text())   [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { [ATTENTION] if ( tagNames ! = null ) { ancestors = Collections . emptyList ( ) ; } else { ancestors = new ArrayList<Tag> ( tagNames . length ) ; for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^364^^^^^363^373^
[REPLACE]  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ; 	[BUGGY] ancestors =  new ArrayList<Tag> ( null . length ) ; [CE] <null> cannot be dereferenced  [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { ancestors = Collections . emptyList ( ) ; } else { [ATTENTION] ancestors = new ArrayList<Tag> ( null . length )  ; for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^367^^^^^363^373^
[ADD]  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { ancestors = Collections . emptyList ( ) ; } else { [ATTENTION] for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^367^^^^^363^373^
[REPLACE]  for  (  String  name  :  tagNames  )  { 	[BUGGY] Tag tag = tags . get ( tagName ) ; [CE] illegal start of type  [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { ancestors = Collections . emptyList ( ) ; } else { ancestors = new ArrayList<Tag> ( tagNames . length ) ; [ATTENTION] Tag tag = tags . get ( tagName )  ; ancestors . add ( Tag . valueOf ( name ) ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^368^^^^^363^373^
[REPLACE]  ancestors  =  Collections  .  emptyList  (  )  ; 	[BUGGY] ancestors  =  ancestors ; [NO-ERROR]  [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { [ATTENTION] ancestors = ancestors ; } else { ancestors = new ArrayList<Tag> ( tagNames . length ) ; for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^365^^^^^363^373^
[ADD]  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  } 	[BUGGY] [FE]  AssertionFailedError  expected:<[]Replaced> but was:<[Hello ]Replaced> assertEquals(  "Replaced  " , doc.text())   [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { ancestors = Collections . emptyList ( ) ; } else { ancestors = new ArrayList<Tag> ( tagNames . length ) ; [ATTENTION]  } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^368^369^370^^^363^373^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setAncestor [TYPE] Tag [PARAMETER] tagNames [CLASS] Tag  [TYPE] List ancestors [TYPE] boolean canContainBlock canContainInline empty false isBlock optionalClosing preserveWhitespace true [TYPE] Tag child defaultAncestor inline tag [TYPE] String name tagName [TYPE] String[] tagNames [TYPE] Map tags  [CONTEXT]  private Tag setAncestor ( String . . . tagNames ) { if ( tagNames = = null ) { ancestors = Collections . emptyList ( ) ; } else { ancestors = new ArrayList<Tag> ( tagNames . length ) ; for ( String name : tagNames ) { ancestors . add ( Tag . valueOf ( name ) ) ; } } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Tag.java^372^^^^^363^373^
[REPLACE]  Validate  .  notNull  (  data  )  ; 	[BUGGY] data  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String data [CLASS] TokenQueue  [TYPE] char c [TYPE] String data [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] char[] chars  [CONTEXT]  public TokenQueue ( String data ) { [ATTENTION] data ;  queue = new LinkedList<Character> ( ) ; char[] chars = data . toCharArray ( ) ; for ( char c : chars ) { queue . add ( c ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^21^^^^^20^28^
[REPLACE]  queue  =  new  LinkedList<Character>  (  )  ; 	[BUGGY] queue ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String data [CLASS] TokenQueue  [TYPE] char c [TYPE] String data [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] char[] chars  [CONTEXT]  public TokenQueue ( String data ) { Validate . notNull ( data ) ;  [ATTENTION] queue ; char[] chars = data . toCharArray ( ) ; for ( char c : chars ) { queue . add ( c ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^23^^^^^20^28^
[REPLACE]  char[]  chars  =  data  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = seq . toCharArray ( ) ; [CE] cannot find symbol seq  [METHOD]  <init> [TYPE] String) [PARAMETER] String data [CLASS] TokenQueue  [TYPE] char c [TYPE] String data [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] char[] chars  [CONTEXT]  public TokenQueue ( String data ) { Validate . notNull ( data ) ;  queue = new LinkedList<Character> ( ) ; [ATTENTION] char[] chars = seq . toCharArray ( )  ; for ( char c : chars ) { queue . add ( c ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^24^^^^^20^28^
[REPLACE]  for  (  char  c  :  chars  )  { 	[BUGGY] for ( char c : chars ) { queue . add ( c ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String data [CLASS] TokenQueue  [TYPE] char c [TYPE] String data [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] char[] chars  [CONTEXT]  public TokenQueue ( String data ) { Validate . notNull ( data ) ;  queue = new LinkedList<Character> ( ) ; char[] chars = data . toCharArray ( ) ; [ATTENTION] for ( char c : chars ) { queue . add ( c )  ; queue . add ( c ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^25^^^^^20^28^
[REPLACE]  return  queue  .  isEmpty  (  )  ; 	[BUGGY] return queue . toString ( )  ; [CE] incompatible types  [METHOD]  isEmpty [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public boolean isEmpty ( ) { [ATTENTION] return queue . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^35^^^^^34^36^
[REPLACE]  return  queue  .  peek  (  )  ; 	[BUGGY] return queue . removeFirst ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  peek [TYPE] Character [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public Character peek ( ) { [ATTENTION] return queue . removeFirst ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^43^^^^^42^44^
[REPLACE]  queue  .  addFirst  (  c  )  ; 	[BUGGY] queue . add ( c ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addFirst [TYPE] void [PARAMETER] Character c [CLASS] TokenQueue  [TYPE] Character c [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public void addFirst ( Character c ) { [ATTENTION] queue . add ( c )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^51^^^^^50^52^
[REPLACE]  char[]  chars  =  seq  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = seq . length ( ) ; [CE] incompatible types  [METHOD]  addFirst [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i [TYPE] char[] chars  [CONTEXT]  public void addFirst ( String seq ) { [ATTENTION] char[] chars = seq . length ( )  ; for ( int i = chars . length - 1 ; i > = 0 ; i-- ) { addFirst ( chars[i] ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^59^^^^^58^63^
[REPLACE]  for  (  int  i  =  chars  .  length  -  1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = chars . length % 2 - 1 ; i > = 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addFirst [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i [TYPE] char[] chars  [CONTEXT]  public void addFirst ( String seq ) { char[] chars = seq . toCharArray ( ) ; [ATTENTION] for ( int i = chars . length %2 - 1 ; i > = 0 ; i-- ) { addFirst ( chars[i] ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^60^^^^^58^63^
[REPLACE]  addFirst  (  chars[i]  )  ; 	[BUGGY] queue . addFirst ( c ) ; [CE] cannot find symbol c  [METHOD]  addFirst [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i [TYPE] char[] chars  [CONTEXT]  public void addFirst ( String seq ) { char[] chars = seq . toCharArray ( ) ; for ( int i = chars . length - 1 ; i > = 0 ; i-- ) { [ATTENTION] queue . addFirst ( c )  ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^61^^^^^58^63^
[REPLACE]  for  (  int  i  =  chars  .  length  -  1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = chars . length - 5 - 1 ; i > = 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addFirst [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i [TYPE] char[] chars  [CONTEXT]  public void addFirst ( String seq ) { char[] chars = seq . toCharArray ( ) ; [ATTENTION] for ( int i = chars . length - 5 - 1 ; i > = 0 ; i-- ) { addFirst ( chars[i] ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^60^^^^^58^63^
[REPLACE]  int  len  =  seq  .  length  (  )  ; 	[BUGGY] int len = seq . toCharArray ( ) ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { [ATTENTION] int len = seq . toCharArray ( )  ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^71^^^^^70^83^
[REPLACE]  if  (  len  >  queue  .  size  (  )  )  return  false; 	[BUGGY] if ( len > queue . size ( ) % 0 . 5 ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; [ATTENTION] if ( len > queue . size ( ) %0 . 5 ) return false ;  List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^72^73^^^^70^83^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) [ATTENTION] return true ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^73^^^^^70^83^
[REPLACE]  List<Character>  chars  =  queue  .  subList  (  0,  len  )  ; 	[BUGGY] List<Character> chars = queue . subList ( 0 - 1 , len ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; [ATTENTION] List<Character> chars = queue . subList ( 0 - 1 , len )  ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^74^^^^^70^83^
[ADD]  List<Character>  chars  =  queue  .  subList  (  0,  len  )  ; 	[BUGGY] [CE] cannot find symbol chars  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; [ATTENTION] char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^74^^^^^70^83^
[REPLACE]  char[]  seqChars  =  seq  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = seq . toCharArray ( ) ; [CE] variable chars is already defined in method matches(String)  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; [ATTENTION] char[] chars = seq . toCharArray ( )  ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^75^^^^^70^83^
[REPLACE]  if  (  !found  .  equals  (  check  )  )  return  false; 	[BUGGY] if ( !found . equals ( check ) ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; [ATTENTION] if ( !found . equals ( check ) ) return true ;  } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^79^80^^^^70^83^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) [ATTENTION] return true ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^80^^^^^70^83^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  { 	[BUGGY] for ( int i = 0 ; i > len ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; [ATTENTION] for ( int i = 0 ; i>len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^76^^^^^70^83^
[REPLACE]  if  (  !found  .  equals  (  check  )  )  return  false; 	[BUGGY] if ( !found . toLowerCase ( check ) ) return true ; [CE] bad operand type char for unary operator '!'  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; [ATTENTION] if ( !found . toLowerCase ( check ) ) return true ;  } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^79^80^^^^70^83^
[REPLACE]  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ; 	[BUGGY] Character found = Character . toLowerCase ( null . get ( i ) ) ; [CE] <null> cannot be dereferenced  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { [ATTENTION] Character found = Character . toLowerCase ( null . get ( i ) )  ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^77^^^^^70^83^
[REPLACE]  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ; 	[BUGGY] Character check = Character . isWhitespace ( null )  ; [CE] no suitable method found for isWhitespace(<null>)  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; [ATTENTION] Character check = Character . isWhitespace ( null ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^78^^^^^70^83^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  { 	[BUGGY] for ( int i = 2 ; i < len ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; [ATTENTION] for ( int i = 2 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^76^^^^^70^83^
[REPLACE]  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ; 	[BUGGY] Character found = Character . toLowerCase ( this . get ( i ) ) ; [CE] cannot find symbol  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { [ATTENTION] Character found = Character . toLowerCase ( this . get ( i ) )  ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^77^^^^^70^83^
[REPLACE]  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ; 	[BUGGY] Character check = Character . isWhitespace ( true )  ; [CE] no suitable method found for isWhitespace(boolean)  [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; [ATTENTION] Character check = Character . isWhitespace ( true ) ; if ( !found . equals ( check ) ) return false ; } return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^78^^^^^70^83^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] Character check found [TYPE] List chars [TYPE] String seq [TYPE] LinkedList queue [TYPE] int i len [TYPE] char[] seqChars  [CONTEXT]  public boolean matches ( String seq ) { int len = seq . length ( ) ; if ( len > queue . size ( ) ) return false ; List<Character> chars = queue . subList ( 0 , len ) ; char[] seqChars = seq . toCharArray ( ) ; for ( int i = 0 ; i < len ; i++ ) { Character found = Character . toLowerCase ( chars . get ( i ) ) ; Character check = Character . toLowerCase ( seqChars[i] ) ; if ( !found . equals ( check ) ) return false ; } [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^82^^^^^70^83^
[REPLACE]  if  (  matches  (  s  )  )  return  true; 	[BUGGY] if ( matches ( s ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matchesAny [TYPE] boolean [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] String s [TYPE] boolean false true [TYPE] LinkedList queue  [CONTEXT]  public boolean matchesAny ( String . . . seq ) { for ( String s : seq ) { [ATTENTION] if ( matches ( s ) ) return false ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^92^93^^^^90^96^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matchesAny [TYPE] boolean [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] String s [TYPE] boolean false true [TYPE] LinkedList queue  [CONTEXT]  public boolean matchesAny ( String . . . seq ) { for ( String s : seq ) { if ( matches ( s ) ) [ATTENTION] return false ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^93^^^^^90^96^
[REPLACE]  for  (  String  s  :  seq  )  { 	[BUGGY] for ( char c : chars ) { queue . add ( c ) ; [CE] cannot find symbol chars  [METHOD]  matchesAny [TYPE] boolean [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] String s [TYPE] boolean false true [TYPE] LinkedList queue  [CONTEXT]  public boolean matchesAny ( String . . . seq ) { [ATTENTION] for ( char c : chars ) { queue . add ( c )  ; if ( matches ( s ) ) return true ; } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^91^^^^^90^96^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matchesAny [TYPE] boolean [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] String s [TYPE] boolean false true [TYPE] LinkedList queue  [CONTEXT]  public boolean matchesAny ( String . . . seq ) { for ( String s : seq ) { if ( matches ( s ) ) return true ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^95^^^^^90^96^
[REPLACE]  if  (  matches  (  seq  )  )  { 	[BUGGY] if ( !found . equals ( check ) ) return false ; [CE] illegal start of type  [METHOD]  matchChomp [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String seq [TYPE] boolean false true  [CONTEXT]  public boolean matchChomp ( String seq ) { [ATTENTION] if ( !found . equals ( check ) ) return false ; consume ( seq ) ; return true ; } else { return false ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^105^^^^^104^111^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matchChomp [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String seq [TYPE] boolean false true  [CONTEXT]  public boolean matchChomp ( String seq ) { if ( matches ( seq ) ) { consume ( seq ) ; return true ; } else { [ATTENTION] return true ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^109^^^^^104^111^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matchChomp [TYPE] boolean [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String seq [TYPE] boolean false true  [CONTEXT]  public boolean matchChomp ( String seq ) { if ( matches ( seq ) ) { consume ( seq ) ; [ATTENTION] return false ; } else { return false ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^107^^^^^104^111^
[REPLACE]  return  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  ; 	[BUGGY] return !queue . isEmpty ( ) &&  queue . peek ( )  ; [CE] bad operand types for binary operator '&&'  [METHOD]  matchesWhitespace [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public boolean matchesWhitespace ( ) { [ATTENTION] return !queue . isEmpty ( ) && queue . peek ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^118^^^^^117^119^
[REPLACE]  return  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ; 	[BUGGY] returntrue ( )  ; [CE] cannot find symbol  [METHOD]  matchesWord [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public boolean matchesWord ( ) { [ATTENTION] returntrue ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^126^^^^^125^127^
[REPLACE]  return  queue  .  removeFirst  (  )  ; 	[BUGGY] return queue . LinkedList ( ) ; [CE] cannot find symbol  [METHOD]  consume [TYPE] Character [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public Character consume ( ) { [ATTENTION] return queue . LinkedList ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^134^^^^^133^135^
[REPLACE]  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] if ( len > queue . size ( ) ) throw new IllegalStateException (  "   ")  ; [CE] cannot find symbol len  [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { [ATTENTION] if ( len > queue . size ( ) ) throw new IllegalStateException (   "   " ) ;  int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^145^146^^^^144^153^
[REMOVE]   	[BUGGY] if ( len > ( queue . size ( ) ) )   throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; [CE] cannot find symbol len  [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { [ATTENTION] if ( !matches ( seq ) )  if ( len > ( queue . size ( ) ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " )  ; throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^145^^^^^144^153^
[REPLACE]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) [ATTENTION] return ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^146^^^^^144^153^
[ADD]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] [CE] '.class' expected  [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) [ATTENTION] int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^146^^^^^144^153^
[REPLACE]  int  len  =  seq  .  length  (  )  ; 	[BUGGY] int len = seq . toCharArray ( ) ; [CE] incompatible types  [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; [ATTENTION] int len = seq . toCharArray ( )  ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^147^^^^^144^153^
[ADD]  int  len  =  seq  .  length  (  )  ; 	[BUGGY] [CE] cannot find symbol len  [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; [ATTENTION] if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^147^^^^^144^153^
[REPLACE]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] if ( len > queue . size ( ) + 1 ) throw new IllegalStateException  (   "   " )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; [ATTENTION] if ( len > queue . size ( ) + 1 ) throw new IllegalStateException (   "   " )  ;  for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^148^149^^^^144^153^
[ADD]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (  "    ")  ;  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; [ATTENTION]   }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^148^149^150^151^152^144^153^
[REPLACE]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) [ATTENTION] return ; for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^149^^^^^144^153^
[ADD]  throw  new  IllegalStateException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) [ATTENTION] for ( int i = 0 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^149^^^^^144^153^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  { 	[BUGGY] for ( int i = 2 ; i > =  len ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; [ATTENTION] for ( int i = 2 ; i> = len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^150^^^^^144^153^
[ADD]  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^150^151^152^^^144^153^
[REPLACE]  consume  (  )  ; 	[BUGGY] consume ( seq ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; for ( int i = 0 ; i < len ; i++ ) { [ATTENTION] consume ( seq )  ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^151^^^^^144^153^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  { 	[BUGGY] for ( int i = 4 ; i < len ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consume [TYPE] void [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] String seq [TYPE] boolean false true [TYPE] LinkedList queue [TYPE] int i len  [CONTEXT]  public void consume ( String seq ) { if ( !matches ( seq ) ) throw new IllegalStateException (   "Queue did not match expected sequence  " ) ; int len = seq . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException (   "Queue not long enough to consume sequence  " ) ; [ATTENTION] for ( int i = 4 ; i < len ; i++ ) { consume ( ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^150^^^^^144^153^
[REPLACE]  return  consumeToAny  (  seq  )  ; 	[BUGGY] return data ; [CE] cannot find symbol data  [METHOD]  consumeTo [TYPE] String [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String seq [TYPE] boolean false true  [CONTEXT]  public String consumeTo ( String seq ) { [ATTENTION] return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^161^^^^^160^162^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder wordAccum = new StringBuilder ( ) ; [CE] cannot find symbol accum  [METHOD]  consumeToAny [TYPE] String [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] LinkedList queue  [CONTEXT]  public String consumeToAny ( String . . . seq ) { [ATTENTION] StringBuilder wordAccum = new StringBuilder ( )  ; while ( !queue . isEmpty ( ) && !matchesAny ( seq ) ) accum . append ( consume ( ) ) ;  return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^170^^^^^169^175^
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ; 	[BUGGY] while (true ( )  ; [CE] ')' expected  [METHOD]  consumeToAny [TYPE] String [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] LinkedList queue  [CONTEXT]  public String consumeToAny ( String . . . seq ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] while ( true ( ) ;  return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^171^172^^^^169^175^
[ADD]  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeToAny [TYPE] String [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] LinkedList queue  [CONTEXT]  public String consumeToAny ( String . . . seq ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION]  return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^171^172^^^^169^175^
[REPLACE]  accum  .  append  (  consume  (  )  )  ; 	[BUGGY] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; [CE] illegal start of expression  [METHOD]  consumeToAny [TYPE] String [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] LinkedList queue  [CONTEXT]  public String consumeToAny ( String . . . seq ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && !matchesAny ( seq ) ) [ATTENTION] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) )  ;  return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^172^^^^^169^175^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  consumeToAny [TYPE] String [PARAMETER] seq [CLASS] TokenQueue  [TYPE] String[] seq [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] LinkedList queue  [CONTEXT]  public String consumeToAny ( String . . . seq ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && !matchesAny ( seq ) ) accum . append ( consume ( ) ) ;  [ATTENTION] return accum . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^174^^^^^169^175^
[REPLACE]  String  data  =  consumeTo  (  seq  )  ; 	[BUGGY] List<Character> chars = queue . subList ( 0 , len ) ; [CE] cannot find symbol len  [METHOD]  chompTo [TYPE] String [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String data seq [TYPE] boolean false true  [CONTEXT]  public String chompTo ( String seq ) { [ATTENTION] List<Character> chars = queue . subList ( 0 , len )  ; matchChomp ( seq ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^186^^^^^185^189^
[REPLACE]  matchChomp  (  seq  )  ; 	[BUGGY] consume ( seq ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  chompTo [TYPE] String [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String data seq [TYPE] boolean false true  [CONTEXT]  public String chompTo ( String seq ) { String data = consumeTo ( seq ) ; [ATTENTION] consume ( seq )  ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^187^^^^^185^189^
[REPLACE]  return  data; 	[BUGGY] return consumeToAny ( seq ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  chompTo [TYPE] String [PARAMETER] String seq [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] String data seq [TYPE] boolean false true  [CONTEXT]  public String chompTo ( String seq ) { String data = consumeTo ( seq ) ; matchChomp ( seq ) ; [ATTENTION] return consumeToAny ( seq )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^188^^^^^185^189^
[REPLACE]  boolean  seen  =  false; 	[BUGGY] boolean seen = true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeWhitespace [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false seen true  [CONTEXT]  public boolean consumeWhitespace ( ) { [ATTENTION] boolean seen = true ; while ( !queue . isEmpty ( ) && Character . isWhitespace ( queue . peek ( ) ) ) { consume ( ) ; seen = true ; } return seen ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^195^^^^^194^201^
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  { 	[BUGGY] while ( !queue . isEmpty ( )  || Character . isWhitespace ( queue . peek ( ) ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeWhitespace [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false seen true  [CONTEXT]  public boolean consumeWhitespace ( ) { boolean seen = false ; [ATTENTION] while ( !queue . isEmpty ( ) ||Character . isWhitespace ( queue . peek ( ) ) ) { consume ( ) ; seen = true ; } return seen ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^196^^^^^194^201^
[REPLACE]  seen  =  true; 	[BUGGY] seen = false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeWhitespace [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false seen true  [CONTEXT]  public boolean consumeWhitespace ( ) { boolean seen = false ; while ( !queue . isEmpty ( ) && Character . isWhitespace ( queue . peek ( ) ) ) { consume ( ) ; [ATTENTION] seen = false ; } return seen ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^198^^^^^194^201^
[REPLACE]  return  seen; 	[BUGGY] return data ; [CE] cannot find symbol data  [METHOD]  consumeWhitespace [TYPE] boolean [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false seen true  [CONTEXT]  public boolean consumeWhitespace ( ) { boolean seen = false ; while ( !queue . isEmpty ( ) && Character . isWhitespace ( queue . peek ( ) ) ) { consume ( ) ; seen = true ; } [ATTENTION] return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^200^^^^^194^201^
[REPLACE]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder accum = new StringBuilder ( ) ; [CE] cannot find symbol wordAccum  [METHOD]  consumeWord [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder wordAccum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeWord ( ) { [ATTENTION] StringBuilder accum = new StringBuilder ( )  ; while ( !queue . isEmpty ( ) && Character . isLetterOrDigit ( queue . peek ( ) ) ) { wordAccum . append ( queue . removeFirst ( ) ) ; } return wordAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^208^^^^^207^213^
[ADD]  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  consumeWord [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder wordAccum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeWord ( ) { StringBuilder wordAccum = new StringBuilder ( ) ; [ATTENTION]  } return wordAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^209^210^^^^207^213^
[REPLACE]  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ; 	[BUGGY] wordAccum . append ( queue . addFirst ( 1 )  ) ; [CE] method addFirst in class LinkedList<E> cannot be applied to given types ;  [METHOD]  consumeWord [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder wordAccum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeWord ( ) { StringBuilder wordAccum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && Character . isLetterOrDigit ( queue . peek ( ) ) ) { [ATTENTION] wordAccum . append ( queue . addFirst ( 1 )  )  ; } return wordAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^210^^^^^207^213^
[REPLACE]  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ; 	[BUGGY] wordAccum . append ( queue . addFirst ( null )  ) ; [CE] 'void' type not allowed here  [METHOD]  consumeWord [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder wordAccum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeWord ( ) { StringBuilder wordAccum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && Character . isLetterOrDigit ( queue . peek ( ) ) ) { [ATTENTION] wordAccum . append ( queue . addFirst ( null )  )  ; } return wordAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^210^^^^^207^213^
[REPLACE]  return  wordAccum  .  toString  (  )  ; 	[BUGGY] return wordAccum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  consumeWord [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder wordAccum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeWord ( ) { StringBuilder wordAccum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && Character . isLetterOrDigit ( queue . peek ( ) ) ) { wordAccum . append ( queue . removeFirst ( ) ) ; } [ATTENTION] return wordAccum . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^212^^^^^207^213^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder wordAccum = new StringBuilder ( ) ; [CE] cannot find symbol accum  [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { [ATTENTION] StringBuilder wordAccum = new StringBuilder ( )  ; Character c = queue . peek ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^221^^^^^220^228^
[REPLACE]  Character  c  =  queue  .  peek  (  )  ; 	[BUGGY] Character c = queue . size ( ) ; [CE] incompatible types  [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] Character c = queue . size ( )  ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^222^^^^^220^228^
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  { 	[BUGGY] while ( !queue . isEmpty ( ) || ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; [ATTENTION] while ( !queue . isEmpty ( ) || ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^223^^^^^220^228^
[REPLACE]  c  =  queue  .  peek  (  )  ; 	[BUGGY] c  =  c ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; [ATTENTION] c = c ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^225^^^^^220^228^
[ADD]  c  =  queue  .  peek  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; [ATTENTION] } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^225^^^^^220^228^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  consumeCssIdentifier [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Character c [TYPE] LinkedList queue  [CONTEXT]  public String consumeCssIdentifier ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( c ) || c . equals ( '-' ) || c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } [ATTENTION] return accum . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^227^^^^^220^228^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder wordAccum = new StringBuilder ( ) ; [CE] cannot find symbol accum  [METHOD]  consumeAttributeKey [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeAttributeKey ( ) { [ATTENTION] StringBuilder wordAccum = new StringBuilder ( )  ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) { accum . append ( queue . removeFirst ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^235^^^^^234^240^
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (    "-  ",    "_  ",    ":  "  )  )  )  { 	[BUGGY] while ( !queue . isEmpty ( )  ! =  ( Character . isWhitespace ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  consumeAttributeKey [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] while ( !queue . isEmpty ( ) ! =  ( Character . isWhitespace ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) { accum . append ( queue . removeFirst ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^236^^^^^234^240^
[REPLACE]  accum  .  append  (  queue  .  removeFirst  (  )  )  ; 	[BUGGY] accum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  consumeAttributeKey [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) { [ATTENTION] accum . StringBuilder ( ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^237^^^^^234^240^
[REPLACE]  accum  .  append  (  queue  .  removeFirst  (  )  )  ; 	[BUGGY] accum . append ( queue . LinkedList ( ) ) ; [CE] cannot find symbol  [METHOD]  consumeAttributeKey [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) { [ATTENTION] accum . append ( queue . LinkedList ( ) )  ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^237^^^^^234^240^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  consumeAttributeKey [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String consumeAttributeKey ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) && ( Character . isLetterOrDigit ( queue . peek ( ) ) || matchesAny (   "-  " ,   "_  " ,   ":  " ) ) ) { accum . append ( queue . removeFirst ( ) ) ; } [ATTENTION] return accum . StringBuilder ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^239^^^^^234^240^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder wordAccum = new StringBuilder ( ) ; [CE] cannot find symbol accum  [METHOD]  remainder [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String remainder ( ) { [ATTENTION] StringBuilder wordAccum = new StringBuilder ( )  ; while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^247^^^^^246^252^
[ADD]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] [CE] cannot find symbol accum  [METHOD]  remainder [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String remainder ( ) { [ATTENTION] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^247^^^^^246^252^
[REPLACE]  accum  .  append  (  consume  (  )  )  ; 	[BUGGY] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; [CE] illegal start of expression  [METHOD]  remainder [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String remainder ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) ) { [ATTENTION] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) )  ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^249^^^^^246^252^
[REMOVE]   	[BUGGY] while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; [CE] illegal start of expression  [METHOD]  remainder [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String remainder ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) ) { [ATTENTION] accum . append ( consume ( ) ) ;  while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) )  ; } return accum . toString ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^249^^^^^246^252^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  remainder [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] StringBuilder accum [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String remainder ( ) { StringBuilder accum = new StringBuilder ( ) ; while ( !queue . isEmpty ( ) ) { accum . append ( consume ( ) ) ; } [ATTENTION] return accum . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^251^^^^^246^252^
[REPLACE]  return  queue  .  toString  (  )  ; 	[BUGGY] return queue . isEmpty ( ) ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] TokenQueue  [TYPE] LinkedList queue [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return queue . isEmpty ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/TokenQueue.java^255^^^^^254^256^
[REPLACE]  private  static  final  String  SQ  =    "'  "; 	[BUGGY] private static  int SQ =   "'  " ; [CE] incompatible types  [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^13^^^^^^^
[REPLACE]  private  static  final  String  DQ  =    "\  "  "; 	[BUGGY] private static final double DQ =   "\  "  " ; [CE] incompatible types  [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^14^^^^^^^
[REPLACE]  private  static  final  Tag  htmlTag  =  Tag  .  valueOf  (    "html  "  )  ; 	[BUGGY] private static final Tag htmlTag  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^16^^^^^^^
[REPLACE]  private  static  final  Tag  headTag  =  Tag  .  valueOf  (    "head  "  )  ; 	[BUGGY] private static Tag headTag = Tag . valueOf (   "head  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^17^^^^^^^
[REPLACE]  private  static  final  Tag  bodyTag  =  Tag  .  valueOf  (    "body  "  )  ; 	[BUGGY] private static final Tag bodyTag ; [CE] variable bodyTag might not have been initialized  [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^18^^^^^^^
[REPLACE]  private  static  final  Tag  titleTag  =  Tag  .  valueOf  (    "title  "  )  ; 	[BUGGY] private static final Tag titleTag ; [CE] variable titleTag might not have been initialized  [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^19^^^^^^^
[REPLACE]  private  static  final  Tag  textareaTag  =  Tag  .  valueOf  (    "textarea  "  )  ; 	[BUGGY] private static final Tag textareaTag  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^20^^^^^^^
[REPLACE]  private  final  LinkedList<Element>  stack; 	[BUGGY] private LinkedList<Element> stack ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^22^^^^^^^
[REPLACE]  private  final  TokenQueue  tq; 	[BUGGY] private TokenQueue tq ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Parser  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^23^^^^^^^
[REPLACE]  Validate  .  notNull  (  html  )  ; 	[BUGGY] html  ; [CE] not a statement  [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { [ATTENTION] html ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^28^^^^^27^42^
[REPLACE]  Validate  .  notNull  (  baseUri  )  ; 	[BUGGY] Validate . notNull ( SQ ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; [ATTENTION] Validate . notNull ( SQ )  ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^29^^^^^27^42^
[REPLACE]  stack  =  new  LinkedList<Element>  (  )  ; 	[BUGGY] stack  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  [ATTENTION] stack = null ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^31^^^^^27^42^
[REPLACE]  tq  =  new  TokenQueue  (  html  )  ; 	[BUGGY] tq =  new TokenQueue ( null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; [ATTENTION] tq = new TokenQueue ( null )  ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^32^^^^^27^42^
[ADD]  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri; 	[BUGGY] this . baseUri = baseUri ; [CE] variable tq might not have been initialized  [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; [ATTENTION] this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^32^33^^^^27^42^
[REPLACE]  this  .  baseUri  =  baseUri; 	[BUGGY] this . baseUri =  SQ ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; [ATTENTION] this . baseUri = SQ ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^33^^^^^27^42^
[REPLACE]  if  (  isBodyFragment  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  [ATTENTION] if ( true ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^35^^^^^27^42^
[REPLACE]  doc  =  new  Document  (  baseUri  )  ; 	[BUGGY] doc =  new Document ( SQ ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { [ATTENTION] doc = new Document ( SQ )  ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^39^^^^^27^42^
[ADD]  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ; 	[BUGGY] stack . add ( doc ) ; [CE] variable doc might not have been initialized  [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { doc = Document . createShell ( baseUri ) ; stack . add ( doc . body ( ) ) ; } else { [ATTENTION] stack . add ( doc )  ;  } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^39^40^^^^27^42^
[REPLACE]  doc  =  Document  .  createShell  (  baseUri  )  ; 	[BUGGY] doc =  Document . createShell ( SQ ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String html String baseUri boolean isBodyFragment [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false isBodyFragment true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Parser ( String html , String baseUri , boolean isBodyFragment ) { Validate . notNull ( html ) ; Validate . notNull ( baseUri ) ;  stack = new LinkedList<Element> ( ) ; tq = new TokenQueue ( html ) ; this . baseUri = baseUri ;  if ( isBodyFragment ) { [ATTENTION] doc = Document . createShell ( SQ )  ; stack . add ( doc . body ( ) ) ; } else { doc = new Document ( baseUri ) ; stack . add ( doc ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^36^^^^^27^42^
[REPLACE]  Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ; 	[BUGGY] Parser parser = new Parser ( html , baseUri , true ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] String html String baseUri [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] Parser parser  [CONTEXT]  public static Document parse ( String html , String baseUri ) { [ATTENTION] Parser parser = new Parser ( html , baseUri , true )  ; return parser . parse ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^51^^^^^50^53^
[REPLACE]  return  parser  .  parse  (  )  ; 	[BUGGY] return . lastr . parse ( ) ; [CE] illegal start of expression  [METHOD]  parse [TYPE] Document [PARAMETER] String html String baseUri [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] String DQ SQ baseUri html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] Parser parser  [CONTEXT]  public static Document parse ( String html , String baseUri ) { Parser parser = new Parser ( html , baseUri , false ) ; [ATTENTION] return . lastr . parse ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^52^^^^^50^53^
[REPLACE]  Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ; 	[BUGGY] Parser parser = new Parser ( bodyHtml , baseUri , false ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseBodyFragment [TYPE] Document [PARAMETER] String bodyHtml String baseUri [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] Parser parser  [CONTEXT]  public static Document parseBodyFragment ( String bodyHtml , String baseUri ) { [ATTENTION] Parser parser = new Parser ( bodyHtml , baseUri , false )  ; return parser . parse ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^62^^^^^61^64^
[REPLACE]  return  parser  .  parse  (  )  ; 	[BUGGY] return parser . parse ( SQ , DQ )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseBodyFragment [TYPE] Document [PARAMETER] String bodyHtml String baseUri [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] Parser parser  [CONTEXT]  public static Document parseBodyFragment ( String bodyHtml , String baseUri ) { Parser parser = new Parser ( bodyHtml , baseUri , true ) ; [ATTENTION] return parser . parse ( SQ , DQ ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^63^^^^^61^64^
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( tq . isEmpty ( ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { [ATTENTION] while ( tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^67^^^^^66^83^
[REPLACE]  if  (  tq  .  matches  (    "<!--  "  )  )  { 	[BUGGY] if ( tq . matches (   "<--  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { [ATTENTION] if ( tq . matches (   "<--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^68^^^^^66^83^
[REMOVE]   	[BUGGY] if ( tq . matches (   "<![CDATA[  " ) ) {   parseCdata ( ) ; }else   if ( ( tq . matches (   "<?  " ) ) || ( tq . matches (   "<!  " ) ) ) {     parseXmlDecl ( ) ;   }else     if ( tq . matches (   "</  " ) ) {       parseEndTag ( ) ;     }else       if ( tq . matches (   "<  " ) ) {         parseStartTag ( ) ;       }else {         parseTextNode ( ) ;       }[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { [ATTENTION] if ( tq . matches (   "<!--  " ) ) { if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( )  ; }else if ( ( tq . matches (   "<?  " ) ) || ( tq . matches (   "<!  " ) ) ) { parseXmlDecl ( )  ; }else if ( tq . matches (   "</  " ) ) { parseEndTag ( )  ; }else if ( tq . matches (   "<  " ) ) { parseStartTag ( )  ; }else { parseTextNode ( )  ; }parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^68^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<![CDATA[  "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; [ATTENTION] }else { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^70^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  { 	[BUGGY]  if ( tq . matches (   "<?  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] }if ( tq . matches (   "<?  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY] else if ( tq . matchChomp ( DQ ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } else if ( tq . matchChomp ( DQ ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<  "  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] }else { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^^^^^66^83^
[REPLACE]  parseTextNode  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { [ATTENTION] Validate . notNull ( html )  ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^79^^^^^66^83^
[REPLACE]  parseStartTag  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { [ATTENTION] Validate . notNull ( html )  ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^77^^^^^66^83^
[REPLACE]  parseEndTag  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { [ATTENTION] Validate . notNull ( html )  ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^75^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<  "  )  )  { 	[BUGGY]  if ( tq . matches (   "<  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] }if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^^^^^66^83^
[ADD]  else  if  (  tq  .  matches  (    "<  "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  } 	[BUGGY]  parseTextNode ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] } parseTextNode ( )  ;   } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^77^78^79^80^66^83^
[REMOVE]   	[BUGGY] valueAccum . append ( tq . consume ( ) ) ; [CE] cannot find symbol valueAccum  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { [ATTENTION] parseTextNode ( ) ;  valueAccum . append ( tq . consume ( ) )  ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^79^^^^^66^83^
[REPLACE]  parseXmlDecl  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { [ATTENTION] Validate . notNull ( html )  ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^73^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY]  if ( tq . matchesAny ( html , html , baseUri )  ) {[CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] }if ( tq . matchesAny ( html , html , baseUri )  ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[ADD]  else  if  (  tq  .  matches  (    "<  "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  } 	[BUGGY]  parseStartTag ( ) ; parseTextNode ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] } parseStartTag ( )  ; parseTextNode ( )  ;   } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^77^78^79^80^66^83^
[REPLACE]  parseCdata  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { [ATTENTION] Validate . notNull ( html )  ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^71^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] }else { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY] else if ( tq . matchesAny ( bodyHtml , SQ , SQ )  ) {[CE] cannot find symbol bodyHtml  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } else if ( tq . matchesAny ( bodyHtml , SQ , SQ )  ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   "</  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } else if ( tq . matchChomp (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<  "  )  )  { 	[BUGGY] else if ( tq . matchChomp (   "<  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] } else if ( tq . matchChomp (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^^^^^66^83^
[REMOVE]   	[BUGGY] if ( tq . matches (   "</  " ) ) {   parseEndTag ( ) ; }else   if ( tq . matches (   "<  " ) ) {     parseStartTag ( ) ;   }else {     parseTextNode ( ) ;   }[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] } else if ( tq . matches (   "<  " ) ) { if ( tq . matches (   "</  " ) ) { parseEndTag ( )  ; }else if ( tq . matches (   "<  " ) ) { parseStartTag ( )  ; }else { parseTextNode ( )  ; }parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^^^^^66^83^
[ADD]  parseTextNode  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { [ATTENTION] } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^79^^^^^66^83^
[REPLACE]  parseComment  (  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { [ATTENTION] Validate . notNull ( html )  ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^69^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<![CDATA[  "  )  )  { 	[BUGGY]  if ( tq . matches (   "<[CDATA[  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; [ATTENTION] }if ( tq . matches (   "<[CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^70^^^^^66^83^
[ADD]  else  if  (  tq  .  matches  (    "<![CDATA[  "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  {  parseXmlDecl  (  )  ; 	[BUGGY]  parseXmlDecl ( ) ; [CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; [ATTENTION] } parseXmlDecl ( )  ;   } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^70^71^72^73^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  { 	[BUGGY] else if ( tq . matches (   "<?  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] } else if ( tq . matches (   "<?  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^^^^^66^83^
[ADD]  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (    "</  "  )  )  {  parseEndTag  (  )  ; 	[BUGGY]  parseEndTag ( ) ; [CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] } parseEndTag ( )  ;   } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^73^74^75^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY] else if ( tq . matchesAny ( baseUri , SQ , DQ )  ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } else if ( tq . matchesAny ( baseUri , SQ , DQ )  ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<  "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   "<  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [ATTENTION] }if ( tq . matchChomp (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^76^^^^^66^83^
[ADD]  parseXmlDecl  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { [ATTENTION] } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^73^^^^^66^83^
[ADD]  parseStartTag  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { [ATTENTION] } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^77^^^^^66^83^
[ADD]  parseCdata  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { [ATTENTION] } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^71^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY]  else {[CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] }else { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY]  if ( tq . matchesAny ( html , baseUri , DQ )  ) {[CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] }if ( tq . matchesAny ( html , baseUri , DQ )  ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REMOVE]   	[BUGGY] if ( tq . matches (   "<  " ) ) {   parseStartTag ( ) ; }else {   parseTextNode ( ) ; }[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } else if ( tq . matches (   "</  " ) ) { if ( tq . matches (   "<  " ) ) { parseStartTag ( )  ; }else { parseTextNode ( )  ; }parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[REMOVE]   	[BUGGY] else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { [ATTENTION] parseEndTag ( ) ;  } else if ( tq . matches (   "</  " ) ) { parseEndTag ( )  ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^75^^^^^66^83^
[REMOVE]   	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { [ATTENTION] parseStartTag ( ) ;  Validate . notNull ( html )  ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^77^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  { 	[BUGGY]  if ( tq . matches (   "<?  " ) || tq . matches (   "<  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] }if ( tq . matches (   "<?  " ) || tq . matches (   "<  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "</  "  )  )  { 	[BUGGY]  if ( tq . matches (   "</  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] }if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^^^^^66^83^
[ADD]  else  if  (  tq  .  matches  (    "</  "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (    "<  "  )  )  {  parseStartTag  (  )  ; 	[BUGGY]  parseStartTag ( ) ; [CE]  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; [ATTENTION] } parseStartTag ( )  ;   } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^74^75^76^77^^66^83^
[REMOVE]   	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { [ATTENTION] parseCdata ( ) ;  Validate . notNull ( html )  ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^71^^^^^66^83^
[REPLACE]  }  else  if  (  tq  .  matches  (    "<?  "  )  ||  tq  .  matches  (    "<!  "  )  )  { 	[BUGGY]  if ( tq . matchChomp (   "<?  " ) || tq . matches (   "<  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; [ATTENTION] }if ( tq . matchChomp (   "<?  " ) || tq . matches (   "<  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^72^^^^^66^83^
[ADD]  parseEndTag  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { [ATTENTION] } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^75^^^^^66^83^
[REPLACE]  return  doc  .  normalise  (  )  ; 	[BUGGY] return doc . body ( ) ; [CE] incompatible types  [METHOD]  parse [TYPE] Document [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Document parse ( ) { while ( !tq . isEmpty ( ) ) { if ( tq . matches (   "<!--  " ) ) { parseComment ( ) ; } else if ( tq . matches (   "<![CDATA[  " ) ) { parseCdata ( ) ; } else if ( tq . matches (   "<?  " ) || tq . matches (   "<!  " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches (   "</  " ) ) { parseEndTag ( ) ; } else if ( tq . matches (   "<  " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } [ATTENTION] return doc . body ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^82^^^^^66^83^
[REPLACE]  tq  .  consume  (    "<!--  "  )  ; 	[BUGGY] tq . consumeTo ( bodyHtml )  ; [CE] cannot find symbol bodyHtml  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { [ATTENTION] tq . consumeTo ( bodyHtml ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^86^^^^^85^93^
[REMOVE]   	[BUGGY] valueAccum . append ( tq . consume ( ) ) ; [CE] cannot find symbol valueAccum  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { [ATTENTION] tq . consume (   "<!--  " ) ;  valueAccum . append ( tq . consume ( ) )  ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^86^^^^^85^93^
[REPLACE]  String  data  =  tq  .  chompTo  (    "->  "  )  ; 	[BUGGY] String data = tq . consumeTo (   "->  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; [ATTENTION] String data = tq . consumeTo (   "->  " )  ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^87^^^^^85^93^
[REPLACE]  if  (  data  .  endsWith  (    "-  "  )  )  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ; 	[BUGGY] if ( data . endsWith (   "-  " ) ) data = data . substring ( 0 , data . length ( ) - 3-1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  [ATTENTION] if ( data . endsWith (   "-  " ) ) data = data . substring ( 0 , data . length ( ) - 3-1 )  ;  Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^89^90^^^^85^93^
[REPLACE]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ; 	[BUGGY] data = data . substring ( 0 , data . length ( ) * 2-1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> [ATTENTION] data = data . substring ( 0 , data . length ( ) *2-1 )  ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^90^^^^^85^93^
[REPLACE]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ; 	[BUGGY] data = data . substring ( 0 , data . length ( ) + 3-1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> [ATTENTION] data = data . substring ( 0 , data . length ( ) + 3-1 )  ; Comment comment = new Comment ( data , baseUri ) ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^90^^^^^85^93^
[ADD]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data,  baseUri  )  ; 	[BUGGY] Comment comment = new Comment ( data , baseUri ) ; [CE] not a statement  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> [ATTENTION] Comment comment = new Comment ( data , baseUri )  ;  last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^90^91^^^^85^93^
[REPLACE]  Comment  comment  =  new  Comment  (  data,  baseUri  )  ; 	[BUGGY] Comment comment = new Comment ( bodyHtml , baseUri ) ; [CE] cannot find symbol bodyHtml  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; [ATTENTION] Comment comment = new Comment ( bodyHtml , baseUri )  ; last ( ) . appendChild ( comment ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^91^^^^^85^93^
[REPLACE]  last  (  )    .  appendChild  (  comment  )  ; 	[BUGGY] last ( )  . absUrl ( bodyHtml )  ; [CE] cannot find symbol bodyHtml  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; Comment comment = new Comment ( data , baseUri ) ; [ATTENTION] last ( ) . absUrl ( bodyHtml ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^92^^^^^85^93^
[REPLACE]  last  (  )    .  appendChild  (  comment  )  ; 	[BUGGY] implicit . appendChild ( child ) ; [CE] cannot find symbol child  [METHOD]  parseComment [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] Comment comment [TYPE] boolean false true [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseComment ( ) { tq . consume (   "<!--  " ) ; String data = tq . chompTo (   "->  " ) ;  if ( data . endsWith (   "-  " ) ) // i . e . was --> data = data . substring ( 0 , data . length ( ) -1 ) ; Comment comment = new Comment ( data , baseUri ) ; [ATTENTION] implicit . appendChild ( child )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^92^^^^^85^93^
[REPLACE]  tq  .  consume  (    "<  "  )  ; 	[BUGGY] tq . consumeTo (   "<  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { [ATTENTION] tq . consumeTo (   "<  " )  ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^96^^^^^95^103^
[REPLACE]  Character  firstChar  =  tq  .  consume  (  )  ; 	[BUGGY] Character firstChar = tq . consumeWord ( ) ; [CE] incompatible types  [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; [ATTENTION] Character firstChar = tq . consumeWord ( )  ; boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^97^^^^^95^103^
[ADD]  Character  firstChar  =  tq  .  consume  (  )  ; 	[BUGGY] [CE] cannot find symbol firstChar  [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; [ATTENTION] boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^97^^^^^95^103^
[REPLACE]  boolean  procInstr  =  firstChar  .  toString  (  )    .  equals  (    "!  "  )  ; 	[BUGGY] boolean procInstr = firstChar . toString ( ) . endsWith (   "!  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . [ATTENTION] boolean procInstr = firstChar . toString ( )  . endsWith (   "!  " )  ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^98^^^^^95^103^
[REPLACE]  String  data  =  tq  .  chompTo  (    ">  "  )  ; 	[BUGGY] String data = tq . consumeTo (   ">  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; [ATTENTION] String data = tq . consumeTo (   ">  " )  ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^99^^^^^95^103^
[REPLACE]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ; 	[BUGGY] XmlDeclaration decl = new XmlDeclaration ( data , baseUri , true ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  [ATTENTION] XmlDeclaration decl = new XmlDeclaration ( data , baseUri , true )  ; last ( ) . appendChild ( decl ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^101^^^^^95^103^
[REPLACE]  last  (  )    .  appendChild  (  decl  )  ; 	[BUGGY] last ( )  . absUrl ( html )  ; [CE] cannot find symbol html  [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; [ATTENTION] last ( ) . absUrl ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^102^^^^^95^103^
[REPLACE]  last  (  )    .  appendChild  (  decl  )  ; 	[BUGGY] valueAccum . append ( tq . consume ( ) ) ; [CE] cannot find symbol valueAccum  [METHOD]  parseXmlDecl [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false procInstr true [TYPE] Character firstChar [TYPE] XmlDeclaration decl [TYPE] String DQ SQ baseUri bodyHtml data html [TYPE] Tag bodyTag headTag htmlTag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseXmlDecl ( ) { tq . consume (   "<  " ) ; Character firstChar = tq . consume ( ) ; // <? or <! , from initial match . boolean procInstr = firstChar . toString ( ) . equals (   "!  " ) ; String data = tq . chompTo (   ">  " ) ;  XmlDeclaration decl = new XmlDeclaration ( data , baseUri , procInstr ) ; [ATTENTION] valueAccum . append ( tq . consume ( ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^102^^^^^95^103^
[REPLACE]  tq  .  consume  (    "</  "  )  ; 	[BUGGY] tq . consumeTo (   "</  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { [ATTENTION] tq . consumeTo (   "</  " )  ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  if ( tagName . length ( ) ! = 0 ) { Tag tag = Tag . valueOf ( tagName ) ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^106^^^^^105^114^
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ; 	[BUGGY] String tagName = tq . consumeTo ( data )  ; [CE] cannot find symbol data  [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; [ATTENTION] String tagName = tq . consumeTo ( data ) ; tq . chompTo (   ">  " ) ;  if ( tagName . length ( ) ! = 0 ) { Tag tag = Tag . valueOf ( tagName ) ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^107^^^^^105^114^
[REPLACE]  tq  .  chompTo  (    ">  "  )  ; 	[BUGGY] tq . consumeTo (   ">  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; [ATTENTION] tq . consumeTo (   ">  " )  ;  if ( tagName . length ( ) ! = 0 ) { Tag tag = Tag . valueOf ( tagName ) ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^108^^^^^105^114^
[REPLACE]  if  (  tagName  .  length  (  )  !=  0  )  { 	[BUGGY] if ( tagName . length ( ) - 1 ! = 0 ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  [ATTENTION] if ( tagName . length ( ) - 1 ! = 0 ) { Tag tag = Tag . valueOf ( tagName ) ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^110^^^^^105^114^
[ADD]  if  (  tagName  .  length  (  )  !=  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  } 	[BUGGY] Tag tag = Tag . valueOf ( tagName ) ; popStackToClose ( tag ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  [ATTENTION] Tag tag = Tag . valueOf ( tagName )  ; popStackToClose ( tag )  ;   }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^110^111^112^113^^105^114^
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ; 	[BUGGY] Tag tag = Tag . valueOf ( html ) ; [CE] cannot find symbol html  [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  if ( tagName . length ( ) ! = 0 ) { [ATTENTION] Tag tag = Tag . valueOf ( html )  ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^111^^^^^105^114^
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ; 	[BUGGY] Tag tag = Tag . equals ( html ) ; [CE] cannot find symbol html  [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  if ( tagName . length ( ) ! = 0 ) { [ATTENTION] Tag tag = Tag . equals ( html )  ; popStackToClose ( tag ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^111^^^^^105^114^
[ADD]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseEndTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseEndTag ( ) { tq . consume (   "</  " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo (   ">  " ) ;  if ( tagName . length ( ) ! = 0 ) { [ATTENTION]  } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^111^112^^^^105^114^
[REPLACE]  tq  .  consume  (    "<  "  )  ; 	[BUGGY] tq . consumeTo (   "<  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { [ATTENTION] tq . consumeTo (   "<  " )  ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^117^^^^^116^166^
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ; 	[BUGGY] String tagName = tq . consume ( ) ; [CE] incompatible types  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; [ATTENTION] String tagName = tq . consume ( )  ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^118^^^^^116^166^
[REPLACE]  if  (  tagName  .  length  (  )  ==  0  )  { 	[BUGGY] if ( tagName . size ( )  = = 0 ) {[CE] cannot find symbol  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  [ATTENTION] if ( tagName . size ( ) = = 0 ) { tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^120^^^^^116^166^
[REPLACE]  return; 	[BUGGY] return parent ; [CE] cannot return a value from method whose result type is void  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; [ATTENTION] return parent ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^123^^^^^116^166^
[REPLACE]  Attributes  attributes  =  new  Attributes  (  )  ; 	[BUGGY] StringBuilder valueAccum = new StringBuilder ( ) ; [CE] cannot find symbol attributes  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } [ATTENTION] StringBuilder valueAccum = new StringBuilder ( )  ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^126^^^^^116^166^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " )  ; [CE]  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; [ATTENTION] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ; Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^127^^^^^116^166^
[REPLACE]  if  (  attribute  !=  null  )  attributes  .  put  (  attribute  )  ; 	[BUGGY] if ( attribute = = this ) attributes . put ( attribute ) ; [CE] incomparable types: Attribute and Parser  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; [ATTENTION] if ( attribute = = this ) attributes . put ( attribute )  ;  } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^129^130^^^^116^166^
[REPLACE]  attributes  .  put  (  attribute  )  ; 	[BUGGY] attributes . Attributes ( )  ; [CE] cannot find symbol  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) [ATTENTION] attributes . Attributes ( ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^130^^^^^116^166^
[REPLACE]  Attribute  attribute  =  parseAttribute  (  )  ; 	[BUGGY] Attributes attributes = new Attributes ( ) ; [CE] variable attributes is already defined in method parseStartTag()  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { [ATTENTION] Attributes attributes = new Attributes ( )  ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^128^^^^^116^166^
[REPLACE]  if  (  attribute  !=  null  )  attributes  .  put  (  attribute  )  ; 	[BUGGY] if ( attribute = = true ) attributes . put ( attribute ) ; [CE] incomparable types: Attribute and boolean  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; [ATTENTION] if ( attribute = = true ) attributes . put ( attribute )  ;  } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^129^130^^^^116^166^
[REPLACE]  attributes  .  put  (  attribute  )  ; 	[BUGGY] Attribute attribute = parseAttribute ( ) ; [CE] not a statement  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) [ATTENTION] Attribute attribute = parseAttribute ( )  ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^130^^^^^116^166^
[ADD]  attributes  .  put  (  attribute  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) [ATTENTION] } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^130^^^^^116^166^
[ADD]  Attribute  attribute  =  parseAttribute  (  )  ; 	[BUGGY] [CE] cannot find symbol attribute  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { [ATTENTION] if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^128^^^^^116^166^
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ; 	[BUGGY] Tag tag = Tag . valueOf ( html ) ; [CE] cannot find symbol html  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } [ATTENTION] Tag tag = Tag . valueOf ( html )  ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^133^^^^^116^166^
[ADD]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ; 	[BUGGY] Element child = new Element ( tag , baseUri , attributes ) ; [CE] cannot find symbol tag  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } [ATTENTION] Element child = new Element ( tag , baseUri , attributes )  ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^133^134^^^^116^166^
[REPLACE]  Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ; 	[BUGGY] Element el = stack . get ( i ) ; [CE] cannot find symbol i  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; [ATTENTION] Element el = stack . get ( i )  ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^134^^^^^116^166^
[REPLACE]  boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ; 	[BUGGY] boolean . isDataElement = textareaTag . isEmpty ( ) ; [CE] class expected  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  [ATTENTION] boolean . isDataElement = textareaTag . isEmpty ( )  ; if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^136^^^^^116^166^
[ADD]  boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ; 	[BUGGY] [CE] cannot find symbol isEmptyElement  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  [ATTENTION] if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^136^^^^^116^166^
[REPLACE]  if  (  tq  .  matchChomp  (    "/>  "  )  )  { 	[BUGGY] if ( tq . matches ( baseUri )  ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> [ATTENTION] if ( tq . matches ( baseUri )  ) { isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^137^^^^^116^166^
[ADD]  if  (  tq  .  matchChomp  (    "/>  "  )  )  {  isEmptyElement  =  true;  }  else  {  tq  .  matchChomp  (    ">  "  )  ;  } 	[BUGGY] isEmptyElement = true ; tq . matchChomp (   ">  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> [ATTENTION] isEmptyElement = true ; tq . matchChomp (   ">  " )  ;     if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^137^138^139^140^141^116^166^
[REPLACE]  tq  .  matchChomp  (    ">  "  )  ; 	[BUGGY] tq . matches ( data )  ; [CE] cannot find symbol data  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { [ATTENTION] tq . matches ( data ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^140^^^^^137^141^
[REPLACE]  isEmptyElement  =  true; 	[BUGGY] isEmptyElement = false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag [ATTENTION] isEmptyElement = false ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^138^^^^^116^166^
[ADD]  isEmptyElement  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag [ATTENTION] } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^138^^^^^116^166^
[REPLACE]  if  (  tag  .  isData  (  )  )  { 	[BUGGY] if ( href . length ( ) ! = 0 ) {[CE] cannot find symbol href  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  [ATTENTION] if ( href . length ( ) ! = 0 ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^144^^^^^116^166^
[REPLACE]  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ; 	[BUGGY] if ( tag . equals ( titleTag ) && tag . equals ( textareaTag ) ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; [ATTENTION] if ( tag . equals ( titleTag ) && tag . equals ( textareaTag ) ) dataNode = TextNode . createFromEncoded ( data , baseUri )  ;  else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^149^150^^^^116^166^
[ADD]  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ; 	[BUGGY] dataNode = TextNode . createFromEncoded ( data , baseUri ) ; dataNode = new DataNode ( data , baseUri ) ; child . appendChild ( dataNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; [ATTENTION] dataNode = TextNode . createFromEncoded ( data , baseUri )  ; dataNode = new DataNode ( data , baseUri )  ; child . appendChild ( dataNode )  ;   }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^149^150^151^152^153^116^166^
[REPLACE]  dataNode  =  new  DataNode  (  data,  baseUri  )  ; 	[BUGGY] dataNode =  new DataNode ( tagName , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else [ATTENTION] dataNode = new DataNode ( tagName , baseUri )  ; child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^152^^^^^116^166^
[ADD]  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ; 	[BUGGY] child . appendChild ( dataNode ) ; [CE] variable dataNode might not have been initialized  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else [ATTENTION] child . appendChild ( dataNode )  ;  }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^152^153^^^^116^166^
[REPLACE]  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ; 	[BUGGY] dataNode =  TextNode . createFromEncoded ( tagName , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) [ATTENTION] dataNode = TextNode . createFromEncoded ( tagName , baseUri )  ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^150^^^^^116^166^
[ADD]  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) [ATTENTION] else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^150^^^^^116^166^
[REPLACE]  dataNode  =  new  DataNode  (  data,  baseUri  )  ; 	[BUGGY] dataNode =  new Element ( parentTag , baseUri )  ; [CE] cannot find symbol parentTag  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else [ATTENTION] dataNode = new Element ( parentTag , baseUri ) ; child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^152^^^^^116^166^
[REPLACE]  String  data  =  tq  .  chompTo  (    "</  "  +  tagName  )  ; 	[BUGGY] String data = tq . chompTo (   "</  " ! =  html ) ; [CE] cannot find symbol html  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { [ATTENTION] String data = tq . chompTo (   "</  "! = html )  ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^145^^^^^116^166^
[REPLACE]  Node  dataNode; 	[BUGGY] Element child = new Element ( tag , baseUri , attributes ) ; [CE] variable child is already defined in method parseStartTag()  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  [ATTENTION] Element child = new Element ( tag , baseUri , attributes )  ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^148^^^^^116^166^
[ADD]  Node  dataNode; 	[BUGGY] [CE] cannot find symbol dataNode  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  [ATTENTION] if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^148^^^^^116^166^
[ADD]  dataNode  =  new  DataNode  (  data,  baseUri  )  ; 	[BUGGY] [CE] variable dataNode might not have been initialized  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else [ATTENTION] child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^152^^^^^116^166^
[REPLACE]  String  data  =  tq  .  chompTo  (    "</  "  +  tagName  )  ; 	[BUGGY] String data = tq . chompTo (   "</  " > =  tagName ) ; [CE] bad operand types for binary operator  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { [ATTENTION] String data = tq . chompTo (   "</  "> = tagName )  ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^145^^^^^116^166^
[REPLACE]  if  (  child  .  tagName  (  )    .  equals  (    "base  "  )  )  { 	[BUGGY] if ( child . tag ( ) . equals ( bodyTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  [ATTENTION] if ( child . tag ( )  . equals ( bodyTag ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^157^^^^^116^166^
[REPLACE]  if  (  href  .  length  (  )  !=  0  )  { 	[BUGGY] if ( href . length ( ) * 0 . 5 ! = 0 ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; [ATTENTION] if ( href . length ( ) *0 . 5! = 0 ) { baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^159^^^^^116^166^
[ADD]  if  (  href  .  length  (  )  !=  0  )  {  baseUri  =  href;  doc  .  setBaseUri  (  href  )  ;  } 	[BUGGY] baseUri = href ; doc . setBaseUri ( href ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; [ATTENTION] baseUri = href ; doc . setBaseUri ( href )  ;   } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^159^160^161^162^^116^166^
[REPLACE]  baseUri  =  href; 	[BUGGY] baseUri =  html ; [CE] cannot find symbol html  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc [ATTENTION] baseUri = html ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^160^^^^^116^166^
[REPLACE]  String  href  =  child  .  absUrl  (    "href  "  )  ; 	[BUGGY] String href = child . appendChild (   "href  " ) ; [CE] method appendChild in class Element cannot be applied to given types ;  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { [ATTENTION] String href = child . appendChild (   "href  " )  ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^158^^^^^116^166^
[ADD]  String  href  =  child  .  absUrl  (    "href  "  )  ; 	[BUGGY] [CE] cannot find symbol href  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { [ATTENTION] if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^158^^^^^116^166^
[REPLACE]  if  (  href  .  length  (  )  !=  0  )  { 	[BUGGY] if ( href . equals ( ) + 1 ! = 0 ) {[CE] no suitable method found for equals()  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; [ATTENTION] if ( href . equals ( ) + 1 ! = 0 ) { baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^159^^^^^116^166^
[REPLACE]  baseUri  =  href; 	[BUGGY] baseUri =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc [ATTENTION] baseUri = null ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } addChildToParent ( child , isEmptyElement ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^160^^^^^116^166^
[REPLACE]  addChildToParent  (  child,  isEmptyElement  )  ; 	[BUGGY] if ( parent2 . isValidParent ( childTag ) ) { return true ; [CE] illegal start of expression  [METHOD]  parseStartTag [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true [TYPE] Attribute attribute [TYPE] Element child [TYPE] Node dataNode [TYPE] Attributes attributes [TYPE] String DQ SQ baseUri bodyHtml data href html tagName [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseStartTag ( ) { tq . consume (   "<  " ) ; String tagName = tq . consumeWord ( ) ;  if ( tagName . length ( )  = = 0 ) { // doesn't look like a start tag after all ; put < back on stack and handle as text tq . addFirst (   "&lt ;   " ) ; parseTextNode ( ) ; return ; } Attributes attributes = new Attributes ( ) ; while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; Element child = new Element ( tag , baseUri , attributes ) ;  boolean isEmptyElement = tag . isEmpty ( ) ; // empty element if empty tag ( e . g . img ) or self-closed el ( <div/> if ( tq . matchChomp (   "/>  " ) ) { // close empty element or tag isEmptyElement = true ; } else { tq . matchChomp (   ">  " ) ; }  if ( tag . isData ( ) ) { String data = tq . chompTo (   "</  " + tagName ) ; tq . chompTo (   ">  " ) ;  Node dataNode ; if ( tag . equals ( titleTag ) || tag . equals ( textareaTag ) ) // want to show as text , but not contain inside tags ( so not a data tag? ) dataNode = TextNode . createFromEncoded ( data , baseUri ) ; else dataNode = new DataNode ( data , baseUri ) ; // data not encoded but raw ( for   " in script ) child . appendChild ( dataNode ) ; }  if ( child . tagName ( ) . equals (   "base  " ) ) { String href = child . absUrl (   "href  " ) ; if ( href . length ( ) ! = 0 ) { // ignore <base target> etc baseUri = href ; doc . setBaseUri ( href ) ; // set on the doc so doc . createElement ( Tag ) will get updated base } } [ATTENTION] if ( parent2 . isValidParent ( childTag ) ) { return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^165^^^^^116^166^
[REPLACE]  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] tq . matchesWhitespace ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { [ATTENTION] tq . matchesWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^169^^^^^168^196^
[ADD]  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { [ATTENTION] String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^169^^^^^168^196^
[REPLACE]  String  key  =  tq  .  consumeAttributeKey  (  )  ; 	[BUGGY] String key = tq . consumeWord ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; [ATTENTION] String key = tq . consumeWord ( )  ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^170^^^^^168^196^
[REPLACE]  String  value  =    "  "; 	[BUGGY] String href = child . absUrl (   "href  " ) ; [CE] cannot find symbol child  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; [ATTENTION] String href = child . absUrl (   "href  " )  ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^171^^^^^168^196^
[REPLACE]  tq  .  consumeWhitespace  (  )  ; 	[BUGGY] tq . matchesWhitespace ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; [ATTENTION] tq . matchesWhitespace ( )  ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^172^^^^^168^196^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " )  | !tq . matchesWhitespace ( )  | !tq . isEmpty ( ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION] while ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) |!tq . matchesWhitespace ( ) |!tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^^^^^168^196^
[ADD]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION]  } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^184^^^^168^196^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consume ( baseUri )  ) ; [CE] 'void' type not allowed here  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consume ( baseUri )  )  ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[ADD]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consume ( DQ )  ) ; [CE] 'void' type not allowed here  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consume ( DQ )  )  ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[REPLACE]  if  (  tq  .  matchChomp  (    "=  "  )  )  { 	[BUGGY] if ( tq . matchChomp (   "/>  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; [ATTENTION] if ( tq . matchChomp (   "/>  " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^173^^^^^168^196^
[REMOVE]   	[BUGGY] if ( tq . matchChomp ( SQ ) ) {   value = tq . chompTo ( SQ ) ; }else   if ( tq . matchChomp ( DQ ) ) {     value = tq . chompTo ( DQ ) ;   }else {     StringBuilder valueAccum = new StringBuilder ( ) ;     while ( ( ( ! ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ) ) && ( ! ( tq . matchesWhitespace ( ) ) ) ) && ( ! ( tq . isEmpty ( ) ) ) ) {       valueAccum . append ( tq . consume ( ) ) ;     }     value = valueAccum . toString ( ) ;   }[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; [ATTENTION] if ( tq . matchChomp (   " =   " ) ) { if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ )  ; }else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ )  ; }else { StringBuilder valueAccum = new StringBuilder ( )  ; while ( ( ( ! ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ) ) && ( ! ( tq . matchesWhitespace ( ) ) ) ) && ( ! ( tq . isEmpty ( ) ) ) ) { valueAccum . append ( tq . consume ( ) )  ; }value = valueAccum . toString ( )  ; }tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^173^^^^^168^196^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " )  ; [CE]  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ; valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^^^^^168^196^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consumeWord ( ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consumeWord ( ) )  ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consume ( data )  ) ; [CE] cannot find symbol data  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consume ( data )  )  ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[REPLACE]  if  (  tq  .  matchChomp  (  SQ  )  )  { 	[BUGGY] else if ( tq . matchChomp ( DQ ) ) {[CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  [ATTENTION] } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^176^^^^^168^196^
[ADD]  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  [ATTENTION]   } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^176^177^178^179^^168^196^
[REMOVE]   	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consume ( ) ) ;  Validate . notNull ( html )  ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^168^196^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  { 	[BUGGY]  else {[CE] 'else' without 'if'  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; [ATTENTION] }else { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^178^^^^^168^196^
[ADD]  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ; 	[BUGGY]  value = tq . chompTo ( DQ ) ; StringBuilder valueAccum = new StringBuilder ( ) ; [CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; [ATTENTION] } value = tq . chompTo ( DQ )  ; StringBuilder valueAccum = new StringBuilder ( )  ;    while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^178^179^180^181^^168^196^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " )  ; [CE]  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION] while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ; valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^^^^^178^187^
[ADD]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION]  } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^184^^^^178^187^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consumeWord ( ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consumeWord ( ) )  ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^178^187^
[REPLACE]  value  =  valueAccum  .  toString  (  )  ; 	[BUGGY] value =  null . toString ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } [ATTENTION] value = null . toString ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^186^^^^^178^187^
[REPLACE]  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ; 	[BUGGY] Attributes attributes = new Attributes ( ) ; [CE] cannot find symbol valueAccum  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { [ATTENTION] Attributes attributes = new Attributes ( )  ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^181^^^^^178^187^
[REPLACE]  value  =  tq  .  chompTo  (  DQ  )  ; 	[BUGGY] value = tq . chompTo ( SQ ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { [ATTENTION] value = tq . chompTo ( SQ )  ;  ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^179^^^^^168^196^
[ADD]  value  =  tq  .  chompTo  (  DQ  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { [ATTENTION] } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^179^^^^^168^196^
[REPLACE]  value  =  valueAccum  .  toString  (  )  ; 	[BUGGY] value =  null . toString ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } [ATTENTION] value = null . toString ( )  ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^186^^^^^168^196^
[ADD]  value  =  valueAccum  .  toString  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } [ATTENTION] } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^186^^^^^168^196^
[REPLACE]  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ; 	[BUGGY] Attributes attributes = new Attributes ( ) ; [CE] cannot find symbol valueAccum  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { [ATTENTION] Attributes attributes = new Attributes ( )  ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^181^^^^^168^196^
[REPLACE]  value  =  tq  .  chompTo  (  SQ  )  ; 	[BUGGY] value = tq . chompTo ( DQ ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { [ATTENTION] value = tq . chompTo ( DQ )  ;  ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^177^^^^^168^196^
[ADD]  value  =  tq  .  chompTo  (  SQ  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { [ATTENTION] } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^177^^^^^168^196^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  { 	[BUGGY] else if ( tq . matches (   "</  " ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; [ATTENTION] } else if ( tq . matches (   "</  " ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^178^^^^^168^196^
[REMOVE]   	[BUGGY] if ( tq . matchChomp ( SQ ) ) {   value = tq . chompTo ( SQ ) ; }else   if ( tq . matchChomp ( DQ ) ) {     value = tq . chompTo ( DQ ) ;   }else {     StringBuilder valueAccum = new StringBuilder ( ) ;     while ( ( ( ! ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ) ) && ( ! ( tq . matchesWhitespace ( ) ) ) ) && ( ! ( tq . isEmpty ( ) ) ) ) {       valueAccum . append ( tq . consume ( ) ) ;     }     value = valueAccum . toString ( ) ;   }[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; [ATTENTION] } else if ( tq . matchChomp ( DQ ) ) { if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ )  ; }else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ )  ; }else { StringBuilder valueAccum = new StringBuilder ( )  ; while ( ( ( ! ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) ) ) && ( ! ( tq . matchesWhitespace ( ) ) ) ) && ( ! ( tq . isEmpty ( ) ) ) ) { valueAccum . append ( tq . consume ( ) )  ; }value = valueAccum . toString ( )  ; }value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^178^^^^^168^196^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( !tq . matches (   "<  " ,   "/>  " ,   ">  " )  ; [CE]  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION] while ( !tq . matches (   "<  " ,   "/>  " ,   ">  " ) ; valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^^^^^178^187^
[ADD]  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ; 	[BUGGY] value = tq . chompTo ( SQ ) ; value = tq . chompTo ( DQ ) ; [CE] illegal start of type  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  [ATTENTION] value = tq . chompTo ( SQ )  ; value = tq . chompTo ( DQ )  ;   } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^176^177^178^179^^168^196^
[REPLACE]  while  (  !tq  .  matchesAny  (    "<  ",    "/>  ",    ">  "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  { 	[BUGGY] while ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " )  < =  !tq . matchesWhitespace ( )  < =  !tq . isEmpty ( ) ) {[CE] bad operand types for binary operator  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  [ATTENTION] while ( tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) < = !tq . matchesWhitespace ( ) < = !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^183^^^^^178^187^
[ADD]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^178^187^
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ; 	[BUGGY] valueAccum . append ( tq . consume ( baseUri )  ) ; [CE] 'void' type not allowed here  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { [ATTENTION] valueAccum . append ( tq . consume ( baseUri )  )  ; } value = valueAccum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^184^^^^^178^187^
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  { 	[BUGGY]  if ( tq . matchChomp ( DQ ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; [ATTENTION] }if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^178^^^^^168^196^
[REPLACE]  if  (  key  .  length  (  )  !=  0  )  return  Attribute  .  createFromEncoded  (  key,  value  )  ; 	[BUGGY] if ( key . length ( ) % 0 . 5 ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } [ATTENTION] if ( key . length ( ) %0 . 5! = 0 ) return Attribute . createFromEncoded ( key , value )  ;  else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^190^191^^^^168^196^
[ADD]  if  (  key  .  length  (  )  !=  0  )  return  Attribute  .  createFromEncoded  (  key,  value  )  ;  else  {  tq  .  consume  (  )  ;  return  null; 	[BUGGY] return Attribute . createFromEncoded ( key , value ) ; tq . consume ( ) ; return null ; [CE] class , interface , or enum expected  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } [ATTENTION] return Attribute . createFromEncoded ( key , value )  ; tq . consume ( )  ; return null ;   } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^190^191^192^193^194^168^196^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] incompatible types  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^194^^^^^190^195^
[REPLACE]  return  Attribute  .  createFromEncoded  (  key,  value  )  ; 	[BUGGY] return Attribute . createFromEncoded ( href , value ) ; [CE] cannot find symbol href  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) [ATTENTION] return Attribute . createFromEncoded ( href , value )  ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck return null ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^191^^^^^168^196^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  parseAttribute [TYPE] Attribute [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] StringBuilder valueAccum [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Attribute parseAttribute ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value =   "  " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp (   " =   " ) ) { tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ;  while ( !tq . matchesAny (   "<  " ,   "/>  " ,   ">  " ) && !tq . matchesWhitespace ( ) && !tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; // unknown char , keep popping so not get stuck [ATTENTION] return false ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^194^^^^^168^196^
[REPLACE]  String  text  =  tq  .  consumeTo  (    "<  "  )  ; 	[BUGGY] String text = tq . consume (   "<  " ) ; [CE] incompatible types  [METHOD]  parseTextNode [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseTextNode ( ) { [ATTENTION] String text = tq . consume (   "<  " )  ; TextNode textNode = TextNode . createFromEncoded ( text , baseUri ) ; last ( ) . appendChild ( textNode ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^199^^^^^198^202^
[REPLACE]  TextNode  textNode  =  TextNode  .  createFromEncoded  (  text,  baseUri  )  ; 	[BUGGY] TextNode textNode = TextNode . TextNode ( text , baseUri ) ; [CE] cannot find symbol  [METHOD]  parseTextNode [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseTextNode ( ) { String text = tq . consumeTo (   "<  " ) ; [ATTENTION] TextNode textNode = TextNode . TextNode ( text , baseUri )  ; last ( ) . appendChild ( textNode ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^200^^^^^198^202^
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ; 	[BUGGY] last ( )  . absUrl ( text )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseTextNode [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseTextNode ( ) { String text = tq . consumeTo (   "<  " ) ; TextNode textNode = TextNode . createFromEncoded ( text , baseUri ) ; [ATTENTION] last ( ) . absUrl ( text ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^201^^^^^198^202^
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ; 	[BUGGY] last ( ) . appendChild ( comment ) ; [CE] cannot find symbol comment  [METHOD]  parseTextNode [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseTextNode ( ) { String text = tq . consumeTo (   "<  " ) ; TextNode textNode = TextNode . createFromEncoded ( text , baseUri ) ; [ATTENTION] last ( )  . appendChild ( comment )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^201^^^^^198^202^
[REPLACE]  tq  .  consume  (    "<![CDATA[  "  )  ; 	[BUGGY] tq . consumeTo ( value )  ; [CE] cannot find symbol value  [METHOD]  parseCdata [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseCdata ( ) { [ATTENTION] tq . consumeTo ( value ) ; String rawText = tq . chompTo (   "]]>  " ) ; TextNode textNode = new TextNode ( rawText , baseUri ) ; // constructor does not escape last ( ) . appendChild ( textNode ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^205^^^^^204^209^
[REPLACE]  String  rawText  =  tq  .  chompTo  (    "]]>  "  )  ; 	[BUGGY] String rawText = tq . consumeTo ( tagName )  ; [CE] cannot find symbol tagName  [METHOD]  parseCdata [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseCdata ( ) { tq . consume (   "<![CDATA[  " ) ; [ATTENTION] String rawText = tq . consumeTo ( tagName ) ; TextNode textNode = new TextNode ( rawText , baseUri ) ; // constructor does not escape last ( ) . appendChild ( textNode ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^206^^^^^204^209^
[REPLACE]  TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ; 	[BUGGY] TextNode textNode = new TextNode ( value , baseUri ) ; [CE] cannot find symbol value  [METHOD]  parseCdata [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseCdata ( ) { tq . consume (   "<![CDATA[  " ) ; String rawText = tq . chompTo (   "]]>  " ) ; [ATTENTION] TextNode textNode = new TextNode ( value , baseUri )  ; last ( ) . appendChild ( textNode ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^207^^^^^204^209^
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ; 	[BUGGY] last ( ) . appendChild ( comment ) ; [CE] cannot find symbol comment  [METHOD]  parseCdata [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseCdata ( ) { tq . consume (   "<![CDATA[  " ) ; String rawText = tq . chompTo (   "]]>  " ) ; TextNode textNode = new TextNode ( rawText , baseUri ) ; // constructor does not escape [ATTENTION] last ( )  . appendChild ( comment )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^208^^^^^204^209^
[REMOVE]   	[BUGGY] String data = tq . chompTo (   "</  " + tagName ) ; [CE] cannot find symbol tagName  [METHOD]  parseCdata [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] TextNode textNode [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag headTag htmlTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private void parseCdata ( ) { tq . consume (   "<![CDATA[  " ) ; String rawText = tq . chompTo (   "]]>  " ) ; TextNode textNode = new TextNode ( rawText , baseUri ) ; // constructor does not escape [ATTENTION] last ( ) . appendChild ( textNode ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^208^^^^^204^209^
[REPLACE]  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ; 	[BUGGY] Element parent = popStackToSuitableContainer ( implicit . tag ( ) ) ; [CE] cannot find symbol implicit  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { [ATTENTION] Element parent = popStackToSuitableContainer ( implicit . tag ( ) )  ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^212^^^^^211^239^
[REPLACE]  Tag  childTag  =  child  .  tag  (  )  ; 	[BUGGY] Tag childTag = child . tagName ( ) ; [CE] incompatible types  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; [ATTENTION] Tag childTag = child . tagName ( )  ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^213^^^^^211^239^
[ADD]  Tag  childTag  =  child  .  tag  (  )  ; 	[BUGGY] [CE] cannot find symbol childTag  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; [ATTENTION] boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^213^^^^^211^239^
[REPLACE]  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ; 	[BUGGY] boolean validAncestor = stackHasValidParent ( titleTag ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; [ATTENTION] boolean validAncestor = stackHasValidParent ( titleTag )  ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^214^^^^^211^239^
[ADD]  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ; 	[BUGGY] [CE] cannot find symbol validAncestor  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; [ATTENTION]  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^214^^^^^211^239^
[REPLACE]  if  (  !validAncestor  )  { 	[BUGGY] if ( validAncestor ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  [ATTENTION] if ( validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^216^^^^^211^239^
[REPLACE]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  { 	[BUGGY] if ( head . tag ( ) . equals ( bodyTag ) ) {[CE] cannot find symbol head  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  [ATTENTION] if ( head . tag ( )  . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^221^^^^^211^239^
[ADD]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  } 	[BUGGY] Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  [ATTENTION] Element head = new Element ( headTag , baseUri )  ; implicit . appendChild ( head )  ;   implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^221^222^223^224^^211^239^
[REPLACE]  Element  head  =  new  Element  (  headTag,  baseUri  )  ; 	[BUGGY] Element child = new Element ( tag , baseUri , attributes ) ; [CE] variable child is already defined in method addChildToParent(Element , boolean)  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { [ATTENTION] Element child = new Element ( tag , baseUri , attributes )  ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^222^^^^^211^239^
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ; 	[BUGGY] if ( !isEmptyElement ) stack . add ( implicit ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; [ATTENTION] if ( !isEmptyElement ) stack . add ( implicit )  ;  return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^229^230^^^^211^239^
[ADD]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; [ATTENTION]   parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^229^230^231^232^^211^239^
[REPLACE]  stack  .  addLast  (  child  )  ; 	[BUGGY] stack . add ( implicit ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) [ATTENTION] stack . add ( implicit )  ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^230^^^^^211^239^
[REPLACE]  return  root; 	[BUGGY] return parent ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; [ATTENTION] return parent ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^231^^^^^211^239^
[REPLACE]  Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ; 	[BUGGY] Tag parentTag = titleTag . getImplicitParent ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  [ATTENTION] Tag parentTag = titleTag . getImplicitParent ( )  ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^218^^^^^211^239^
[ADD]  Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ; 	[BUGGY] [CE] cannot find symbol parentTag  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  [ATTENTION] Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^218^^^^^211^239^
[REPLACE]  Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ; 	[BUGGY] Element implicit = new Element ( titleTag , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; [ATTENTION] Element implicit = new Element ( titleTag , baseUri )  ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^219^^^^^211^239^
[REPLACE]  Element  root  =  addChildToParent  (  implicit,  false  )  ; 	[BUGGY] Element root = addChildToParent ( implicit , true ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   [ATTENTION] Element root = addChildToParent ( implicit , true )  ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^228^^^^^211^239^
[REPLACE]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  { 	[BUGGY] if ( child . tag ( ) . canContain ( bodyTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  [ATTENTION] if ( child . tag ( )  . canContain ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^221^^^^^211^239^
[ADD]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  [ATTENTION]   implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^221^222^223^224^^211^239^
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ; 	[BUGGY] if ( !isEmptyElement ) stack . addLast ( implicit ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; [ATTENTION] if ( !isEmptyElement ) stack . addLast ( implicit )  ;  return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^229^230^^^^211^239^
[REPLACE]  stack  .  addLast  (  child  )  ; 	[BUGGY] stack . addLast ( implicit ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) [ATTENTION] stack . addLast ( implicit )  ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^230^^^^^211^239^
[ADD]  stack  .  addLast  (  child  )  ;  return  root; 	[BUGGY] return root ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) [ATTENTION] return root ;  } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^230^231^^^^211^239^
[REPLACE]  Element  root  =  addChildToParent  (  implicit,  false  )  ; 	[BUGGY] Element root = addChildToParent ( root , true ) ; [CE] variable root might not have been initialized  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   [ATTENTION] Element root = addChildToParent ( root , true )  ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^228^^^^^211^239^
[REPLACE]  parent  .  appendChild  (  child  )  ; 	[BUGGY] parent . absUrl ( text )  ; [CE] cannot find symbol text  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } [ATTENTION] parent . absUrl ( text ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^234^^^^^211^239^
[ADD]  parent  .  appendChild  (  child  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } [ATTENTION]  if ( !isEmptyElement ) stack . addLast ( child ) ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^234^^^^^211^239^
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ; 	[BUGGY] if ( !validAncestor ) stack . addLast ( child ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  [ATTENTION] if ( !validAncestor ) stack . addLast ( child )  ;  return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^236^237^^^^211^239^
[ADD]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent;  } 	[BUGGY] stack . addLast ( child ) ; return parent ; [CE] illegal start of expression  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  [ATTENTION] stack . addLast ( child )  ; return parent ;    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^236^237^238^239^^211^239^
[REPLACE]  stack  .  addLast  (  child  )  ; 	[BUGGY] stack . addLast ( implicit ) ; [CE] cannot find symbol implicit  [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) [ATTENTION] stack . addLast ( implicit )  ; return parent ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^237^^^^^211^239^
[REPLACE]  return  parent; 	[BUGGY] return stack . getLast ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChildToParent [TYPE] Element [PARAMETER] Element child boolean isEmptyElement [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false isEmptyElement true validAncestor [TYPE] Element child head implicit parent root [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ;  if ( !validAncestor ) {  Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ;  if ( child . tag ( ) . equals ( bodyTag ) ) { Element head = new Element ( headTag , baseUri ) ; implicit . appendChild ( head ) ; } implicit . appendChild ( child ) ;   Element root = addChildToParent ( implicit , false ) ; if ( !isEmptyElement ) stack . addLast ( child ) ; return root ; } parent . appendChild ( child ) ;  if ( !isEmptyElement ) stack . addLast ( child ) ; [ATTENTION] return stack . getLast ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^238^^^^^211^239^
[REPLACE]  if  (  stack  .  size  (  )  ==  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true; 	[BUGGY] if ( stack . get ( ) - 3 = = 0 && childTag . equals ( htmlTag ) ) return true ; [CE] no suitable method found for get()  [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { [ATTENTION] if ( stack . get ( ) - 3 = = 0&& childTag . equals ( htmlTag ) ) return true ;  for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^242^243^^^^241^253^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) [ATTENTION] return false ;  for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^243^^^^^241^253^
[REPLACE]  if  (  parent2  .  isValidParent  (  childTag  )  )  { 	[BUGGY] if ( parent2 . equals ( childTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; [ATTENTION] if ( parent2 . equals ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^248^^^^^241^253^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { [ATTENTION] return false ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^249^^^^^241^253^
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = stack . size ( ) + 1 -1 ; i > = 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node [ATTENTION] for ( int i = stack . size ( ) + 1 -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^245^^^^^241^253^
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ; 	[BUGGY] Element el = stack . getLast ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { [ATTENTION] Element el = stack . getLast ( ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^246^^^^^241^253^
[REPLACE]  Tag  parent2  =  el  .  tag  (  )  ; 	[BUGGY] Tag parent2 = el . tagName ( ) ; [CE] incompatible types  [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; [ATTENTION] Tag parent2 = el . tagName ( )  ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^247^^^^^241^253^
[ADD]  Tag  parent2  =  el  .  tag  (  )  ; 	[BUGGY] [CE] cannot find symbol parent2  [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; [ATTENTION] if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^247^^^^^241^253^
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = stack . size ( ) - 5 -0 ; i > = 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node [ATTENTION] for ( int i = stack . size ( ) - 5 -0 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^245^^^^^241^253^
[ADD]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node [ATTENTION]   } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^245^246^247^248^249^241^253^
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ; 	[BUGGY] Element el = stack . add ( i ) ; [CE] no suitable method found for add(int)  [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { [ATTENTION] Element el = stack . add ( i )  ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^246^^^^^241^253^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  stackHasValidParent [TYPE] boolean [PARAMETER] Tag childTag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int i  [CONTEXT]  private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( )  = = 1 && childTag . equals ( htmlTag ) ) return true ; // root is valid for html node for ( int i = stack . size ( ) -1 ; i > = 0 ; i-- ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^252^^^^^241^253^
[REPLACE]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ; 	[BUGGY] if ( last ( ) . tag ( ) . equals ( titleTag ) ) return last ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { [ATTENTION] if ( last ( )  . tag ( )  . equals ( titleTag ) ) return last ( )  ;  else stack . removeLast ( ) ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^257^258^^^^255^263^
[ADD]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ;  else  stack  .  removeLast  (  )  ;  } 	[BUGGY] return last ( ) ; stack . removeLast ( ) ; [CE] illegal start of expression  [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { [ATTENTION] return last ( )  ; stack . removeLast ( )  ;   return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^257^258^259^260^261^255^263^
[REPLACE]  stack  .  removeLast  (  )  ; 	[BUGGY] stack . getLast ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { if ( last ( ) . tag ( ) . canContain ( tag ) ) return last ( ) ; else [ATTENTION] stack . getLast ( )  ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^260^^^^^255^263^
[ADD]  stack  .  removeLast  (  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { if ( last ( ) . tag ( ) . canContain ( tag ) ) return last ( ) ; else [ATTENTION] } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^260^^^^^255^263^
[REPLACE]  return  last  (  )  ; 	[BUGGY] return parent ; [CE] cannot find symbol parent  [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { if ( last ( ) . tag ( ) . canContain ( tag ) ) [ATTENTION] return parent ; else stack . removeLast ( ) ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^258^^^^^255^263^
[REPLACE]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ; 	[BUGGY] if ( last ( ) . tag ( ) . canContain ( parentTag ) ) return last ( ) ; [CE] cannot find symbol parentTag  [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { [ATTENTION] if ( last ( )  . tag ( )  . canContain ( parentTag ) ) return last ( )  ;  else stack . removeLast ( ) ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^257^258^^^^255^263^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  popStackToSuitableContainer [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element popStackToSuitableContainer ( Tag tag ) { while ( !stack . isEmpty ( ) ) { if ( last ( ) . tag ( ) . canContain ( tag ) ) return last ( ) ; else stack . removeLast ( ) ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^262^^^^^255^263^
[REPLACE]  int  counter  =  0; 	[BUGGY] int counter = 3 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  [ATTENTION] int counter = 3 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^267^^^^^265^286^
[ADD]  int  counter  =  0;  Element  elToClose  =  null; 	[BUGGY] Element elToClose = null ; [CE] cannot find symbol counter  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  [ATTENTION] Element elToClose = null ;  for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^267^268^^^^265^286^
[REPLACE]  Element  elToClose  =  null; 	[BUGGY] Element elToClose = true ; [CE] incompatible types  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; [ATTENTION] Element elToClose = true ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^268^^^^^265^286^
[REPLACE]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  { 	[BUGGY] if ( elTag . isValidParent ( bodyTag ) && elTag . equals ( htmlTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; [ATTENTION] if ( elTag . isValidParent ( bodyTag ) && elTag . equals ( htmlTag ) ) { break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^273^^^^^265^286^
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  { 	[BUGGY]  if ( elTag . equals ( titleTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] }if ( elTag . equals ( titleTag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^^^^^265^286^
[ADD]  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break;  } 	[BUGGY]  break ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] } break ;   } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^276^277^278^^265^286^
[REPLACE]  elToClose  =  el; 	[BUGGY] elToClose =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { [ATTENTION] elToClose = null ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^276^^^^^265^286^
[ADD]  elToClose  =  el;  break; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { [ATTENTION]  } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^276^277^^^^265^286^
[ADD]  elToClose  =  el; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { [ATTENTION] break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^276^^^^^265^286^
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  { 	[BUGGY] else if ( elTag . equals ( titleTag ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] } else if ( elTag . equals ( titleTag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^^^^^265^286^
[ADD]  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break;  } 	[BUGGY]  elToClose = el ; break ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] } elToClose = el ; break ;   } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^276^277^278^^265^286^
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >  0;  i--  )  { 	[BUGGY] for ( int i = stack . size ( ) + 5 -0 ; i > 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; [ATTENTION] for ( int i = stack . size ( ) + 5 -0 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^269^^^^^265^286^
[REPLACE]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  { 	[BUGGY] if ( elTag . endsWith ( DQ )  && elTag[CE] ')' expected  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; [ATTENTION] if ( elTag . endsWith ( DQ ) && elTag break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^273^^^^^265^286^
[ADD]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  break;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break; 	[BUGGY] break ; elToClose = el ; break ; [CE] illegal start of type  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; [ATTENTION] break ; elToClose = el ; break ;   } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^273^274^275^276^277^265^286^
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  { 	[BUGGY] else if ( el tag  ) {[CE] ')' expected  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] } else if ( eltag ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^^^^^265^286^
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  { 	[BUGGY] else if ( elTag . equals ( parentTag ) ) {[CE] cannot find symbol parentTag  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; [ATTENTION] } else if ( elTag . equals ( parentTag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^275^^^^^265^286^
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ; 	[BUGGY] Element el = stack . add ( i ) ; [CE] no suitable method found for add(int)  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; [ATTENTION] Element el = stack . add ( i )  ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^271^^^^^265^286^
[REPLACE]  Tag  elTag  =  el  .  tag  (  )  ; 	[BUGGY] Tag elToCloseTag = el . tag ( ) ; [CE] cannot find symbol elTag  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; [ATTENTION] Tag elToCloseTag = el . tag ( )  ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^272^^^^^265^286^
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >  0;  i--  )  { 	[BUGGY] for ( int i = stack . size ( ) / 2 -1 ; i > 0 ; i-- ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; [ATTENTION] for ( int i = stack . size ( ) /2 -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^269^^^^^265^286^
[REPLACE]  Tag  elTag  =  el  .  tag  (  )  ; 	[BUGGY] Tag elToCloseTag = el . tagName ( ) ; [CE] incompatible types  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; [ATTENTION] Tag elToCloseTag = el . tagName ( )  ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^272^^^^^265^286^
[REPLACE]  if  (  elToClose  !=  null  )  { 	[BUGGY] if ( elToClose = = null ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } [ATTENTION] if ( elToClose = = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^280^^^^^265^286^
[ADD]  if  (  elToClose  !=  null  )  {  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack  .  removeLast  (  )  ;  } 	[BUGGY] [CE] illegal start of type  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } [ATTENTION]   } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^280^281^282^283^^265^286^
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  { 	[BUGGY] for ( int i = 0 ; i > counter ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { [ATTENTION] for ( int i = 0 ; i>counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^281^^^^^265^286^
[ADD]  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack  .  removeLast  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { [ATTENTION]  } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^281^282^283^^^265^286^
[REPLACE]  stack  .  removeLast  (  )  ; 	[BUGGY] stack . getLast ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { [ATTENTION] stack . getLast ( )  ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^282^^^^^265^286^
[ADD]  stack  .  removeLast  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { [ATTENTION] } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^282^^^^^265^286^
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  { 	[BUGGY] for ( int i = 2 ; i < counter ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { [ATTENTION] for ( int i = 2 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^281^^^^^265^286^
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  { 	[BUGGY] for ( int i = 0 ; i > =  counter ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { [ATTENTION] for ( int i = 0 ; i> = counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^281^^^^^265^286^
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  { 	[BUGGY] for ( int i = 0 + 0 ; i < counter ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { [ATTENTION] for ( int i = 0 + 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } return elToClose ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^281^^^^^265^286^
[REPLACE]  return  elToClose; 	[BUGGY] return el ; [CE] cannot find symbol el  [METHOD]  popStackToClose [TYPE] Element [PARAMETER] Tag tag [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] boolean false true [TYPE] Element el elToClose [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] Document doc [TYPE] LinkedList stack [TYPE] int counter i  [CONTEXT]  private Element popStackToClose ( Tag tag ) {  int counter = 0 ; Element elToClose = null ; for ( int i = stack . size ( ) -1 ; i > 0 ; i-- ) { counter++ ; Element el = stack . get ( i ) ; Tag elTag = el . tag ( ) ; if ( elTag . equals ( bodyTag ) || elTag . equals ( htmlTag ) ) { // once in body , don't close past body break ; } else if ( elTag . equals ( tag ) ) { elToClose = el ; break ; } } if ( elToClose ! = null ) { for ( int i = 0 ; i < counter ; i++ ) { stack . removeLast ( ) ; } } [ATTENTION] return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^285^^^^^265^286^
[REPLACE]  return  stack  .  getLast  (  )  ; 	[BUGGY] return stack . removeLast ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  last [TYPE] Element [PARAMETER] [CLASS] Parser  [TYPE] TokenQueue tq [TYPE] String DQ SQ baseUri bodyHtml data href html key rawText tagName text value [TYPE] Tag bodyTag childTag elTag headTag htmlTag parent2 parentTag tag textareaTag titleTag [TYPE] boolean false true [TYPE] Document doc [TYPE] LinkedList stack  [CONTEXT]  private Element last ( ) { [ATTENTION] return stack . removeLast ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/parser/Parser.java^289^^^^^288^290^
[REPLACE]  InputStream  inStream  =  new  FileInputStream  (  in  )  ; 	[BUGGY] int res = conn . getResponseCode ( ) ; [CE] cannot find symbol conn  [METHOD]  load [TYPE] String [PARAMETER] File in String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charsetName data [TYPE] File in  [CONTEXT]  static String load ( File in , String charsetName ) throws IOException { [ATTENTION] int res = conn . getResponseCode ( )  ; String data = readInputStream ( inStream , charsetName ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^23^^^^^22^27^
[REPLACE]  String  data  =  readInputStream  (  inStream,  charsetName  )  ; 	[BUGGY] String data = readInputStream ( inStream , data ) ; [CE] variable data might not have been initialized  [METHOD]  load [TYPE] String [PARAMETER] File in String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charsetName data [TYPE] File in  [CONTEXT]  static String load ( File in , String charsetName ) throws IOException { InputStream inStream = new FileInputStream ( in ) ; [ATTENTION] String data = readInputStream ( inStream , data )  ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^24^^^^^22^27^
[ADD]  String  data  =  readInputStream  (  inStream,  charsetName  )  ; 	[BUGGY] [CE] cannot find symbol data  [METHOD]  load [TYPE] String [PARAMETER] File in String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charsetName data [TYPE] File in  [CONTEXT]  static String load ( File in , String charsetName ) throws IOException { InputStream inStream = new FileInputStream ( in ) ; [ATTENTION] inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^24^^^^^22^27^
[REPLACE]  inStream  .  close  (  )  ; 	[BUGGY] int res = conn . getResponseCode ( ) ; [CE] cannot find symbol conn  [METHOD]  load [TYPE] String [PARAMETER] File in String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charsetName data [TYPE] File in  [CONTEXT]  static String load ( File in , String charsetName ) throws IOException { InputStream inStream = new FileInputStream ( in ) ; String data = readInputStream ( inStream , charsetName ) ; [ATTENTION] int res = conn . getResponseCode ( )  ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^25^^^^^22^27^
[REPLACE]  return  data; 	[BUGGY] return data . toString ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] File in String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charsetName data [TYPE] File in  [CONTEXT]  static String load ( File in , String charsetName ) throws IOException { InputStream inStream = new FileInputStream ( in ) ; String data = readInputStream ( inStream , charsetName ) ; inStream . close ( ) ; [ATTENTION] return data . toString ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^26^^^^^22^27^
[REPLACE]  String  protocol  =  url  .  getProtocol  (  )  ; 	[BUGGY] String protocol = url . toString ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { [ATTENTION] String protocol = url . toString ( )  ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^37^^^^^36^61^
[ADD]  String  protocol  =  url  .  getProtocol  (  )  ; 	[BUGGY] [CE] cannot find symbol protocol  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { [ATTENTION] Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^37^^^^^36^61^
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (    "http  "  )  ||  protocol  .  equals  (    "https  "  )  ,    "Only  http  &  https  protocols  supported  "  )  ; 	[BUGGY] Validate . isTrue ( protocol . equals (   "http  " ) && protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; [ATTENTION] Validate . isTrue ( protocol . equals (   "http  " ) && protocol . equals (   "https  " )  ,   "Only http & https protocols supported  " )  ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^38^^^^^36^61^
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (    "http  "  )  ||  protocol  .  equals  (    "https  "  )  ,    "Only  http  &  https  protocols  supported  "  )  ; 	[BUGGY] Validate . isTrue ( protocol . startsWith ( data )  || protocol[CE] ')' expected  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; [ATTENTION] Validate . isTrue ( protocol . startsWith ( data ) || protocol HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^38^^^^^36^61^
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (    "http  "  )  ||  protocol  .  equals  (    "https  "  )  ,    "Only  http  &  https  protocols  supported  "  )  ; 	[BUGGY] Validate . isTrue ( data . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ; [CE] cannot find symbol data  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; [ATTENTION] Validate . isTrue ( data . equals (   "http  " ) || protocol . equals (   "https  " )  ,   "Only http & https protocols supported  " )  ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^38^^^^^36^61^
[REPLACE]  HttpURLConnection  conn  =  (  HttpURLConnection  )  url  .  openConnection  (  )  ; 	[BUGGY] HttpURLConnection conn =  ( HttpURLConnection ) url . getProtocol ( ) ; [CE] inconvertible types  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  [ATTENTION] HttpURLConnection conn = ( HttpURLConnection ) url . getProtocol ( )  ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^40^^^^^36^61^
[REPLACE]  conn  .  setInstanceFollowRedirects  (  true  )  ; 	[BUGGY] conn . getResponseCode ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; [ATTENTION] conn . getResponseCode ( ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^41^^^^^36^61^
[REPLACE]  conn  .  setConnectTimeout  (  timeoutMillis  )  ; 	[BUGGY] conn . setConnectTimeout ( res ) ; [CE] cannot find symbol res  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; [ATTENTION] conn . setConnectTimeout ( res )  ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^42^^^^^36^61^
[REPLACE]  conn  .  setReadTimeout  (  timeoutMillis  )  ; 	[BUGGY] conn . setReadTimeout ( res ) ; [CE] cannot find symbol res  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; [ATTENTION] conn . setReadTimeout ( res )  ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^43^^^^^36^61^
[REPLACE]  conn  .  connect  (  )  ; 	[BUGGY] conn . getContentType ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; [ATTENTION] conn . getContentType ( )  ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^44^^^^^36^61^
[REPLACE]  int  res  =  conn  .  getResponseCode  (  )  ; 	[BUGGY] int res = conn . setInstanceFollowRedirects ( false )  ; [CE] incompatible types  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  [ATTENTION] int res = conn . setInstanceFollowRedirects ( false ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^46^^^^^36^61^
[REPLACE]  if  (  res  !=  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  "    ")  ; 	[BUGGY] if ( res  = =  HttpURLConnection . HTTP_OK ) throw new IOException (  "   ")  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; [ATTENTION] if ( res = = HttpURLConnection . HTTP_OK ) throw new IOException (   "   " ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^47^48^^^^36^61^
[ADD]  if  (  res  !=  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  "    ")  ;  String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  ==  null  ||  !contentType  .  startsWith  (    "text/  "  )  ) 	[BUGGY] [CE] cannot find symbol contentType  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; [ATTENTION]   throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^47^48^^50^51^36^61^
[REPLACE]  throw  new  IOException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) [ATTENTION] return ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^48^^^^^36^61^
[REPLACE]  throw  new  IOException  (  "    ")  ; 	[BUGGY] conn . connect ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) [ATTENTION] conn . connect ( )  ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^48^^^^^36^61^
[ADD]  throw  new  IOException  (  "    ")  ; 	[BUGGY] [CE] not a statement  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) [ATTENTION]  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^48^^^^^36^61^
[REPLACE]  String  contentType  =  conn  .  getContentType  (  )  ; 	[BUGGY] String contentType = conn . connect ( ) ; [CE] incompatible types  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  [ATTENTION] String contentType = conn . connect ( )  ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^50^^^^^36^61^
[REPLACE]  if  (  contentType  ==  null  ||  !contentType  .  startsWith  (    "text/  "  )  )  t  contentType,  url  .  toString  (  )  )  )  ; 	[BUGGY] if ( contentType ! = null || !contentType . startsWith (   "text/  " ) ) t contentType , url . getProtocol ( ) ) ) ; [CE] not a statement  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; [ATTENTION] if ( contentType ! = null || !contentType . startsWith (   "text/  " ) ) t contentType , url . getProtocol ( ) ) )  ;   InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^51^52^53^^^36^61^
[REPLACE]  t  contentType,  url  .  toString  (  )  )  )  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) [ATTENTION] return ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^52^53^^^^36^61^
[REPLACE]  t  contentType,  url  .  toString  (  )  )  )  ; 	[BUGGY] t protocol , url . toString ( ) ) ) ; [CE] not a statement  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) [ATTENTION] t protocol , url . toString ( ) ) )  ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^52^53^^^^36^61^
[REPLACE]  contentType,  url  .  toString  (  )  )  )  ; 	[BUGGY] contentType , url . getProtocol ( )  ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , [ATTENTION] contentType , url . getProtocol ( )  ) )  ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^53^^^^^36^61^
[REPLACE]  InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ; 	[BUGGY] InputStream inStream = new BufferedInputStream ( conn . getContentType ( ) ) ; [CE] no suitable constructor found for BufferedInputStream(String)  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  [ATTENTION] InputStream inStream = new BufferedInputStream ( conn . getContentType ( ) )  ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^55^^^^^36^61^
[REPLACE]  String  charSet  =    "UTF-8  "; 	[BUGGY] int res = conn . getResponseCode ( ) ; [CE] variable res is already defined in method load(URL , int)  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; [ATTENTION] int res = conn . getResponseCode ( )  ;  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^56^^^^^36^61^
[REPLACE]  String  data  =  readInputStream  (  inStream,  charSet  )  ; 	[BUGGY] String data = readInputStream ( inStream , charsetName ) ; [CE] cannot find symbol charsetName  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  [ATTENTION] String data = readInputStream ( inStream , charsetName )  ; inStream . close ( ) ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^58^^^^^36^61^
[REPLACE]  inStream  .  close  (  )  ; 	[BUGGY] int res = conn . getResponseCode ( ) ; [CE] variable res is already defined in method load(URL , int)  [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; [ATTENTION] int res = conn . getResponseCode ( )  ; return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^59^^^^^36^61^
[REPLACE]  return  data; 	[BUGGY] return protocol ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  load [TYPE] String [PARAMETER] URL url int timeoutMillis [CLASS] DataUtil  [TYPE] HttpURLConnection conn [TYPE] boolean false true [TYPE] InputStream inStream [TYPE] String charSet contentType data protocol [TYPE] URL url [TYPE] int res timeoutMillis  [CONTEXT]  static String load ( URL url , int timeoutMillis ) throws IOException { String protocol = url . getProtocol ( ) ; Validate . isTrue ( protocol . equals (   "http  " ) || protocol . equals (   "https  " ) ,   "Only http & https protocols supported  " ) ;  HttpURLConnection conn =  ( HttpURLConnection ) url . openConnection ( ) ; conn . setInstanceFollowRedirects ( true ) ; conn . setConnectTimeout ( timeoutMillis ) ; conn . setReadTimeout ( timeoutMillis ) ; conn . connect ( ) ;  int res = conn . getResponseCode ( ) ; if ( res ! = HttpURLConnection . HTTP_OK ) throw new IOException ( res +   " error loading URL   " + url . toString ( ) ) ;  String contentType = conn . getContentType ( ) ; if ( contentType = = null || !contentType . startsWith (   "text/  " ) ) throw new IOException ( String . format (   "Unhandled content type \  "%s\  " on URL %s . Must be text/*  " , contentType , url . toString ( ) ) ) ;  InputStream inStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; String charSet =   "UTF-8  " ; // todo[must]: get from content-encoding , or http-equiv ( two-pass? )  String data = readInputStream ( inStream , charSet ) ; inStream . close ( ) ; [ATTENTION] return protocol ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^60^^^^^36^61^
[REPLACE]  char[]  buffer  =  new  char[0x20000]; 	[BUGGY] StringBuilder data = new StringBuilder ( 0x20000 ) ; [CE] variable data is already defined in method readInputStream(InputStream , String)  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { [ATTENTION] StringBuilder data = new StringBuilder ( 0x20000 )  ; StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^64^^^^^63^77^
[REPLACE]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ; 	[BUGGY] char[] buffer = new char[0x20000] ; [CE] variable buffer is already defined in method readInputStream(InputStream , String)  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K [ATTENTION] char[] buffer = new char[0x20000] ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^65^^^^^63^77^
[ADD]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ; 	[BUGGY] Reader inReader = new InputStreamReader ( inStream , charsetName ) ; [CE] cannot find symbol data  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K [ATTENTION] Reader inReader = new InputStreamReader ( inStream , charsetName )  ;  int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^65^66^^^^63^77^
[REPLACE]  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ; 	[BUGGY] String data = readInputStream ( inStream , charSet ) ; [CE] variable data is already defined in method readInputStream(InputStream , String)  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; [ATTENTION] String data = readInputStream ( inStream , charSet )  ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^66^^^^^63^77^
[ADD]  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;  int  read; 	[BUGGY] int read ; [CE] cannot find symbol inReader  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; [ATTENTION] int read ;  do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^66^67^^^^63^77^
[REPLACE]  int  read; 	[BUGGY] int res = conn . getResponseCode ( ) ; [CE] cannot find symbol conn  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; [ATTENTION] int res = conn . getResponseCode ( )  ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^67^^^^^63^77^
[REPLACE]  if  (  read  >  0  )  { 	[BUGGY] if ( read ! =  0 ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; [ATTENTION] if ( read! = 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^70^^^^^63^77^
[REPLACE]  data  .  append  (  buffer,  0,  read  )  ; 	[BUGGY] data . append ( buffer , 0 % 2 , read ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { [ATTENTION] data . append ( buffer , 0 % 2 , read )  ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^71^^^^^63^77^
[REPLACE]  read  =  inReader  .  read  (  buffer,  0,  buffer  .  length  )  ; 	[BUGGY] read = inReader . read ( buffer , 0 , buffer . length ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { [ATTENTION] read = inReader . read ( buffer , 0 , buffer . length )  ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^69^^^^^63^77^
[ADD]  read  =  inReader  .  read  (  buffer,  0,  buffer  .  length  )  ; 	[BUGGY] [CE] variable read might not have been initialized  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { [ATTENTION] if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  return data . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^69^^^^^63^77^
[REPLACE]  return  data  .  toString  (  )  ; 	[BUGGY] return data ; [CE] incompatible types  [METHOD]  readInputStream [TYPE] String [PARAMETER] InputStream inStream String charsetName [CLASS] DataUtil  [TYPE] boolean false true [TYPE] StringBuilder data [TYPE] InputStream inStream [TYPE] Reader inReader [TYPE] String charsetName [TYPE] int read [TYPE] char[] buffer  [CONTEXT]  private static String readInputStream ( InputStream inStream , String charsetName ) throws IOException { char[] buffer = new char[0x20000] ; // ~ 130K StringBuilder data = new StringBuilder ( 0x20000 ) ; Reader inReader = new InputStreamReader ( inStream , charsetName ) ; int read ; do { read = inReader . read ( buffer , 0 , buffer . length ) ; if ( read > 0 ) { data . append ( buffer , 0 , read ) ; } } while ( read > = 0 ) ;  [ATTENTION] return data ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/DataUtil.java^76^^^^^63^77^
[REPLACE]  super  (  Tag  .  valueOf  (    "#root  "  )  ,  baseUri  )  ; 	[BUGGY] super (    "#root  "  , baseUri ) ; [CE] no suitable constructor found for Element(String , String)  [METHOD]  <init> [TYPE] String) [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] String baseUri  [CONTEXT]  public Document ( String baseUri ) { [ATTENTION] super (   "#root  " , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^22^^^^^21^23^
[ADD]  super  (  Tag  .  valueOf  (    "#root  "  )  ,  baseUri  )  ; 	[BUGGY] [CE] no suitable constructor found for Element()  [METHOD]  <init> [TYPE] String) [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] String baseUri  [CONTEXT]  public Document ( String baseUri ) { [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^22^^^^^21^23^
[REPLACE]  Validate  .  notNull  (  baseUri  )  ; 	[BUGGY] baseUri  ; [CE] not a statement  [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { [ATTENTION] baseUri ;  Document doc = new Document ( baseUri ) ; Element html = doc . appendElement (   "html  " ) ; html . appendElement (   "head  " ) ; html . appendElement (   "body  " ) ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^31^^^^^30^39^
[REPLACE]  Document  doc  =  new  Document  (  baseUri  )  ; 	[BUGGY] Element html = doc . appendElement (   "html  " ) ; [CE] cannot find symbol doc  [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  [ATTENTION] Element html = doc . appendElement (   "html  " )  ; Element html = doc . appendElement (   "html  " ) ; html . appendElement (   "head  " ) ; html . appendElement (   "body  " ) ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^33^^^^^30^39^
[ADD]  Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (    "html  "  )  ; 	[BUGGY] Element html = doc . appendElement (   "html  " ) ; [CE] cannot find symbol doc  [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  [ATTENTION] Element html = doc . appendElement (   "html  " )  ;  html . appendElement (   "head  " ) ; html . appendElement (   "body  " ) ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^33^34^^^^30^39^
[REPLACE]  Element  html  =  doc  .  appendElement  (    "html  "  )  ; 	[BUGGY] Element html = doc . prependElement (   "html  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  Document doc = new Document ( baseUri ) ; [ATTENTION] Element html = doc . prependElement (   "html  " )  ; html . appendElement (   "head  " ) ; html . appendElement (   "body  " ) ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^34^^^^^30^39^
[REPLACE]  html  .  appendElement  (    "head  "  )  ; 	[BUGGY] html . prependElement ( baseUri )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  Document doc = new Document ( baseUri ) ; Element html = doc . appendElement (   "html  " ) ; [ATTENTION] html . prependElement ( baseUri ) ; html . appendElement (   "body  " ) ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^35^^^^^30^39^
[REPLACE]  html  .  appendElement  (    "body  "  )  ; 	[BUGGY] html . text (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  Document doc = new Document ( baseUri ) ; Element html = doc . appendElement (   "html  " ) ; html . appendElement (   "head  " ) ; [ATTENTION] html . text (   "body  " )  ;  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^36^^^^^30^39^
[ADD]  html  .  appendElement  (    "body  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  Document doc = new Document ( baseUri ) ; Element html = doc . appendElement (   "html  " ) ; html . appendElement (   "head  " ) ; [ATTENTION]  return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^36^^^^^30^39^
[REPLACE]  return  doc; 	[BUGGY] return   "#document  " ; [CE] incompatible types  [METHOD]  createShell [TYPE] Document [PARAMETER] String baseUri [CLASS] Document  [TYPE] boolean false true [TYPE] Element html [TYPE] String baseUri [TYPE] Document doc  [CONTEXT]  static public Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ;  Document doc = new Document ( baseUri ) ; Element html = doc . appendElement (   "html  " ) ; html . appendElement (   "head  " ) ; html . appendElement (   "body  " ) ;  [ATTENTION] return   "#document  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^38^^^^^30^39^
[REPLACE]  return  getElementsByTag  (    "head  "  )    .  first  (  )  ; 	[BUGGY] return getElementsByTag (   "body  " ) . first ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  head [TYPE] Element [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Element head ( ) { [ATTENTION] return getElementsByTag (   "body  " )  . first ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^46^^^^^45^47^
[REPLACE]  return  getElementsByTag  (    "body  "  )    .  first  (  )  ; 	[BUGGY] return getElementsByTag (   "head  " ) . first ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  body [TYPE] Element [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Element body ( ) { [ATTENTION] return getElementsByTag (   "head  " )  . first ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^54^^^^^53^55^
[REPLACE]  Element  titleEl  =  getElementsByTag  (    "title  "  )    .  first  (  )  ; 	[BUGGY] Element titleEl = getElementsByTag (   "title  " )  . trim ( )  ; [CE] cannot find symbol  [METHOD]  title [TYPE] String [PARAMETER] [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl  [CONTEXT]  public String title ( ) { [ATTENTION] Element titleEl = getElementsByTag (   "title  " ) . trim ( ) ; return titleEl ! = null ? titleEl . text ( ) . trim ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^62^^^^^61^64^
[ADD]  Element  titleEl  =  getElementsByTag  (    "title  "  )    .  first  (  )  ;  return  titleEl  !=  null  ?  titleEl  .  text  (  )    .  trim  (  )  :    "  "; 	[BUGGY] [CE] missing return statement  [METHOD]  title [TYPE] String [PARAMETER] [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl  [CONTEXT]  public String title ( ) { [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^62^63^^^^61^64^
[REPLACE]  return  titleEl  !=  null  ?  titleEl  .  text  (  )    .  trim  (  )  :    "  "; 	[BUGGY] return titleEl ! = true ? titleEl . text ( ) . text ( ) :   "  " ; [CE] incomparable types: Element and boolean  [METHOD]  title [TYPE] String [PARAMETER] [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl  [CONTEXT]  public String title ( ) { Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; [ATTENTION] return titleEl ! = true ? titleEl . text ( )  . text ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^63^^^^^61^64^
[REPLACE]  Validate  .  notNull  (  title  )  ; 	[BUGGY] title  ; [CE] not a statement  [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { [ATTENTION] title ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^72^^^^^71^79^
[REMOVE]   	[BUGGY] Validate . notNull ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { [ATTENTION] Validate . notNull ( title ) ;  Validate . notNull ( baseUri )  ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { titleEl . text ( title ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^72^^^^^71^79^
[REPLACE]  Element  titleEl  =  getElementsByTag  (    "title  "  )    .  first  (  )  ; 	[BUGGY] Element html = doc . appendElement (   "html  " ) ; [CE] cannot find symbol doc  [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; [ATTENTION] Element html = doc . appendElement (   "html  " )  ; if ( titleEl = = null ) { // add to head head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^73^^^^^71^79^
[REPLACE]  if  (  titleEl  ==  null  )  { 	[BUGGY] if ( titleEl ! = null ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; [ATTENTION] if ( titleEl ! = null ) { head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^74^^^^^71^79^
[REPLACE]  titleEl  .  text  (  title  )  ; 	[BUGGY] titleEl . appendElement ( title ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { [ATTENTION] titleEl . appendElement ( title )  ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^77^^^^^71^79^
[ADD]  titleEl  .  text  (  title  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head head ( ) . appendElement (   "title  " ) . text ( title ) ; } else { [ATTENTION] } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^77^^^^^71^79^
[REPLACE]  head  (  )    .  appendElement  (    "title  "  )    .  text  (  title  )  ; 	[BUGGY] head ( ) . appendElement (   "title  " ) . select ( title ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head [ATTENTION] head ( )  . appendElement (   "title  " )  . select ( title )  ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^75^^^^^71^79^
[ADD]  head  (  )    .  appendElement  (    "title  "  )    .  text  (  title  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head [ATTENTION] } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^75^^^^^71^79^
[REPLACE]  head  (  )    .  appendElement  (    "title  "  )    .  text  (  title  )  ; 	[BUGGY] head ( )  . prependElement ( title )  . text ( title ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head [ATTENTION] head ( ) . prependElement ( title ) . text ( title )  ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^75^^^^^71^79^
[REPLACE]  head  (  )    .  appendElement  (    "title  "  )    .  text  (  title  )  ; 	[BUGGY] body ( ) . text ( text ) ; [CE] cannot find symbol text  [METHOD]  title [TYPE] void [PARAMETER] String title [CLASS] Document  [TYPE] boolean false true [TYPE] Element titleEl [TYPE] String title  [CONTEXT]  public void title ( String title ) { Validate . notNull ( title ) ; Element titleEl = getElementsByTag (   "title  " ) . first ( ) ; if ( titleEl = = null ) { // add to head [ATTENTION] body ( )  . text ( text )  ; } else { titleEl . text ( title ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^75^^^^^71^79^
[REPLACE]  return  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  this  .  baseUri  (  )  )  ; 	[BUGGY] return new Element (  tagName  , this . baseUri ( ) ) ; [CE] no suitable constructor found for Element(String , String)  [METHOD]  createElement [TYPE] Element [PARAMETER] String tagName [CLASS] Document  [TYPE] boolean false true [TYPE] String tagName  [CONTEXT]  public Element createElement ( String tagName ) { [ATTENTION] return new Element ( tagName , this . baseUri ( ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^87^^^^^86^88^
[REPLACE]  if  (  select  (    "html  "  )    .  isEmpty  (  )  )  appendElement  (    "html  "  )  ; 	[BUGGY] if ( select (   "html  " )  . text ( )  ) appendElement (   "html  " ) ; [CE] incompatible types  [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { [ATTENTION] if ( select (   "html  " ) . text ( )  ) appendElement (   "html  " )  ;  if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^96^97^^^^95^110^
[REPLACE]  appendElement  (    "html  "  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . appendElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) [ATTENTION] select (   "html  " )  . first ( )  . appendElement (   "body  " )  ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^97^^^^^95^110^
[ADD]  appendElement  (    "html  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) [ATTENTION] if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^97^^^^^95^110^
[REPLACE]  if  (  head  (  )  ==  null  )  select  (    "html  "  )    .  first  (  )    .  prependElement  (    "head  "  )  ; 	[BUGGY] if ( head ( ) ! = null ) select (   "html  " ) . first ( ) . appendElement (   "head  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; [ATTENTION] if ( head ( ) ! = null ) select (   "html  " )  . first ( )  . appendElement (   "head  " )  ;  if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^98^99^^^^95^110^
[ADD]  if  (  head  (  )  ==  null  )  select  (    "html  "  )    .  first  (  )    .  prependElement  (    "head  "  )  ;  if  (  body  (  )  ==  null  )  select  (    "html  "  )    .  first  (  )    .  appendElement  (    "body  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; [ATTENTION]     normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^98^99^100^101^^95^110^
[REPLACE]  select  (    "html  "  )    .  first  (  )    .  prependElement  (    "head  "  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . appendElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) [ATTENTION] select (   "html  " )  . first ( )  . appendElement (   "body  " )  ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^99^^^^^95^110^
[REPLACE]  select  (    "html  "  )    .  first  (  )    .  prependElement  (    "head  "  )  ; 	[BUGGY] select (   "html  " )  . trim ( )  . prependElement (   "head  " ) ; [CE] cannot find symbol  [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) [ATTENTION] select (   "html  " ) . trim ( ) . prependElement (   "head  " )  ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^99^^^^^95^110^
[REPLACE]  if  (  body  (  )  ==  null  )  select  (    "html  "  )    .  first  (  )    .  appendElement  (    "body  "  )  ; 	[BUGGY] if ( body ( ) ! = null ) select (   "html  " )  . trim ( )  . appendElement (   "body  " ) ; [CE] cannot find symbol  [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; [ATTENTION] if ( body ( ) ! = null ) select (   "html  " ) . trim ( ) . appendElement (   "body  " )  ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^100^101^^^^95^110^
[ADD]  if  (  body  (  )  ==  null  )  select  (    "html  "  )    .  first  (  )    .  appendElement  (    "body  "  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . appendElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; [ATTENTION] select (   "html  " )  . first ( )  . appendElement (   "body  " )  ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^100^101^^^^95^110^
[REPLACE]  select  (    "html  "  )    .  first  (  )    .  appendElement  (    "body  "  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . prependElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) [ATTENTION] select (   "html  " )  . first ( )  . prependElement (   "body  " )  ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^101^^^^^95^110^
[REPLACE]  select  (    "html  "  )    .  first  (  )    .  appendElement  (    "body  "  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) [ATTENTION] select (   "html  " )  . first ( )  . prependElement (   "head  " )  ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^101^^^^^95^110^
[REPLACE]  normalise  (  head  (  )  )  ; 	[BUGGY] normalise ( select (   "html  " ) . first ( ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    [ATTENTION] normalise ( select (   "html  " )  . first ( ) )  ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^105^^^^^95^110^
[REMOVE]   	[BUGGY] body ( ) . text ( text ) ; [CE] cannot find symbol text  [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    [ATTENTION] normalise ( head ( ) ) ;  body ( )  . text ( text )  ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  return this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^105^^^^^95^110^
[REPLACE]  normalise  (  select  (    "html  "  )    .  first  (  )  )  ; 	[BUGGY] select (   "html  " ) . first ( ) . appendElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; [ATTENTION] select (   "html  " )  . first ( )  . appendElement (   "body  " )  ; normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^106^^^^^95^110^
[ADD]  normalise  (  select  (    "html  "  )    .  first  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; [ATTENTION] normalise ( this ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^106^^^^^95^110^
[REMOVE]   	[BUGGY] select (   "html  " ) . first ( ) . appendElement (   "body  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; [ATTENTION] normalise ( select (   "html  " ) . first ( ) ) ;  select (   "html  " )  . first ( )  . appendElement (   "body  " )  ; normalise ( this ) ;  return this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^106^^^^^95^110^
[REPLACE]  normalise  (  this  )  ; 	[BUGGY] body ( ) . text ( text ) ; [CE] cannot find symbol text  [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; [ATTENTION] body ( )  . text ( text )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^107^^^^^95^110^
[ADD]  normalise  (  this  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; [ATTENTION]  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^107^^^^^95^110^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] Document [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public Document normalise ( ) { if ( select (   "html  " ) . isEmpty ( ) ) appendElement (   "html  " ) ; if ( head ( )  = = null ) select (   "html  " ) . first ( ) . prependElement (   "head  " ) ; if ( body ( )  = = null ) select (   "html  " ) . first ( ) . appendElement (   "body  " ) ;    normalise ( head ( ) ) ; normalise ( select (   "html  " ) . first ( ) ) ; normalise ( this ) ;  [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^109^^^^^95^110^
[REPLACE]  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ; 	[BUGGY] for ( Node node: toMove ) { element . removeChild ( node ) ; [CE] ' ; ' expected  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { [ATTENTION] for ( Node node: toMove ) { element . removeChild ( node )  ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^114^^^^^113^128^
[REPLACE]  if  (  node  instanceof  TextNode  )  { 	[BUGGY] if ( ! node instanceof TextNode ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { [ATTENTION] if ( ! node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^116^^^^^113^128^
[REPLACE]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ; 	[BUGGY] if ( !tn . isBlank ( ) ) null . add ( tn ) ; [CE] <null> cannot be dereferenced  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; [ATTENTION] if ( !tn . isBlank ( ) ) null . add ( tn )  ;  } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^118^119^^^^113^128^
[ADD]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  } 	[BUGGY] toMove . add ( tn ) ; [CE] ' ; ' expected  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; [ATTENTION] toMove . add ( tn )  ;  } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^118^119^120^^^113^128^
[REPLACE]  toMove  .  add  (  tn  )  ; 	[BUGGY] body ( ) . text ( text ) ; [CE] cannot find symbol text  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; if ( !tn . isBlank ( ) ) [ATTENTION] body ( )  . text ( text )  ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^119^^^^^113^128^
[REPLACE]  TextNode  tn  =  (  TextNode  )  node; 	[BUGGY] List<Node> toMove = new ArrayList<Node> ( ) ; [CE] variable toMove is already defined in method normalise(Element)  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { [ATTENTION] List<Node> toMove = new ArrayList<Node> ( )  ; if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^117^^^^^113^128^
[REPLACE]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ; 	[BUGGY] if ( tn . isBlank ( ) ) toMove . add ( tn ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; [ATTENTION] if ( tn . isBlank ( ) ) toMove . add ( tn )  ;  } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^118^119^^^^113^128^
[REPLACE]  for  (  Node  node:  element  .  childNodes  )  { 	[BUGGY] for ( Node node: toMove ) { element . removeChild ( node ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; [ATTENTION] for ( Node node: toMove ) { element . removeChild ( node )  ; if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^115^^^^^113^128^
[ADD]  TextNode  tn  =  (  TextNode  )  node; 	[BUGGY] [CE] cannot find symbol tn  [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { [ATTENTION] if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( Node node: toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^117^^^^^113^128^
[REPLACE]  for  (  Node  node:  toMove  )  { 	[BUGGY] for ( Node node: toMove ) { element . removeChild ( node ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  normalise [TYPE] void [PARAMETER] Element element [CLASS] Document  [TYPE] boolean false true [TYPE] Element element [TYPE] Node node [TYPE] List toMove [TYPE] TextNode tn  [CONTEXT]  private void normalise ( Element element ) { List<Node> toMove = new ArrayList<Node> ( ) ; for ( Node node: element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn =  ( TextNode ) node ; if ( !tn . isBlank ( ) ) toMove . add ( tn ) ; } } [ATTENTION] for ( Node node: toMove ) { element . removeChild ( node )  ; element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode (   "   " ,   "  " ) ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^123^^^^^113^128^
[REPLACE]  return  super  .  html  (  )  ; 	[BUGGY] return super . isEmpty ( )  ; [CE] cannot find symbol  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public String outerHtml ( ) { [ATTENTION] return super . isEmpty ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^132^^^^^131^133^
[REPLACE]  body  (  )    .  text  (  text  )  ; 	[BUGGY] body ( ) . appendElement ( text ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Document  [TYPE] boolean false true [TYPE] String text  [CONTEXT]  public Element text ( String text ) { [ATTENTION] body ( )  . appendElement ( text )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^142^^^^^141^144^
[REPLACE]  body  (  )    .  text  (  text  )  ; 	[BUGGY] toMove . add ( tn ) ; [CE] cannot find symbol tn  [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Document  [TYPE] boolean false true [TYPE] String text  [CONTEXT]  public Element text ( String text ) { [ATTENTION] toMove . add ( tn )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^142^^^^^141^144^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Document  [TYPE] boolean false true [TYPE] String text  [CONTEXT]  public Element text ( String text ) { body ( ) . text ( text ) ; // overridden to not nuke doc structure [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^143^^^^^141^144^
[REPLACE]  return    "#document  "; 	[BUGGY] return doc ; [CE] cannot find symbol doc  [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] Document  [TYPE] boolean false true  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return doc ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Document.java^148^^^^^147^149^
[REPLACE]  private  String  tagName; 	[BUGGY] private char tagName ; [CE] incompatible types  [CONTEXT]    [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  	None^20^^^^^^^
[REPLACE]  private  String  id; 	[BUGGY] private char id ; [CE] incompatible types  [CONTEXT]    [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  	None^31^^^^^^^
[REPLACE]  private  String  className; 	[BUGGY] private char className ; [CE] incompatible types  [CONTEXT]    [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  	None^42^^^^^^^
[REPLACE]  protected  String  key; 	[BUGGY] protected byte key ; [CE] incompatible types  [CONTEXT]    [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  	None^115^^^^^^^
[REPLACE]  protected  String  value; 	[BUGGY] private String value ; [CE] value has private access in AttributeKeyPair  [CONTEXT]    [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  	None^116^^^^^^^
[REPLACE]  this  .  tagName  =  tagName; 	[BUGGY] this . className = className ;  ; [CE] cannot find symbol className  [METHOD]  <init> [TYPE] String) [PARAMETER] String tagName [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  Tag ( String tagName ) { [ATTENTION] this . className = className ;  ; }  	None^22^^^^^21^23^
[ADD]  this  .  tagName  =  tagName; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String tagName [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  Tag ( String tagName ) { [ATTENTION] }  	None^22^^^^^21^23^
[REPLACE]  this  .  id  =  id; 	[BUGGY] this . id =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String id [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  Id ( String id ) { [ATTENTION] this . id = null ; }  	None^33^^^^^32^34^
[REPLACE]  this  .  className  =  className; 	[BUGGY] this . tagName = tagName ;  ; [CE] cannot find symbol tagName  [METHOD]  <init> [TYPE] String) [PARAMETER] String className [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  Class ( String className ) { [ATTENTION] this . tagName = tagName ;  ; }  	None^44^^^^^43^45^
[REPLACE]  this  .  key  =  key; 	[BUGGY] this . key =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  Attribute ( String key ) { [ATTENTION] this . key = null ; }  	None^56^^^^^55^57^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] super ( key , tagName ) ; [CE] cannot find symbol tagName  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValue ( String key , String value ) { [ATTENTION] super ( key , tagName )  ; }  	None^66^^^^^65^67^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] super ( key , tagName ) ; [CE] cannot find symbol tagName  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueNot ( String key , String value ) { [ATTENTION] super ( key , tagName )  ; }  	None^76^^^^^75^77^
[REMOVE]   	[BUGGY] this . key = key . trim ( ) . toLowerCase ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueNot ( String key , String value ) { [ATTENTION] super ( key , value ) ;   	None^76^^^^^75^77^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] super ( key , tagName ) ; [CE] cannot find symbol tagName  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueStarting ( String key , String value ) { [ATTENTION] super ( key , tagName )  ; }  	None^86^^^^^85^87^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] Validate . notEmpty ( value ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueEnding ( String key , String value ) { [ATTENTION] Validate . notEmpty ( value )  ; }  	None^96^^^^^95^97^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] super ( key , tagName ) ; [CE] cannot find symbol tagName  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueContaining ( String key , String value ) { [ATTENTION] super ( key , tagName )  ; }  	None^106^^^^^105^107^
[ADD]  super  (  key,  value  )  ; 	[BUGGY] [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeWithValueContaining ( String key , String value ) { [ATTENTION] }  	None^106^^^^^105^107^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] key  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { [ATTENTION] key ; Validate . notEmpty ( value ) ;  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^119^^^^^118^124^
[ADD]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { [ATTENTION] Validate . notEmpty ( value ) ;  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^119^^^^^118^124^
[REPLACE]  Validate  .  notEmpty  (  value  )  ; 	[BUGGY] tagName  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; [ATTENTION] tagName ;  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^120^^^^^118^124^
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . value = value . trim ( ) . toLowerCase ( ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  [ATTENTION] this . value = value . trim ( )  . toLowerCase ( )  ;  ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^122^^^^^118^124^
[ADD]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  [ATTENTION] this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^122^^^^^118^124^
[REPLACE]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . key = key . trim ( ) . toLowerCase ( ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  this . key = key . trim ( ) . toLowerCase ( ) ; [ATTENTION] this . key = key . trim ( )  . toLowerCase ( )  ;  ; }  	None^123^^^^^118^124^
[REPLACE]  super  (  index  )  ; 	[BUGGY] super ( key , value ) ; [CE] cannot find symbol key  [METHOD]  <init> [TYPE] Evaluator$IndexLessThan(int) [PARAMETER] int index [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  IndexLessThan ( int index ) { [ATTENTION] super ( key , value )  ; }  	None^135^^^^^134^136^
[REPLACE]  super  (  index  )  ; 	[BUGGY] super ( key , value ) ; [CE] cannot find symbol key  [METHOD]  <init> [TYPE] Evaluator$IndexGreaterThan(int) [PARAMETER] int index [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  IndexGreaterThan ( int index ) { [ATTENTION] super ( key , value )  ; }  	None^145^^^^^144^146^
[REPLACE]  super  (  index  )  ; 	[BUGGY] super ( key , value ) ; [CE] cannot find symbol key  [METHOD]  <init> [TYPE] Evaluator$IndexEquals(int) [PARAMETER] int index [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  IndexEquals ( int index ) { [ATTENTION] super ( key , value )  ; }  	None^155^^^^^154^156^
[REPLACE]  this  .  index  =  index; 	[BUGGY] this . index =  null ; [CE] incompatible types  [METHOD]  <init> [TYPE] Evaluator$IndexEvaluator(int) [PARAMETER] int index [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] int index [TYPE] String className id key tagName value [TYPE] boolean false true  [CONTEXT]  IndexEvaluator ( int index ) { [ATTENTION] this . index = null ; }  	None^167^^^^^166^168^
[REPLACE]  return  (  element  .  tagName  (  )    .  equals  (  tagName  )  )  ; 	[BUGGY] return ( element . tagName ( )  . contains ( className )  ) ; [CE] cannot find symbol className  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( element . tagName ( ) . contains ( className )  )  ; }  	None^26^^^^^25^27^
[REPLACE]  return  (  id  .  equals  (  element  .  id  (  )  )  )  ; 	[BUGGY] return ( id . equalsIgnoreCase ( element . id ( ) ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( id . equalsIgnoreCase ( element . id ( ) ) )  ; }  	None^37^^^^^36^38^
[REPLACE]  return  (  element  .  hasClass  (  className  )  )  ; 	[BUGGY] return ( element . hasAttr ( className ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( element . hasAttr ( className ) )  ; }  	None^48^^^^^47^49^
[REPLACE]  return  (  element  .  hasAttr  (  key  )  )  ; 	[BUGGY] return ( element . attr ( key ) ) ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( element . attr ( key ) )  ; }  	None^60^^^^^59^61^
[REPLACE]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ; 	[BUGGY] return ( value . equals ( element . attr ( key ) ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( value . equals ( element . attr ( key ) ) )  ; }  	None^70^^^^^69^71^
[REPLACE]  return  (  !value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ; 	[BUGGY] return ( value . equalsIgnoreCase ( element . attr ( key ) ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return ( value . equalsIgnoreCase ( element . attr ( key ) ) )  ; }  	None^80^^^^^79^81^
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  startsWith  (  value  )  ; 	[BUGGY] return element . hasAttr ( key ) . toLowerCase ( ) . startsWith ( value ) ; [CE] boolean cannot be dereferenced  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . hasAttr ( key )  . toLowerCase ( )  . startsWith ( value )  ; }  	None^90^^^^^89^91^
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  endsWith  (  value  )  ; 	[BUGGY] return element . hasAttr ( className )  . toLowerCase ( ) . endsWith ( value ) ; [CE] cannot find symbol className  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . hasAttr ( className ) . toLowerCase ( )  . endsWith ( value )  ; }  	None^100^^^^^99^101^
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )  ; 	[BUGGY] return element . hasAttr ( key ) . toLowerCase ( ) . contains ( value ) ; [CE] boolean cannot be dereferenced  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . hasAttr ( key )  . toLowerCase ( )  . contains ( value )  ; }  	None^110^^^^^109^111^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return false ; }  	None^129^^^^^128^130^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  <  index; 	[BUGGY] return element . attr ( ) < index ; [CE] no suitable method found for attr()  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . attr ( ) < index ; }  	None^139^^^^^138^140^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  >  index; 	[BUGGY] return element . attr ( ) > index ; [CE] no suitable method found for attr()  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . attr ( ) > index ; }  	None^149^^^^^148^150^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  ==  index; 	[BUGGY] return element . attr ( )  = = index ; [CE] no suitable method found for attr()  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Evaluator Tag Id Class Attribute AttributeWithValue AttributeWithValueNot AttributeWithValueStarting AttributeWithValueEnding AttributeWithValueContaining AttributeKeyPair AllElements IndexLessThan IndexGreaterThan IndexEquals IndexEvaluator  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . attr ( ) = = index ; }  	None^159^^^^^158^160^
[REPLACE]  private  String  tagName; 	[BUGGY] private int tagName ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Tag  [TYPE] String className id key tagName value [TYPE] boolean false true [TYPE] int index [TYPE] Element element  [CONTEXT]   	^20^^^^^^^
[REPLACE]  this  .  tagName  =  tagName; 	[BUGGY] this . tagName =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String tagName [CLASS] Tag  [TYPE] String tagName [TYPE] boolean false true  [CONTEXT]  Tag ( String tagName ) { [ATTENTION] this . tagName = null ; }  	^22^^^^^21^23^
[REPLACE]  this  .  id  =  id; 	[BUGGY] this . id =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String id [CLASS] Id  [TYPE] String id [TYPE] boolean false true  [CONTEXT]  Id ( String id ) { [ATTENTION] this . id = null ; }  	None^33^^^^^32^34^
[REPLACE]  private  String  className; 	[BUGGY] private byte className ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Class  [TYPE] String id [TYPE] Element element [TYPE] boolean false true  [CONTEXT]   	None^42^^^^^^^
[REPLACE]  this  .  className  =  className; 	[BUGGY] this . className =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String className [CLASS] Class  [TYPE] String className [TYPE] boolean false true  [CONTEXT]  Class ( String className ) { [ATTENTION] this . className = null ; }  	None^44^^^^^43^45^
[REPLACE]  private  String  key; 	[BUGGY] private double key ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] Attribute  [TYPE] String className [TYPE] Element element [TYPE] boolean false true  [CONTEXT]   	^53^^^^^^^
[REPLACE]  this  .  key  =  key; 	[BUGGY] this . key =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key [CLASS] Attribute  [TYPE] String key [TYPE] boolean false true  [CONTEXT]  Attribute ( String key ) { [ATTENTION] this . key = null ; }  	^56^^^^^55^57^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] return ( value . equalsIgnoreCase ( element . attr ( key ) ) ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValue  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValue ( String key , String value ) { [ATTENTION] return ( value . equalsIgnoreCase ( element . attr ( key ) ) )  ; }  	None^66^^^^^65^67^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] return ( !value . equalsIgnoreCase ( element . attr ( key ) ) ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueNot  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueNot ( String key , String value ) { [ATTENTION] return ( !value . equalsIgnoreCase ( element . attr ( key ) ) )  ; }  	None^76^^^^^75^77^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] return element . attr ( key ) . toLowerCase ( ) . startsWith ( value ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueStarting  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueStarting ( String key , String value ) { [ATTENTION] return element . attr ( key )  . toLowerCase ( )  . startsWith ( value )  ; }  	None^86^^^^^85^87^
[ADD]  super  (  key,  value  )  ; 	[BUGGY] [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueStarting  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueStarting ( String key , String value ) { [ATTENTION] }  	None^86^^^^^85^87^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] return element . attr ( key ) . toLowerCase ( ) . endsWith ( value ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueEnding  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueEnding ( String key , String value ) { [ATTENTION] return element . attr ( key )  . toLowerCase ( )  . endsWith ( value )  ; }  	None^96^^^^^95^97^
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  endsWith  (  value  )  ; 	[BUGGY] return element . attr ( key ) . toLowerCase ( )  . toLowerCase ( )  ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] AttributeWithValueEnding  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . attr ( key )  . toLowerCase ( ) . toLowerCase ( ) ; }  	None^100^^^^^99^101^
[REPLACE]  super  (  key,  value  )  ; 	[BUGGY] return element . attr ( key ) . toLowerCase ( ) . contains ( value ) ; [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueContaining  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueContaining ( String key , String value ) { [ATTENTION] return element . attr ( key )  . toLowerCase ( )  . contains ( value )  ; }  	None^106^^^^^105^107^
[ADD]  super  (  key,  value  )  ; 	[BUGGY] [CE] constructor AttributeKeyPair in class AttributeKeyPair cannot be applied to given types ;  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeWithValueContaining  [TYPE] boolean false true [TYPE] String key value  [CONTEXT]  AttributeWithValueContaining ( String key , String value ) { [ATTENTION] }  	None^106^^^^^105^107^
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )  ; 	[BUGGY] return element . attr ( key ) . contains ( ) . contains ( value ) ; [CE] method contains in class String cannot be applied to given types ;  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] AttributeWithValueContaining  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . attr ( key )  . contains ( )  . contains ( value )  ; }  	None^110^^^^^109^111^
[REPLACE]  protected  String  key; 	[BUGGY] protected long key ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] AttributeKeyPair  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]   	None^115^^^^^^^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] key  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeKeyPair  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { [ATTENTION] key ; Validate . notEmpty ( value ) ;  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^119^^^^^118^124^
[ADD]  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeKeyPair  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { [ATTENTION]  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^119^120^^^^118^124^
[REPLACE]  Validate  .  notEmpty  (  value  )  ; 	[BUGGY] value  ; [CE] not a statement  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeKeyPair  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; [ATTENTION] value ;  this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^120^^^^^118^124^
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . value = value . trim ( ) . toLowerCase ( ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeKeyPair  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  [ATTENTION] this . value = value . trim ( )  . toLowerCase ( )  ;  ; this . value = value . trim ( ) . toLowerCase ( ) ; }  	None^122^^^^^118^124^
[REPLACE]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . key = key . trim ( ) . toLowerCase ( ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] AttributeKeyPair  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ;  this . key = key . trim ( ) . toLowerCase ( ) ; [ATTENTION] this . key = key . trim ( )  . toLowerCase ( )  ;  ; }  	None^123^^^^^118^124^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] AllElements  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return false ; }  	None^129^^^^^128^130^
[REPLACE]  super  (  index  )  ; 	[BUGGY] return element . elementSiblingIndex ( ) < index ; [CE] constructor IndexEvaluator in class IndexEvaluator cannot be applied to given types ;  [METHOD]  <init> [TYPE] Evaluator$IndexLessThan(int) [PARAMETER] int index [CLASS] IndexLessThan  [TYPE] boolean false true [TYPE] int index  [CONTEXT]  IndexLessThan ( int index ) { [ATTENTION] return element . elementSiblingIndex ( ) < index ; }  	None^135^^^^^134^136^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  <  index; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] IndexLessThan  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return true ; }  	None^139^^^^^138^140^
[REPLACE]  super  (  index  )  ; 	[BUGGY] return element . elementSiblingIndex ( ) > index ; [CE] constructor IndexEvaluator in class IndexEvaluator cannot be applied to given types ;  [METHOD]  <init> [TYPE] Evaluator$IndexGreaterThan(int) [PARAMETER] int index [CLASS] IndexGreaterThan  [TYPE] boolean false true [TYPE] int index  [CONTEXT]  IndexGreaterThan ( int index ) { [ATTENTION] return element . elementSiblingIndex ( ) > index ; }  	None^145^^^^^144^146^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  >  index; 	[BUGGY] return element . elementSiblingIndex ( )  ; [CE] incompatible types  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] IndexGreaterThan  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . elementSiblingIndex ( )  ; }  	None^149^^^^^148^150^
[REPLACE]  super  (  index  )  ; 	[BUGGY] return element . elementSiblingIndex ( )  = = index ; [CE] constructor IndexEvaluator in class IndexEvaluator cannot be applied to given types ;  [METHOD]  <init> [TYPE] Evaluator$IndexEquals(int) [PARAMETER] int index [CLASS] IndexEquals  [TYPE] boolean false true [TYPE] int index  [CONTEXT]  IndexEquals ( int index ) { [ATTENTION] return element . elementSiblingIndex ( ) = = index ; }  	None^155^^^^^154^156^
[REPLACE]  return  element  .  elementSiblingIndex  (  )  ==  index; 	[BUGGY] return element . elementSiblingIndex ( )  || index ; [CE] bad operand types for binary operator '||'  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] IndexEquals  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean matches ( Element element ) { [ATTENTION] return element . elementSiblingIndex ( ) ||index ; }  	None^159^^^^^158^160^
[REPLACE]  protected  int  index; 	[BUGGY] protected short index ; [CE] possible loss of precision  [METHOD]  matches [TYPE] boolean [PARAMETER] Element element [CLASS] IndexEvaluator  [TYPE] boolean false true [TYPE] Element element  [CONTEXT]   	None^164^^^^^^^
[REPLACE]  this  .  index  =  index; 	[BUGGY] this . index =  null ; [CE] incompatible types  [METHOD]  <init> [TYPE] Evaluator$IndexEvaluator(int) [PARAMETER] int index [CLASS] IndexEvaluator  [TYPE] int index [TYPE] boolean false true  [CONTEXT]  IndexEvaluator ( int index ) { [ATTENTION] this . index = null ; }  	None^167^^^^^166^168^
[REPLACE]  private  static  final  String  DECL_KEY  =    "declaration  "; 	[BUGGY] private static final String DECL_KEY  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] XmlDeclaration  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^8^^^^^^^
[REPLACE]  super  (  baseUri  )  ; 	[BUGGY] super ( data ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String data String baseUri boolean isProcessingInstruction [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public XmlDeclaration ( String data , String baseUri , boolean isProcessingInstruction ) { [ATTENTION] super ( data )  ; attributes . put ( DECL_KEY , data ) ; this . isProcessingInstruction = isProcessingInstruction ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^18^^^^^17^21^
[ADD]  super  (  baseUri  )  ; 	[BUGGY] [CE] no suitable constructor found for Node()  [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String data String baseUri boolean isProcessingInstruction [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public XmlDeclaration ( String data , String baseUri , boolean isProcessingInstruction ) { [ATTENTION] attributes . put ( DECL_KEY , data ) ; this . isProcessingInstruction = isProcessingInstruction ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^18^^^^^17^21^
[REPLACE]  attributes  .  put  (  DECL_KEY,  data  )  ; 	[BUGGY] attributes . put ( DECL_KEY , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String data String baseUri boolean isProcessingInstruction [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public XmlDeclaration ( String data , String baseUri , boolean isProcessingInstruction ) { super ( baseUri ) ; [ATTENTION] attributes . put ( DECL_KEY , baseUri )  ; this . isProcessingInstruction = isProcessingInstruction ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^19^^^^^17^21^
[REPLACE]  this  .  isProcessingInstruction  =  isProcessingInstruction; 	[BUGGY] this . isProcessingInstruction =  true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String , boolean) [PARAMETER] String data String baseUri boolean isProcessingInstruction [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public XmlDeclaration ( String data , String baseUri , boolean isProcessingInstruction ) { super ( baseUri ) ; attributes . put ( DECL_KEY , data ) ; [ATTENTION] this . isProcessingInstruction = true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^20^^^^^17^21^
[REPLACE]  return    "#declaration  "; 	[BUGGY] return outerHtml ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return outerHtml ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^24^^^^^23^25^
[REPLACE]  return  attributes  .  get  (  DECL_KEY  )  ; 	[BUGGY] return  DECL_KEY  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getWholeDeclaration [TYPE] String [PARAMETER] [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public String getWholeDeclaration ( ) { [ATTENTION] return DECL_KEY ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^32^^^^^31^33^
[REPLACE]  accum  .  append  (  String  .  format  (    "<%s%s>  ",  isProcessingInstruction  ?    "!  "  :    "?  ",  getWholeDeclaration  (  )  )  )  ; 	[BUGGY] return outerHtml ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] XmlDeclaration  [TYPE] StringBuilder accum [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] return outerHtml ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^36^^^^^35^37^
[ADD]  accum  .  append  (  String  .  format  (    "<%s%s>  ",  isProcessingInstruction  ?    "!  "  :    "?  ",  getWholeDeclaration  (  )  )  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] XmlDeclaration  [TYPE] StringBuilder accum [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION]   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^36^37^^^^35^37^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return   "#declaration  " ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] XmlDeclaration  [TYPE] boolean false isProcessingInstruction true [TYPE] String DECL_KEY baseUri data  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "#declaration  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/XmlDeclaration.java^40^^^^^39^41^
[REPLACE]  private  LinkedHashMap<String,  Attribute>  attributes  =  new  LinkedHashMap<String,  Attribute>  (  )  ; 	[BUGGY] private LinkedHashMap<String , Attribute> attributes  = null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Attributes  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^18^^^^^^^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  get [TYPE] String [PARAMETER] String key [CLASS] Attributes  [TYPE] String key [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public String get ( String key ) { [ATTENTION] Validate . notNull ( key )  ;  Attribute attr = attributes . get ( key . toLowerCase ( ) ) ; return attr ! = null ? attr . getValue ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^28^^^^^27^32^
[ADD]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  get [TYPE] String [PARAMETER] String key [CLASS] Attributes  [TYPE] String key [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public String get ( String key ) { [ATTENTION]  Attribute attr = attributes . get ( key . toLowerCase ( ) ) ; return attr ! = null ? attr . getValue ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^28^^^^^27^32^
[REPLACE]  Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] Attribute attr = attributes . put ( key , key )  ; [CE] no suitable method found for put(String , String)  [METHOD]  get [TYPE] String [PARAMETER] String key [CLASS] Attributes  [TYPE] String key [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public String get ( String key ) { Validate . notEmpty ( key ) ;  [ATTENTION] Attribute attr = attributes . put ( key , key ) ; return attr ! = null ? attr . getValue ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^30^^^^^27^32^
[ADD]  Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] [CE] cannot find symbol attr  [METHOD]  get [TYPE] String [PARAMETER] String key [CLASS] Attributes  [TYPE] String key [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public String get ( String key ) { Validate . notEmpty ( key ) ;  [ATTENTION] return attr ! = null ? attr . getValue ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^30^^^^^27^32^
[REPLACE]  return  attr  !=  null  ?  attr  .  getValue  (  )  :    "  "; 	[BUGGY] return attr ! = null ? attr . getKey ( ) :   "  " ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  get [TYPE] String [PARAMETER] String key [CLASS] Attributes  [TYPE] String key [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public String get ( String key ) { Validate . notEmpty ( key ) ;  Attribute attr = attributes . get ( key . toLowerCase ( ) ) ; [ATTENTION] return attr ! = null ? attr . getKey ( ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^31^^^^^27^32^
[REPLACE]  Attribute  attr  =  new  Attribute  (  key,  value  )  ; 	[BUGGY] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; [CE] cannot find symbol attr  [METHOD]  put [TYPE] void [PARAMETER] String key String value [CLASS] Attributes  [TYPE] String key value [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public void put ( String key , String value ) { [ATTENTION] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) )  ; put ( attr ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^40^^^^^39^42^
[REPLACE]  put  (  attr  )  ; 	[BUGGY] return html ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  put [TYPE] void [PARAMETER] String key String value [CLASS] Attributes  [TYPE] String key value [TYPE] boolean false true [TYPE] Attribute attr [TYPE] LinkedHashMap attributes  [CONTEXT]  public void put ( String key , String value ) { Attribute attr = new Attribute ( key , value ) ; [ATTENTION] return html ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^41^^^^^39^42^
[REPLACE]  Validate  .  notNull  (  attribute  )  ; 	[BUGGY] Validate . notEmpty ( attribute ) ; [CE] no suitable method found for notEmpty(Attribute)  [METHOD]  put [TYPE] void [PARAMETER] Attribute attribute [CLASS] Attributes  [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public void put ( Attribute attribute ) { [ATTENTION] Validate . notEmpty ( attribute )  ; attributes . put ( attribute . getKey ( ) , attribute ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^49^^^^^48^51^
[REPLACE]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ; 	[BUGGY] attributes . put ( attribute . getValue ( )  , attribute ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  put [TYPE] void [PARAMETER] Attribute attribute [CLASS] Attributes  [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public void put ( Attribute attribute ) { Validate . notNull ( attribute ) ; [ATTENTION] attributes . put ( attribute . getValue ( ) , attribute )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^50^^^^^48^51^
[ADD]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  put [TYPE] void [PARAMETER] Attribute attribute [CLASS] Attributes  [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public void put ( Attribute attribute ) { Validate . notNull ( attribute ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^50^^^^^48^51^
[REPLACE]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ; 	[BUGGY] attributes . put ( attribute . getValue ( ) , attribute ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  put [TYPE] void [PARAMETER] Attribute attribute [CLASS] Attributes  [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public void put ( Attribute attribute ) { Validate . notNull ( attribute ) ; [ATTENTION] attributes . put ( attribute . getValue ( )  , attribute )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^50^^^^^48^51^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] String key [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public void remove ( String key ) { [ATTENTION] Validate . notNull ( key )  ; attributes . remove ( key . toLowerCase ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^58^^^^^57^60^
[REPLACE]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] attributes . get ( key . toLowerCase ( ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] String key [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public void remove ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] attributes . get ( key . toLowerCase ( ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^59^^^^^57^60^
[ADD]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] String key [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public void remove ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^59^^^^^57^60^
[REPLACE]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] attributes . put ( attribute . getKey ( ) , attribute ) ; [CE] cannot find symbol attribute  [METHOD]  remove [TYPE] void [PARAMETER] String key [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public void remove ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] attributes . put ( attribute . getKey ( )  , attribute )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^59^^^^^57^60^
[REPLACE]  return  attributes  .  containsKey  (  key  .  toLowerCase  (  )  )  ; 	[BUGGY] return asList ( ) . iterator ( ) ; [CE] incompatible types  [METHOD]  hasKey [TYPE] boolean [PARAMETER] String key [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public boolean hasKey ( String key ) { [ATTENTION] return asList ( )  . iterator ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^68^^^^^67^69^
[REPLACE]  return  attributes  .  size  (  )  ; 	[BUGGY] return attributes . hashCode ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  size [TYPE] int [PARAMETER] [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public int size ( ) { [ATTENTION] return attributes . hashCode ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^76^^^^^75^77^
[REPLACE]  attributes  .  putAll  (  incoming  .  attributes  )  ; 	[BUGGY] attributes . equals ( incoming . attributes ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addAll [TYPE] void [PARAMETER] Attributes incoming [CLASS] Attributes  [TYPE] Attributes incoming [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public void addAll ( Attributes incoming ) { [ATTENTION] attributes . equals ( incoming . attributes )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^84^^^^^83^85^
[REPLACE]  return  asList  (  )    .  iterator  (  )  ; 	[BUGGY] return attributes . size ( ) ; [CE] incompatible types  [METHOD]  iterator [TYPE] Iterator [PARAMETER] [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public Iterator<Attribute> iterator ( ) { [ATTENTION] return attributes . size ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^88^^^^^87^89^
[REPLACE]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ; 	[BUGGY] List<Attribute> list = new ArrayList<Attribute> ( attributes . hashCode ( )  ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  asList [TYPE] List [PARAMETER] [CLASS] Attributes  [TYPE] List list [TYPE] Entry entry [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public List<Attribute> asList ( ) { [ATTENTION] List<Attribute> list = new ArrayList<Attribute> ( attributes . hashCode ( )  )  ; for ( Map . Entry<String , Attribute> entry : attributes . entrySet ( ) ) { list . add ( entry . getValue ( ) ) ; } return Collections . unmodifiableList ( list ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^97^^^^^96^102^
[REPLACE]  for  (  Map  .  Entry<String,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  { 	[BUGGY] for ( Attribute attribute : this ) { accum . append (   "   " ) ; [CE] cannot find symbol accum  [METHOD]  asList [TYPE] List [PARAMETER] [CLASS] Attributes  [TYPE] List list [TYPE] Entry entry [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public List<Attribute> asList ( ) { List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; [ATTENTION] for ( Attribute attribute : this ) { accum . append (   "   " )  ; list . add ( entry . getValue ( ) ) ; } return Collections . unmodifiableList ( list ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^98^^^^^96^102^
[ADD]  for  (  Map  .  Entry<String,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  {  list  .  add  (  entry  .  getValue  (  )  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  asList [TYPE] List [PARAMETER] [CLASS] Attributes  [TYPE] List list [TYPE] Entry entry [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public List<Attribute> asList ( ) { List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; [ATTENTION]  return Collections . unmodifiableList ( list ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^98^99^100^^^96^102^
[REPLACE]  return  Collections  .  unmodifiableList  (  list  )  ; 	[BUGGY] return  null  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  asList [TYPE] List [PARAMETER] [CLASS] Attributes  [TYPE] List list [TYPE] Entry entry [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public List<Attribute> asList ( ) { List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; for ( Map . Entry<String , Attribute> entry : attributes . entrySet ( ) ) { list . add ( entry . getValue ( ) ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^101^^^^^96^102^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] Attribute attr = new Attribute ( key , value ) ; [CE] cannot find symbol key  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes  [CONTEXT]  public String html ( ) { [ATTENTION] Attribute attr = new Attribute ( key , value )  ; for ( Attribute attribute : this ) { accum . append (   "   " ) ; accum . append ( attribute . html ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^109^^^^^108^115^
[ADD]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] [CE] cannot find symbol accum  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes  [CONTEXT]  public String html ( ) { [ATTENTION] for ( Attribute attribute : this ) { accum . append (   "   " ) ; accum . append ( attribute . html ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^109^^^^^108^115^
[REPLACE]  for  (  Attribute  attribute  :  this  )  { 	[BUGGY] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; [CE] illegal start of type  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes  [CONTEXT]  public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) )  ; accum . append (   "   " ) ; accum . append ( attribute . html ( ) ) ; } return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^110^^^^^108^115^
[ADD]  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (    "    "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes  [CONTEXT]  public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION]   return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^110^111^112^113^^108^115^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Attribute attribute [TYPE] LinkedHashMap attributes  [CONTEXT]  public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; for ( Attribute attribute : this ) { accum . append (   "   " ) ; accum . append ( attribute . html ( ) ) ; } [ATTENTION] return accum . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^114^^^^^108^115^
[REPLACE]  return  html  (  )  ; 	[BUGGY] return asList ( ) . iterator ( ) ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return asList ( )  . iterator ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^118^^^^^117^119^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this ! =  o ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this! = o ) return true ; if ( ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^123^^^^^122^131^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this = = o ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this = = o ) return false ; if ( ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^123^^^^^122^131^
[REPLACE]  if  (  !  (  o  instanceof  Attributes  )  )  return  false; 	[BUGGY] if ( ! ! ( o instanceof Attributes ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^124^^^^^122^131^
[REPLACE]  if  (  !  (  o  instanceof  Attributes  )  )  return  false; 	[BUGGY] if ( ! ( o instanceof Attributes ) ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ( o instanceof Attributes ) ) return true ;  Attributes that =  ( Attributes ) o ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^124^^^^^122^131^
[REPLACE]  Attributes  that  =  (  Attributes  )  o; 	[BUGGY] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) ) ; [CE] cannot find symbol that  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attributes ) ) return false ;  [ATTENTION] List<Attribute> list = new ArrayList<Attribute> ( attributes . size ( ) )  ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^126^^^^^122^131^
[REPLACE]  if  (  attributes  !=  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !=  null  )  return  false; 	[BUGGY] if ( attributes ! =  that . attributes = = null ) return false ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  [ATTENTION] if ( attributes ! = that . attributes = = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^128^^^^^122^131^
[REPLACE]  if  (  attributes  !=  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !=  null  )  return  false; 	[BUGGY] if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  [ATTENTION] if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return true ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^128^^^^^122^131^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attributes  [TYPE] Attributes that [TYPE] Object o [TYPE] boolean false true [TYPE] LinkedHashMap attributes  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attributes ) ) return false ;  Attributes that =  ( Attributes ) o ;  if ( attributes ! = null ? !attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ;  [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^130^^^^^122^131^
[REPLACE]  return  attributes  !=  null  ?  attributes  .  hashCode  (  )  :  0; 	[BUGGY] return attributes ! = null ? attributes . length ( ) : 0 ; [CE] cannot find symbol  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Attributes  [TYPE] LinkedHashMap attributes [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { [ATTENTION] return attributes ! = null ? attributes . length ( ) : 0 ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attributes.java^135^^^^^134^136^
[REPLACE]  final  Attributes  attributes; 	[BUGGY] Attributes attributes ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [CONTEXT]    [CLASS] Node  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^20^^^^^^^
[REPLACE]  String  baseUri; 	[BUGGY] char baseUri ; [CE] incompatible types  [CONTEXT]    [CLASS] Node  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^21^^^^^^^
[REPLACE]  Validate  .  notNull  (  baseUri  )  ; 	[BUGGY] Validate . notEmpty ( baseUri )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { [ATTENTION] Validate . notEmpty ( baseUri ) ; Validate . notNull ( attributes ) ;  childNodes = new ArrayList<Node> ( ) ; this . baseUri = baseUri . trim ( ) ; this . attributes = attributes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^29^^^^^28^35^
[REPLACE]  Validate  .  notNull  (  attributes  )  ; 	[BUGGY] Validate . notNull ( attributeKey ) ; [CE] cannot find symbol attributeKey  [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { Validate . notNull ( baseUri ) ; [ATTENTION] Validate . notNull ( attributeKey )  ;  childNodes = new ArrayList<Node> ( ) ; this . baseUri = baseUri . trim ( ) ; this . attributes = attributes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^30^^^^^28^35^
[REPLACE]  childNodes  =  new  ArrayList<Node>  (  )  ; 	[BUGGY] childNodes ; [CE] not a statement  [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { Validate . notNull ( baseUri ) ; Validate . notNull ( attributes ) ;  [ATTENTION] childNodes ; this . baseUri = baseUri . trim ( ) ; this . attributes = attributes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^32^^^^^28^35^
[REPLACE]  this  .  baseUri  =  baseUri  .  trim  (  )  ; 	[BUGGY] this . baseUri =  null . trim ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { Validate . notNull ( baseUri ) ; Validate . notNull ( attributes ) ;  childNodes = new ArrayList<Node> ( ) ; [ATTENTION] this . baseUri = null . trim ( )  ; this . attributes = attributes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^33^^^^^28^35^
[ADD]  this  .  baseUri  =  baseUri  .  trim  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { Validate . notNull ( baseUri ) ; Validate . notNull ( attributes ) ;  childNodes = new ArrayList<Node> ( ) ; [ATTENTION] this . attributes = attributes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^33^^^^^28^35^
[REPLACE]  this  .  attributes  =  attributes; 	[BUGGY] this . attributes =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Attributes) [PARAMETER] String baseUri Attributes attributes [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri , Attributes attributes ) { Validate . notNull ( baseUri ) ; Validate . notNull ( attributes ) ;  childNodes = new ArrayList<Node> ( ) ; this . baseUri = baseUri . trim ( ) ; [ATTENTION] this . attributes = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^34^^^^^28^35^
[REPLACE]  this  (  baseUri,  new  Attributes  (  )  )  ; 	[BUGGY] if ( !hasAttr ( attributeKey ) ) { return   "  " ; [CE] illegal start of expression  [METHOD]  <init> [TYPE] String) [PARAMETER] String baseUri [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri ) { [ATTENTION] if ( !hasAttr ( attributeKey ) ) { return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^38^^^^^37^39^
[REMOVE]   	[BUGGY] if ( !hasAttr ( attributeKey ) ) { return   "  " ; [CE] illegal start of expression  [METHOD]  <init> [TYPE] String) [PARAMETER] String baseUri [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  protected Node ( String baseUri ) { [ATTENTION] this ( baseUri , new Attributes ( ) ) ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^38^^^^^37^39^
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ; 	[BUGGY] Validate . notEmpty ( baseUri )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { [ATTENTION] Validate . notEmpty ( baseUri ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^60^^^^^59^67^
[REPLACE]  if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ; 	[BUGGY] if ( hasAttr ( baseUri ) ) return attributes . get ( attributeKey ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  [ATTENTION] if ( hasAttr ( baseUri ) ) return attributes . get ( attributeKey )  ;  else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^62^63^^^^59^67^
[REPLACE]  else  if  (  attributeKey  .  toLowerCase  (  )    .  startsWith  (    "abs:  "  )  )  return  absUrl  (  attributeKey  .  substring  (    "abs:  "  .  length  (  )  )  )  ; 	[BUGGY] if ( baseUri . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; [ATTENTION] if ( baseUri . toLowerCase ( )  . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) )  ;  else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^64^65^^^^59^67^
[ADD]  else  if  (  attributeKey  .  toLowerCase  (  )    .  startsWith  (    "abs:  "  )  )  return  absUrl  (  attributeKey  .  substring  (    "abs:  "  .  length  (  )  )  )  ;  else  return    "  ";  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^64^65^66^67^^59^67^
[REPLACE]  else  return    "  "; 	[BUGGY] return   "  " ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; [ATTENTION] return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^66^^^^^59^67^
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (    "abs:  "  .  length  (  )  )  )  ; 	[BUGGY] return absUrl ( baseUri . substring (   "abs:  " . length ( ) ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) [ATTENTION] return absUrl ( baseUri . substring (   "abs:  " . length ( ) ) )  ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^65^^^^^59^67^
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (    "abs:  "  .  length  (  )  )  )  ; 	[BUGGY] return absUrl ( attributeKey . substring (   "abs:  " . startsWith ( baseUri )  ) ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) [ATTENTION] return absUrl ( attributeKey . substring (   "abs:  " . startsWith ( baseUri )  ) )  ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^65^^^^^59^67^
[REPLACE]  return  attributes  .  get  (  attributeKey  )  ; 	[BUGGY] return attributes . hasKey ( baseUri ) ; [CE] incompatible types  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) [ATTENTION] return attributes . hasKey ( baseUri )  ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^63^^^^^59^67^
[REPLACE]  return  attributes  .  get  (  attributeKey  )  ; 	[BUGGY] return attributes . put ( baseUri , baseUri )  ; [CE] incompatible types  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) [ATTENTION] return attributes . put ( baseUri , baseUri ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) return absUrl ( attributeKey . substring (   "abs:  " . length ( ) ) ) ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^63^^^^^59^67^
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (    "abs:  "  .  length  (  )  )  )  ; 	[BUGGY] return absUrl ( baseUri . substring (   "abs:  " . startsWith ( baseUri )  ) ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  attr [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ;  if ( hasAttr ( attributeKey ) ) return attributes . get ( attributeKey ) ; else if ( attributeKey . toLowerCase ( ) . startsWith (   "abs:  " ) ) [ATTENTION] return absUrl ( baseUri . substring (   "abs:  " . startsWith ( baseUri )  ) )  ; else return   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^65^^^^^59^67^
[REPLACE]  return  attributes; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  attributes [TYPE] Attributes [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Attributes attributes ( ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^74^^^^^73^75^
[REPLACE]  attributes  .  put  (  attributeKey,  attributeValue  )  ; 	[BUGGY] attributes . put ( baseUri , attributeValue ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] Node [PARAMETER] String attributeKey String attributeValue [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node attr ( String attributeKey , String attributeValue ) { [ATTENTION] attributes . put ( baseUri , attributeValue )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^84^^^^^83^86^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] Node [PARAMETER] String attributeKey String attributeValue [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node attr ( String attributeKey , String attributeValue ) { attributes . put ( attributeKey , attributeValue ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^85^^^^^83^86^
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ; 	[BUGGY] Validate . notEmpty ( attributeKey ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { [ATTENTION] Validate . notEmpty ( attributeKey )  ; return attributes . hasKey ( attributeKey ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^94^^^^^93^96^
[REPLACE]  return  attributes  .  hasKey  (  attributeKey  )  ; 	[BUGGY] return attributes . get ( attributeKey ) ; [CE] incompatible types  [METHOD]  hasAttr [TYPE] boolean [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; [ATTENTION] return attributes . get ( attributeKey )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^95^^^^^93^96^
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ; 	[BUGGY] Validate . notNull ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeAttr [TYPE] Node [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node removeAttr ( String attributeKey ) { [ATTENTION] Validate . notNull ( baseUri )  ; attributes . remove ( attributeKey ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^104^^^^^103^107^
[REPLACE]  attributes  .  remove  (  attributeKey  )  ; 	[BUGGY] attributes . get ( attributeKey ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeAttr [TYPE] Node [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node removeAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; [ATTENTION] attributes . get ( attributeKey )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^105^^^^^103^107^
[REMOVE]   	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  removeAttr [TYPE] Node [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node removeAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; [ATTENTION] attributes . remove ( attributeKey ) ;  return siblings . get ( index-1 )  ; return this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^105^^^^^103^107^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeAttr [TYPE] Node [PARAMETER] String attributeKey [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node removeAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; attributes . remove ( attributeKey ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^106^^^^^103^107^
[REPLACE]  return  baseUri; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  baseUri [TYPE] String [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public String baseUri ( ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^114^^^^^113^115^
[REPLACE]  Validate  .  notNull  (  baseUri  )  ; 	[BUGGY] Validate . notNull ( attributeValue ) ; [CE] cannot find symbol attributeValue  [METHOD]  setBaseUri [TYPE] void [PARAMETER] String baseUri [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void setBaseUri ( String baseUri ) { [ATTENTION] Validate . notNull ( attributeValue )  ; this . baseUri = baseUri ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^122^^^^^121^124^
[REPLACE]  this  .  baseUri  =  baseUri; 	[BUGGY] this . baseUri =  attributeValue ; [CE] cannot find symbol attributeValue  [METHOD]  setBaseUri [TYPE] void [PARAMETER] String baseUri [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void setBaseUri ( String baseUri ) { Validate . notNull ( baseUri ) ; [ATTENTION] this . baseUri = attributeValue ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^123^^^^^121^124^
[ADD]  this  .  baseUri  =  baseUri; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setBaseUri [TYPE] void [PARAMETER] String baseUri [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void setBaseUri ( String baseUri ) { Validate . notNull ( baseUri ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^123^^^^^121^124^
[REPLACE]  Validate  .  notEmpty  (  attributeKey  )  ; 	[BUGGY] Validate . notEmpty ( relUrl ) ; [CE] cannot find symbol relUrl  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { [ATTENTION] Validate . notEmpty ( relUrl )  ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^144^^^^^143^165^
[REPLACE]  String  relUrl  =  attr  (  attributeKey  )  ; 	[BUGGY] String relUrl = attr ( relUrl ) ; [CE] variable relUrl might not have been initialized  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  [ATTENTION] String relUrl = attr ( relUrl )  ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^146^^^^^143^165^
[REPLACE]  if  (  !hasAttr  (  attributeKey  )  )  { 	[BUGGY] if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; [CE] illegal start of type  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; [ATTENTION] if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 )  ; return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^147^^^^^143^165^
[ADD]  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  { 	[BUGGY] base = new URL ( baseUri ) ; [CE] illegal start of type  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; [ATTENTION] base = new URL ( baseUri )  ;   URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^151^152^153^154^155^143^165^
[ADD]  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {  URL  abs  =  new  URL  (  relUrl  )  ; 	[BUGGY] base = new URL ( baseUri ) ; URL abs = new URL ( relUrl ) ; [CE] 'try' without 'catch' or 'finally'  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { [ATTENTION] base = new URL ( baseUri )  ; URL abs = new URL ( relUrl )  ;    return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^152^153^154^^156^143^165^
[REPLACE]  base  =  new  URL  (  baseUri  )  ; 	[BUGGY] base =  new URL ( relUrl )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { [ATTENTION] base = new URL ( relUrl ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^153^^^^^143^165^
[ADD]  base  =  new  URL  (  baseUri  )  ; 	[BUGGY] [CE] exception MalformedURLException is never thrown in body of corresponding try statement  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { [ATTENTION] } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^153^^^^^143^165^
[REPLACE]  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] return base . toExternalForm ( ) ; [CE] variable base might not have been initialized  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; [ATTENTION] return base . toExternalForm ( )  ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^157^^^^^143^165^
[REPLACE]  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] return base . URL ( baseUri )  ; [CE] cannot find symbol  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; [ATTENTION] return base . URL ( baseUri ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^160^^^^^143^165^
[REPLACE]  URL  abs  =  new  URL  (  relUrl  )  ; 	[BUGGY] URL abs = new URL ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  [ATTENTION] URL abs = new URL ( baseUri )  ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^156^^^^^143^165^
[REPLACE]  URL  abs  =  new  URL  (  base,  relUrl  )  ; 	[BUGGY] URL abs = new URL ( abs , relUrl ) ; [CE] variable abs might not have been initialized  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } [ATTENTION] URL abs = new URL ( abs , relUrl )  ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^159^^^^^143^165^
[ADD]  URL  abs  =  new  URL  (  base,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } [ATTENTION]  } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^159^160^^^^143^165^
[REPLACE]  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] return base . URL ( relUrl )  ; [CE] cannot find symbol  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; [ATTENTION] return base . URL ( relUrl ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^157^^^^^143^165^
[REPLACE]  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] return base . toExternalForm ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; [ATTENTION] return base . toExternalForm ( )  ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^160^^^^^143^165^
[REPLACE]  return    "  "; 	[BUGGY] return parentNode ; [CE] incompatible types  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { [ATTENTION] return parentNode ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^162^^^^^143^165^
[REPLACE]  URL  base; 	[BUGGY] N node = nodes . get ( i ) ; [CE] cannot find symbol  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { [ATTENTION] N node = nodes . get ( i )  ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^150^^^^^143^165^
[REPLACE]  return    "  "; 	[BUGGY] return parentNode ; [CE] incompatible types  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { [ATTENTION] return parentNode ; } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^148^^^^^143^165^
[REPLACE]  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] return abs . URL ( relUrl )  ; [CE] cannot find symbol  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; [ATTENTION] return abs . URL ( relUrl ) ; } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^157^^^^^143^165^
[REPLACE]  URL  abs  =  new  URL  (  base,  relUrl  )  ; 	[BUGGY] URL abs = new URL ( base , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  URL abs = new URL ( relUrl ) ; return abs . toExternalForm ( ) ; } [ATTENTION] URL abs = new URL ( base , baseUri )  ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^159^^^^^143^165^
[ADD]  URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ; 	[BUGGY] [CE] variable base might not have been initialized  [METHOD]  absUrl [TYPE] String [PARAMETER] String attributeKey [CLASS] Node  [TYPE] MalformedURLException e [TYPE] boolean false true [TYPE] Node parentNode [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] URL abs base  [CONTEXT]  public String absUrl ( String attributeKey ) { Validate . notEmpty ( attributeKey ) ;  String relUrl = attr ( attributeKey ) ; if ( !hasAttr ( attributeKey ) ) { return   "  " ; // nothing to make absolute with } else { URL base ; try { try { base = new URL ( baseUri ) ; } catch ( MalformedURLException e ) {  [ATTENTION]  } URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) { return   "  " ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^156^157^^^^143^165^
[REPLACE]  return  childNodes  .  get  (  index  )  ; 	[BUGGY] return childNodes . remove ( index ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  childNode [TYPE] Node [PARAMETER] int index [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node parentNode  [CONTEXT]  public Node childNode ( int index ) { [ATTENTION] return childNodes . remove ( index )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^173^^^^^172^174^
[REPLACE]  return  Collections  .  unmodifiableList  (  childNodes  )  ; 	[BUGGY] return  childNodes  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  childNodes [TYPE] List [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public List<Node> childNodes ( ) { [ATTENTION] return childNodes ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^182^^^^^181^183^
[REPLACE]  return  parentNode; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  parent [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public Node parent ( ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^190^^^^^189^191^
[REPLACE]  Validate  .  notNull  (  parentNode  )  ; 	[BUGGY] Validate . notNull ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void remove ( ) { [ATTENTION] Validate . notNull ( baseUri )  ; parentNode . removeChild ( this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^197^^^^^196^199^
[REPLACE]  parentNode  .  removeChild  (  this  )  ; 	[BUGGY] parentNode . addChild ( this ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void remove ( ) { Validate . notNull ( parentNode ) ; [ATTENTION] parentNode . addChild ( this )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^198^^^^^196^199^
[ADD]  parentNode  .  removeChild  (  this  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  remove [TYPE] void [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node parentNode  [CONTEXT]  public void remove ( ) { Validate . notNull ( parentNode ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^198^^^^^196^199^
[REPLACE]  Validate  .  notNull  (  in  )  ; 	[BUGGY] Validate . notNull ( parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceWith [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  public void replaceWith ( Node in ) { [ATTENTION] Validate . notNull ( parentNode )  ; Validate . notNull ( parentNode ) ; parentNode . replaceChild ( this , in ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^206^^^^^205^209^
[REPLACE]  Validate  .  notNull  (  parentNode  )  ; 	[BUGGY] Validate . notNull ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceWith [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  public void replaceWith ( Node in ) { Validate . notNull ( in ) ; [ATTENTION] Validate . notNull ( baseUri )  ; parentNode . replaceChild ( this , in ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^207^^^^^205^209^
[REPLACE]  parentNode  .  replaceChild  (  this,  in  )  ; 	[BUGGY] parentNode . replaceChild ( this , parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceWith [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  public void replaceWith ( Node in ) { Validate . notNull ( in ) ; Validate . notNull ( parentNode ) ; [ATTENTION] parentNode . replaceChild ( this , parentNode )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^208^^^^^205^209^
[ADD]  parentNode  .  replaceChild  (  this,  in  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceWith [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  public void replaceWith ( Node in ) { Validate . notNull ( in ) ; Validate . notNull ( parentNode ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^208^^^^^205^209^
[REPLACE]  if  (  this  .  parentNode  !=  null  )  throw  new  NotImplementedException  (  "    ")  ; 	[BUGGY] if (parentNode = = null ) throw new NotImplementedException (  "   ")  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setParentNode [TYPE] void [PARAMETER] Node parentNode [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  protected void setParentNode ( Node parentNode ) { [ATTENTION] if ( parentNode = = null ) throw new NotImplementedException (   "   " ) ;  this . parentNode = parentNode ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^212^213^^^^211^215^
[REPLACE]  throw  new  NotImplementedException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setParentNode [TYPE] void [PARAMETER] Node parentNode [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  protected void setParentNode ( Node parentNode ) { if ( this . parentNode ! = null ) [ATTENTION] return ; this . parentNode = parentNode ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^213^^^^^211^215^
[REPLACE]  this  .  parentNode  =  parentNode; 	[BUGGY] this . parentNode =  in ; [CE] cannot find symbol in  [METHOD]  setParentNode [TYPE] void [PARAMETER] Node parentNode [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in parentNode  [CONTEXT]  protected void setParentNode ( Node parentNode ) { if ( this . parentNode ! = null ) throw new NotImplementedException (   "Cannot ( yet ) move nodes in tree  " ) ; // TODO: remove from prev node children [ATTENTION] this . parentNode = in ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^214^^^^^211^215^
[REPLACE]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ; 	[BUGGY] Validate . isTrue ( out . parentNode ! =  this ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { [ATTENTION] Validate . isTrue ( out . parentNode! = this )  ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^218^^^^^217^227^
[ADD]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ;  Validate  .  notNull  (  in  )  ; 	[BUGGY] Validate . notNull ( in ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { [ATTENTION] Validate . notNull ( in )  ;  if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^218^219^^^^217^227^
[REPLACE]  Validate  .  notNull  (  in  )  ; 	[BUGGY] Validate . notNull ( index ) ; [CE] cannot find symbol index  [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; [ATTENTION] Validate . notNull ( index )  ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^219^^^^^217^227^
[REPLACE]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ; 	[BUGGY] if ( in . parentNode = = this ) in . parentNode . removeChild ( in ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; [ATTENTION] if ( in . parentNode = = this ) in . parentNode . removeChild ( in )  ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^220^221^^^^217^227^
[REPLACE]  in  .  parentNode  .  removeChild  (  in  )  ; 	[BUGGY] in . parentNode . removeChild ( parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) [ATTENTION] in . parentNode . removeChild ( parentNode )  ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^221^^^^^217^227^
[ADD]  in  .  parentNode  .  removeChild  (  in  )  ; 	[BUGGY] [CE] not a statement  [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) [ATTENTION]  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^221^^^^^217^227^
[REPLACE]  Integer  index  =  indexInList  (  out,  childNodes  )  ; 	[BUGGY] Integer index = indexInList ( parentNode , childNodes ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  [ATTENTION] Integer index = indexInList ( parentNode , childNodes )  ; childNodes . set ( index , in ) ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^223^^^^^217^227^
[REPLACE]  childNodes  .  set  (  index,  in  )  ; 	[BUGGY] childNodes . set ( parentNodedex , in ) ; [CE] cannot find symbol parentNodedex  [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; [ATTENTION] childNodes . set ( parentNodedex , in )  ; in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^224^^^^^217^227^
[REMOVE]   	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; [ATTENTION] childNodes . set ( index , in ) ;  return siblings . get ( index-1 )  ; in . parentNode = this ; out . parentNode = null ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^224^^^^^217^227^
[REPLACE]  in  .  parentNode  =  this; 	[BUGGY] in . parentNode =  this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; [ATTENTION] in . parentNode = this ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^225^^^^^217^227^
[ADD]  in  .  parentNode  =  this;  out  .  parentNode  =  null; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^225^226^^^^217^227^
[REPLACE]  out  .  parentNode  =  null; 	[BUGGY] out . parentNode = this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  replaceChild [TYPE] void [PARAMETER] Node out Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void replaceChild ( Node out , Node in ) { Validate . isTrue ( out . parentNode = = this ) ; Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  Integer index = indexInList ( out , childNodes ) ; childNodes . set ( index , in ) ; in . parentNode = this ; [ATTENTION] out . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^226^^^^^217^227^
[REPLACE]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ; 	[BUGGY] Validate . isTrue ( out . parentNode && this ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { [ATTENTION] Validate . isTrue ( out . parentNode&&this )  ; int index = indexInList ( out , childNodes ) ; childNodes . remove ( index ) ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^230^^^^^229^234^
[ADD]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { [ATTENTION] int index = indexInList ( out , childNodes ) ; childNodes . remove ( index ) ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^230^^^^^229^234^
[REPLACE]  int  index  =  indexInList  (  out,  childNodes  )  ; 	[BUGGY] int index = indexInList ( parentNode , childNodes ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { Validate . isTrue ( out . parentNode = = this ) ; [ATTENTION] int index = indexInList ( parentNode , childNodes )  ; childNodes . remove ( index ) ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^231^^^^^229^234^
[REPLACE]  childNodes  .  remove  (  index  )  ; 	[BUGGY] childNodes . hashCode ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { Validate . isTrue ( out . parentNode = = this ) ; int index = indexInList ( out , childNodes ) ; [ATTENTION] childNodes . hashCode ( ) ; out . parentNode = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^232^^^^^229^234^
[REPLACE]  out  .  parentNode  =  null; 	[BUGGY] out . parentNode = this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { Validate . isTrue ( out . parentNode = = this ) ; int index = indexInList ( out , childNodes ) ; childNodes . remove ( index ) ; [ATTENTION] out . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^233^^^^^229^234^
[ADD]  out  .  parentNode  =  null; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeChild [TYPE] void [PARAMETER] Node out [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int index [TYPE] Node in out parentNode  [CONTEXT]  protected void removeChild ( Node out ) { Validate . isTrue ( out . parentNode = = this ) ; int index = indexInList ( out , childNodes ) ; childNodes . remove ( index ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^233^^^^^229^234^
[REPLACE]  Validate  .  notNull  (  in  )  ; 	[BUGGY] Validate . notNull ( parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { [ATTENTION] Validate . notNull ( parentNode )  ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  childNodes . add ( in ) ; in . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^237^^^^^236^243^
[REPLACE]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ; 	[BUGGY] if ( in . parentNode = = null ) in . parentNode . removeChild ( in ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; [ATTENTION] if ( in . parentNode = = null ) in . parentNode . removeChild ( in )  ;  childNodes . add ( in ) ; in . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^238^239^^^^236^243^
[ADD]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ;  childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; [ATTENTION]   }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^238^239^^241^242^236^243^
[REPLACE]  in  .  parentNode  .  removeChild  (  in  )  ; 	[BUGGY] in . parentNode . addChild ( parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) [ATTENTION] in . parentNode . addChild ( parentNode )  ;  childNodes . add ( in ) ; in . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^239^^^^^236^243^
[REMOVE]   	[BUGGY] N node = nodes . get ( i ) ; [CE] cannot find symbol  [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) [ATTENTION] in . parentNode . removeChild ( in ) ;  N node = nodes . get ( i )  ; childNodes . add ( in ) ; in . parentNode = this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^239^^^^^236^243^
[REPLACE]  childNodes  .  add  (  in  )  ; 	[BUGGY] childNodes . add ( parentNode ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  [ATTENTION] childNodes . add ( parentNode )  ; in . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^241^^^^^236^243^
[REMOVE]   	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  [ATTENTION] childNodes . add ( in ) ;  return siblings . get ( index-1 )  ; in . parentNode = this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^241^^^^^236^243^
[REPLACE]  in  .  parentNode  =  this; 	[BUGGY] in . parentNode =  this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  childNodes . add ( in ) ; [ATTENTION] in . parentNode = this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^242^^^^^236^243^
[ADD]  in  .  parentNode  =  this; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addChild [TYPE] void [PARAMETER] Node in [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected void addChild ( Node in ) { Validate . notNull ( in ) ; if ( in . parentNode ! = null ) in . parentNode . removeChild ( in ) ;  childNodes . add ( in ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^242^^^^^236^243^
[REPLACE]  if  (  parentNode  ==  null  )  return  0; 	[BUGGY] if ( parentNode ! = null ) return 0 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nodeDepth [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected int nodeDepth ( ) { [ATTENTION] if ( parentNode ! = null ) return 0 ;  else return parentNode . nodeDepth ( ) + 1 ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^246^247^^^^245^250^
[REPLACE]  return  parentNode  .  nodeDepth  (  )  +  1; 	[BUGGY] return parentNode . childNode ( ) +this ; [CE] method childNode in class Node cannot be applied to given types ;  [METHOD]  nodeDepth [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected int nodeDepth ( ) { if ( parentNode = = null ) return 0 ; else [ATTENTION] return parentNode . childNode ( ) +this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^249^^^^^245^250^
[REPLACE]  return  0; 	[BUGGY] return i ; [CE] cannot find symbol i  [METHOD]  nodeDepth [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected int nodeDepth ( ) { if ( parentNode = = null ) [ATTENTION] return i ; else return parentNode . nodeDepth ( ) + 1 ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^247^^^^^245^250^
[REPLACE]  return  0; 	[BUGGY] return 0 / 3 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nodeDepth [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected int nodeDepth ( ) { if ( parentNode = = null ) [ATTENTION] return 0 / 3 ; else return parentNode . nodeDepth ( ) + 1 ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^247^^^^^245^250^
[REPLACE]  return  parentNode  .  nodeDepth  (  )  +  1; 	[BUGGY] return parentNode . childNode ( ) + 1 ; [CE] method childNode in class Node cannot be applied to given types ;  [METHOD]  nodeDepth [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  protected int nodeDepth ( ) { if ( parentNode = = null ) return 0 ; else [ATTENTION] return parentNode . childNode ( ) + 1 ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^249^^^^^245^250^
[REPLACE]  return  parent  (  )    .  childNodes  (  )  ; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  siblingNodes [TYPE] List [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public List<Node> siblingNodes ( ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^257^^^^^256^258^
[REPLACE]  List<Node>  siblings  =  parentNode  .  childNodes; 	[BUGGY] int index = indexInList ( out , childNodes ) ; [CE] cannot find symbol out  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { [ATTENTION] int index = indexInList ( out , childNodes )  ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^265^^^^^264^272^
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ; 	[BUGGY] Integer index = indexInList ( this , null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; [ATTENTION] Integer index = indexInList ( this , null )  ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^266^^^^^264^272^
[ADD]  Integer  index  =  indexInList  (  this,  siblings  )  ;  Validate  .  notNull  (  index  )  ; 	[BUGGY] [CE] cannot find symbol index  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; [ATTENTION]  if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^266^267^^^^264^272^
[REPLACE]  Validate  .  notNull  (  index  )  ; 	[BUGGY] Validate . notEmpty ( relUrl )  ; [CE] cannot find symbol relUrl  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; [ATTENTION] Validate . notEmpty ( relUrl ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^267^^^^^264^272^
[REPLACE]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] if ( siblings . size ( ) * 0 . 5 > index+1 ) return siblings . get ( index+1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; [ATTENTION] if ( siblings . size ( ) *0 . 5> index+1 ) return siblings . get ( index+1 )  ;  else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^268^269^^^^264^272^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^271^^^^^264^272^
[REPLACE]  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] return siblings . size ( index+1 ) ; [CE] no suitable method found for size(int)  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) [ATTENTION] return siblings . size ( index+1 )  ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^269^^^^^264^272^
[REPLACE]  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] return siblings . get ( baseUri )  ; [CE] method get in interface List<E> cannot be applied to given types ;  [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) [ATTENTION] return siblings . get ( baseUri ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^269^^^^^264^272^
[REPLACE]  return  null; 	[BUGGY] return this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nextSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node nextSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^271^^^^^264^272^
[REPLACE]  List<Node>  siblings  =  parentNode  .  childNodes; 	[BUGGY] int index = indexInList ( out , childNodes ) ; [CE] cannot find symbol out  [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { [ATTENTION] int index = indexInList ( out , childNodes )  ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^279^^^^^278^286^
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ; 	[BUGGY] Integer index = indexInList ( this , false ) ; [CE] method indexInList in class Node cannot be applied to given types ;  [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { List<Node> siblings = parentNode . childNodes ; [ATTENTION] Integer index = indexInList ( this , false )  ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^280^^^^^278^286^
[REPLACE]  Validate  .  notNull  (  index  )  ; 	[BUGGY] Validate . notEmpty ( attributeValue )  ; [CE] cannot find symbol attributeValue  [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; [ATTENTION] Validate . notEmpty ( attributeValue ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^281^^^^^278^286^
[REPLACE]  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ; 	[BUGGY] if ( index > =  3 ) return siblings . get ( index-1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; [ATTENTION] if ( index> = 3 ) return siblings . get ( index-1 )  ;  else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^282^283^^^^278^286^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^285^^^^^278^286^
[REPLACE]  return  siblings  .  get  (  index-1  )  ; 	[BUGGY] return siblings . size ( index-1 ) ; [CE] no suitable method found for size(int)  [METHOD]  previousSibling [TYPE] Node [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] Integer index [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Node previousSibling ( ) { List<Node> siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) [ATTENTION] return siblings . size ( index-1 )  ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^283^^^^^278^286^
[REPLACE]  return  indexInList  (  this,  parent  (  )    .  childNodes  )  ; 	[BUGGY] return indexInList ( null , parent ( ) . childNodes ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  siblingIndex [TYPE] Integer [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public Integer siblingIndex ( ) { [ATTENTION] return indexInList ( null , parent ( )  . childNodes )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^295^^^^^294^296^
[REPLACE]  Validate  .  notNull  (  search  )  ; 	[BUGGY] Validate . notEmpty ( attributeKey )  ; [CE] cannot find symbol attributeKey  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { [ATTENTION] Validate . notEmpty ( attributeKey ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) return i ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^299^^^^^298^308^
[REPLACE]  Validate  .  notNull  (  nodes  )  ; 	[BUGGY] Validate . notNull ( index ) ; [CE] cannot find symbol index  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; [ATTENTION] Validate . notNull ( index )  ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) return i ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^300^^^^^298^308^
[REPLACE]  if  (  node  .  equals  (  search  )  )  return  i; 	[BUGGY] if ( node . indexInList ( search , true )  ) return i ; [CE] method indexInList in class Node cannot be applied to given types ;  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; [ATTENTION] if ( node . indexInList ( search , true )  ) return i ;  } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^304^305^^^^298^308^
[REPLACE]  return  i; 	[BUGGY] return 0 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) [ATTENTION] return 0 ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^305^^^^^298^308^
[REPLACE]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < nodes . set ( i , null )  * 2 ; i++ ) {[CE] bad operand types for binary operator '*'  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  [ATTENTION] for ( int i = 0 ; i < nodes . set ( i , null ) *2 ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) return i ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^302^^^^^298^308^
[ADD]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i;  } 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  [ATTENTION]   return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^302^303^304^305^306^298^308^
[REPLACE]  if  (  node  .  equals  (  search  )  )  return  i; 	[BUGGY] if ( node . absUrl ( search ) ) return i ; [CE] method absUrl in class Node cannot be applied to given types ;  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; [ATTENTION] if ( node . absUrl ( search ) ) return i ;  } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^304^305^^^^298^308^
[REPLACE]  N  node  =  nodes  .  get  (  i  )  ; 	[BUGGY] N node = nodes . remove ( i ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { [ATTENTION] N node = nodes . remove ( i )  ; if ( node . equals ( search ) ) return i ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^303^^^^^298^308^
[REPLACE]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < nodes . size ( ) ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  [ATTENTION] for ( int i = 0 ; i < nodes . size ( )  ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) return i ; } return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^302^^^^^298^308^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  indexInList [TYPE] <N [PARAMETER] N search List<N> nodes [CLASS] Node  [TYPE] boolean false true [TYPE] Node in out parentNode [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] N node search [TYPE] int i  [CONTEXT]  protected static <N extends Node> Integer indexInList ( N search , List<N> nodes ) { Validate . notNull ( search ) ; Validate . notNull ( nodes ) ;  for ( int i = 0 ; i < nodes . size ( ) ; i++ ) { N node = nodes . get ( i ) ; if ( node . equals ( search ) ) return i ; } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^307^^^^^298^308^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] URL abs = new URL ( relUrl ) ; [CE] cannot find symbol relUrl  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  public String outerHtml ( ) { [ATTENTION] URL abs = new URL ( relUrl )  ; outerHtml ( accum ) ; return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^315^^^^^314^318^
[REPLACE]  outerHtml  (  accum  )  ; 	[BUGGY] Validate . notNull ( baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  public String outerHtml ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] Validate . notNull ( baseUri )  ; return accum . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^316^^^^^314^318^
[REPLACE]  return  accum  .  toString  (  )  ; 	[BUGGY] return accum . StringBuilder ( ) ; [CE] cannot find symbol  [METHOD]  outerHtml [TYPE] String [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  public String outerHtml ( ) { StringBuilder accum = new StringBuilder ( ) ; outerHtml ( accum ) ; [ATTENTION] return accum . StringBuilder ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^317^^^^^314^318^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public String toString ( ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^327^^^^^326^328^
[REPLACE]  accum  .  append  (    "\n  "  )    .  append  (  StringUtils  .  leftPad  (    "  ",  nodeDepth  (  )  -1  *  2  )  )  ; 	[BUGGY] accum . append (   "\n  " ) . append ( StringUtils . leftPad (   "  " , nodeDepth ( )  > = 1 * 2 ) ) ; [CE] no suitable method found for leftPad(String , boolean)  [METHOD]  indent [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  protected void indent ( StringBuilder accum ) { [ATTENTION] accum . append (   "\n  " )  . append ( StringUtils . leftPad (   "  " , nodeDepth ( ) > = 1 * 2 ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^331^^^^^330^332^
[REPLACE]  accum  .  append  (    "\n  "  )    .  append  (  StringUtils  .  leftPad  (    "  ",  nodeDepth  (  )  -1  *  2  )  )  ; 	[BUGGY] accum . StringBuilder ( )[CE] ' ; ' expected  [METHOD]  indent [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  protected void indent ( StringBuilder accum ) { [ATTENTION] accum . StringBuilder ( ) }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^331^^^^^330^332^
[REPLACE]  accum  .  append  (    "\n  "  )    .  append  (  StringUtils  .  leftPad  (    "  ",  nodeDepth  (  )  -1  *  2  )  )  ; 	[BUGGY] accum . append (   "\n  " ) . append ( StringUtils . leftPad (   "  " , nodeDepth ( )  ! = 1 * 2 ) ) ; [CE] no suitable method found for leftPad(String , boolean)  [METHOD]  indent [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  protected void indent ( StringBuilder accum ) { [ATTENTION] accum . append (   "\n  " )  . append ( StringUtils . leftPad (   "  " , nodeDepth ( ) ! = 1 * 2 ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^331^^^^^330^332^
[REPLACE]  accum  .  append  (    "\n  "  )    .  append  (  StringUtils  .  leftPad  (    "  ",  nodeDepth  (  )  -1  *  2  )  )  ; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  indent [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  protected void indent ( StringBuilder accum ) { [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^331^^^^^330^332^
[ADD]  accum  .  append  (    "\n  "  )    .  append  (  StringUtils  .  leftPad  (    "  ",  nodeDepth  (  )  -1  *  2  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  indent [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node in out parentNode  [CONTEXT]  protected void indent ( StringBuilder accum ) { [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^331^^^^^330^332^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this && o ) return true ; [CE] bad operand types for binary operator '&&'  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] Object o [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this&&o ) return true ;  return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^336^^^^^335^339^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this = = o ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] Object o [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this = = o ) return false ;  return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^336^^^^^335^339^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] Object o [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] Node in out parentNode  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ;  [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^338^^^^^335^339^
[REPLACE]  int  result  =  parentNode  !=  null  ?  parentNode  .  hashCode  (  )  :  0; 	[BUGGY] int result  =  0 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int result [TYPE] Node in out parentNode  [CONTEXT]  public int hashCode ( ) { [ATTENTION] int result = 0 ;  result = 31 * result + ( attributes ! = null ? attributes . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^343^^^^^342^347^
[REPLACE]  result  =  31  *  result  +  (  attributes  !=  null  ?  attributes  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int result [TYPE] Node in out parentNode  [CONTEXT]  public int hashCode ( ) { int result = parentNode ! = null ? parentNode . hashCode ( ) : 0 ;  [ATTENTION] result = 0 )  ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^345^^^^^342^347^
[REPLACE]  return  result; 	[BUGGY] return siblings . get ( index-1 ) ; [CE] cannot find symbol index  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Node  [TYPE] Attributes attributes [TYPE] List childNodes nodes siblings [TYPE] String attributeKey attributeValue baseUri relUrl [TYPE] boolean false true [TYPE] int result [TYPE] Node in out parentNode  [CONTEXT]  public int hashCode ( ) { int result = parentNode ! = null ? parentNode . hashCode ( ) : 0 ;  result = 31 * result + ( attributes ! = null ? attributes . hashCode ( ) : 0 ) ; [ATTENTION] return siblings . get ( index-1 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Node.java^346^^^^^342^347^
[REPLACE]  super  (  baseUri,  attributes  )  ; 	[BUGGY] return attr (   "value  " ) ; [CE] no suitable constructor found for Node()  [METHOD]  <init> [TYPE] Attributes) [PARAMETER] Tag tag String baseUri Attributes attributes [CLASS] Element  [TYPE] Attributes attributes [TYPE] Set classNames [TYPE] Tag tag [TYPE] String baseUri [TYPE] boolean false true  [CONTEXT]  public Element ( Tag tag , String baseUri , Attributes attributes ) { [ATTENTION] return attr (   "value  " )  ;  Validate . notNull ( tag ) ; this . tag = tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^35^^^^^34^39^
[REPLACE]  Validate  .  notNull  (  tag  )  ; 	[BUGGY] tag  ; [CE] not a statement  [METHOD]  <init> [TYPE] Attributes) [PARAMETER] Tag tag String baseUri Attributes attributes [CLASS] Element  [TYPE] Attributes attributes [TYPE] Set classNames [TYPE] Tag tag [TYPE] String baseUri [TYPE] boolean false true  [CONTEXT]  public Element ( Tag tag , String baseUri , Attributes attributes ) { super ( baseUri , attributes ) ;  [ATTENTION] tag ; this . tag = tag ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^37^^^^^34^39^
[REPLACE]  this  .  tag  =  tag; 	[BUGGY] this . tag =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] Attributes) [PARAMETER] Tag tag String baseUri Attributes attributes [CLASS] Element  [TYPE] Attributes attributes [TYPE] Set classNames [TYPE] Tag tag [TYPE] String baseUri [TYPE] boolean false true  [CONTEXT]  public Element ( Tag tag , String baseUri , Attributes attributes ) { super ( baseUri , attributes ) ;  Validate . notNull ( tag ) ; [ATTENTION] this . tag = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^38^^^^^34^39^
[REPLACE]  this  (  tag,  baseUri,  new  Attributes  (  )  )  ; 	[BUGGY] . append ( attributes . html ( ) ) ; [CE] illegal start of expression  [METHOD]  <init> [TYPE] String) [PARAMETER] Tag tag String baseUri [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String baseUri [TYPE] boolean false true  [CONTEXT]  public Element ( Tag tag , String baseUri ) { [ATTENTION] . append ( attributes . html ( ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^50^^^^^49^51^
[REPLACE]  return  tag  .  getName  (  )  ; 	[BUGGY] return tag . hashCode ( ) ; [CE] incompatible types  [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return tag . hashCode ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^55^^^^^54^56^
[REPLACE]  return  tag  .  getName  (  )  ; 	[BUGGY] return tag . hashCode ( ) ; [CE] incompatible types  [METHOD]  tagName [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String tagName ( ) { [ATTENTION] return tag . hashCode ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^64^^^^^63^65^
[REPLACE]  return  tag; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  tag [TYPE] Tag [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Tag tag ( ) { [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^73^^^^^72^74^
[REPLACE]  return  tag  .  isBlock  (  )  ; 	[BUGGY] return tag . isEmpty ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  isBlock [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public boolean isBlock ( ) { [ATTENTION] return tag . isEmpty ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^83^^^^^82^84^
[REPLACE]  String  id  =  attr  (    "id  "  )  ; 	[BUGGY] Set<String> classes = classNames ( ) ; [CE] cannot find symbol id  [METHOD]  id [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true  [CONTEXT]  public String id ( ) { [ATTENTION] Set<String> classes = classNames ( )  ; return id = = null ?   "  " : id ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^92^^^^^91^94^
[REPLACE]  return  id  ==  null  ?    "  "  :  id; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  id [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true  [CONTEXT]  public String id ( ) { String id = attr (   "id  " ) ; [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^93^^^^^91^94^
[REPLACE]  super  .  attr  (  attributeKey,  attributeValue  )  ; 	[BUGGY] super . indexInList ( attributeKey , attributeValue ) ; [CE] method indexInList in class Node cannot be applied to given types ;  [METHOD]  attr [TYPE] Element [PARAMETER] String attributeKey String attributeValue [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String attributeKey attributeValue [TYPE] boolean false true  [CONTEXT]  public Element attr ( String attributeKey , String attributeValue ) { [ATTENTION] super . indexInList ( attributeKey , attributeValue )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^103^^^^^102^105^
[ADD]  super  .  attr  (  attributeKey,  attributeValue  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] Element [PARAMETER] String attributeKey String attributeValue [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String attributeKey attributeValue [TYPE] boolean false true  [CONTEXT]  public Element attr ( String attributeKey , String attributeValue ) { [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^103^^^^^102^105^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  attr [TYPE] Element [PARAMETER] String attributeKey String attributeValue [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String attributeKey attributeValue [TYPE] boolean false true  [CONTEXT]  public Element attr ( String attributeKey , String attributeValue ) { super . attr ( attributeKey , attributeValue ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^104^^^^^102^105^
[REPLACE]  return  (  Element  )  super  .  parent  (  )  ; 	[BUGGY] return ( Element ) super . indent ( false )  ; [CE] method indent in class Node cannot be applied to given types ;  [METHOD]  parent [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element parent ( ) { [ATTENTION] return ( Element ) super . indent ( false ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^109^^^^^108^110^
[REPLACE]  return  children  (  )    .  get  (  index  )  ; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  child [TYPE] Element [PARAMETER] int index [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] int index  [CONTEXT]  public Element child ( int index ) { [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^123^^^^^122^124^
[REPLACE]  List<Element>  elements  =  new  ArrayList<Element>  (  )  ; 	[BUGGY] Elements wrapChildren = wrapBody . children ( ) ; [CE] cannot find symbol wrapBody  [METHOD]  children [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] List elements [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node node  [CONTEXT]  public Elements children ( ) {  [ATTENTION] Elements wrapChildren = wrapBody . children ( )  ; for ( Node node : childNodes ) { if ( node instanceof Element ) elements . add ( ( Element ) node ) ; } return new Elements ( elements ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^136^^^^^134^142^
[REPLACE]  if  (  node  instanceof  Element  )  elements  .  add  (  (  Element  )  node  )  ; 	[BUGGY] if ( ! node instanceof Element ) null . add ( null )  ; [CE] bad operand type Node for unary operator '!'  [METHOD]  children [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] List elements [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node node  [CONTEXT]  public Elements children ( ) {  List<Element> elements = new ArrayList<Element> ( ) ; for ( Node node : childNodes ) { [ATTENTION] if ( ! node instanceof Element ) null . add ( null ) ;  } return new Elements ( elements ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^138^139^^^^134^142^
[REPLACE]  elements  .  add  (  (  Element  )  node  )  ; 	[BUGGY] elements . size ( ( Element ) node ) ; [CE] no suitable method found for size(Element)  [METHOD]  children [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] List elements [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node node  [CONTEXT]  public Elements children ( ) {  List<Element> elements = new ArrayList<Element> ( ) ; for ( Node node : childNodes ) { if ( node instanceof Element ) [ATTENTION] elements . size ( ( Element ) node )  ; } return new Elements ( elements ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^139^^^^^134^142^
[REPLACE]  for  (  Node  node  :  childNodes  )  { 	[BUGGY] Node node = nodes . get ( i ) ; [CE] illegal start of type  [METHOD]  children [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] List elements [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node node  [CONTEXT]  public Elements children ( ) {  List<Element> elements = new ArrayList<Element> ( ) ; [ATTENTION] Node node = nodes . get ( i )  ; if ( node instanceof Element ) elements . add ( ( Element ) node ) ; } return new Elements ( elements ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^137^^^^^134^142^
[REPLACE]  return  new  Elements  (  elements  )  ; 	[BUGGY] return new Elements ( null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  children [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] List elements [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node node  [CONTEXT]  public Elements children ( ) {  List<Element> elements = new ArrayList<Element> ( ) ; for ( Node node : childNodes ) { if ( node instanceof Element ) elements . add ( ( Element ) node ) ; } [ATTENTION] return new Elements ( null )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^141^^^^^134^142^
[REPLACE]  return  Selector  .  select  (  query,  this  )  ; 	[BUGGY] return Selector . select ( query , null ) ; [CE] reference to select is ambiguous , both method select(String , Element) in Selector and method select(String , Iterable<Element>) in Selector match  [METHOD]  select [TYPE] Elements [PARAMETER] String query [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String query [TYPE] boolean false true  [CONTEXT]  public Elements select ( String query ) { [ATTENTION] return Selector . select ( query , null )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^162^^^^^161^163^
[REPLACE]  Validate  .  notNull  (  child  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  appendChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element appendChild ( Node child ) { [ATTENTION] Validate . notNull ( html )  ;  child . setParentNode ( this ) ; childNodes . add ( child ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^172^^^^^171^177^
[REPLACE]  child  .  setParentNode  (  this  )  ; 	[BUGGY] child . outerHtml ( this ) ; [CE] no suitable method found for outerHtml(Element)  [METHOD]  appendChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element appendChild ( Node child ) { Validate . notNull ( child ) ;  [ATTENTION] child . outerHtml ( this )  ; childNodes . add ( child ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^174^^^^^171^177^
[REPLACE]  childNodes  .  add  (  child  )  ; 	[BUGGY] childNodes . add ( this , child )  ; [CE] no suitable method found for add(Element , Node)  [METHOD]  appendChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element appendChild ( Node child ) { Validate . notNull ( child ) ;  child . setParentNode ( this ) ; [ATTENTION] childNodes . add ( this , child ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^175^^^^^171^177^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  appendChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element appendChild ( Node child ) { Validate . notNull ( child ) ;  child . setParentNode ( this ) ; childNodes . add ( child ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^176^^^^^171^177^
[REPLACE]  Validate  .  notNull  (  child  )  ; 	[BUGGY] Validate . notNull ( html ) ; [CE] cannot find symbol html  [METHOD]  prependChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element prependChild ( Node child ) { [ATTENTION] Validate . notNull ( html )  ;  child . setParentNode ( this ) ; childNodes . add ( 0 , child ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^186^^^^^185^191^
[REPLACE]  child  .  setParentNode  (  this  )  ; 	[BUGGY] child . outerHtml ( this ) ; [CE] no suitable method found for outerHtml(Element)  [METHOD]  prependChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element prependChild ( Node child ) { Validate . notNull ( child ) ;  [ATTENTION] child . outerHtml ( this )  ; childNodes . add ( 0 , child ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^188^^^^^185^191^
[REPLACE]  childNodes  .  add  (  0,  child  )  ; 	[BUGGY] childNodes . add ( 2 , child ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element prependChild ( Node child ) { Validate . notNull ( child ) ;  child . setParentNode ( this ) ; [ATTENTION] childNodes . add ( 2 , child )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^189^^^^^185^191^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependChild [TYPE] Element [PARAMETER] Node child [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child  [CONTEXT]  public Element prependChild ( Node child ) { Validate . notNull ( child ) ;  child . setParentNode ( this ) ; childNodes . add ( 0 , child ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^190^^^^^185^191^
[REPLACE]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ; 	[BUGGY] Element child = new Element ( Tag . equals ( tagName ) , baseUri ( ) ) ; [CE] non-static method equals(Object) cannot be referenced from a static context  [METHOD]  appendElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element appendElement ( String tagName ) { [ATTENTION] Element child = new Element ( Tag . equals ( tagName )  , baseUri ( ) )  ; appendChild ( child ) ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^201^^^^^200^204^
[ADD]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ; 	[BUGGY] [CE] cannot find symbol child  [METHOD]  appendElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element appendElement ( String tagName ) { [ATTENTION] appendChild ( child ) ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^201^^^^^200^204^
[REPLACE]  appendChild  (  child  )  ; 	[BUGGY] prependChild ( child ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  appendElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; [ATTENTION] prependChild ( child )  ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^202^^^^^200^204^
[ADD]  appendChild  (  child  )  ;  return  child; 	[BUGGY] return child ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  appendElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; [ATTENTION] return child ;  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^202^203^^^^200^204^
[REPLACE]  return  child; 	[BUGGY] return text ( ) ; [CE] incompatible types  [METHOD]  appendElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; appendChild ( child ) ; [ATTENTION] return text ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^203^^^^^200^204^
[REPLACE]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ; 	[BUGGY] Element child = new Element ( Tag . hashCode ( )  , baseUri ( ) ) ; [CE] non-static method hashCode() cannot be referenced from a static context  [METHOD]  prependElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element prependElement ( String tagName ) { [ATTENTION] Element child = new Element ( Tag . hashCode ( ) , baseUri ( ) )  ; prependChild ( child ) ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^214^^^^^213^217^
[ADD]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ; 	[BUGGY] [CE] cannot find symbol child  [METHOD]  prependElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element prependElement ( String tagName ) { [ATTENTION] prependChild ( child ) ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^214^^^^^213^217^
[REPLACE]  prependChild  (  child  )  ; 	[BUGGY] appendChild ( child ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; [ATTENTION] appendChild ( child )  ; return child ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^215^^^^^213^217^
[ADD]  prependChild  (  child  )  ;  return  child; 	[BUGGY] return child ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; [ATTENTION] return child ;  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^215^216^^^^213^217^
[REPLACE]  return  child; 	[BUGGY] return text ( ) ; [CE] incompatible types  [METHOD]  prependElement [TYPE] Element [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true [TYPE] Element child  [CONTEXT]  public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; prependChild ( child ) ; [ATTENTION] return text ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^216^^^^^213^217^
[REPLACE]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ; 	[BUGGY] TextNode textNode = new TextNode ( text , baseUri ) ; [CE] cannot find symbol node  [METHOD]  appendText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element appendText ( String text ) { [ATTENTION] TextNode textNode = new TextNode ( text , baseUri )  ; appendChild ( node ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^226^^^^^225^229^
[ADD]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ;  appendChild  (  node  )  ; 	[BUGGY] appendChild ( node ) ; [CE] cannot find symbol node  [METHOD]  appendText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element appendText ( String text ) { [ATTENTION] appendChild ( node )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^226^227^^^^225^229^
[REPLACE]  appendChild  (  node  )  ; 	[BUGGY] prependChild ( node ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  appendText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element appendText ( String text ) { TextNode node = new TextNode ( text , baseUri ( ) ) ; [ATTENTION] prependChild ( node )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^227^^^^^225^229^
[ADD]  appendChild  (  node  )  ;  return  this; 	[BUGGY] [CE] missing return statement  [METHOD]  appendText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element appendText ( String text ) { TextNode node = new TextNode ( text , baseUri ( ) ) ; [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^227^228^^^^225^229^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  appendText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element appendText ( String text ) { TextNode node = new TextNode ( text , baseUri ( ) ) ; appendChild ( node ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^228^^^^^225^229^
[REPLACE]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ; 	[BUGGY] TextNode textNode = new TextNode ( text , baseUri ) ; [CE] cannot find symbol node  [METHOD]  prependText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element prependText ( String text ) { [ATTENTION] TextNode textNode = new TextNode ( text , baseUri )  ; prependChild ( node ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^238^^^^^237^241^
[REPLACE]  prependChild  (  node  )  ; 	[BUGGY] appendChild ( node ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element prependText ( String text ) { TextNode node = new TextNode ( text , baseUri ( ) ) ; [ATTENTION] appendChild ( node )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^239^^^^^237^241^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prependText [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode node [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element prependText ( String text ) { TextNode node = new TextNode ( text , baseUri ( ) ) ; prependChild ( node ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^240^^^^^237^241^
[REPLACE]  Validate  .  notNull  (  html  )  ; 	[BUGGY] Validate . notEmpty ( html ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  append [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node  [CONTEXT]  public Element append ( String html ) { [ATTENTION] Validate . notEmpty ( html )  ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^250^^^^^249^259^
[REPLACE]  Element  fragment  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ; 	[BUGGY] Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; [CE] cannot find symbol fragment  [METHOD]  append [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node  [CONTEXT]  public Element append ( String html ) { Validate . notNull ( html ) ;  [ATTENTION] Element wrapBody = Parser . parseBodyFragment ( html , baseUri )  . body ( )  ;  for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^252^^^^^249^259^
[REPLACE]  node  .  parentNode  =  null; 	[BUGGY] node . parentNode = this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  append [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node  [CONTEXT]  public Element append ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  for ( Node node : fragment . childNodes ( ) ) { [ATTENTION] node . parentNode = this ; appendChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^255^^^^^249^259^
[REPLACE]  for  (  Node  node  :  fragment  .  childNodes  (  )  )  { 	[BUGGY] Node node = nodes . get ( i ) ; [CE] illegal start of type  [METHOD]  append [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node  [CONTEXT]  public Element append ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  [ATTENTION] Node node = nodes . get ( i )  ; node . parentNode = null ; appendChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^254^^^^^249^259^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  append [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node  [CONTEXT]  public Element append ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^258^^^^^249^259^
[REPLACE]  Validate  .  notNull  (  html  )  ; 	[BUGGY] Validate . notEmpty ( html ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { [ATTENTION] Validate . notEmpty ( html )  ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^268^^^^^267^279^
[REPLACE]  Element  fragment  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ; 	[BUGGY] Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; [CE] cannot find symbol fragment  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  [ATTENTION] Element wrapBody = Parser . parseBodyFragment ( html , baseUri )  . body ( )  ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^270^^^^^267^279^
[REPLACE]  List<Node>  nodes  =  fragment  .  childNodes  (  )  ; 	[BUGGY] List<Node> nodes = fragment . siblingIndex ( ) ; [CE] incompatible types  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  [ATTENTION] List<Node> nodes = fragment . siblingIndex ( )  ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^272^^^^^267^279^
[REPLACE]  for  (  int  i  =  nodes  .  size  (  )  -  1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = nodes . size ( ) / 0 . 5 - 1 ; i > = 0 ; i-- ) {[CE] possible loss of precision  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; [ATTENTION] for ( int i = nodes . size ( ) /0 . 5- 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^273^^^^^267^279^
[REPLACE]  node  .  parentNode  =  null; 	[BUGGY] node . parentNode = true ; [CE] incompatible types  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; [ATTENTION] node . parentNode = true ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^275^^^^^267^279^
[ADD]  node  .  parentNode  =  null; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; [ATTENTION] prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^275^^^^^267^279^
[REPLACE]  Node  node  =  nodes  .  get  (  i  )  ; 	[BUGGY] Node node = true . get ( i ) ; [CE] boolean cannot be dereferenced  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { [ATTENTION] Node node = true . get ( i )  ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^274^^^^^267^279^
[REPLACE]  for  (  int  i  =  nodes  .  size  (  )  -  1;  i  >=  0;  i--  )  { 	[BUGGY] for ( int i = nodes . size ( ) % 0 . 5 - 1 ; i > = 0 ; i-- ) {[CE] possible loss of precision  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; [ATTENTION] for ( int i = nodes . size ( ) %0 . 5- 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^273^^^^^267^279^
[REPLACE]  Node  node  =  nodes  .  get  (  i  )  ; 	[BUGGY] Node node = nodes . add ( i ) ; [CE] no suitable method found for add(int)  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { [ATTENTION] Node node = nodes . add ( i )  ; node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^274^^^^^267^279^
[ADD]  Node  node  =  nodes  .  get  (  i  )  ; 	[BUGGY] [CE] cannot find symbol node  [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { [ATTENTION] node . parentNode = null ; prependChild ( node ) ; } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^274^^^^^267^279^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  prepend [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element fragment [TYPE] Node node [TYPE] List nodes [TYPE] Tag tag [TYPE] String html [TYPE] int i  [CONTEXT]  public Element prepend ( String html ) { Validate . notNull ( html ) ;  Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ;  List<Node> nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i-- ) { Node node = nodes . get ( i ) ; node . parentNode = null ; prependChild ( node ) ; } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^278^^^^^267^279^
[REPLACE]  childNodes  .  clear  (  )  ; 	[BUGGY] childNodes . isEmpty ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  empty [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element empty ( ) { [ATTENTION] childNodes . isEmpty ( ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^286^^^^^285^288^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  empty [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element empty ( ) { childNodes . clear ( ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^287^^^^^285^288^
[REPLACE]  Validate  .  notEmpty  (  html  )  ; 	[BUGGY] Validate . notNull ( html ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { [ATTENTION] Validate . notNull ( html )  ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^296^^^^^295^317^
[REPLACE]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ; 	[BUGGY] Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; [CE] cannot find symbol wrapBody  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  [ATTENTION] Element fragment = Parser . parseBodyFragment ( html , baseUri )  . body ( )  ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^298^^^^^295^317^
[REPLACE]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ; 	[BUGGY] Elements wrapChildren = wrap . children ( ) ; [CE] cannot find symbol wrap  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; [ATTENTION] Elements wrapChildren = wrap . children ( )  ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^299^^^^^295^317^
[ADD]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ; 	[BUGGY] [CE] cannot find symbol wrap  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; [ATTENTION]  if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^299^300^^^^295^317^
[REPLACE]  Element  wrap  =  wrapChildren  .  first  (  )  ; 	[BUGGY] Element wrap = wrapChildren . size ( ) ; [CE] incompatible types  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; [ATTENTION] Element wrap = wrapChildren . size ( )  ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^300^^^^^295^317^
[REPLACE]  if  (  wrap  ==  null  )  return  null; 	[BUGGY] if ( wrap ! = null ) return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; [ATTENTION] if ( wrap ! = null ) return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^301^302^^^^295^317^
[REMOVE]   	[BUGGY] if ( ! ( super . equals ( o ) ) )   return false ; [CE] cannot find symbol o  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; [ATTENTION] if ( wrap = = null ) // nothing to wrap with ; noop if ( ! ( super . equals ( o ) ) ) return false ; return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^301^^^^^295^317^
[REPLACE]  return  null; 	[BUGGY] return this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop [ATTENTION] return this ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^302^^^^^295^317^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop [ATTENTION] return true ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^302^^^^^295^317^
[REPLACE]  Element  deepest  =  getDeepChild  (  wrap  )  ; 	[BUGGY] Element deepest = getDeepChild ( wrapBody ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  [ATTENTION] Element deepest = getDeepChild ( wrapBody )  ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^304^^^^^295^317^
[ADD]  Element  deepest  =  getDeepChild  (  wrap  )  ; 	[BUGGY] [CE] cannot find symbol deepest  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  [ATTENTION] parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^304^^^^^295^317^
[REPLACE]  parentNode  .  replaceChild  (  this,  wrap  )  ; 	[BUGGY] parentNode . replaceChild ( this , wrapBody ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; [ATTENTION] parentNode . replaceChild ( this , wrapBody )  ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^305^^^^^295^317^
[REPLACE]  deepest  .  addChild  (  this  )  ; 	[BUGGY] deepest . indent ( this ) ; [CE] method indent in class Node cannot be applied to given types ;  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; [ATTENTION] deepest . indent ( this )  ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^306^^^^^295^317^
[REPLACE]  if  (  wrapChildren  .  size  (  )  >  1  )  { 	[BUGGY] if ( wrapChildren . size ( ) / 0 . 5 > 1 ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   [ATTENTION] if ( wrapChildren . size ( ) /0 . 5> 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^309^^^^^295^317^
[ADD]  if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   [ATTENTION]   } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^309^310^311^312^313^295^317^
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 1 ; i < wrapChildren . size ( ) + 1 ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { [ATTENTION] for ( int i = 1 ; i < wrapChildren . size ( ) + 1 ; i++ ) { Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^310^^^^^295^317^
[REPLACE]  Element  remainder  =  wrapChildren  .  get  (  i  )  ; 	[BUGGY] Element remainder = wrapChildren . Elements ( i ) ; [CE] cannot find symbol  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first [ATTENTION] Element remainder = wrapChildren . Elements ( i )  ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^311^^^^^295^317^
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < wrapChildren . size ( ) ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { [ATTENTION] for ( int i = 0 ; i < wrapChildren . size ( )  ; i++ ) { Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^310^^^^^295^317^
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  { 	[BUGGY] for ( int i = 1 ; i < wrapChildren . size ( ) % 2 ; i++ ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { [ATTENTION] for ( int i = 1 ; i < wrapChildren . size ( ) %2 ; i++ ) { Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^310^^^^^295^317^
[ADD]  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ; 	[BUGGY] [CE] cannot find symbol remainder  [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first [ATTENTION]  wrap . appendChild ( remainder ) ; } } return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^311^312^^^^295^317^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  wrap [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] Element deepest remainder wrap wrapBody [TYPE] Tag tag [TYPE] String html [TYPE] Elements wrapChildren [TYPE] int i  [CONTEXT]  public Element wrap ( String html ) { Validate . notEmpty ( html ) ;  Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) // nothing to wrap with ; noop return null ;  Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ;   if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i++ ) { // skip first Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^316^^^^^295^317^
[REPLACE]  List<Element>  children  =  el  .  children  (  )  ; 	[BUGGY] List<Element> children = el . child ( null )  ; [CE] method child in class Element cannot be applied to given types ;  [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { [ATTENTION] List<Element> children = el . child ( null ) ; if ( children . size ( ) > 0 ) return getDeepChild ( children . get ( 0 ) ) ; else return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^320^^^^^319^325^
[ADD]  List<Element>  children  =  el  .  children  (  )  ; 	[BUGGY] [CE] cannot find symbol children  [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { [ATTENTION] if ( children . size ( ) > 0 ) return getDeepChild ( children . get ( 0 ) ) ; else return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^320^^^^^319^325^
[REPLACE]  if  (  children  .  size  (  )  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ; 	[BUGGY] if ( children . size ( ) % 2 > 0 ) return getDeepChild ( children . get ( 0 ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { List<Element> children = el . children ( ) ; [ATTENTION] if ( children . size ( ) %2 > 0 ) return getDeepChild ( children . get ( 0 ) )  ;  else return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^321^322^^^^319^325^
[REPLACE]  return  el; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { List<Element> children = el . children ( ) ; if ( children . size ( ) > 0 ) return getDeepChild ( children . get ( 0 ) ) ; else [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^324^^^^^319^325^
[REPLACE]  return  getDeepChild  (  children  .  get  (  0  )  )  ; 	[BUGGY] return getDeepChild ( children . Elements ( null )  ) ; [CE] cannot find symbol  [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { List<Element> children = el . children ( ) ; if ( children . size ( ) > 0 ) [ATTENTION] return getDeepChild ( children . Elements ( null )  )  ; else return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^322^^^^^319^325^
[REPLACE]  return  getDeepChild  (  children  .  get  (  0  )  )  ; 	[BUGGY] return getDeepChild ( children . get ( 3 ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getDeepChild [TYPE] Element [PARAMETER] Element el [CLASS] Element  [TYPE] List children [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element el  [CONTEXT]  private Element getDeepChild ( Element el ) { List<Element> children = el . children ( ) ; if ( children . size ( ) > 0 ) [ATTENTION] return getDeepChild ( children . get ( 3 ) )  ; else return el ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^322^^^^^319^325^
[REPLACE]  return  parent  (  )    .  children  (  )  ; 	[BUGGY] return parent ( ) . child ( ) ; [CE] method child in class Element cannot be applied to given types ;  [METHOD]  siblingElements [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Elements siblingElements ( ) { [ATTENTION] return parent ( )  . child ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^332^^^^^331^333^
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] Elements wrapChildren = wrapBody . children ( ) ; [CE] cannot find symbol wrapBody  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { [ATTENTION] Elements wrapChildren = wrapBody . children ( )  ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^344^^^^^343^351^
[ADD]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] [CE] cannot find symbol siblings  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { [ATTENTION] Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^344^^^^^343^351^
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ; 	[BUGGY] Integer index = indexInList ( this , true ) ; [CE] method indexInList in class Node cannot be applied to given types ;  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; [ATTENTION] Integer index = indexInList ( this , true )  ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^345^^^^^343^351^
[REPLACE]  Validate  .  notNull  (  index  )  ; 	[BUGGY] Validate . notNull ( text ) ; [CE] cannot find symbol text  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; [ATTENTION] Validate . notNull ( text )  ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^346^^^^^343^351^
[ADD]  Validate  .  notNull  (  index  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; [ATTENTION] if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^346^^^^^343^351^
[REPLACE]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] if ( siblings . size ( ) + 5 > index+1 ) return siblings . size ( index+1 ) ; [CE] no suitable method found for size(int)  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; [ATTENTION] if ( siblings . size ( ) + 5 > index+1 ) return siblings . size ( index+1 )  ;  else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^347^348^^^^343^351^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) return siblings . get ( index+1 ) ; else [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^350^^^^^343^351^
[REPLACE]  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] return siblings . get ( this )  ; [CE] method get in interface List<E> cannot be applied to given types ;  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) [ATTENTION] return siblings . get ( this ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^348^^^^^343^351^
[REPLACE]  return  siblings  .  get  (  index+1  )  ; 	[BUGGY] return siblings . size(index ; [CE] ')' expected  [METHOD]  nextElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element nextElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index+1 ) [ATTENTION] return siblings . size ( index ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^348^^^^^343^351^
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] List<Element> siblings = parent ( ) . child ( ) ; [CE] method child in class Element cannot be applied to given types ;  [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { [ATTENTION] List<Element> siblings = parent ( )  . child ( )  ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^359^^^^^358^366^
[ADD]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] [CE] cannot find symbol siblings  [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { [ATTENTION] Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^359^^^^^358^366^
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ; 	[BUGGY] Integer index = indexInList ( this , null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; [ATTENTION] Integer index = indexInList ( this , null )  ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^360^^^^^358^366^
[REPLACE]  Validate  .  notNull  (  index  )  ; 	[BUGGY] Validate . notNull ( text ) ; [CE] cannot find symbol text  [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; [ATTENTION] Validate . notNull ( text )  ; if ( index > 0 ) return siblings . get ( index-1 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^361^^^^^358^366^
[REPLACE]  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ; 	[BUGGY] if ( index > =  0 ) return siblings . get ( index-1 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; [ATTENTION] if ( index> = 0 ) return siblings . get ( index-1 )  ;  else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^362^363^^^^358^366^
[REPLACE]  return  null; 	[BUGGY] return this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index-1 ) ; else [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^365^^^^^358^366^
[REPLACE]  return  siblings  .  get  (  index-1  )  ; 	[BUGGY] return siblings . size ( index-0 ) ; [CE] no suitable method found for size(int)  [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) [ATTENTION] return siblings . size ( index-0 )  ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^363^^^^^358^366^
[REPLACE]  return  siblings  .  get  (  index-1  )  ; 	[BUGGY] return siblings . size(index ; [CE] ')' expected  [METHOD]  previousElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] Integer index [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element previousElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) [ATTENTION] return siblings . size ( index ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^363^^^^^358^366^
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] List<Element> siblings = parent ( ) . child ( ) ; [CE] method child in class Element cannot be applied to given types ;  [METHOD]  firstElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element firstElementSibling ( ) {  [ATTENTION] List<Element> siblings = parent ( )  . child ( )  ; return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^374^^^^^372^376^
[REPLACE]  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  0  )  :  null; 	[BUGGY] return siblings . size ( ) + 4 > 1 ? siblings . get ( 0 ) : null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  firstElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element firstElementSibling ( ) {  List<Element> siblings = parent ( ) . children ( ) ; [ATTENTION] return siblings . size ( ) + 4 > 1 ? siblings . get ( 0 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^375^^^^^372^376^
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0; 	[BUGGY] if ( parent ( ) ! = null ) return 0 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  elementSiblingIndex [TYPE] Integer [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Integer elementSiblingIndex ( ) { [ATTENTION] if ( parent ( ) ! = null ) return 0 ; return indexInList ( this , parent ( ) . children ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^384^^^^^383^386^
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0; 	[BUGGY] if ( parent ( )  = = null ) return 0 + 2 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  elementSiblingIndex [TYPE] Integer [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Integer elementSiblingIndex ( ) { [ATTENTION] if ( parent ( ) = = null ) return 0 + 2 ; return indexInList ( this , parent ( ) . children ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^384^^^^^383^386^
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0; 	[BUGGY] if ( parent ( )  = = null ) return 4 ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  elementSiblingIndex [TYPE] Integer [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Integer elementSiblingIndex ( ) { [ATTENTION] if ( parent ( ) = = null ) return 4 ; return indexInList ( this , parent ( ) . children ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^384^^^^^383^386^
[REPLACE]  return  indexInList  (  this,  parent  (  )    .  children  (  )  )  ; 	[BUGGY] return indexInList ( this , parent ( ) . child ( ) ) ; [CE] method child in class Element cannot be applied to given types ;  [METHOD]  elementSiblingIndex [TYPE] Integer [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Integer elementSiblingIndex ( ) { if ( parent ( )  = = null ) return 0 ; [ATTENTION] return indexInList ( this , parent ( )  . child ( ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^385^^^^^383^386^
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ; 	[BUGGY] Elements wrapChildren = wrapBody . children ( ) ; [CE] cannot find symbol wrapBody  [METHOD]  lastElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element lastElementSibling ( ) { [ATTENTION] Elements wrapChildren = wrapBody . children ( )  ; return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - 1 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^393^^^^^392^395^
[REPLACE]  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  siblings  .  size  (  )  -  1  )  :  null; 	[BUGGY] return siblings . size ( ) % 0 . 5 > 1 ? siblings . get ( siblings . size ( ) % 0 . 5 - 1 ) : null ; [CE] method get in interface List<E> cannot be applied to given types ;  [METHOD]  lastElementSibling [TYPE] Element [PARAMETER] [CLASS] Element  [TYPE] List siblings [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element lastElementSibling ( ) { List<Element> siblings = parent ( ) . children ( ) ; [ATTENTION] return siblings . size ( ) %0 . 5> 1 ? siblings . get ( siblings . size ( ) %0 . 5- 1 ) : null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^394^^^^^392^395^
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ; 	[BUGGY] Validate . notNull ( tagName ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementsByTag [TYPE] Elements [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByTag ( String tagName ) { [ATTENTION] Validate . notNull ( tagName )  ; tagName = tagName . toLowerCase ( ) . trim ( ) ;  return Collector . collect ( new Evaluator . Tag ( tagName ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^405^^^^^404^409^
[REPLACE]  tagName  =  tagName  .  toLowerCase  (  )    .  trim  (  )  ; 	[BUGGY] tagName =  null . toLowerCase ( ) . trim ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  getElementsByTag [TYPE] Elements [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByTag ( String tagName ) { Validate . notEmpty ( tagName ) ; [ATTENTION] tagName = null . toLowerCase ( )  . trim ( )  ;  return Collector . collect ( new Evaluator . Tag ( tagName ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^406^^^^^404^409^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Tag  (  tagName  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . Tag ( tagName )  ; [CE] incompatible types  [METHOD]  getElementsByTag [TYPE] Elements [PARAMETER] String tagName [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String tagName [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByTag ( String tagName ) { Validate . notEmpty ( tagName ) ; tagName = tagName . toLowerCase ( ) . trim ( ) ;  [ATTENTION] return new Evaluator . Tag ( tagName ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^408^^^^^404^409^
[REPLACE]  Validate  .  notEmpty  (  id  )  ; 	[BUGGY] Validate . notNull ( id ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { [ATTENTION] Validate . notNull ( id )  ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) > 0 ) return elements . get ( 0 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^421^^^^^420^428^
[REPLACE]  Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ; 	[BUGGY] Elements elements = Collector . collect ( tag , this )  ; [CE] method collect in class Collector cannot be applied to given types ;  [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  [ATTENTION] Elements elements = Collector . collect ( tag , this ) ; if ( elements . size ( ) > 0 ) return elements . get ( 0 ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^423^^^^^420^428^
[REPLACE]  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ; 	[BUGGY] if ( elements . size ( ) * 2 > 0 ) return elements . get ( 0 ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; [ATTENTION] if ( elements . size ( ) *2 > 0 ) return elements . get ( 0 )  ;  else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^424^425^^^^420^428^
[ADD]  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  return  null;  } 	[BUGGY] return elements . get ( 0 ) ; return null ; [CE] illegal start of expression  [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; [ATTENTION] return elements . get ( 0 )  ; return null ;     	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^424^425^426^427^428^420^428^
[REPLACE]  return  null; 	[BUGGY] return this ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) > 0 ) return elements . get ( 0 ) ; else [ATTENTION] return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^427^^^^^420^428^
[REPLACE]  return  elements  .  get  (  0  )  ; 	[BUGGY] return elements . Elements ( 0 ) ; [CE] cannot find symbol  [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) > 0 ) [ATTENTION] return elements . Elements ( 0 )  ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^425^^^^^420^428^
[REPLACE]  return  elements  .  get  (  0  )  ; 	[BUGGY] return elements . Elements ( null )  ; [CE] cannot find symbol  [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) > 0 ) [ATTENTION] return elements . Elements ( null ) ; else return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^425^^^^^420^428^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  getElementById [TYPE] Element [PARAMETER] String id [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String id [TYPE] boolean false true [TYPE] Elements elements  [CONTEXT]  public Element getElementById ( String id ) { Validate . notEmpty ( id ) ;  Elements elements = Collector . collect ( new Evaluator . Id ( id ) , this ) ; if ( elements . size ( ) > 0 ) return elements . get ( 0 ) ; else [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^427^^^^^420^428^
[REPLACE]  Validate  .  notEmpty  (  className  )  ; 	[BUGGY] Validate . notNull ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementsByClass [TYPE] Elements [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByClass ( String className ) { [ATTENTION] Validate . notNull ( className )  ;  return Collector . collect ( new Evaluator . Class ( className ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^442^^^^^441^445^
[ADD]  Validate  .  notEmpty  (  className  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementsByClass [TYPE] Elements [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByClass ( String className ) { [ATTENTION]  return Collector . collect ( new Evaluator . Class ( className ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^442^^^^^441^445^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Class  (  className  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . Class ( className )  ; [CE] incompatible types  [METHOD]  getElementsByClass [TYPE] Elements [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByClass ( String className ) { Validate . notEmpty ( className ) ;  [ATTENTION] return new Evaluator . Class ( className ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^444^^^^^441^445^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getElementsByAttribute [TYPE] Elements [PARAMETER] String key [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttribute ( String key ) { [ATTENTION] Validate . notNull ( key )  ; key = key . trim ( ) . toLowerCase ( ) ;  return Collector . collect ( new Evaluator . Attribute ( key ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^454^^^^^453^458^
[REPLACE]  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] key =  null . trim ( ) . toLowerCase ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  getElementsByAttribute [TYPE] Elements [PARAMETER] String key [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttribute ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] key = null . trim ( )  . toLowerCase ( )  ;  return Collector . collect ( new Evaluator . Attribute ( key ) , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^455^^^^^453^458^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Attribute  (  key  )  ,  this  )  ; 	[BUGGY] return Collector . collect ( tag , this )  ; [CE] method collect in class Collector cannot be applied to given types ;  [METHOD]  getElementsByAttribute [TYPE] Elements [PARAMETER] String key [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttribute ( String key ) { Validate . notEmpty ( key ) ; key = key . trim ( ) . toLowerCase ( ) ;  [ATTENTION] return Collector . collect ( tag , this ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^457^^^^^453^458^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValue  (  key,  value  )  ,  this  )  ; 	[BUGGY] return Collector . collect ( new Evaluator . AttributeWithValueEnding ( key , valueSuffix ) , this ) ; [CE] cannot find symbol valueSuffix  [METHOD]  getElementsByAttributeValue [TYPE] Elements [PARAMETER] String key String value [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttributeValue ( String key , String value ) { [ATTENTION] return Collector . collect ( new Evaluator . AttributeWithValueEnding ( key , valueSuffix )  , this )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^468^^^^^467^469^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueNot  (  key,  value  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . AttributeWithValueNot ( key , value )  ; [CE] incompatible types  [METHOD]  getElementsByAttributeValueNot [TYPE] Elements [PARAMETER] String key String value [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttributeValueNot ( String key , String value ) { [ATTENTION] return new Evaluator . AttributeWithValueNot ( key , value ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^479^^^^^478^480^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueStarting  (  key,  valuePrefix  )  ,  this  )  ; 	[BUGGY] return  Evaluator . new AttributeWithValue ( key , value )  ; [CE] cannot find symbol Evaluator  [METHOD]  getElementsByAttributeValueStarting [TYPE] Elements [PARAMETER] String key String valuePrefix [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key valuePrefix [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttributeValueStarting ( String key , String valuePrefix ) { [ATTENTION] returnEvaluator . new AttributeWithValue ( key , value )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^490^^^^^489^491^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueEnding  (  key,  valueSuffix  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . AttributeWithValueEnding ( key , valueSuffix )  ; [CE] incompatible types  [METHOD]  getElementsByAttributeValueEnding [TYPE] Elements [PARAMETER] String key String valueSuffix [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key valueSuffix [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttributeValueEnding ( String key , String valueSuffix ) { [ATTENTION] return new Evaluator . AttributeWithValueEnding ( key , valueSuffix ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^501^^^^^500^502^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueContaining  (  key,  match  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . AttributeWithValueContaining ( key , match )  ; [CE] incompatible types  [METHOD]  getElementsByAttributeValueContaining [TYPE] Elements [PARAMETER] String key String match [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String key match [TYPE] boolean false true  [CONTEXT]  public Elements getElementsByAttributeValueContaining ( String key , String match ) { [ATTENTION] return new Evaluator . AttributeWithValueContaining ( key , match ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^512^^^^^511^513^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexLessThan  (  index  )  ,  this  )  ; 	[BUGGY] return Collector . collect ( tag , 1 )  ; [CE] method collect in class Collector cannot be applied to given types ;  [METHOD]  getElementsByIndexLessThan [TYPE] Elements [PARAMETER] int index [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] int index  [CONTEXT]  public Elements getElementsByIndexLessThan ( int index ) { [ATTENTION] return Collector . collect ( tag , 1 ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^521^^^^^520^522^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexGreaterThan  (  index  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . IndexGreaterThan ( index )  ; [CE] incompatible types  [METHOD]  getElementsByIndexGreaterThan [TYPE] Elements [PARAMETER] int index [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] int index  [CONTEXT]  public Elements getElementsByIndexGreaterThan ( int index ) { [ATTENTION] return new Evaluator . IndexGreaterThan ( index ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^530^^^^^529^531^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexEquals  (  index  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . IndexEquals ( index )  ; [CE] incompatible types  [METHOD]  getElementsByIndexEquals [TYPE] Elements [PARAMETER] int index [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] int index  [CONTEXT]  public Elements getElementsByIndexEquals ( int index ) { [ATTENTION] return new Evaluator . IndexEquals ( index ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^539^^^^^538^540^
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AllElements  (  )  ,  this  )  ; 	[BUGGY] return  new Evaluator . AllElements ( )  ; [CE] incompatible types  [METHOD]  getAllElements [TYPE] Elements [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Elements getAllElements ( ) { [ATTENTION] return new Evaluator . AllElements ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^548^^^^^547^549^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder accum = new StringBuilder ( ) ; [CE] cannot find symbol sb  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder sb  [CONTEXT]  public String text ( ) { [ATTENTION] StringBuilder accum = new StringBuilder ( )  ; text ( sb ) ; return sb . toString ( ) . trim ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^557^^^^^556^560^
[REPLACE]  text  (  sb  )  ; 	[BUGGY] append ( html ) ; [CE] cannot find symbol html  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder sb  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION] append ( html )  ; return sb . toString ( ) . trim ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^558^^^^^556^560^
[ADD]  text  (  sb  )  ;  return  sb  .  toString  (  )    .  trim  (  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder sb  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^558^559^^^^556^560^
[REPLACE]  return  sb  .  toString  (  )    .  trim  (  )  ; 	[BUGGY] return accum . toString ( ) . trim ( ) ; [CE] cannot find symbol accum  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder sb  [CONTEXT]  public String text ( ) { StringBuilder sb = new StringBuilder ( ) ; text ( sb ) ; [ATTENTION] return accum . toString ( )  . trim ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^559^^^^^556^560^
[REPLACE]  if  (  child  instanceof  TextNode  )  { 	[BUGGY] if ( ! child instanceof TextNode ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { [ATTENTION] if ( ! child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^564^^^^^562^582^
[ADD]  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =  (  TextNode  )  child;  String  text  =  textNode  .  getWholeText  (  )  ; 	[BUGGY] TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ; [CE]  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { [ATTENTION] TextNode textNode = ( TextNode ) child ; String text = textNode . getWholeText ( )  ;   if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^564^565^566^^^562^582^
[REPLACE]  }  else  if  (  child  instanceof  Element  )  { 	[BUGGY] else if ( ! child instanceof Element ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  [ATTENTION] } else if ( ! child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^575^^^^^562^582^
[REMOVE]   	[BUGGY] if ( childNode instanceof DataNode ) {   DataNode data =  ( ( DataNode )  ( childNode ) ) ;   sb . append ( data . getWholeData ( ) ) ; }else   if ( childNode instanceof Element ) {     Element element =  ( ( Element )  ( childNode ) ) ;     String elementData = element . data ( ) ;     sb . append ( elementData ) ;   }[CE] cannot find symbol childNode  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  [ATTENTION] } else if ( child instanceof Element ) { if ( childNode instanceof DataNode ) { DataNode data = ( ( DataNode )  ( childNode ) )  ; sb . append ( data . getWholeData ( ) )  ; }else if ( childNode instanceof Element ) { Element element = ( ( Element )  ( childNode ) )  ; String elementData = element . data ( )  ; sb . append ( elementData )  ; }Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^575^^^^^562^582^
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ; 	[BUGGY] if ( accum . length ( ) + 1 > 0 && element . isBlock ( ) && !TextNode . normaliseWhitespace ( text )  ) accum . append (   "   " ) ; [CE] cannot find symbol text  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; [ATTENTION] if ( accum . length ( ) + 1 > 0 && element . isBlock ( ) && !TextNode . normaliseWhitespace ( text )  ) accum . append (   "   " )  ;  element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^577^578^^^^562^582^
[ADD]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ;  element  .  text  (  accum  )  ;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; [ATTENTION]   } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^577^578^579^580^^562^582^
[REPLACE]  accum  .  append  (    "    "  )  ; 	[BUGGY] accum . append (   " />  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) [ATTENTION] accum . append (   " />  " )  ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^578^^^^^562^582^
[REPLACE]  Element  element  =  (  Element  )  child; 	[BUGGY] Element element =  ( Element ) o ; [CE] cannot find symbol o  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { [ATTENTION] Element element = ( Element ) o ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^576^^^^^562^582^
[ADD]  Element  element  =  (  Element  )  child; 	[BUGGY] [CE] cannot find symbol element  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { [ATTENTION] if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^576^^^^^562^582^
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ; 	[BUGGY] if ( accum . size ( ) > 0 && element . child ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; [CE] cannot find symbol  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; [ATTENTION] if ( accum . size ( ) > 0 && element . child ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " )  ;  element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^577^578^^^^562^582^
[REPLACE]  if  (  !preserveWhitespace  (  )  )  { 	[BUGGY] if ( preserveWhitespace ( ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  [ATTENTION] if ( preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^568^^^^^562^582^
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ; 	[BUGGY] if ( TextNode . normaliseWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; [CE] method normaliseWhitespace in class TextNode cannot be applied to given types ;  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; [ATTENTION] if ( TextNode . normaliseWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text )  ;  } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^570^571^^^^562^582^
[REPLACE]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ; 	[BUGGY] text = TextNode . normaliseWhitespace ( text ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) [ATTENTION] text = TextNode . normaliseWhitespace ( text )  ;  ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^571^^^^^562^582^
[ADD]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) [ATTENTION] } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^571^^^^^562^582^
[REPLACE]  text  =  TextNode  .  normaliseWhitespace  (  text  )  ; 	[BUGGY] text = TextNode . stripLeadingWhitespace ( text ) ;  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { [ATTENTION] text = TextNode . stripLeadingWhitespace ( text )  ;  ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^569^^^^^562^582^
[ADD]  text  =  TextNode  .  normaliseWhitespace  (  text  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { [ATTENTION] if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^569^^^^^562^582^
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ; 	[BUGGY] if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . normaliseWhitespace ( text )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; [ATTENTION] if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . normaliseWhitespace ( text ) ;  } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^570^571^^^^562^582^
[REPLACE]  TextNode  textNode  =  (  TextNode  )  child; 	[BUGGY] TextNode textNode = new TextNode ( text , baseUri ) ; [CE] cannot find symbol text  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { [ATTENTION] TextNode textNode = new TextNode ( text , baseUri )  ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^565^^^^^562^582^
[REPLACE]  String  text  =  textNode  .  getWholeText  (  )  ; 	[BUGGY] String text = textNode . isBlank ( ) ; [CE] incompatible types  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; [ATTENTION] String text = textNode . isBlank ( )  ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^566^^^^^562^582^
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ; 	[BUGGY] if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . normaliseWhitespace ( text ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; [ATTENTION] if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . normaliseWhitespace ( text )  ;  } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^570^571^^^^562^582^
[REPLACE]  }  else  if  (  child  instanceof  Element  )  { 	[BUGGY]  if ( ! child instanceof Element ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  [ATTENTION] }if ( ! child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^575^^^^^562^582^
[ADD]  else  if  (  child  instanceof  Element  )  {  Element  element  =  (  Element  )  child;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ;  element  .  text  (  accum  )  ; 	[BUGGY]  Element element =  ( Element ) child ; accum . append (   "   " ) ; element . text ( accum ) ; [CE] class , interface , or enum expected  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  [ATTENTION] } Element element = ( Element ) child ; accum . append (   "   " )  ; element . text ( accum )  ;   } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^575^576^577^578^579^562^582^
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ; 	[BUGGY] if ( accum . size ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; [CE] cannot find symbol  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; [ATTENTION] if ( accum . size ( ) > 0&& element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " )  ;  element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^577^578^^^^562^582^
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (    "    "  )  ; 	[BUGGY] if ( accum . length ( ) / 2 > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; [ATTENTION] if ( accum . length ( ) /2 > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " )  ;  element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^577^578^^^^562^582^
[REPLACE]  for  (  Node  child  :  childNodes  )  { 	[BUGGY] List<Node> nodes = fragment . childNodes ( ) ; [CE] class , interface , or enum expected  [METHOD]  text [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node child [TYPE] Element element [TYPE] TextNode textNode [TYPE] Tag tag [TYPE] String text  [CONTEXT]  private void text ( StringBuilder accum ) { [ATTENTION] List<Node> nodes = fragment . childNodes ( )  ; if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; String text = textNode . getWholeText ( ) ;  if ( !preserveWhitespace ( ) ) { text = TextNode . normaliseWhitespace ( text ) ; if ( TextNode . lastCharIsWhitespace ( accum ) ) text = TextNode . stripLeadingWhitespace ( text ) ; } accum . append ( text ) ;  } else if ( child instanceof Element ) { Element element =  ( Element ) child ; if ( accum . length ( ) > 0 && element . isBlock ( ) && !TextNode . lastCharIsWhitespace ( accum ) ) accum . append (   "   " ) ; element . text ( accum ) ; } } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^563^^^^^562^582^
[REPLACE]  return  tag  .  preserveWhitespace  (  )  ||  parent  (  )  !=  null  &&  parent  (  )    .  preserveWhitespace  (  )  ; 	[BUGGY] return tag . prepend ( ) || parent ( ) ! = null && parent ( ) . preserveWhitespace ( ) ; [CE] cannot find symbol  [METHOD]  preserveWhitespace [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  boolean preserveWhitespace ( ) { [ATTENTION] return tag . prepend ( ) || parent ( ) ! = null && parent ( )  . preserveWhitespace ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^585^^^^^584^586^
[REPLACE]  Validate  .  notNull  (  text  )  ; 	[BUGGY] Validate . notEmpty ( text ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element text ( String text ) { [ATTENTION] Validate . notEmpty ( text )  ;  empty ( ) ; TextNode textNode = new TextNode ( text , baseUri ) ; appendChild ( textNode ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^594^^^^^593^601^
[REPLACE]  empty  (  )  ; 	[BUGGY] append ( html ) ; [CE] cannot find symbol html  [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element text ( String text ) { Validate . notNull ( text ) ;  [ATTENTION] append ( html )  ; TextNode textNode = new TextNode ( text , baseUri ) ; appendChild ( textNode ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^596^^^^^593^601^
[REPLACE]  TextNode  textNode  =  new  TextNode  (  text,  baseUri  )  ; 	[BUGGY] Node node = nodes . get ( i ) ; [CE] cannot find symbol i  [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element text ( String text ) { Validate . notNull ( text ) ;  empty ( ) ; [ATTENTION] Node node = nodes . get ( i )  ; appendChild ( textNode ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^597^^^^^593^601^
[REPLACE]  appendChild  (  textNode  )  ; 	[BUGGY] prependChild ( node ) ; [CE] cannot find symbol node  [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element text ( String text ) { Validate . notNull ( text ) ;  empty ( ) ; TextNode textNode = new TextNode ( text , baseUri ) ; [ATTENTION] prependChild ( node )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^598^^^^^593^601^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] Element [PARAMETER] String text [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] String text [TYPE] boolean false true  [CONTEXT]  public Element text ( String text ) { Validate . notNull ( text ) ;  empty ( ) ; TextNode textNode = new TextNode ( text , baseUri ) ; appendChild ( textNode ) ;  [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^600^^^^^593^601^
[REPLACE]  if  (  child  instanceof  TextNode  )  { 	[BUGGY] if ( ! child instanceof TextNode ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { [ATTENTION] if ( ! child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^609^^^^^607^620^
[ADD]  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =  (  TextNode  )  child;  if  (  !textNode  .  isBlank  (  )  )  return  true; 	[BUGGY] [CE]  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { [ATTENTION]   } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^609^610^611^612^^607^620^
[REPLACE]  }  else  if  (  child  instanceof  Element  )  { 	[BUGGY]  else {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; [ATTENTION] }else { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^613^^^^^607^620^
[REPLACE]  if  (  el  .  hasText  (  )  )  return  true; 	[BUGGY] if ( el . text ( ) ) return false ; [CE] incompatible types  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; [ATTENTION] if ( el . text ( ) ) return false ;  } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^615^616^^^^607^620^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) [ATTENTION] return false ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^616^^^^^607^620^
[REPLACE]  Element  el  =  (  Element  )  child; 	[BUGGY] Element element =  ( Element ) child ; [CE] cannot find symbol el  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { [ATTENTION] Element element = ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^614^^^^^607^620^
[REPLACE]  if  (  el  .  hasText  (  )  )  return  true; 	[BUGGY] if ( el . hasText ( ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; [ATTENTION] if ( el . hasText ( ) ) return false ;  } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^615^616^^^^607^620^
[REPLACE]  if  (  !textNode  .  isBlank  (  )  )  return  true; 	[BUGGY] if ( !textNode . normaliseWhitespace ( null )  ) return false ; [CE] bad operand type String for unary operator '!'  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; [ATTENTION] if ( !textNode . normaliseWhitespace ( null )  ) return false ;  } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^611^612^^^^607^620^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) [ATTENTION] return false ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^612^^^^^607^620^
[REPLACE]  TextNode  textNode  =  (  TextNode  )  child; 	[BUGGY] TextNode textNode = new TextNode ( text , baseUri ) ; [CE] cannot find symbol text  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { [ATTENTION] TextNode textNode = new TextNode ( text , baseUri )  ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^610^^^^^607^620^
[ADD]  TextNode  textNode  =  (  TextNode  )  child; 	[BUGGY] [CE] cannot find symbol textNode  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { [ATTENTION] if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^610^^^^^607^620^
[REPLACE]  if  (  !textNode  .  isBlank  (  )  )  return  true; 	[BUGGY] if ( !textNode . isBlank ( ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; [ATTENTION] if ( !textNode . isBlank ( ) ) return false ;  } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^611^612^^^^607^620^
[ADD]  if  (  !textNode  .  isBlank  (  )  )  return  true;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =  (  Element  )  child;  if  (  el  .  hasText  (  )  ) 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; [ATTENTION]   return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^611^612^613^614^615^607^620^
[ADD]  if  (  el  .  hasText  (  )  )  return  true;  } 	[BUGGY] return true ; [CE] illegal start of expression  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; [ATTENTION] return true ;  } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^615^616^617^^^607^620^
[REPLACE]  for  (  Node  child:  childNodes  )  { 	[BUGGY] List<Node> nodes = fragment . childNodes ( ) ; [CE] illegal start of type  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { [ATTENTION] List<Node> nodes = fragment . childNodes ( )  ; if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^608^^^^^607^620^
[ADD]  Element  el  =  (  Element  )  child; 	[BUGGY] [CE] cannot find symbol el  [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { [ATTENTION] if ( el . hasText ( ) ) return true ; } } return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^614^^^^^607^620^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hasText [TYPE] boolean [PARAMETER] [CLASS] Element  [TYPE] TextNode textNode [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true [TYPE] Node child [TYPE] Element el  [CONTEXT]  public boolean hasText ( ) { for ( Node child: childNodes ) { if ( child instanceof TextNode ) { TextNode textNode =  ( TextNode ) child ; if ( !textNode . isBlank ( ) ) return true ; } else if ( child instanceof Element ) { Element el =  ( Element ) child ; if ( el . hasText ( ) ) return true ; } } [ATTENTION] return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^619^^^^^607^620^
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder accum = new StringBuilder ( ) ; [CE] cannot find symbol sb  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { [ATTENTION] StringBuilder accum = new StringBuilder ( )  ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^627^^^^^626^640^
[REPLACE]  if  (  childNode  instanceof  DataNode  )  { 	[BUGGY] if ( ! childNode instanceof DataNode ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { [ATTENTION] if ( ! childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^630^^^^^626^640^
[ADD]  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =  (  DataNode  )  childNode;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =  (  Element  )  childNode; 	[BUGGY] DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; Element element =  ( Element ) childNode ; [CE] illegal start of type  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { [ATTENTION] DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) )  ; Element element = ( Element ) childNode ;   String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^630^631^632^633^634^626^640^
[REPLACE]  }  else  if  (  childNode  instanceof  Element  )  { 	[BUGGY]  else {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; [ATTENTION] }else { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^633^^^^^626^640^
[REPLACE]  Element  element  =  (  Element  )  childNode; 	[BUGGY] Element element =  ( Element ) child ; [CE] cannot find symbol child  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { [ATTENTION] Element element = ( Element ) child ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^634^^^^^626^640^
[REPLACE]  String  elementData  =  element  .  data  (  )  ; 	[BUGGY] String elementData = element . tag ( ) ; [CE] incompatible types  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; [ATTENTION] String elementData = element . tag ( )  ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^635^^^^^626^640^
[REPLACE]  DataNode  data  =  (  DataNode  )  childNode; 	[BUGGY] TextNode textNode =  ( TextNode ) child ; [CE] cannot find symbol child  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { [ATTENTION] TextNode textNode = ( TextNode ) child ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^631^^^^^626^640^
[ADD]  DataNode  data  =  (  DataNode  )  childNode; 	[BUGGY] [CE] cannot find symbol data  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { [ATTENTION] sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^631^^^^^626^640^
[REPLACE]  }  else  if  (  childNode  instanceof  Element  )  { 	[BUGGY]  if ( ! childNode instanceof Element ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; [ATTENTION] }if ( ! childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^633^^^^^626^640^
[ADD]  else  if  (  childNode  instanceof  Element  )  {  Element  element  =  (  Element  )  childNode;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  } 	[BUGGY]  Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; [ATTENTION] } Element element = ( Element ) childNode ; String elementData = element . data ( )  ; sb . append ( elementData )  ;   } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^633^634^635^636^637^626^640^
[ADD]  Element  element  =  (  Element  )  childNode;  String  elementData  =  element  .  data  (  )  ; 	[BUGGY] String elementData = element . data ( ) ; [CE] cannot find symbol element  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { [ATTENTION] String elementData = element . data ( )  ;  sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^634^635^^^^626^640^
[REPLACE]  for  (  Node  childNode  :  childNodes  )  { 	[BUGGY] Node node = nodes . get ( i ) ; [CE] illegal start of type  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  [ATTENTION] Node node = nodes . get ( i )  ; if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^629^^^^^626^640^
[REPLACE]  String  elementData  =  element  .  data  (  )  ; 	[BUGGY] String elementData = element . hasText ( )  ; [CE] incompatible types  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; [ATTENTION] String elementData = element . hasText ( ) ; sb . append ( elementData ) ; } } return sb . toString ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^635^^^^^626^640^
[REPLACE]  return  sb  .  toString  (  )  ; 	[BUGGY] return sb . StringBuilder ( )  ; [CE] cannot find symbol  [METHOD]  data [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] boolean false true [TYPE] StringBuilder sb [TYPE] DataNode data [TYPE] Node childNode [TYPE] Element element [TYPE] Tag tag [TYPE] String elementData  [CONTEXT]  public String data ( ) { StringBuilder sb = new StringBuilder ( ) ;  for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data =  ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Element ) { Element element =  ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } } [ATTENTION] return sb . StringBuilder ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^639^^^^^626^640^
[REPLACE]  return  attributes  .  hasKey  (    "class  "  )  ?  attributes  .  get  (    "class  "  )  :    "  "; 	[BUGGY] return attributes . hasKey (   "class  " ) ? attributes . put (   "class  " ) :   "  " ; [CE] no suitable method found for put(String)  [METHOD]  className [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String className ( ) { [ATTENTION] return attributes . hasKey (   "class  " ) ? attributes . put (   "class  " ) :   "  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^648^^^^^647^649^
[REPLACE]  if  (  classNames  ==  null  )  { 	[BUGGY] if ( classNames ! = null ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { [ATTENTION] if ( classNames ! = null ) { String[] names = className ( ) . split (   "\\s+  " ) ; classNames = new LinkedHashSet<String> ( Arrays . asList ( names ) ) ; } return classNames ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^658^^^^^657^663^
[REPLACE]  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ; 	[BUGGY] classNames =  new LinkedHashSet<String> ( Arrays . asList ( null ) ) ; [CE] no suitable constructor found for LinkedHashSet(List<Object>)  [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { if ( classNames = = null ) { String[] names = className ( ) . split (   "\\s+  " ) ; [ATTENTION] classNames = new LinkedHashSet<String> ( Arrays . asList ( null ) )  ; } return classNames ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^660^^^^^657^663^
[ADD]  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { if ( classNames = = null ) { String[] names = className ( ) . split (   "\\s+  " ) ; [ATTENTION] } return classNames ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^660^^^^^657^663^
[REPLACE]  String[]  names  =  className  (  )    .  split  (    "\\s+  "  )  ; 	[BUGGY] String[] names = className ( )  . trim ( )  ; [CE] incompatible types  [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { if ( classNames = = null ) { [ATTENTION] String[] names = className ( ) . trim ( ) ; classNames = new LinkedHashSet<String> ( Arrays . asList ( names ) ) ; } return classNames ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^659^^^^^657^663^
[ADD]  String[]  names  =  className  (  )    .  split  (    "\\s+  "  )  ;  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { if ( classNames = = null ) { [ATTENTION]  } return classNames ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^659^660^^^^657^663^
[REPLACE]  return  classNames; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  classNames [TYPE] Set [PARAMETER] [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String[] names [TYPE] boolean false true  [CONTEXT]  public Set<String> classNames ( ) { if ( classNames = = null ) { String[] names = className ( ) . split (   "\\s+  " ) ; classNames = new LinkedHashSet<String> ( Arrays . asList ( names ) ) ; } [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^662^^^^^657^663^
[REPLACE]  Validate  .  notNull  (  classNames  )  ; 	[BUGGY] Validate . notNull ( this ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  classNames [TYPE] Element [PARAMETER] String> classNames [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element classNames ( Set<String> classNames ) { [ATTENTION] Validate . notNull ( this )  ; attributes . put (   "class  " , StringUtils . join ( classNames ,   "   " ) ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^671^^^^^670^674^
[REPLACE]  attributes  .  put  (    "class  ",  StringUtils  .  join  (  classNames,    "    "  )  )  ; 	[BUGGY] attributes . put (   "class  " , StringUtils . join ( 0 ,   "   " ) ) ; [CE] no suitable method found for join(int , String)  [METHOD]  classNames [TYPE] Element [PARAMETER] String> classNames [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element classNames ( Set<String> classNames ) { Validate . notNull ( classNames ) ; [ATTENTION] attributes . put (   "class  " , StringUtils . join ( 0 ,   "   " ) )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^672^^^^^670^674^
[REMOVE]   	[BUGGY] . append ( attributes . html ( ) ) ; [CE] illegal start of expression  [METHOD]  classNames [TYPE] Element [PARAMETER] String> classNames [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element classNames ( Set<String> classNames ) { Validate . notNull ( classNames ) ; [ATTENTION] attributes . put (   "class  " , StringUtils . join ( classNames ,   "   " ) ) ;  . append ( attributes . html ( ) )  ; return this ;   	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^672^^^^^670^674^
[REPLACE]  attributes  .  put  (    "class  ",  StringUtils  .  join  (  classNames,    "    "  )  )  ; 	[BUGGY] attributes . put (   "class  " , StringUtils . join ( true ,   "   " ) ) ; [CE] no suitable method found for join(boolean , String)  [METHOD]  classNames [TYPE] Element [PARAMETER] String> classNames [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element classNames ( Set<String> classNames ) { Validate . notNull ( classNames ) ; [ATTENTION] attributes . put (   "class  " , StringUtils . join ( true ,   "   " ) )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^672^^^^^670^674^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  classNames [TYPE] Element [PARAMETER] String> classNames [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public Element classNames ( Set<String> classNames ) { Validate . notNull ( classNames ) ; attributes . put (   "class  " , StringUtils . join ( classNames ,   "   " ) ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^673^^^^^670^674^
[REPLACE]  return  classNames  (  )    .  contains  (  className  )  ; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  hasClass [TYPE] boolean [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public boolean hasClass ( String className ) { [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^682^^^^^681^683^
[REPLACE]  Validate  .  notNull  (  className  )  ; 	[BUGGY] Validate . notEmpty ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element addClass ( String className ) { [ATTENTION] Validate . notEmpty ( className )  ;  Set<String> classes = classNames ( ) ; classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^691^^^^^690^698^
[REPLACE]  Set<String>  classes  =  classNames  (  )  ; 	[BUGGY] List<Element> siblings = parent ( ) . children ( ) ; [CE] cannot find symbol classes  [METHOD]  addClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element addClass ( String className ) { Validate . notNull ( className ) ;  [ATTENTION] List<Element> siblings = parent ( )  . children ( )  ; classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^693^^^^^690^698^
[REPLACE]  classes  .  add  (  className  )  ; 	[BUGGY] classes . contains ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element addClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; [ATTENTION] classes . contains ( className )  ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^694^^^^^690^698^
[REPLACE]  classNames  (  classes  )  ; 	[BUGGY] classNames ( true ) ; [CE] no suitable method found for classNames(boolean)  [METHOD]  addClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element addClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; classes . add ( className ) ; [ATTENTION] classNames ( true )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^695^^^^^690^698^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  addClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element addClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; classes . add ( className ) ; classNames ( classes ) ;  [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^697^^^^^690^698^
[REPLACE]  Validate  .  notNull  (  className  )  ; 	[BUGGY] Validate . notEmpty ( className )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element removeClass ( String className ) { [ATTENTION] Validate . notEmpty ( className ) ;  Set<String> classes = classNames ( ) ; classes . remove ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^706^^^^^705^713^
[REPLACE]  Set<String>  classes  =  classNames  (  )  ; 	[BUGGY] List<Element> siblings = parent ( ) . children ( ) ; [CE] cannot find symbol classes  [METHOD]  removeClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element removeClass ( String className ) { Validate . notNull ( className ) ;  [ATTENTION] List<Element> siblings = parent ( )  . children ( )  ; classes . remove ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^708^^^^^705^713^
[REPLACE]  classes  .  remove  (  className  )  ; 	[BUGGY] classes . contains ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element removeClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; [ATTENTION] classes . contains ( className )  ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^709^^^^^705^713^
[REPLACE]  classNames  (  classes  )  ; 	[BUGGY] classNames ( false ) ; [CE] no suitable method found for classNames(boolean)  [METHOD]  removeClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element removeClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; classes . remove ( className ) ; [ATTENTION] classNames ( false )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^710^^^^^705^713^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  removeClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element removeClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; classes . remove ( className ) ; classNames ( classes ) ;  [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^712^^^^^705^713^
[REPLACE]  Validate  .  notNull  (  className  )  ; 	[BUGGY] Validate . notEmpty ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { [ATTENTION] Validate . notEmpty ( className )  ;  Set<String> classes = classNames ( ) ; if ( classes . contains ( className ) ) classes . remove ( className ) ; else classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^721^^^^^720^731^
[REPLACE]  Set<String>  classes  =  classNames  (  )  ; 	[BUGGY] List<Element> siblings = parent ( ) . children ( ) ; [CE] cannot find symbol classes  [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  [ATTENTION] List<Element> siblings = parent ( )  . children ( )  ; if ( classes . contains ( className ) ) classes . remove ( className ) ; else classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^723^^^^^720^731^
[REPLACE]  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ; 	[BUGGY] if ( classes . contains ( className ) ) classes . contains ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; [ATTENTION] if ( classes . contains ( className ) ) classes . contains ( className )  ;  else classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^724^725^^^^720^731^
[REPLACE]  classes  .  add  (  className  )  ; 	[BUGGY] classes . contains ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; if ( classes . contains ( className ) ) classes . remove ( className ) ; else [ATTENTION] classes . contains ( className )  ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^727^^^^^720^731^
[REPLACE]  classes  .  remove  (  className  )  ; 	[BUGGY] classes . contains ( className ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; if ( classes . contains ( className ) ) [ATTENTION] classes . contains ( className )  ; else classes . add ( className ) ; classNames ( classes ) ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^725^^^^^720^731^
[REPLACE]  classNames  (  classes  )  ; 	[BUGGY] classNames ( null ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; if ( classes . contains ( className ) ) classes . remove ( className ) ; else classes . add ( className ) ; [ATTENTION] classNames ( null )  ;  return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^728^^^^^720^731^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toggleClass [TYPE] Element [PARAMETER] String className [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String className [TYPE] boolean false true  [CONTEXT]  public Element toggleClass ( String className ) { Validate . notNull ( className ) ;  Set<String> classes = classNames ( ) ; if ( classes . contains ( className ) ) classes . remove ( className ) ; else classes . add ( className ) ; classNames ( classes ) ;  [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^730^^^^^720^731^
[REPLACE]  if  (  tagName  (  )    .  equals  (    "textarea  "  )  )  return  text  (  )  ; 	[BUGGY] if ( tagName ( ) . split (   "textarea  " ) ) return text ( ) ; [CE] incompatible types  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String val ( ) { [ATTENTION] if ( tagName ( )  . split (   "textarea  " ) ) return text ( )  ;  else return attr (   "value  " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^738^739^^^^737^742^
[ADD]  if  (  tagName  (  )    .  equals  (    "textarea  "  )  )  return  text  (  )  ;  else  return  attr  (    "value  "  )  ;  } 	[BUGGY] return text ( ) ; return attr (   "value  " ) ; [CE] illegal start of expression  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String val ( ) { [ATTENTION] return text ( )  ; return attr (   "value  " )  ;     	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^738^739^740^741^742^737^742^
[REPLACE]  return  attr  (    "value  "  )  ; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String val ( ) { if ( tagName ( ) . equals (   "textarea  " ) ) return text ( ) ; else [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^741^^^^^737^742^
[REPLACE]  return  text  (  )  ; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  val [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String val ( ) { if ( tagName ( ) . equals (   "textarea  " ) ) [ATTENTION] return elements . get ( 0 )  ; else return attr (   "value  " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^739^^^^^737^742^
[REPLACE]  if  (  tagName  (  )    .  equals  (    "textarea  "  )  )  text  (  value  )  ; 	[BUGGY] if ( tagName ( ) . equals (   "textarea  " ) ) return text ( ) ; [CE] incompatible types  [METHOD]  val [TYPE] Element [PARAMETER] String value [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public Element val ( String value ) { [ATTENTION] if ( tagName ( )  . equals (   "textarea  " ) ) return text ( )  ;  else attr (   "value  " , value ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^750^751^^^^749^755^
[ADD]  if  (  tagName  (  )    .  equals  (    "textarea  "  )  )  text  (  value  )  ;  else  attr  (    "value  ",  value  )  ;  return  this; 	[BUGGY] [CE] missing return statement  [METHOD]  val [TYPE] Element [PARAMETER] String value [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public Element val ( String value ) { [ATTENTION]   }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^750^751^752^753^754^749^755^
[REPLACE]  attr  (    "value  ",  value  )  ; 	[BUGGY] text ( value ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  val [TYPE] Element [PARAMETER] String value [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public Element val ( String value ) { if ( tagName ( ) . equals (   "textarea  " ) ) text ( value ) ; else [ATTENTION] text ( value )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^753^^^^^749^755^
[REPLACE]  text  (  value  )  ; 	[BUGGY] append ( html ) ; [CE] cannot find symbol html  [METHOD]  val [TYPE] Element [PARAMETER] String value [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public Element val ( String value ) { if ( tagName ( ) . equals (   "textarea  " ) ) [ATTENTION] append ( html )  ; else attr (   "value  " , value ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^751^^^^^749^755^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  val [TYPE] Element [PARAMETER] String value [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String value [TYPE] boolean false true  [CONTEXT]  public Element val ( String value ) { if ( tagName ( ) . equals (   "textarea  " ) ) text ( value ) ; else attr (   "value  " , value ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^754^^^^^749^755^
[REPLACE]  if  (  isBlock  (  )  ||  (  parent  (  )  !=  null  &&  parent  (  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  ==  0  )  )  indent  (  accum  )  ; 	[BUGGY] if (false ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( ) ! = 0 ) ) indent ( accum ) ; [CE] ')' expected  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] if ( false ( ) || ( parent ( ) ! = null && parent ( )  . tag ( )  . canContainBlock ( ) && siblingIndex ( ) ! = 0 ) ) indent ( accum )  ;  accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^758^759^^^^757^773^
[ADD]  if  (  isBlock  (  )  ||  (  parent  (  )  !=  null  &&  parent  (  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  ==  0  )  )  indent  (  accum  )  ;  accum    .  append  (    "<  "  )    .  append  (  tagName  (  )  ) 	[BUGGY] indent ( accum ) ; [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] indent ( accum )  ;    . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^758^759^760^761^762^757^773^
[REPLACE]  indent  (  accum  )  ; 	[BUGGY] append ( html ) ; [CE] cannot find symbol html  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) [ATTENTION] append ( html )  ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^759^^^^^757^773^
[REPLACE]  accum    .  append  (    "<  "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ; 	[BUGGY] accum . append (   "<  " ) . append ( tagName ( ) ) . append ( attributes . html ( )  ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; [ATTENTION] accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( )  )  ;   if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^760^761^762^763^^757^773^
[ADD]  accum    .  append  (    "<  "  )    .  append  (  tagName  (  )  ) 	[BUGGY] [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; [ATTENTION]   . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^760^761^762^^^757^773^
[REPLACE]    .  append  (  attributes  .  html  (  )  )  ; 	[BUGGY] . append ( attributes . html ( )  ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) ) [ATTENTION] . append ( attributes . html ( )  )  ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^763^^^^^757^773^
[REPLACE]  if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  { 	[BUGGY] if ( childNodes . isEmpty ( ) ) {[FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  [ATTENTION] if ( childNodes . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^765^^^^^757^773^
[ADD]  if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (    "  />  "  )  ;  }  else  {  accum  .  append  (    ">  "  )  ;  html  (  accum  )  ; 	[BUGGY] accum . append (   " />  " ) ; accum . append (   ">  " ) ; html ( accum ) ; [CE] class , interface , or enum expected  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  [ATTENTION] accum . append (   " />  " )  ; accum . append (   ">  " )  ; html ( accum )  ;   if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^765^766^767^768^769^757^773^
[REPLACE]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ; 	[BUGGY] if ( parent ( )  = = null ) return 0 ; return indexInList ( this , parent ( ) . children ( ) ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; [ATTENTION] if ( parent ( ) = = null ) return 0 ; return indexInList ( this , parent ( )  . children ( ) )  ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^770^^^^^757^773^
[ADD]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (    "</  "  )    .  append  (  tagName  (  )  )    .  append  (    ">  "  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^770^771^772^^^757^773^
[ADD]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (    "</  "  )    .  append  (  tagName  (  )  )    .  append  (    ">  "  )  ;  } 	[BUGGY] accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; [ATTENTION] accum . append (   "</  " )  . append ( tagName ( ) )  . append (   ">  " )  ;  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^770^771^772^^^757^773^
[REPLACE]  accum  .  append  (    "  />  "  )  ; 	[BUGGY] accum . append (   ">  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { [ATTENTION] accum . append (   ">  " )  ; } else { accum . append (   ">  " ) ; html ( accum ) ; if ( tag . canContainBlock ( ) ) indent ( accum ) ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^766^^^^^757^773^
[REPLACE]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ; 	[BUGGY] if ( tag . isBlock ( ) ) indent ( accum ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  void outerHtml ( StringBuilder accum ) { if ( isBlock ( ) || ( parent ( ) ! = null && parent ( ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) ) indent ( accum ) ; accum . append (   "<  " )  . append ( tagName ( ) )  . append ( attributes . html ( ) ) ;  if ( childNodes . isEmpty ( ) && tag . isEmpty ( ) ) { accum . append (   " />  " ) ; } else { accum . append (   ">  " ) ; html ( accum ) ; [ATTENTION] if ( tag . isBlock ( ) ) indent ( accum )  ; accum . append (   "</  " ) . append ( tagName ( ) ) . append (   ">  " ) ; } }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^770^^^^^757^773^
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ; 	[BUGGY] StringBuilder sb = new StringBuilder ( ) ; [CE] cannot find symbol accum  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  public String html ( ) { [ATTENTION] StringBuilder sb = new StringBuilder ( )  ; html ( accum ) ; return accum . toString ( ) . trim ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^783^^^^^782^786^
[REPLACE]  html  (  accum  )  ; 	[BUGGY] append ( html ) ; [CE] cannot find symbol html  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; [ATTENTION] append ( html )  ; return accum . toString ( ) . trim ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^784^^^^^782^786^
[REPLACE]  return  accum  .  toString  (  )    .  trim  (  )  ; 	[BUGGY] return accum . StringBuilder ( )  . trim ( ) ; [CE] cannot find symbol  [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum  [CONTEXT]  public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; [ATTENTION] return accum . StringBuilder ( ) . trim ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^785^^^^^782^786^
[ADD]  for  (  Node  node  :  childNodes  )  node  .  outerHtml  (  accum  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  html [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] StringBuilder accum [TYPE] Node node  [CONTEXT]  private void html ( StringBuilder accum ) { [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^789^790^791^^^788^791^
[REPLACE]  empty  (  )  ; 	[BUGGY] append ( html ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  html [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true  [CONTEXT]  public Element html ( String html ) { [ATTENTION] append ( html )  ; append ( html ) ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^800^^^^^799^803^
[REPLACE]  append  (  html  )  ; 	[BUGGY] prependChild ( node ) ; [CE] cannot find symbol node  [METHOD]  html [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true  [CONTEXT]  public Element html ( String html ) { empty ( ) ; [ATTENTION] prependChild ( node )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^801^^^^^799^803^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  html [TYPE] Element [PARAMETER] String html [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] String html [TYPE] boolean false true  [CONTEXT]  public Element html ( String html ) { empty ( ) ; append ( html ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^802^^^^^799^803^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^806^^^^^805^807^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this ! =  o ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this! = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^811^^^^^810^820^
[ADD]  if  (  this  ==  o  )  return  true;  if  (  !  (  o  instanceof  Element  )  )  return  false;  if  (  !super  .  equals  (  o  )  )  return  false;  Element  element  =  (  Element  )  o; 	[BUGGY] [CE] cannot find symbol element  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION]    if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^811^812^813^^815^810^820^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this = = o ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this = = o ) return false ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^811^^^^^810^820^
[REPLACE]  if  (  !  (  o  instanceof  Element  )  )  return  false; 	[BUGGY] if ( ! ! ( o instanceof Element ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^812^^^^^810^820^
[ADD]  if  (  !  (  o  instanceof  Element  )  )  return  false;  if  (  !super  .  equals  (  o  )  )  return  false;  Element  element  =  (  Element  )  o; 	[BUGGY] if ( !super . equals ( o ) ) return false ; Element element =  ( Element ) o ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( !super . equals ( o ) ) return false ; Element element = ( Element ) o ;   if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^812^813^^815^^810^820^
[REPLACE]  if  (  !  (  o  instanceof  Element  )  )  return  false; 	[BUGGY] if ( ! ( o instanceof Element ) ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ( o instanceof Element ) ) return true ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^812^^^^^810^820^
[REPLACE]  if  (  !super  .  equals  (  o  )  )  return  false; 	[BUGGY] if ( !super . equals ( o ) ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; [ATTENTION] if ( !super . equals ( o ) ) return true ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^813^^^^^810^820^
[REPLACE]  Element  element  =  (  Element  )  o; 	[BUGGY] Element element =  ( Element ) child ; [CE] cannot find symbol child  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  [ATTENTION] Element element = ( Element ) child ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^815^^^^^810^820^
[REPLACE]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false; 	[BUGGY] if ( tag ! =  element . tag ! = null ) return false ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  [ATTENTION] if ( tag ! = element . tag ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^817^^^^^810^820^
[ADD]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false;  return  true;  } 	[BUGGY] [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^817^818^819^820^^810^820^
[REPLACE]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false; 	[BUGGY] if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  [ATTENTION] if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return true ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^817^^^^^810^820^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Element  [TYPE] Object o [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] Element element  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Element ) ) return false ; if ( !super . equals ( o ) ) return false ;  Element element =  ( Element ) o ;  if ( tag ! = null ? !tag . equals ( element . tag ) : element . tag ! = null ) return false ;  [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^819^^^^^810^820^
[REPLACE]  int  result  =  super  .  hashCode  (  )  ; 	[BUGGY] int result = super . Object ( ) ; [CE] cannot find symbol  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] int result  [CONTEXT]  public int hashCode ( ) { [ATTENTION] int result = super . Object ( )  ; result = 31 * result + ( tag ! = null ? tag . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^824^^^^^823^827^
[ADD]  int  result  =  super  .  hashCode  (  )  ;  result  =  31  *  result  +  (  tag  !=  null  ?  tag  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result = 31 * result + ( tag ! = null ? tag . hashCode ( ) : 0 ) ; [CE] cannot find symbol result  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] int result  [CONTEXT]  public int hashCode ( ) { [ATTENTION] result = 31 * result + ( tag ! = null ? tag . hashCode ( ) : 0 )  ;  return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^824^825^^^^823^827^
[REPLACE]  result  =  31  *  result  +  (  tag  !=  null  ?  tag  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = super . hashCode ( ) ; [ATTENTION] result = 0 )  ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^825^^^^^823^827^
[REPLACE]  return  result; 	[BUGGY] return elements . get ( 0 ) ; [CE] cannot find symbol elements  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Element  [TYPE] Set classNames classes [TYPE] Tag tag [TYPE] boolean false true [TYPE] int result  [CONTEXT]  public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( tag ! = null ? tag . hashCode ( ) : 0 ) ; [ATTENTION] return elements . get ( 0 )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Element.java^826^^^^^823^827^
[REPLACE]  private  static  final  String  DATA_KEY  =    "data  "; 	[BUGGY] private static final String DATA_KEY ; [CE] variable DATA_KEY might not have been initialized  [CONTEXT]    [CLASS] DataNode  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^10^^^^^^^
[REPLACE]  super  (  baseUri  )  ; 	[BUGGY] super ( data ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String data String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public DataNode ( String data , String baseUri ) { [ATTENTION] super ( data )  ; attributes . put ( DATA_KEY , data ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^18^^^^^17^20^
[ADD]  super  (  baseUri  )  ;  attributes  .  put  (  DATA_KEY,  data  )  ; 	[BUGGY] [CE] no suitable constructor found for Node()  [METHOD]  <init> [TYPE] String) [PARAMETER] String data String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public DataNode ( String data , String baseUri ) { [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^18^19^^^^17^20^
[REPLACE]  attributes  .  put  (  DATA_KEY,  data  )  ; 	[BUGGY] attributes . put ( DATA_KEY , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String data String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public DataNode ( String data , String baseUri ) { super ( baseUri ) ; [ATTENTION] attributes . put ( DATA_KEY , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^19^^^^^17^20^
[REPLACE]  return    "#data  "; 	[BUGGY] return outerHtml ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return outerHtml ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^23^^^^^22^24^
[REPLACE]  return  attributes  .  get  (  DATA_KEY  )  ; 	[BUGGY] return  DATA_KEY  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getWholeData [TYPE] String [PARAMETER] [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String getWholeData ( ) { [ATTENTION] return DATA_KEY ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^31^^^^^30^32^
[REPLACE]  accum  .  append  (  getWholeData  (  )  )  ; 	[BUGGY] return outerHtml ( ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] DataNode  [TYPE] StringBuilder accum [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] return outerHtml ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^35^^^^^34^36^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return   "#data  " ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "#data  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^39^^^^^38^40^
[REPLACE]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  encodedData  )  ; 	[BUGGY] String data = StringEscapeUtils . unescapeHtml ( data ) ; [CE] variable data might not have been initialized  [METHOD]  createFromEncoded [TYPE] DataNode [PARAMETER] String encodedData String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data encodedData [TYPE] boolean false true  [CONTEXT]  public static DataNode createFromEncoded ( String encodedData , String baseUri ) { [ATTENTION] String data = StringEscapeUtils . unescapeHtml ( data )  ; return new DataNode ( data , baseUri ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^49^^^^^48^51^
[ADD]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  encodedData  )  ; 	[BUGGY] [CE] cannot find symbol data  [METHOD]  createFromEncoded [TYPE] DataNode [PARAMETER] String encodedData String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data encodedData [TYPE] boolean false true  [CONTEXT]  public static DataNode createFromEncoded ( String encodedData , String baseUri ) { [ATTENTION] return new DataNode ( data , baseUri ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^49^^^^^48^51^
[REPLACE]  return  new  DataNode  (  data,  baseUri  )  ; 	[BUGGY] return new DataNode ( encodedData , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createFromEncoded [TYPE] DataNode [PARAMETER] String encodedData String baseUri [CLASS] DataNode  [TYPE] String DATA_KEY baseUri data encodedData [TYPE] boolean false true  [CONTEXT]  public static DataNode createFromEncoded ( String encodedData , String baseUri ) { String data = StringEscapeUtils . unescapeHtml ( encodedData ) ; [ATTENTION] return new DataNode ( encodedData , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/DataNode.java^50^^^^^48^51^
[REPLACE]  private  static  final  String  COMMENT_KEY  =    "comment  "; 	[BUGGY] private static final String COMMENT_KEY ; [CE] variable COMMENT_KEY might not have been initialized  [CONTEXT]    [CLASS] Comment  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^8^^^^^^^
[REPLACE]  super  (  baseUri  )  ; 	[BUGGY] super ( data ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String data String baseUri [CLASS] Comment  [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public Comment ( String data , String baseUri ) { [ATTENTION] super ( data )  ; attributes . put ( COMMENT_KEY , data ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^16^^^^^15^18^
[REPLACE]  attributes  .  put  (  COMMENT_KEY,  data  )  ; 	[BUGGY] attributes . put ( COMMENT_KEY , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String data String baseUri [CLASS] Comment  [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public Comment ( String data , String baseUri ) { super ( baseUri ) ; [ATTENTION] attributes . put ( COMMENT_KEY , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^17^^^^^15^18^
[REPLACE]  return    "#comment  "; 	[BUGGY] return outerHtml ( ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] Comment  [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return outerHtml ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^21^^^^^20^22^
[REPLACE]  return  attributes  .  get  (  COMMENT_KEY  )  ; 	[BUGGY] return attributes . put ( baseUri , COMMENT_KEY )  ; [CE] incompatible types  [METHOD]  getData [TYPE] String [PARAMETER] [CLASS] Comment  [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String getData ( ) { [ATTENTION] return attributes . put ( baseUri , COMMENT_KEY ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^29^^^^^28^30^
[REPLACE]  indent  (  accum  )  ; 	[BUGGY] super ( baseUri ) ; [CE] call to super must be first statement in constructor  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Comment  [TYPE] StringBuilder accum [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] super ( baseUri )  ; accum . append ( String . format (   "<!--%s-->  " , getData ( ) ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^33^^^^^32^35^
[REPLACE]  accum  .  append  (  String  .  format  (    "<!--%s-->  ",  getData  (  )  )  )  ; 	[BUGGY] attributes . put ( COMMENT_KEY , data ) ; [CE] cannot find symbol data  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] Comment  [TYPE] StringBuilder accum [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { indent ( accum ) ; [ATTENTION] attributes . put ( COMMENT_KEY , data )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^34^^^^^32^35^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return   "#comment  " ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Comment  [TYPE] String COMMENT_KEY baseUri data [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return   "#comment  " ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Comment.java^38^^^^^37^39^
[REPLACE]  private  static  final  String  TEXT_KEY  =    "text  "; 	[BUGGY] private static final String TEXT_KEY ; [CE] variable TEXT_KEY might not have been initialized  [CONTEXT]    [CLASS] TextNode  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^12^^^^^^^
[REPLACE]  super  (  baseUri  )  ; 	[BUGGY] super ( text ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String text String baseUri [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public TextNode ( String text , String baseUri ) { [ATTENTION] super ( text )  ; attributes . put ( TEXT_KEY , text ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^22^^^^^21^24^
[REPLACE]  attributes  .  put  (  TEXT_KEY,  text  )  ; 	[BUGGY] attributes . get ( TEXT_KEY )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String text String baseUri [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public TextNode ( String text , String baseUri ) { super ( baseUri ) ; [ATTENTION] attributes . get ( TEXT_KEY ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^23^^^^^21^24^
[REPLACE]  return    "#text  "; 	[BUGGY] return new TextNode ( text , baseUri ) ; [CE] cannot find symbol text  [METHOD]  nodeName [TYPE] String [PARAMETER] [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public String nodeName ( ) { [ATTENTION] return new TextNode ( text , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^27^^^^^26^28^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return new TextNode ( text , baseUri ) ; [CE] cannot find symbol text  [METHOD]  text [TYPE] String [PARAMETER] [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public String text ( ) { [ATTENTION] return new TextNode ( text , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^36^^^^^35^37^
[REPLACE]  attributes  .  put  (  TEXT_KEY,  text  )  ; 	[BUGGY] attributes . put ( TEXT_KEY , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] TextNode [PARAMETER] String text [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public TextNode text ( String text ) { [ATTENTION] attributes . put ( TEXT_KEY , baseUri )  ; return this ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^45^^^^^44^47^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  text [TYPE] TextNode [PARAMETER] String text [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public TextNode text ( String text ) { attributes . put ( TEXT_KEY , text ) ; [ATTENTION] return null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^46^^^^^44^47^
[REPLACE]  return  attributes  .  get  (  TEXT_KEY  )  ; 	[BUGGY] return  TEXT_KEY  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getWholeText [TYPE] String [PARAMETER] [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public String getWholeText ( ) { [ATTENTION] return TEXT_KEY ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^54^^^^^53^55^
[REPLACE]  return  StringUtils  .  isBlank  (  normaliseWhitespace  (  getWholeText  (  )  )  )  ; 	[BUGGY] return  normaliseWhitespace ( getWholeText ( )  ) ; [CE] incompatible types  [METHOD]  isBlank [TYPE] boolean [PARAMETER] [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri text [TYPE] boolean false true  [CONTEXT]  public boolean isBlank ( ) { [ATTENTION] return normaliseWhitespace ( getWholeText ( )  )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^62^^^^^61^63^
[REPLACE]  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ; 	[BUGGY] String html = StringEscapeUtils . unescapeHtml ( getWholeText ( ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] String html = StringEscapeUtils . unescapeHtml ( getWholeText ( ) )  ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^66^^^^^65^74^
[ADD]  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ; 	[BUGGY] [CE] cannot find symbol html  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { [ATTENTION] if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^66^^^^^65^74^
[REPLACE]  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )    .  preserveWhitespace  (  )  )  { 	[BUGGY] if ( ! parent ( ) instanceof Element ) {[CE] bad operand type Node for unary operator '!'  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; [ATTENTION] if ( ! parent ( ) instanceof Element ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^67^^^^^65^74^
[REPLACE]  html  =  normaliseWhitespace  (  html  )  ; 	[BUGGY] html =  normaliseWhitespace ( TEXT_KEY ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { [ATTENTION] html = normaliseWhitespace ( TEXT_KEY )  ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^68^^^^^65^74^
[ADD]  html  =  normaliseWhitespace  (  html  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { [ATTENTION] } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^68^^^^^65^74^
[REPLACE]  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )    .  tag  (  )    .  canContainBlock  (  )    &&  siblingIndex  (  )  ==  0  )  indent  (  accum  )  ; 	[BUGGY] if ( ! !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( )  && siblingIndex ( )  = = 3 ) indent ( accum ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } [ATTENTION] if ( ! !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode )  . tag ( )  . canContainBlock ( ) && siblingIndex ( ) = = 3 ) indent ( accum )  ;  accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^71^72^^^^65^74^
[ADD]  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )    .  tag  (  )    .  canContainBlock  (  )    &&  siblingIndex  (  )  ==  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } [ATTENTION]    	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^71^72^73^74^^65^74^
[REPLACE]  indent  (  accum  )  ; 	[BUGGY] super ( baseUri ) ; [CE] call to super must be first statement in constructor  [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) [ATTENTION] super ( baseUri )  ; accum . append ( html ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^72^^^^^65^74^
[REPLACE]  accum  .  append  (  html  )  ; 	[BUGGY] accum . append ( TEXT_KEY ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; [ATTENTION] accum . append ( TEXT_KEY )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^73^^^^^65^74^
[ADD]  accum  .  append  (  html  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  outerHtml [TYPE] void [PARAMETER] StringBuilder accum [CLASS] TextNode  [TYPE] StringBuilder accum [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  void outerHtml ( StringBuilder accum ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element && ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( !isBlank ( ) && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) && siblingIndex ( )  = = 0 ) indent ( accum ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^73^^^^^65^74^
[REPLACE]  return  outerHtml  (  )  ; 	[BUGGY] return new TextNode ( text , baseUri ) ; [CE] cannot find symbol text  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri html text [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return new TextNode ( text , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^77^^^^^76^78^
[REPLACE]  String  text  =  StringEscapeUtils  .  unescapeHtml  (  encodedText  )  ; 	[BUGGY] String text = StringEscapeUtils . escapeHtml ( baseUri )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createFromEncoded [TYPE] TextNode [PARAMETER] String encodedText String baseUri [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri encodedText html text [TYPE] boolean false true  [CONTEXT]  public static TextNode createFromEncoded ( String encodedText , String baseUri ) { [ATTENTION] String text = StringEscapeUtils . escapeHtml ( baseUri ) ; return new TextNode ( text , baseUri ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^86^^^^^85^88^
[REPLACE]  return  new  TextNode  (  text,  baseUri  )  ; 	[BUGGY] return new TextNode ( encodedText , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createFromEncoded [TYPE] TextNode [PARAMETER] String encodedText String baseUri [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri encodedText html text [TYPE] boolean false true  [CONTEXT]  public static TextNode createFromEncoded ( String encodedText , String baseUri ) { String text = StringEscapeUtils . unescapeHtml ( encodedText ) ; [ATTENTION] return new TextNode ( encodedText , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^87^^^^^85^88^
[REPLACE]  text  =  text  .  replaceAll  (    "\\s{2,}|  (  \\r\\n|\\r|\\n  )    ",    "    "  )  ; 	[BUGGY] text =  encodedText . replaceAll (   "\\s{2 , }| ( \\r\\n|\\r|\\n )   " ,   "   " ) ; [CE] cannot find symbol encodedText  [METHOD]  normaliseWhitespace [TYPE] String [PARAMETER] String text [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri encodedText html text [TYPE] boolean false true  [CONTEXT]  static String normaliseWhitespace ( String text ) { [ATTENTION] text = encodedText . replaceAll (   "\\s{2 , }| ( \\r\\n|\\r|\\n )   " ,   "   " )  ; return text ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^91^^^^^90^93^
[REPLACE]  return  text; 	[BUGGY] return encodedText ; [CE] cannot find symbol encodedText  [METHOD]  normaliseWhitespace [TYPE] String [PARAMETER] String text [CLASS] TextNode  [TYPE] String TEXT_KEY baseUri encodedText html text [TYPE] boolean false true  [CONTEXT]  static String normaliseWhitespace ( String text ) { text = text . replaceAll (   "\\s{2 , }| ( \\r\\n|\\r|\\n )   " ,   "   " ) ; // more than one space , and newlines to   "   " [ATTENTION] return encodedText ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^92^^^^^90^93^
[REPLACE]  if  (  sb  .  length  (  )  ==  0  )  return  false; 	[BUGGY] if ( sb . length ( ) - 3 = = 0 ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { [ATTENTION] if ( sb . length ( ) - 3 = = 0 ) return false ;  String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; Validate . isTrue ( lastChar . length ( )  = = 1 ) ; // todo: remove check return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^100^101^^^^99^105^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) [ATTENTION] return true ; String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; Validate . isTrue ( lastChar . length ( )  = = 1 ) ; // todo: remove check return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^101^^^^^99^105^
[REPLACE]  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1,  sb  .  length  (  )  )  ; 	[BUGGY] String lastChar = sb . substring ( sb . size ( ) -1 , sb . size ( ) ) ; [CE] cannot find symbol  [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) return false ; [ATTENTION] String lastChar = sb . substring ( sb . size ( ) -1 , sb . size ( ) )  ; Validate . isTrue ( lastChar . length ( )  = = 1 ) ; // todo: remove check return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^102^^^^^99^105^
[REPLACE]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ; 	[BUGGY] Validate . isTrue ( lastChar . substring ( null , null )  + 4 = = 1 ) ; [CE] no suitable method found for substring(<null> , <null>)  [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; [ATTENTION] Validate . isTrue ( lastChar . substring ( null , null ) + 4 = = 1 )  ; return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^103^^^^^99^105^
[REPLACE]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ; 	[BUGGY] Validate . isTrue ( text . length ( )  = = 1 ) ; [CE] cannot find symbol text  [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; [ATTENTION] Validate . isTrue ( text . length ( ) = = 1 )  ; return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^103^^^^^99^105^
[ADD]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; [ATTENTION] return lastChar . equals (   "   " ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^103^^^^^99^105^
[REPLACE]  return  lastChar  .  equals  (    "    "  )  ; 	[BUGGY] return text . equals (   "   " ) ; [CE] cannot find symbol text  [METHOD]  lastCharIsWhitespace [TYPE] boolean [PARAMETER] StringBuilder sb [CLASS] TextNode  [TYPE] StringBuilder sb [TYPE] String TEXT_KEY baseUri encodedText html lastChar text [TYPE] boolean false true  [CONTEXT]  static boolean lastCharIsWhitespace ( StringBuilder sb ) { if ( sb . length ( )  = = 0 ) return false ; String lastChar = sb . substring ( sb . length ( ) -1 , sb . length ( ) ) ; Validate . isTrue ( lastChar . length ( )  = = 1 ) ; // todo: remove check [ATTENTION] return text . equals (   "   " )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/TextNode.java^104^^^^^99^105^
[REPLACE]  private  String  key; 	[BUGGY] private boolean key ; [CE] incompatible types  [CONTEXT]    [CLASS] Attribute  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^11^^^^^^^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] Validate . notNull ( key ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { [ATTENTION] Validate . notNull ( key )  ; Validate . notNull ( value ) ; this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^21^^^^^20^25^
[ADD]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { [ATTENTION] Validate . notNull ( value ) ; this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^21^^^^^20^25^
[REPLACE]  Validate  .  notNull  (  value  )  ; 	[BUGGY] Validate . notEmpty ( value ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { Validate . notEmpty ( key ) ; [ATTENTION] Validate . notEmpty ( value )  ; this . key = key . trim ( ) . toLowerCase ( ) ; this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^22^^^^^20^25^
[ADD]  Validate  .  notNull  (  value  )  ;  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { Validate . notEmpty ( key ) ; [ATTENTION]  this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^22^23^^^^20^25^
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . key =  null . trim ( ) . toLowerCase ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notNull ( value ) ; [ATTENTION] this . key = null . trim ( )  . toLowerCase ( )  ; this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^23^^^^^20^25^
[REPLACE]  this  .  value  =  value; 	[BUGGY] this . value =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  <init> [TYPE] String) [PARAMETER] String key String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public Attribute ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notNull ( value ) ; this . key = key . trim ( ) . toLowerCase ( ) ; [ATTENTION] this . value = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^24^^^^^20^25^
[REPLACE]  return  key; 	[BUGGY] return value ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getKey [TYPE] String [PARAMETER] [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public String getKey ( ) { [ATTENTION] return value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^32^^^^^31^33^
[REPLACE]  Validate  .  notEmpty  (  key  )  ; 	[BUGGY] key  ; [CE] not a statement  [METHOD]  setKey [TYPE] void [PARAMETER] String key [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setKey ( String key ) { [ATTENTION] key ; this . key = key . trim ( ) . toLowerCase ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^40^^^^^39^42^
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] this . key =  null . trim ( ) . toLowerCase ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  setKey [TYPE] void [PARAMETER] String key [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setKey ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] this . key = null . trim ( )  . toLowerCase ( )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^41^^^^^39^42^
[ADD]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setKey [TYPE] void [PARAMETER] String key [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setKey ( String key ) { Validate . notEmpty ( key ) ; [ATTENTION] }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^41^^^^^39^42^
[REPLACE]  return  value; 	[BUGGY] return key ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  getValue [TYPE] String [PARAMETER] [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public String getValue ( ) { [ATTENTION] return key ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^49^^^^^48^50^
[REPLACE]  Validate  .  notNull  (  value  )  ; 	[BUGGY] Validate . notEmpty ( value ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setValue [TYPE] void [PARAMETER] String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setValue ( String value ) { [ATTENTION] Validate . notEmpty ( value )  ; this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^57^^^^^56^59^
[ADD]  Validate  .  notNull  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setValue [TYPE] void [PARAMETER] String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setValue ( String value ) { [ATTENTION] this . value = value ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^57^^^^^56^59^
[REPLACE]  this  .  value  =  value; 	[BUGGY] this . value =  null ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  setValue [TYPE] void [PARAMETER] String value [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public void setValue ( String value ) { Validate . notNull ( value ) ; [ATTENTION] this . value = null ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^58^^^^^56^59^
[REPLACE]  return  String  .  format  (    "%s=\  "%s\  "  ",  key,  StringEscapeUtils  .  escapeHtml  (  value  )  )  ; 	[BUGGY] return String . format (   "%s = \  "%s\  "  " , key , StringEscapeUtils . unescapeHtml ( value ) ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  html [TYPE] String [PARAMETER] [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public String html ( ) { [ATTENTION] return String . format (   "%s = \  "%s\  "  " , key , StringEscapeUtils . unescapeHtml ( value ) )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^66^^^^^65^67^
[REPLACE]  return  html  (  )  ; 	[BUGGY] return key ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Attribute  [TYPE] String key value [TYPE] boolean false true  [CONTEXT]  public String toString ( ) { [ATTENTION] return key ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^74^^^^^73^75^
[REPLACE]  String  value  =  StringEscapeUtils  .  unescapeHtml  (  encodedValue  )  ; 	[BUGGY] String value = StringEscapeUtils . escapeHtml ( value ) ; [CE] variable value might not have been initialized  [METHOD]  createFromEncoded [TYPE] Attribute [PARAMETER] String unencodedKey String encodedValue [CLASS] Attribute  [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true  [CONTEXT]  public static Attribute createFromEncoded ( String unencodedKey , String encodedValue ) { [ATTENTION] String value = StringEscapeUtils . escapeHtml ( value )  ; return new Attribute ( unencodedKey , value ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^84^^^^^83^86^
[REPLACE]  return  new  Attribute  (  unencodedKey,  value  )  ; 	[BUGGY] return new Attribute ( unencodedKey , encodedValue ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  createFromEncoded [TYPE] Attribute [PARAMETER] String unencodedKey String encodedValue [CLASS] Attribute  [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true  [CONTEXT]  public static Attribute createFromEncoded ( String unencodedKey , String encodedValue ) { String value = StringEscapeUtils . unescapeHtml ( encodedValue ) ; [ATTENTION] return new Attribute ( unencodedKey , encodedValue )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^85^^^^^83^86^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this || o ) return true ; [CE] bad operand types for binary operator '||'  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this||o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^90^^^^^89^99^
[REPLACE]  if  (  this  ==  o  )  return  true; 	[BUGGY] if ( this = = o ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { [ATTENTION] if ( this = = o ) return false ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^90^^^^^89^99^
[REPLACE]  if  (  !  (  o  instanceof  Attribute  )  )  return  false; 	[BUGGY] if ( ! ! ( o instanceof Attribute ) ) return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^91^^^^^89^99^
[REPLACE]  if  (  !  (  o  instanceof  Attribute  )  )  return  false; 	[BUGGY] if ( ! ( o instanceof Attribute ) ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; [ATTENTION] if ( ! ( o instanceof Attribute ) ) return true ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^91^^^^^89^99^
[REPLACE]  Attribute  attribute  =  (  Attribute  )  o; 	[BUGGY] String value = StringEscapeUtils . unescapeHtml ( encodedValue ) ; [CE] cannot find symbol encodedValue  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  [ATTENTION] String value = StringEscapeUtils . unescapeHtml ( encodedValue )  ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^93^^^^^89^99^
[REPLACE]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false; 	[BUGGY] if ( key ! =  !key . equals ( attribute . key )  ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  [ATTENTION] if ( key ! = !key . equals ( attribute . key ) ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^95^^^^^89^99^
[ADD]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false;  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false;  return  true;  } 	[BUGGY] if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ; return true ; [CE] ' ; ' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  [ATTENTION] if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ; return true ;     	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^95^96^^98^99^89^99^
[REPLACE]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false; 	[BUGGY] if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  [ATTENTION] if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return true ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^95^^^^^89^99^
[REPLACE]  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false; 	[BUGGY] if ( value ! =  attribute . value = = this ) return false ; [CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; [ATTENTION] if ( value ! = attribute . value = = this ) return false ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^96^^^^^89^99^
[REPLACE]  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false; 	[BUGGY] if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return true ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; [ATTENTION] if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return true ;  return true ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^96^^^^^89^99^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Attribute  [TYPE] Object o [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true [TYPE] Attribute attribute  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Attribute ) ) return false ;  Attribute attribute =  ( Attribute ) o ;  if ( key ! = null ? !key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? !value . equals ( attribute . value ) : attribute . value ! = null ) return false ;  [ATTENTION] return false ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^98^^^^^89^99^
[REPLACE]  int  result  =  key  !=  null  ?  key  .  hashCode  (  )  :  0; 	[BUGGY] int result  =  key . hashCode ( )  ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Attribute  [TYPE] int result [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { [ATTENTION] int result = key . hashCode ( ) ; result = 31 * result + ( value ! = null ? value . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^103^^^^^102^106^
[REPLACE]  result  =  31  *  result  +  (  value  !=  null  ?  value  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Attribute  [TYPE] int result [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { int result = key ! = null ? key . hashCode ( ) : 0 ; [ATTENTION] result = 0 )  ; return result ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^104^^^^^102^106^
[REPLACE]  return  result; 	[BUGGY] return key ; [CE] incompatible types  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Attribute  [TYPE] int result [TYPE] String encodedValue key unencodedKey value [TYPE] boolean false true  [CONTEXT]  public int hashCode ( ) { int result = key ! = null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value ! = null ? value . hashCode ( ) : 0 ) ; [ATTENTION] return key ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/nodes/Attribute.java^105^^^^^102^106^
[REPLACE]  return  Parser  .  parse  (  html,  baseUri  )  ; 	[BUGGY] return Parser . parse ( baseUri )  ; [CE] no suitable method found for parse(String)  [METHOD]  parse [TYPE] Document [PARAMETER] String html String baseUri [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String baseUri html  [CONTEXT]  public static Document parse ( String html , String baseUri ) { [ATTENTION] return Parser . parse ( baseUri ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^28^^^^^27^29^
[REPLACE]  return  Parser  .  parse  (  html,    "  "  )  ; 	[BUGGY] return Parser . parse ( html , baseUri ) ; [CE] cannot find symbol baseUri  [METHOD]  parse [TYPE] Document [PARAMETER] String html [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String html  [CONTEXT]  public static Document parse ( String html ) { [ATTENTION] return Parser . parse ( html , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^41^^^^^40^42^
[REPLACE]  String  html  =  DataUtil  .  load  (  url,  timeoutMillis  )  ; 	[BUGGY] String html = DataUtil . load ( in , charsetName ) ; [CE] cannot find symbol in  [METHOD]  parse [TYPE] Document [PARAMETER] URL url int timeoutMillis [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String html [TYPE] URL url [TYPE] int timeoutMillis  [CONTEXT]  public static Document parse ( URL url , int timeoutMillis ) throws IOException { [ATTENTION] String html = DataUtil . load ( in , charsetName )  ; return parse ( html , url . toExternalForm ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^55^^^^^54^57^
[ADD]  String  html  =  DataUtil  .  load  (  url,  timeoutMillis  )  ;  return  parse  (  html,  url  .  toExternalForm  (  )  )  ; 	[BUGGY] [CE] missing return statement  [METHOD]  parse [TYPE] Document [PARAMETER] URL url int timeoutMillis [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String html [TYPE] URL url [TYPE] int timeoutMillis  [CONTEXT]  public static Document parse ( URL url , int timeoutMillis ) throws IOException { [ATTENTION]  }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^55^56^^^^54^57^
[REPLACE]  return  parse  (  html,  url  .  toExternalForm  (  )  )  ; 	[BUGGY] return cleaner . isValid ( dirty ) ; [CE] cannot find symbol dirty  [METHOD]  parse [TYPE] Document [PARAMETER] URL url int timeoutMillis [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String html [TYPE] URL url [TYPE] int timeoutMillis  [CONTEXT]  public static Document parse ( URL url , int timeoutMillis ) throws IOException { String html = DataUtil . load ( url , timeoutMillis ) ; [ATTENTION] return cleaner . isValid ( dirty )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^56^^^^^54^57^
[REPLACE]  String  html  =  DataUtil  .  load  (  in,  charsetName  )  ; 	[BUGGY] String html = DataUtil . load ( in , html ) ; [CE] variable html might not have been initialized  [METHOD]  parse [TYPE] Document [PARAMETER] File in String charsetName String baseUri [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String baseUri charsetName html [TYPE] File in  [CONTEXT]  public static Document parse ( File in , String charsetName , String baseUri ) throws IOException { [ATTENTION] String html = DataUtil . load ( in , html )  ; return parse ( html , baseUri ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^70^^^^^69^72^
[REPLACE]  return  parse  (  html,  baseUri  )  ; 	[BUGGY] return parse ( charsetName , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parse [TYPE] Document [PARAMETER] File in String charsetName String baseUri [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String baseUri charsetName html [TYPE] File in  [CONTEXT]  public static Document parse ( File in , String charsetName , String baseUri ) throws IOException { String html = DataUtil . load ( in , charsetName ) ; [ATTENTION] return parse ( charsetName , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^71^^^^^69^72^
[REPLACE]  String  html  =  DataUtil  .  load  (  in,  charsetName  )  ; 	[BUGGY] String html = DataUtil . load ( url , timeoutMillis ) ; [CE] cannot find symbol url  [METHOD]  parse [TYPE] Document [PARAMETER] File in String charsetName [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String charsetName html [TYPE] File in  [CONTEXT]  public static Document parse ( File in , String charsetName ) throws IOException { [ATTENTION] String html = DataUtil . load ( url , timeoutMillis )  ; return parse ( html , in . getAbsolutePath ( ) ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^85^^^^^84^87^
[REPLACE]  return  parse  (  html,  in  .  getAbsolutePath  (  )  )  ; 	[BUGGY] return cleaner . isValid ( dirty ) ; [CE] cannot find symbol dirty  [METHOD]  parse [TYPE] Document [PARAMETER] File in String charsetName [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String charsetName html [TYPE] File in  [CONTEXT]  public static Document parse ( File in , String charsetName ) throws IOException { String html = DataUtil . load ( in , charsetName ) ; [ATTENTION] return cleaner . isValid ( dirty )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^86^^^^^84^87^
[REPLACE]  return  Parser  .  parseBodyFragment  (  bodyHtml,  baseUri  )  ; 	[BUGGY] return Parser . parse ( bodyHtml , baseUri ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  parseBodyFragment [TYPE] Document [PARAMETER] String bodyHtml String baseUri [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String baseUri bodyHtml  [CONTEXT]  public static Document parseBodyFragment ( String bodyHtml , String baseUri ) { [ATTENTION] return Parser . parse ( bodyHtml , baseUri )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^99^^^^^98^100^
[REPLACE]  return  Parser  .  parseBodyFragment  (  bodyHtml,    "  "  )  ; 	[BUGGY] return Parser . parseBodyFragment ( bodyHtml )  ; [CE] method parseBodyFragment in class Parser cannot be applied to given types ;  [METHOD]  parseBodyFragment [TYPE] Document [PARAMETER] String bodyHtml [CLASS] Jsoup  [TYPE] boolean false true [TYPE] String bodyHtml  [CONTEXT]  public static Document parseBodyFragment ( String bodyHtml ) { [ATTENTION] return Parser . parseBodyFragment ( bodyHtml ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^111^^^^^110^112^
[REPLACE]  Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ; 	[BUGGY] Document dirty = parseBodyFragment ( bodyHtml ,   "  " ) ; [FE] NullPointerException assertEquals(  "Yahoo! JAPAN  " , doc.title())   [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml String baseUri Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String baseUri bodyHtml [TYPE] Document clean dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static String clean ( String bodyHtml , String baseUri , Whitelist whitelist ) { [ATTENTION] Document dirty = parseBodyFragment ( bodyHtml ,   "  " )  ; Cleaner cleaner = new Cleaner ( whitelist ) ; Document clean = cleaner . clean ( dirty ) ; return clean . body ( ) . html ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^126^^^^^125^130^
[REPLACE]  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ; 	[BUGGY] Document clean = cleaner . clean ( dirty ) ; [CE] cannot find symbol cleaner  [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml String baseUri Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String baseUri bodyHtml [TYPE] Document clean dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static String clean ( String bodyHtml , String baseUri , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml , baseUri ) ; [ATTENTION] Document clean = cleaner . clean ( dirty )  ; Document clean = cleaner . clean ( dirty ) ; return clean . body ( ) . html ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^127^^^^^125^130^
[REPLACE]  Document  clean  =  cleaner  .  clean  (  dirty  )  ; 	[BUGGY] Document . isValid = cleaner . clean ( dirty ) ; [CE] cannot find symbol isValid  [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml String baseUri Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String baseUri bodyHtml [TYPE] Document clean dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static String clean ( String bodyHtml , String baseUri , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml , baseUri ) ; Cleaner cleaner = new Cleaner ( whitelist ) ; [ATTENTION] Document . isValid = cleaner . clean ( dirty )  ; return clean . body ( ) . html ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^128^^^^^125^130^
[ADD]  Document  clean  =  cleaner  .  clean  (  dirty  )  ; 	[BUGGY] [CE] cannot find symbol clean  [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml String baseUri Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String baseUri bodyHtml [TYPE] Document clean dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static String clean ( String bodyHtml , String baseUri , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml , baseUri ) ; Cleaner cleaner = new Cleaner ( whitelist ) ; [ATTENTION] return clean . body ( ) . html ( ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^128^^^^^125^130^
[REPLACE]  return  clean  .  body  (  )    .  html  (  )  ; 	[BUGGY] return cleaner . isValid ( dirty ) ; [CE] incompatible types  [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml String baseUri Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String baseUri bodyHtml [TYPE] Document clean dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static String clean ( String bodyHtml , String baseUri , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml , baseUri ) ; Cleaner cleaner = new Cleaner ( whitelist ) ; Document clean = cleaner . clean ( dirty ) ; [ATTENTION] return cleaner . isValid ( dirty )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^129^^^^^125^130^
[REPLACE]  return  clean  (  bodyHtml,    "  ",  whitelist  )  ; 	[BUGGY] return cleaner . isValid ( dirty ) ; [CE] cannot find symbol dirty  [METHOD]  clean [TYPE] String [PARAMETER] String bodyHtml Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String bodyHtml  [CONTEXT]  public static String clean ( String bodyHtml , Whitelist whitelist ) { [ATTENTION] return cleaner . isValid ( dirty )  ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^143^^^^^142^144^
[REPLACE]  Document  dirty  =  parseBodyFragment  (  bodyHtml,    "  "  )  ; 	[BUGGY] Document dirty = parseBodyFragment ( bodyHtml , baseUri ) ; [CE] cannot find symbol baseUri  [METHOD]  isValid [TYPE] boolean [PARAMETER] String bodyHtml Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String bodyHtml [TYPE] Document dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { [ATTENTION] Document dirty = parseBodyFragment ( bodyHtml , baseUri )  ; Cleaner cleaner = new Cleaner ( whitelist ) ; return cleaner . isValid ( dirty ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^155^^^^^154^158^
[ADD]  Document  dirty  =  parseBodyFragment  (  bodyHtml,    "  "  )  ; 	[BUGGY] [CE] cannot find symbol dirty  [METHOD]  isValid [TYPE] boolean [PARAMETER] String bodyHtml Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String bodyHtml [TYPE] Document dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { [ATTENTION] Cleaner cleaner = new Cleaner ( whitelist ) ; return cleaner . isValid ( dirty ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^155^^^^^154^158^
[REPLACE]  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ; 	[BUGGY] Document clean = cleaner . clean ( dirty ) ; [CE] cannot find symbol cleaner  [METHOD]  isValid [TYPE] boolean [PARAMETER] String bodyHtml Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String bodyHtml [TYPE] Document dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml ,   "  " ) ; [ATTENTION] Document clean = cleaner . clean ( dirty )  ; return cleaner . isValid ( dirty ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^156^^^^^154^158^
[REPLACE]  return  cleaner  .  isValid  (  dirty  )  ; 	[BUGGY] return cleaner . isValid ( bodyHtml , whitelist )  ; [CE] method isValid in class Cleaner cannot be applied to given types ;  [METHOD]  isValid [TYPE] boolean [PARAMETER] String bodyHtml Whitelist whitelist [CLASS] Jsoup  [TYPE] boolean false true [TYPE] Whitelist whitelist [TYPE] String bodyHtml [TYPE] Document dirty [TYPE] Cleaner cleaner  [CONTEXT]  public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { Document dirty = parseBodyFragment ( bodyHtml ,   "  " ) ; Cleaner cleaner = new Cleaner ( whitelist ) ; [ATTENTION] return cleaner . isValid ( bodyHtml , whitelist ) ; }  	./Perturbation-Jsoup-1/src/main/java/org/jsoup/Jsoup.java^157^^^^^154^158^
