private  final  boolean  isEscaping;	[BUGGY]  private    boolean  isEscaping;  [CONTEXT]          abstract  class  Lexer  {    private  final  boolean  isEncapsulating;  [BUGGY]  privateboolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;        [CLASS]  Lexer      [VARIABLES]  
private  final  boolean  isCommentEnabled;	[BUGGY]  private    boolean  isCommentEnabled;  [CONTEXT]      abstract  class  Lexer  {    private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  [BUGGY]  privateboolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;        [CLASS]  Lexer      [VARIABLES]  
private  final  char  delimiter;	[BUGGY]  private  final  int  delimiter;  [CONTEXT]    private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    [BUGGY]  private  final  int  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;        [CLASS]  Lexer      [VARIABLES]  
private  final  char  escape;	[BUGGY]  private  final  String  escape;  [CONTEXT]  private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  [BUGGY]  private  final  String  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;        [CLASS]  Lexer      [VARIABLES]  
private  final  char  escape;	[BUGGY]  private    int  escape;  [CONTEXT]  private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  [BUGGY]  privateint  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;        [CLASS]  Lexer      [VARIABLES]  
private  final  char  encapsulator;	[BUGGY]  private  final  int  encapsulator;  [CONTEXT]  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  [BUGGY]  private  final  int  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;          [CLASS]  Lexer      [VARIABLES]  
private  final  char  encapsulator;	[BUGGY]  private    int  encapsulator;  [CONTEXT]  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  [BUGGY]  privateint  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;          [CLASS]  Lexer      [VARIABLES]  
private  final  char  commmentStart;	[BUGGY]  private  final  int  commmentStart;  [CONTEXT]  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  [BUGGY]  private  final  int  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    final  CSVFormat  format;        [CLASS]  Lexer      [VARIABLES]  
final  boolean  surroundingSpacesIgnored;	[BUGGY]  boolean  surroundingSpacesIgnored;  [CONTEXT]  private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    [BUGGY]  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    final  CSVFormat  format;              [CLASS]  Lexer      [VARIABLES]  
final  boolean  emptyLinesIgnored;	[BUGGY]  boolean  emptyLinesIgnored;  [CONTEXT]  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  [BUGGY]  boolean  emptyLinesIgnored;    final  CSVFormat  format;        final  ExtendedBufferedReader  in;        [CLASS]  Lexer      [VARIABLES]  
final  CSVFormat  format;	[BUGGY]  CSVFormat  format;  [CONTEXT]  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    [BUGGY]  CSVFormat  format;        final  ExtendedBufferedReader  in;    Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {        [CLASS]  Lexer      [VARIABLES]  
final  ExtendedBufferedReader  in;	[BUGGY]  ExtendedBufferedReader  in;  [CONTEXT]  final  boolean  emptyLinesIgnored;    final  CSVFormat  format;        [BUGGY]  ExtendedBufferedReader  in;    Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();        [CLASS]  Lexer      [VARIABLES]  
this.format  =  format;	[BUGGY]  this.format  =    null;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  this.format  =null;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.in  =  in;	[BUGGY]  this.in  =    null;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  [BUGGY]  this.in  =null;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this.isEncapsulating  =    null.isEncapsulating(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isEncapsulating  =null.isEncapsulating  ()  ;  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this.isEscaping  =  format.isEscaping(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUGGY]  this  .isEscaping(  )  =  format  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this  .isEscaping  ()=  format  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.isEscaping  =    null.isEscaping(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.isEscaping  =null.isEscaping  ()  ;  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isEscaping  =  format.isEscaping  (  )  ;	[BUGGY]  this  .isEncapsulating(  )  =  format  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this  .isEncapsulating  ()=  format  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.isCommentEnabled  =    null.isCommentingEnabled(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =null.isCommentingEnabled  ()  ;  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );  this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.isEscaping  =  format.isEscaping(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format  .getCommentStart(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =  format  .getCommentStart  ();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;  this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );  this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;  this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.delimiter  =    null.getDelimiter(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =null.getDelimiter  ()  ;  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.isEscaping  =  format.isEscaping(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.delimiter  =  format.getDelimiter  (  )  ;	[BUGGY]  this.delimiter  =  format  .getEscape(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =  format  .getEscape  ();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.escape  =    null.getEscape(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =null.getEscape  ()  ;  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );  this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.escape  =  format.getEscape(  );  this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.escape  =  format  .getEncapsulator(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  format  .getEncapsulator  ();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;  this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  format.getEscape();                  [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.isEscaping  =  format.isEscaping(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.escape  =  format.getEscape  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.encapsulator  =  format  .isEncapsulating(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =  format  .isEncapsulating  ();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.encapsulator  =    null.getEncapsulator(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =null.getEncapsulator  ()  ;  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.isEscaping  =  format.isEscaping(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =  format.getEncapsulator();                [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.commmentStart  =  format  .getEscape(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  format  .getEscape  ();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.commmentStart  =    null.getCommentStart(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =null.getCommentStart  ()  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.escape  =  format.getEscape(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.delimiter  =  format.getDelimiter(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  format.getCommentStart();              [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.commmentStart  =  format.getCommentStart  (  )  ;	[BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );  this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUGGY]  this.surroundingSpacesIgnored  =    null.isSurroundingSpacesIgnored(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.surroundingSpacesIgnored  =null.isSurroundingSpacesIgnored  ()  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();            [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUGGY]  this.emptyLinesIgnored  =    null.isEmptyLinesIgnored(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =null.isEmptyLinesIgnored  ()  ;  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();          [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
return  in.getLineNumber  (  )  ;	[BUGGY]  return  in.read(  );  [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  in.read  ()  ;  }        [CLASS]  Lexer    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
return  in.getLineNumber  (  )  ;	[BUGGY]    [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  in.getLineNumber();          [CLASS]  Lexer    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
c  =  in.read  (  )  ;	[BUGGY]  c  =  in.lookAhead(  );  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c  =  in.lookAhead  ()  ;  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]  c    =    c  ;  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c=c  ;  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]    [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c  =  in.read();    switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
int  length  =  buffer.length  (  )  ;	[BUGGY]  short    length  =  buffer.length(  );  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  shortlength  =  buffer.length  ()  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]  int  length  =  buffer.length()  +  5  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  5  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]  int  length  =  buffer.setLength(  );  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.setLength  ()  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]  int  length  =  buffer  .setLength(  length)  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer  .setLength  (  length  );  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]  if  (  length  !=  buffer.length(  ))  {  int  length  =  buffer.length(  );  }  [CONTEXT]        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]  int  length  =  buffer.length()  +  8  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  8  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
int  length  =  buffer.length  (  )  ;	[BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length();    while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  ||  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  ||  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  <  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  <  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    <    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length<1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    >=    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length>=1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  length  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  length  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  length)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  length  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  )))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  buffer  >  0  &&  Character.isWhitespace(  length.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  buffer  >  0  &&  Character.isWhitespace  (  length.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character  .isWhitespace(  )  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character  .isWhitespace  ()  ){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
length  =  length  -  1;	[BUGGY]  length  =  length      instanceof      1;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  instanceof  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
length  =  length  -  1;	[BUGGY]  length  =  length  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  ;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
length  =  length  -  1;	[BUGGY]  length  =  length  -  0  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  -  0  ;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
length  =  length  -  1;	[BUGGY]  length  =  length    |    1;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length|1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer  .setLength(  length)  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer  .setLength  (  length  )  )){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {  length  =  length  -  1;	[BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {      }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  length  =  length  -  1;while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    ==    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length==1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {	[BUGGY]  if  (  length  ==  buffer.length(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  ==  buffer.length  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {	[BUGGY]  if  (  length  !=  buffer.length()  -  0  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.length()  -  0){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {	[BUGGY]  if  (  buffer  !=  length.length(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  buffer  !=  length.length  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {	[BUGGY]  if  (  length  !=  buffer.setLength(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.setLength  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUGGY]  buffer.setLength(length);  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (length  !=  buffer.length())  {    buffer.setLength(length);          [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (length  !=  buffer.length())  {              [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
buffer.setLength  (  length  )  ;	[BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  [BUGGY]  buffer.setLength(length);    }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
if  (  length  !=  buffer.length  (  )  )  {	[BUGGY]  if  (  length  !=  buffer.length()  -  1  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.length()  -  1){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
buffer.setLength  (  length  )  ;	[BUGGY]  buffer  .length(  )  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  [BUGGY]  buffer  .length  ();  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  c  !=  format.getDelimiter(  ))  ||  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getDelimiter  ())||  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  c  >=  format.getDelimiter(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  >=  format.getDelimiter  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  format  !=  c.getDelimiter(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  format  !=  c.getDelimiter  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  c  !=  format.getEscape(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getEscape  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;  }	[BUGGY]    [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (c  !=  format.getDelimiter())  &&  Character.isWhitespace((char)  c);          [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  c  !=  format.getDelimiter(  ))  &&  Character  .isWhitespace(  c)  ;  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getDelimiter  ())&&  Character  .isWhitespace  (  c  );  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  ||  in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  !=  '\r'  &&  in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  !=  '\r'  &&  in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  ==  '\r'  &&  in.lookAhead(  )  !=  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  &&  in.lookAhead  ()!=  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  in  ==  '\r'  &&  c.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  in  ==  '\r'  &&  c.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  ==  '\r'){  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  )  {      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (    in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  ==  '\r'  &&  in.read(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  &&  in.read  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUGGY]  c  =  in.read();  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();      return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUGGY]    [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {          return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]  c  =  in.lookAhead(  );  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c  =  in.lookAhead  ()  ;  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]  c  ;  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c  ;  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]    [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c  =  in.read();    }  return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
c  =  in.read  (  )  ;	[BUGGY]  c    =    c  ;  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c=c  ;  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUGGY]  return  (  c  ==  '\n'  &&  c  ==  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  ==  '\n'  &&  c  ==  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUGGY]  return  (  c  >=  '\n'  ||  c  ==  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  >=  '\n'  ||  c  ==  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUGGY]  return  (  c  ==  '\n'  ||  c  <=  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  ==  '\n'  ||  c  <=  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUGGY]  return  false  ;  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return  false  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUGGY]  return  c  !=  ExtendedBufferedReader.END_OF_STREAM;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c  !=  ExtendedBufferedReader.END_OF_STREAM;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUGGY]  return  ExtendedBufferedReader.END_OF_STREAM  ==  c;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  ExtendedBufferedReader.END_OF_STREAM  ==  c;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUGGY]  return  c    ||    ExtendedBufferedReader.END_OF_STREAM;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c||ExtendedBufferedReader.END_OF_STREAM;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  delimiter;	[BUGGY]  return  c  !=  delimiter;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  !=  delimiter;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  delimiter;	[BUGGY]  return  delimiter  ==  c;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  delimiter  ==  c;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  c  ==  delimiter;	[BUGGY]  return  c    ||    delimiter;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c||delimiter;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  isEscaping  ||  c  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  ||  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  isEscaping  &&  c  >=  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  >=  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  isEncapsulating  &&  c  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  isEscaping  &&  c  ==  encapsulator;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  isEscaping  &&  escape  ==  c;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  escape  ==  c;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  c  &&  isEscaping  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  c  &&  isEscaping  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  return  escape  &&  c  ==  isEscaping;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  escape  &&  c  ==  isEscaping;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEscaping  &&  c  ==  escape;	[BUGGY]  returnsurroundingSpacesIgnored  ;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  returnsurroundingSpacesIgnored  ;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  isEncapsulating  &&  c  ==  escape;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  isEncapsulating  &&  encapsulator  ==  c;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  encapsulator  ==  c;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  isEncapsulating  ||  c  ;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  &&  c  !=  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  !=  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  &&  c  ==  escape;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  &&  commmentStart  ==  c;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  commmentStart  ==  c;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  ;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
private  static  final  String  CRLF  =   "\r\n ";	[BUGGY]  private  static  final  char  CRLF  =   "\r\n ";  [CONTEXT]          public  class  CSVFormat  implements  Serializable  {        [BUGGY]  private  static  final  char  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;        [CLASS]  CSVFormat      [VARIABLES]  
private  static  final  String  CRLF  =   "\r\n ";	[BUGGY]  private  static    char  CRLF  =   "\r\n ";  [CONTEXT]          public  class  CSVFormat  implements  Serializable  {        [BUGGY]  private  staticchar  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  delimiter;	[BUGGY]  private  final  String  delimiter;  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {        private  static  final  String  CRLF  =   "\r\n ";    [BUGGY]  private  final  String  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  delimiter;	[BUGGY]  private  final  int  delimiter;  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {        private  static  final  String  CRLF  =   "\r\n ";    [BUGGY]  private  final  int  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  encapsulator;	[BUGGY]  private  final  String  encapsulator;  [CONTEXT]        private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  [BUGGY]  private  final  String  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  commentStart;	[BUGGY]  private  final  int  commentStart;  [CONTEXT]      private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  int  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  commentStart;	[BUGGY]  private  final  String  commentStart;  [CONTEXT]      private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  String  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;        [CLASS]  CSVFormat      [VARIABLES]  
private  final  char  escape;	[BUGGY]  private  final  int  escape;  [CONTEXT]  private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  [BUGGY]  private  final  int  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;          [CLASS]  CSVFormat      [VARIABLES]  
private  final  boolean  emptyLinesIgnored;	[BUGGY]  private    boolean  emptyLinesIgnored;  [CONTEXT]  private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  [BUGGY]  privateboolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;                [CLASS]  CSVFormat      [VARIABLES]  
private  final  String  lineSeparator;	[BUGGY]  private  final  char  lineSeparator;  [CONTEXT]  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  [BUGGY]  private  final  char  lineSeparator;  private  final  String[]  header;                    [CLASS]  CSVFormat      [VARIABLES]  
static  final  char  DISABLED  =  '\ufffe';	[BUGGY]  static  final  int  DISABLED  =  '\ufffe';  [CONTEXT]                      [BUGGY]  static  final  int  DISABLED  =  '\ufffe';                private  static  CSVFormat  PRISTINE  =  new  CSVFormat(DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null);        [CLASS]  CSVFormat      [VARIABLES]  
private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat(  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null);  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';                [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null  )  ;                          [CLASS]  CSVFormat      [VARIABLES]  
private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat(  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  false,  null,  null);  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';                [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  false,  null,  null  )  ;                          [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter(  ',')  .isEncapsulating()  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  ).isEncapsulating  ()        .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static    CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  staticCSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )        .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter(  ',')  .isEncapsulating()  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  ).isEncapsulating  ()        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  RFC4180  ;  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  RFC4180  ;        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public    final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  publicfinal  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withEscape(  '\t').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withEscape  (  '\t'  )  .withEncapsulator  (  ' "'  )        .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUGGY]  public  static    CSVFormat  TDF  =  PRISTINE  .withDelimiter(  '\t').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  staticCSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )        .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )	[BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withEscape(  '\t').withEscape(  '\\'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withEscape  (  '\t'  )  .withEscape  (  '\\'  )        .withLineSeparator( "\n ");        [CLASS]  CSVFormat      [VARIABLES]  
public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )	[BUGGY]  private  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter(  '\t').withEscape(  '\\'  )  [CONTEXT]  [BUGGY]  private  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )        .withLineSeparator( "\n ");        [CLASS]  CSVFormat      [VARIABLES]  
this.delimiter  =  delimiter;	[BUGGY]  this.delimiter  =  escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =  escape;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.delimiter  =  delimiter;	[BUGGY]  this.delimiter  =    null;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =null;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.delimiter  =  delimiter;	[BUGGY]  this.header  =  header;this.delimiter  =  delimiter;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.encapsulator  =  encapsulator;	[BUGGY]  this.encapsulator  =  escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.encapsulator  =  escape;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.encapsulator  =  encapsulator;	[BUGGY]  this.encapsulator  =    delimiter;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.encapsulator  =delimiter;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.commentStart  =  commentStart;	[BUGGY]  this.commentStart  =    escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  [BUGGY]  this.commentStart  =escape;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.escape  =  escape;	[BUGGY]  this.escape  =  encapsulator;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.escape  =  encapsulator;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.escape  =  escape;	[BUGGY]  this.escape  =    delimiter;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.escape  =delimiter;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.escape  =  escape;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  [BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;this.emptyLinesIgnored  =  emptyLinesIgnored;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.lineSeparator  =  lineSeparator;	[BUGGY]  this.lineSeparator  =  CRLF;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.lineSeparator  =  CRLF;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.lineSeparator  =  lineSeparator;	[BUGGY]    this.lineSeparator  =  lineSeparator;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.lineSeparator  =  lineSeparator;	[BUGGY]  this.encapsulator  =  encapsulator;this.lineSeparator  =  lineSeparator;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
this.header  =  header;	[BUGGY]  this.header  =    null;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  [BUGGY]  this.header  =null;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return  c  <=  '\n'  ||  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  <=  '\n'  ||  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return  c  >  '\n'  ||  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  >  '\n'  ||  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return      c  ;  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ;  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  delimiter  !=  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  !=  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  escape  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  escape  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  delimiter  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  ==  escape  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  encapsulator  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  encapsulator  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  encapsulator  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(\ " "  +(encapsulator))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (delimiter  ==  encapsulator)  {    throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (encapsulator))  +   "\ ") "));      if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (delimiter  ==  encapsulator)  {          if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (  delimiter  !=  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  !=  escape  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (  encapsulator  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  ==  escape  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (  escape  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  escape  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  escape  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  escape  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same(\ " "  +(escape))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  escape)  {    throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (escape))  +   "\ ") "));      if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  escape)  {          if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  [BUGGY]  return  ;  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  delimiter  !=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  !=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  delimiter  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  commentStart  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  commentStart  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));      if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  commentStart)  {          if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  0;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  [BUGGY]  return  0;  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  [BUGGY]  return  ;  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  >=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  encapsulator  >=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  escape  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  escape  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  encapsulator  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED){  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  )  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (    encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));      if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {          if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  escape  ))+   "\ "  )   "  ))  ;  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  DISABLED  ||  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  ||  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  escape  ==  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  ==  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  DISABLED  &&  escape  !=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  escape  !=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  encapsulator  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  encapsulator  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  commentStart  !=  DISABLED  &&  escape  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  commentStart  !=  DISABLED  &&  escape  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  DISABLED  !=  escape  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  DISABLED  !=  escape  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  escape  !=  DISABLED){  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  )  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (    escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  and  the  escape  character  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  and  the  escape  character  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));          [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {              [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  delimiter;	[BUGGY]  return  escape;  [CONTEXT]  public  char  getDelimiter()  {  [BUGGY]  return  escape;  }        [CLASS]  CSVFormat    [METHOD]  getDelimiter  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {	[BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {	[BUGGY]  if  (  withEscape(  delimiter))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  withEscape  (  delimiter  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {	[BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {	[BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (isLineBreak(delimiter))  {    throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (isLineBreak(delimiter))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  encapsulator;	[BUGGY]  return  delimiter;  [CONTEXT]  public  char  getEncapsulator()  {  [BUGGY]  return  delimiter;  }        [CLASS]  CSVFormat    [METHOD]  getEncapsulator  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  withEscape(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  withEscape  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (isLineBreak(encapsulator))  {    throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (isLineBreak(encapsulator))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.encapsulator  !=  DISABLED;	[BUGGY]  return  this.encapsulator  >=  DISABLED;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  >=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.encapsulator  !=  DISABLED;	[BUGGY]  return  escape  !=  DISABLED;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  escape  !=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.encapsulator  !=  DISABLED;	[BUGGY]  return  this.encapsulator  !=  encapsulator;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  !=  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.encapsulator  !=  DISABLED;	[BUGGY]  return  DISABLED  !=  this.encapsulator;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  DISABLED  !=  this.encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.encapsulator  !=  DISABLED;	[BUGGY]  return  true  ;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  true  ;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  commentStart;	[BUGGY]  return  encapsulator;  [CONTEXT]  public  char  getCommentStart()  {  [BUGGY]  return  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  getCommentStart  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  commentStart;	[BUGGY]  return  escape;  [CONTEXT]  public  char  getCommentStart()  {  [BUGGY]  return  escape;  }        [CLASS]  CSVFormat    [METHOD]  getCommentStart  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  withEscape(  commentStart))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  withEscape  (  commentStart  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (isLineBreak(commentStart))  {    throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (isLineBreak(commentStart))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.commentStart  !=  DISABLED;	[BUGGY]  return  this.commentStart  <=  DISABLED;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  <=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.commentStart  !=  DISABLED;	[BUGGY]  return  escape  !=  DISABLED;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  escape  !=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.commentStart  !=  DISABLED;	[BUGGY]  return  this.commentStart  !=  escape;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  !=  escape;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.commentStart  !=  DISABLED;	[BUGGY]  return  DISABLED  !=  this.commentStart;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  DISABLED  !=  this.commentStart;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.commentStart  !=  DISABLED;	[BUGGY]  return  this.commentStart    ;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  escape;	[BUGGY]  return  encapsulator;  [CONTEXT]  public  char  getEscape()  {  [BUGGY]  return  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  getEscape  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {	[BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {	[BUGGY]  if  (  withEscape(  escape))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  withEscape  (  escape  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {	[BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {	[BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (isLineBreak(escape))  {    throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (isLineBreak(escape))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  comment  start  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[Delete]	[BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.escape  !=  DISABLED;	[BUGGY]  return  this.escape  >=  DISABLED;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  >=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.escape  !=  DISABLED;	[BUGGY]  return  escape  !=  DISABLED;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  escape  !=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.escape  !=  DISABLED;	[BUGGY]  return  this.escape  !=  encapsulator;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  !=  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.escape  !=  DISABLED;	[BUGGY]  return  DISABLED  !=  this.escape;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  DISABLED  !=  this.escape;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  this.escape  !=  DISABLED;	[BUGGY]  return  encapsulator    ;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  surroundingSpacesIgnored;	[BUGGY]  return  emptyLinesIgnored;  [CONTEXT]  public  boolean  isSurroundingSpacesIgnored()  {  [BUGGY]  return  emptyLinesIgnored;  }        [CLASS]  CSVFormat    [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  surroundingSpacesIgnored;	[BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  return  surroundingSpacesIgnored;  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  emptyLinesIgnored;	[BUGGY]  return  surroundingSpacesIgnored;  [CONTEXT]  public  boolean  isEmptyLinesIgnored()  {  [BUGGY]  return  surroundingSpacesIgnored;  }        [CLASS]  CSVFormat    [METHOD]  isEmptyLinesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  lineSeparator;	[BUGGY]  return  CRLF;  [CONTEXT]  public  String  getLineSeparator()  {  [BUGGY]  return  CRLF;  }        [CLASS]  CSVFormat    [METHOD]  getLineSeparator  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVParser  (  in,  this  )  ;	[BUGGY]  return  return    new  CSVPrinter(  out,  this)  ;  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  return  returnnew  CSVPrinter  (  out,  this  );  }        [CLASS]  CSVFormat    [METHOD]  parse  [RETURN_TYPE]  Iterable      Reader  in  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    Reader    in    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
return  new  CSVParser  (  in,  this  )  ;	[BUGGY]  return    new  CSVPrinter(  out,  this)  ;  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  returnnew  CSVPrinter  (  out,  this  );  }        [CLASS]  CSVFormat    [METHOD]  parse  [RETURN_TYPE]  Iterable      Reader  in  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    Reader    in    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
StringWriter  out  =  new  StringWriter  (  )  ;	[BUGGY]  StringWriter  out  =  new  StringBuilder(  )  ;  [CONTEXT]  public  String  format(String...  values)  {  [BUGGY]  StringWriter  out  =  new  StringBuilder  ();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVParser(  in,  this)  .println(  values);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVParser  (  in,  this  ).println  (  values  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVPrinter(    this).println(  values);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (this  )  .println  (  values  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVPrinter(  out,  this).println(  header);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  )  .println  (  header  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVPrinter(  values,  this).println(  out);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  values,  this  )  .println  (  out  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  DEFAULT)  ;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  ).CSVPrinter  (  DEFAULT  );  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]    [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(out,  this).println(values);    }  catch  (IOException  e)  {      }    return  out.toString().trim();        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  PRISTINE)  ;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  ).CSVPrinter  (  PRISTINE  );  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
return  out.toString  (  )  .trim  (  )  ;	[BUGGY]  return  out.toString(  ).append(  );  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    [BUGGY]  return  out.toString  ()  .append  ()  ;  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
return  out.toString  (  )  .trim  (  )  ;	[BUGGY]  return  out  .StringWriter(  )  .trim(  );  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    [BUGGY]  return  out  .StringWriter  ().trim  ()  ;  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
return  out.toString  (  )  .trim  (  )  ;	[BUGGY]    [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    [BUGGY]  return  out.toString().trim();          [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  sb  =  new  StringWriter(  )  ;  [CONTEXT]  public  String  toString()  {  [BUGGY]  StringBuilder  sb  =  new  StringWriter  ();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  if  (  isEscaping(  ))  {  StringBuilder  sb  =  new  StringBuilder(  );  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  StringWriter  out  =  new  StringWriter(  );StringBuilder  sb  =  new  StringBuilder(  );  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Delimiter=<el ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimiter=<el "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Delimiter=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimiter=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb  .append  (  CRLF  )  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append( "Delimiter=< ").append(delimiter).append('>');    if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Delim ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delim "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb  .append  (  lineSeparator  )  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEscaping  (  )  )  {	[BUGGY]  if  (  isEncapsulating(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if(  isEncapsulating  ()){  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (isEscaping())  {    sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');      if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (isEscaping())  {          if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isCommentingEnabled(  ))  {          sb.append(  '  ');          sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isEncapsulating(  ))  {          sb.append(  '  ');          sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;	[BUGGY]  sb  .append(  CRLF)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb  .append  (  CRLF  );  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb.append('  ');    sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "scascape=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "scascape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Escape=< ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append( "Escape=< ").append(escape).append('>');    }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "capscape=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "capscape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Escape=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb  .append  (  lineSeparator  )  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Esc ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Esc "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;	[BUGGY]  sb  .append(  lineSeparator)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb  .append  (  lineSeparator  );  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Escape=< ").append(  escape).append(  '>');  sb.append(  '  ');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');sb.append(  '  ');  sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Escape=< ").append(  escape).append(  '>');sb.append(  '  ');  sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');sb.append(  '  ');  sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');sb.append(  '  ');  sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "scape=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "scape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Escape=<Esc ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=<Esc "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "cap ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "cap "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEncapsulating  (  )  )  {	[BUGGY]  if  (  isEscaping(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if(  isEscaping  ()){  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (isEncapsulating())  {    sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');      if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (isEncapsulating())  {          if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isCommentingEnabled(  ))  {          sb.append(  '  ');          sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isEscaping(  ))  {          sb.append(  '  ');          sb.append(   "Escape=< ").append(  escape).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  [BUGGY]  sb.append('  ');    sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "capsulncapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "capsulncapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Encapsulator=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb  .append  (  lineSeparator  )  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append( "Encapsulator=< ").append(encapsulator).append('>');    }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "ncapsulatoncapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ncapsulatoncapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Encapsulator=< ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Enncapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Enncapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Encapsulator=<Enc ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=<Enc "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "ulator= ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ulator= "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "Encapncapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapncapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isCommentingEnabled  (  )  )  {	[BUGGY]  if  (  isEmptyLinesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if(  isEmptyLinesIgnored  ()){  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (isCommentingEnabled())  {    sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');      if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (isCommentingEnabled())  {          if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isEscaping(  ))  {          sb.append(  '  ');          sb.append(   "Escape=< ").append(  escape).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isEncapsulating(  ))  {          sb.append(  '  ');          sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  [BUGGY]  sb.append('  ');      }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   " ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   " "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CommentStart=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append( "CommentStart=< ").append(commentStart).append('>');    }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CommentStart=<omme ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=<omme "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CommentStart=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CoommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CoommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (  '  '  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  [BUGGY]  sb.append('  ');    sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "ommentommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ommentommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "CommentStart=<Commen ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=<Commen "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUGGY]  sb.append(   "artommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "artommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEmptyLinesIgnored  (  )  )  {	[BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if(  isSurroundingSpacesIgnored  ()){  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUGGY]  sb.append( "  EmptyLines:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if  (isEmptyLinesIgnored())  {    sb.append( "  EmptyLines:ignored ");    if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if  (isEmptyLinesIgnored())  {        if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {          sb.append(   "  SurroundingSpaces:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  EmptyLines:ignored "  )  ;	[BUGGY]  sb.append(   "EmptEmptyLines:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append  (   "EmptEmptyLines:ignored "  )  ;  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  EmptyLines:ignored "  )  ;	[BUGGY]  sb  .append(  CRLF)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb  .append  (  CRLF  );  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  EmptyLines:ignored "  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append( "  EmptyLines:ignored ");    }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  EmptyLines:ignored "  )  ;	[BUGGY]  sb.append(   "  EmptyLines:ignoredtyLines:igno ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append  (   "  EmptyLines:ignoredtyLines:igno "  )  ;  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isSurroundingSpacesIgnored  (  )  )  {	[BUGGY]  if  (  isEmptyLinesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if(  isEmptyLinesIgnored  ()){  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUGGY]  sb.append( "  SurroundingSpaces:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if  (isSurroundingSpacesIgnored())  {    sb.append( "  SurroundingSpaces:ignored ");    return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if  (isSurroundingSpacesIgnored())  {        return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[Delete]	[BUGGY]  if  (  isEmptyLinesIgnored(  ))  {          sb.append(   "  EmptyLines:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]  sb.append(   "s: ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append  (   "s: "  )  ;  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");    }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  sb.append(   "  SurroundingSpaces:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]  sb.append(   "  SurroundingSpaces:ignored:ig ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append  (   "  SurroundingSpaces:ignored:ig "  )  ;  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
return  sb.toString  (  )  ;	[BUGGY]  return  sb.append(  );  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.append  ()  ;  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
return  sb.toString  (  )  ;	[BUGGY]  return  sb  .StringWriter(  )  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb  .StringWriter  ();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
return  sb.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.toString();          [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUGGY]  private  static  final    short    INITIAL_TOKEN_LENGTH  =  50;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  finalshortINITIAL_TOKEN_LENGTH  =  50;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  47;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  47;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUGGY]  private  static  final    short    INITIAL_TOKEN_LENGTH  =  50L;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  finalshortINITIAL_TOKEN_LENGTH  =  50L;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
Token.Type  type  =  INVALID;	[BUGGY]  Token.Type  type  ;  [CONTEXT]      EORECORD  }        [BUGGY]  Token.Type  type  ;        StringBuilder  content  =  new  StringBuilder(INITIAL_TOKEN_LENGTH);              [CLASS]  Token  Type      [VARIABLES]  
content.setLength  (  0  )  ;	[BUGGY]  content.setLength(  INITIAL_TOKEN_LENGTH);  [CONTEXT]  Token  reset()  {  [BUGGY]  content.setLength  (  INITIAL_TOKEN_LENGTH  )  ;  type  =  INVALID;  isReady  =  false;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
content.setLength  (  0  )  ;	[BUGGY]    [CONTEXT]  Token  reset()  {  [BUGGY]  content.setLength(0);    type  =  INVALID;  isReady  =  false;  return  this;        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
type  =  INVALID;	[BUGGY]  type  =  type;  [CONTEXT]  Token  reset()  {  content.setLength(0);  [BUGGY]  type  =  type;  isReady  =  false;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
isReady  =  false;	[BUGGY]  isReady  =  true;  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  [BUGGY]  isReady  =  true;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
return  this;	[BUGGY]  return  null;  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  isReady  =  false;  [BUGGY]  return  null;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
private  final  List<String>  record  =  new  ArrayList<String>  (  )  ;	[BUGGY]  private  final  List<String>  record  ;  [CONTEXT]  private  final  Map<String,  Integer>  headerMapping;              [BUGGY]  private  final  List<String>  record  ;  private  final  Token  reusableToken  =  new  Token();                      [CLASS]  CSVParser  1      [VARIABLES]  
private  final  Token  reusableToken  =  new  Token  (  )  ;	[BUGGY]  private  final  Token  reusableToken  ;  [CONTEXT]              private  final  List<String>  record  =  new  ArrayList<String>();  [BUGGY]  private  final  Token  reusableToken  ;                          [CLASS]  CSVParser  1      [VARIABLES]  
this  (  input,  CSVFormat.DEFAULT  )  ;	[BUGGY]    [CONTEXT]  public  CSVParser(Reader  input)  throws  IOException  {  [BUGGY]  this(input,  CSVFormat.DEFAULT);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  Reader)      Reader  input  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    Map    headerMapping    
format.validate  (  )  ;	[BUGGY]  format  .getHeader(  )  ;  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  format  .getHeader  ();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
format.validate  (  )  ;  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;  this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUGGY]    [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  format.validate();                  [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUGGY]  this.lexer  =  new  CSVLexer(    new  ExtendedBufferedReader(  input));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =  new  CSVLexer  (new  ExtendedBufferedReader  (  input  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUGGY]  this.lexer  =  new  CSVLexer(  input,  new  ExtendedBufferedReader(  format));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =  new  CSVLexer  (  input,  new  ExtendedBufferedReader  (  format  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUGGY]  this.lexer  =    new  CSVLexer(  null,  new  ExtendedBufferedReader(  input));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =new  CSVLexer  (  null,  new  ExtendedBufferedReader  (  input  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this.headerMapping  =  initializeHeader  (  format  )  ;	[BUGGY]  this.headerMapping  =    initializeHeader(  null);  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    [BUGGY]  this.headerMapping  =initializeHeader  (  null  )  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUGGY]    [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    [BUGGY]  this.headerMapping  =  initializeHeader(format);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUGGY]  this(  new  StringReader(  input));  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this  (  new  StringReader  (  input  ))  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUGGY]  this(  new  StringReader(  format),  input);  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this  (  new  StringReader  (  format  )  ,  input  )  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
this  (  new  StringReader  (  input  )  ,  format  )  ;  }	[BUGGY]    [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this(new  StringReader(input),  format);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec;	[BUGGY]  CSVRecord  rec;  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec;	[BUGGY]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  );List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  );  CSVRecord  rec;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec  =  getRecord(  ))  ==  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec  =  getRecord  ())==  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  current  =  getRecord(  ))  !=  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  current  =  getRecord  ())!=  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec  =  toString(  ))  !=  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec  =  toString  ())!=  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  current  =  toString(  ))  !=  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  current  =  toString  ())!=  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
records.add  (  rec  )  ;	[BUGGY]  records.add(  current);  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add  (  current  )  ;  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
records.add  (  rec  )  ;	[BUGGY]    [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add(rec);    }  return  records;        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec    =    while  (  (  rec  ;  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec=while((  rec  ;  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec  =  getRecord(  ))  !=  null)  {  records.add(  rec);while  (  (  rec  =  getRecord(  ))  !=  null)  {  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {  records.add  (  rec  )  ;	[BUGGY]    [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  ((rec  =  getRecord())  !=  null)  {      }  return  records;        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
records.add  (  rec  )  ;	[BUGGY]  records  .add(  rec)  ;  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records  .add  (  rec  );  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;  record.clear  (  )  ;	[BUGGY]  record.clear(  );  CSVRecord  result  =  new  CSVRecord(  null,  headerMapping);  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;  record.clear  (  )  ;	[BUGGY]  CSVRecord  result  =  new  CSVRecord(  null,  headerMapping);CSVRecord  result  =  new  CSVRecord(  null,  headerMapping);  record.clear(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.clear  (  )  ;	[BUGGY]  record.add(  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record.add  ()  ;  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.clear  (  )  ;	[BUGGY]  record  .isEmpty(  )  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record  .isEmpty  ();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.clear  (  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record.clear();    do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUGGY]  record.add(reusableToken.content.toString());  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  if  (reusableToken.isReady)  {    record.add(reusableToken.content.toString());        break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  if  (reusableToken.isReady)  {            break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  null;	[BUGGY]  result  =  true;  [CONTEXT]  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  true;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.add(  reusableToken.content  .getLineNumber(  )  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add  (  reusableToken.content  .getLineNumber  ()  )  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add(reusableToken.content.toString());    }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  null;	[BUGGY]  result  =  false;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  false;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
throw  new  IOException  ( "   ")  ;	[BUGGY]  return  false;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  return  false;  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
reusableToken.reset  (  )  ;	[BUGGY]  reusableToken.Token(  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  reusableToken.Token  ()  ;  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
reusableToken.reset  (  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  reusableToken.reset();    lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
lexer.nextToken  (  reusableToken  )  ;	[BUGGY]  lexer.getLineNumber(  reusableToken);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.getLineNumber  (  reusableToken  )  ;  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
lexer.nextToken  (  reusableToken  )  ;	[BUGGY]  lexer  .getLineNumber(  )  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer  .getLineNumber  ();  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
lexer.nextToken  (  reusableToken  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.nextToken(reusableToken);    switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.add(  reusableToken.content  .getLineNumber(  )  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add  (  reusableToken.content  .getLineNumber  ()  )  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;  break;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add(reusableToken.content.toString());      case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
record.add  (  reusableToken.content.toString  (  )  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.add(reusableToken.content.toString());    break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
throw  new  IOException  ( "   ")  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");    }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  !record.isEmpty  (  )  )  {	[BUGGY]  if  (  !record.clear(  ))  {  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if(  !record.clear  ()){  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUGGY]  result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if  (!record.isEmpty())  {    result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);    return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if  (!record.isEmpty())  {        return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  8  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  8  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  headerMapping.toArray(  new  String[record.size(  )]),  record);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  headerMapping.toArray  (  new  String[record.size  ()  ]  )  ,  record  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size(  )]));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  ()  ]  ))  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.clear(  new  String[record.size(  )]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.clear  (  new  String[record.size  ()  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.add(  )]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.add  ()  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record  .isEmpty(  )  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record  .isEmpty  ()]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result    =    result  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result=result  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[Delete]	[BUGGY]  if  (  !(  record.isEmpty(  )))  {          result  =  new  CSVRecord(  record.toArray(  new  size(  )]),  headerMapping);  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  2  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  2  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record  .add(  current)  ,  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record  .add  (  current  ),  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  5  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  5  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record  .add(  rec)  ,  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record  .add  (  rec  ),  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);    }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  7  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  7  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record  .add(  result)  ,  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record  .add  (  result  ),  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result    =  null  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result=  null  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  5  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  5  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  1  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  1  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
return  result;	[BUGGY]  return  rec;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  [BUGGY]  return  rec;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  format.getHeader(  )  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()==  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  length  ==  0  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  rec  !=  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  header  !=  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  i  <  header.length)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  i  <  header.length  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  format.getHeader(  )  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()!=  false  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  format.getHeader(  ).length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  0  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  ).length  <  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  <  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  ).length  ==  -9)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  -9  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  rec  !=  null  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  ).length  ==  0  )  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  0){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  )  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()!=  null  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUGGY]  org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if(rec  !=  null)  {        header  =  rec.values();};  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if  (format.getHeader().length  ==  0)  {    org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {header  =  rec.values();};        }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if  (format.getHeader().length  ==  0)  {            }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  format.getHeader  (  )  ;	[BUGGY]  header  =    null.getHeader(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =null.getHeader  ()  ;  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  format.getHeader  (  )  ;	[BUGGY]  if  (  format.getHeader(  )  !=  null)  {  header  =  format.getHeader(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  format.getHeader  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  format.getHeader();            if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  rec  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  result  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  result  !=  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  result  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  result  !=  false  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  header  !=  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  current  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  next  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUGGY]  header  =  rec.values();  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if  (rec  !=  null)  {    header  =  rec.values();    }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if  (rec  !=  null)  {        }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[Delete]	[BUGGY]  if  (  (  current)  ==  null)  {          current  =  getNextRecord(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  rec.values  (  )  ;	[BUGGY]  header  =  result.values(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  result.values  ()  ;  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  rec.values  (  )  ;	[BUGGY]  header  =  rec.CSVRecord(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  rec.CSVRecord  ()  ;  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  rec.values  (  )  ;	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  rec.values();    }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
CSVRecord  rec  =  getRecord  (  )  ;	[BUGGY]  CSVRecord  rec  =  toString(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      [BUGGY]  CSVRecord  rec  =  toString  ()  ;  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
CSVRecord  rec  =  getRecord  (  )  ;	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      [BUGGY]  CSVRecord  rec  =  getRecord();    if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  rec  !=  true)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  !=  true  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  header  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  i  <  header.length)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  i  <  header.length  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  header  !=  true)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  !=  true  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  current  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  rec  !=  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  next  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUGGY]  for(int  i  =  0;  i  <(header.length);  i++)  {        hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if  (header  !=  null)  {    for  (int  i  =  0;  i  <  (header.length);  i++)  {hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};      }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if  (header  !=  null)  {          }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (    long    i  =  0;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(longi  =  0;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <=  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  <=  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  -6;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  -6;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[Delete]	[BUGGY]  if  (  header  !=  null)  {          for  (  int  i  =  0;  i  <  (  header.length);  i++)  {                  hdrMap.put(  header[i],  valueOf(  i));          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUGGY]  hdrMap.put(  i[i],  Integer.valueOf(  header));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put  (  i[i],  Integer.valueOf  (  header  ))  ;  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));    }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (    short    i  =  0;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(shorti  =  0;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  i;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  i;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUGGY]  hdrMap  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  [BUGGY]  hdrMap  ;    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  format.getHeader  (  )  ;	[BUGGY]  header  =  format  .validate(  )  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  format  .validate  ();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format  .validate(  )  .length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format  .validate  ().length  ==  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  ).length  <=  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  <=  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUGGY]  if  (  format.getHeader(  ).length  ==  i)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  i  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  rec.values  (  )  ;	[BUGGY]  header  =  rec  .CSVRecord(  3)  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  rec  .CSVRecord  (  3  );  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  rec  !=  null  )  {	[BUGGY]  if  (  rec  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  !=  false  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
header  =  rec.values  (  )  ;	[BUGGY]  header  =  result.CSVRecord(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  result.CSVRecord  ()  ;  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  header  !=  null  )  {	[BUGGY]  if  (  header  !=  this)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  !=  this  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  9;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  9;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  >  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  >  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUGGY]  for  (  int  i  =  -3;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  -3;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  result  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  ==  false)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  false  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  header  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  rec  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]  current  =  getNextRecord();  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]    [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  rec  !=  null)  {          header  =  rec.values(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =  null  ;  [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=  null  ;  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  result  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  true  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  header  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  rec  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  false)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  false  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  header  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  rec  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
next  =  getNextRecord  (  )  ;	[BUGGY]  next  ;  [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
next  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  result  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  this)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  this  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  getRecord  (  )  ;	[BUGGY]  return  toString(  );  [CONTEXT]  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString  ()  ;  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  getRecord  (  )  ;	[BUGGY]    [CONTEXT]  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                      [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =    current  ;  [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
current  =  null;	[BUGGY]  current  =  false;  [CONTEXT]      public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  false;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
current  =  null;	[BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  new  Iterator<CSVRecord>  (  )  {	[BUGGY]  return  new  Iterator;  [CONTEXT]      if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  [BUGGY]  return  new  Iterator;  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  return  current  ==  null;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  return  result  !=  null;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  result  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  returnresult  ;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  returnresult  ;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  next;	[BUGGY]  return  result;  [CONTEXT]  return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  result;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
CSVRecord  next  =  current;	[BUGGY]  CSVRecord  next  =  result;  [CONTEXT]          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
CSVRecord  next  =  current;	[BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  return  ;  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
throw  new  UnsupportedOperationException  ( "   ")  ;	[BUGGY]  return  false;  [CONTEXT]  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  [BUGGY]  return  false;  }  };  }                                    public  int  getLineNumber()  {  return  lexer.getLineNumber();  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  result  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  ==  true)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  true  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  header  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  rec  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]  current  =  getNextRecord();  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  rec  !=  null)  {          header  =  rec.values(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =    current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =  null  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=  null  ;  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  return  current  ==  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  return  result  !=  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  result  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  return  current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  current  !=  null;	[BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
CSVRecord  next  =  current;	[BUGGY]  CSVRecord  next  =  result;  [CONTEXT]  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
CSVRecord  next  =  current;	[BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
current  =  null;	[BUGGY]  current  =  true;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  true;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
current  =  null;	[BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  result  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  this)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  this  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  header  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  rec  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  result  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  true  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  header  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {	[BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  rec  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
next  =  getNextRecord  (  )  ;	[BUGGY]  next    =    next  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
next  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  return  ;  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  next;	[BUGGY]  return  result;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
return  getRecord  (  )  ;	[BUGGY]  return  toString(  );  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString  ()  ;  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  getRecord  (  )  ;	[BUGGY]    [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
return  lexer.getLineNumber  (  )  ;	[BUGGY]    [CONTEXT]  public  int  getLineNumber()  {  [BUGGY]  return  lexer.getLineNumber();          [CLASS]  CSVParser  1    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
if  (  current  ==  null  )  {	[BUGGY]  if  (  current  ==  false)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  false  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
if  (  current  ==  null  )  {	[BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]  current  =  getNextRecord();  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =  null  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=  null  ;  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
current  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
current  =  getNextRecord  (  )  ;	[BUGGY]  current    =    current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
return  current  !=  null;	[BUGGY]  return  current  ==  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
return  current  !=  null;	[BUGGY]  return  current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
return  current  !=  null;	[BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
current  =  null;	[BUGGY]  current  =  false;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  false;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
current  =  null;	[BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  this)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  this  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  false)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  false  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[Delete]	[BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
next  =  getNextRecord  (  )  ;	[BUGGY]  next    =    next  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  return  ;  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
next  =  getNextRecord  (  )  ;	[BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
if  (  next  ==  null  )  {	[BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  true  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
return  next;	[BUGGY]  return  current;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  current;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
return  getRecord  (  )  ;	[BUGGY]    [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    IOException    e    boolean    
private  boolean  newLine  =  true;	[BUGGY]  private  boolean  newLine  =  false;  [CONTEXT]      private  final  Appendable  out;  private  final  CSVFormat  format;        [BUGGY]  private  boolean  newLine  =  false;                          [CLASS]  CSVPrinter      [VARIABLES]  
this.out  =  out;	[BUGGY]  this.out  =    null;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  [BUGGY]  this.out  =null;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUGGY]  this.format  =  format(  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  (  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format.validate  (  )  ;	[BUGGY]  this.format.getEscape(  );  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    [BUGGY]  this.format.getEscape  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
this.format.validate  (  )  ;  }	[BUGGY]    [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    [BUGGY]  this.format.validate();          [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out  .append  ();  newLine  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  format.getEncapsulator(  ));  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append  (  format.getEncapsulator  ())  ;  newLine  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;  newLine  =  true;  }	[BUGGY]    [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(format.getLineSeparator());            [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]    out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  format.getCommentStart(  ));out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getLineSeparator  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
newLine  =  true;	[BUGGY]  newLine  =  false;  [CONTEXT]  public  void  println()  throws  IOException  {  out.append(format.getLineSeparator());  [BUGGY]  newLine  =  false;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  out  instanceof  Flushable  )  {	[BUGGY]  if  (  out    !=    Flushable)  {  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if(  out!=Flushable  ){  ((Flushable)  out).flush();  }  }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUGGY]  ((java.io.Flushable)(out)).flush();  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if  (out  instanceof  Flushable)  {    ((java.io.Flushable)  (out)).flush();          [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUGGY]    [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if  (out  instanceof  Flushable)  {              [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
(  (  Flushable  )  out  )  .flush  (  )  ;	[BUGGY]  (  (  Flushable)  out)  .flush(  )  ;  [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  ((  Flushable  )out  ).flush  ();  }  }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
(  (  Flushable  )  out  )  .flush  (  )  ;	[BUGGY]    [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  ((Flushable)  out).flush();    }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
for  (  String  value  :  values  )  {	[BUGGY]  for  (  char  value  :  values)  {  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  [BUGGY]  for(  char  value  :  values  ){  print(value);  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
print  (  value  )  ;	[BUGGY]  printComment(  value);  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  printComment  (  value  )  ;  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
print  (  value  )  ;	[BUGGY]    [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  print(value);    }  println();        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
println  (  )  ;	[BUGGY]  printSep(  );  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  printSep  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
println  (  )  ;	[BUGGY]    [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  println();          [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
if  (  !format.isCommentingEnabled  (  )  )  {	[BUGGY]  if  (  !format.getCommentStart(  ))  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if(  !format.getCommentStart  ()){  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !format.isCommentingEnabled  (  )  )  {	[BUGGY]  if  (  format.isEncapsulating(  ))  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if(  format.isEncapsulating  ()){  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUGGY]  return  ;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (!format.isCommentingEnabled())  {    return  ;    if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (!format.isCommentingEnabled())  {        if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[Delete]	[BUGGY]  if  (  !(  format.isCommentingEnabled(  )))  {          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !newLine  )  {	[BUGGY]  if  (  newLine)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if(  newLine  ){  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !newLine  )  {	[BUGGY]  if  (  !quote)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if(  !quote  ){  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !newLine  )  {  println  (  )  ;  }	[BUGGY]  println();  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (!newLine)  {    println();    out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  !newLine  )  {  println  (  )  ;  }	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (!newLine)  {        out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  printSep  ()  ;  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  println();    }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append  (  format.getEscape  ())  ;  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;  out.append  (  '  '  )  ;	[BUGGY]  out.append(  '  ');  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;  out.append  (  '  '  )  ;	[BUGGY]  out.append(  format.getCommentStart(  ));out.append(  format.getCommentStart(  ));  out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;  out.append  (  '  '  )  ;	[BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getCommentStart(  ));  out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;  out.append  (  '  '  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getCommentStart(  ));  out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  '  ');  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');    for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length(  )  ||  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()||  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  >  comment.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  >  comment.length  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i    |    1  <  comment.length(  )  &&  comment.charAt(  i    |    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i|1  <  comment.length  ()&&  comment.charAt  (  i|1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  !=  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()&&  comment.charAt  (  i  +  1  )!=  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i    >=    1  <  comment.length(  )  &&  comment.charAt(  i    >=    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i>=1  <  comment.length  ()&&  comment.charAt  (  i>=1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i    <  comment.length(  )  &&  comment.charAt(  i  )  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i<  comment.length  ()&&  comment.charAt  (  i)==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  i  <  comment.length(  )  &&  comment.charAt(  i  +  i)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  i  <  comment.length  ()&&  comment.charAt  (  i  +  i  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length()  -  7    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  7&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  comment  +  1  <  i.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  comment  +  1  <  i.length  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length(  )){  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ())  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (    comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  comment.charAt(  (  i  +  1))  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  comment.charAt  ((  i  +  1  ))==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.charAt(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.charAt  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (    comment.charAt(  i  +  0  )  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(comment.charAt  (  i  +  0)==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUGGY]  i++;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {    i++;        case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {            case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (    short    i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(shorti  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <=  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <=  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  >  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  >  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for    <=  (  int  i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for<=(  int  i  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for    &&  (  int  i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for&&(  int  i  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  i;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  i;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  7  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  -  7  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  commentnt  i  =  0;  i  <  i.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  commentnt  i  =  0;  i  <  i.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  cnt  i  =  0;  i  <  iomment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  cnt  i  =  0;  i  <  iomment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  comment.charAt(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.charAt  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  ==  comment.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  ==  comment.length  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i    !=    1  <  comment.length(  )  &&  comment.charAt(  i    !=    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i!=1  <  comment.length  ()&&  comment.charAt  (  i!=1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  >=  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()&&  comment.charAt  (  i  +  1  )>=  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length()  -  5    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  5&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  0    <  comment.charAt(  )){  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  0<  comment.charAt  ())  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
char  c  =  comment.charAt  (  i  )  ;	[BUGGY]  int  c  =  comment.charAt(  i);  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  int  c  =  comment.charAt  (  i  )  ;  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
char  c  =  comment.charAt  (  i  )  ;	[BUGGY]  char  c  =  i.charAt(  comment);  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  i.charAt  (  comment  )  ;  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
char  c  =  comment.charAt  (  i  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);    switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length()  -  2    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  2&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length()  +  9    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  +  9&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  [BUGGY]  printSep  ()  ;  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  [BUGGY]  println();    out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getCommentStart(  ));  println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getCommentStart(  ));println(  );  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getLineSeparator(  ));println(  );  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));println(  );  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  [BUGGY]  out  .append  ();  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  [BUGGY]  out.append  (  format.getEscape  ())  ;  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  '  ');  out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  format.getCommentStart  (  )  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;  break;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');      default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  default:  out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  c);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  value);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  encapsulator);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  out.append(  escape);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out  .append(  4  ,  i  ,  i)  ;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out  .append  (  4  ,  i  ,  i  );  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(c);    break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]    out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out.append(  value);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out.append(  encapsulator);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out.append(  '  ');out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out.append(  escape);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (    long    i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(longi  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  +  3  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  +  3  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  +  6  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  +  6  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment.length()  -  4    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  4&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]  print(  value);println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]  printSep(  );println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');    break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  '  '  )  ;	[BUGGY]  break;  out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
out.append  (  c  )  ;  break;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(c);      }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  printSep  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
println  (  )  ;	[BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  println();          [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
if  (  format.isEncapsulating  (  )  )  {	[BUGGY]  if  (  format.isEscaping(  ))  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  if(  format.isEscaping  ()){  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[Delete]	[BUGGY]  if  (  format.isEscaping(  ))  {          printAndEscape(  value,  offset,  len);  }else  {          printSep(  );          out.append(  value,  offset,  (  offset  +  len));  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
}  else  if  (  format.isEscaping  (  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
}  else  if  (  format.isEscaping  (  )  )  {	[BUGGY]    else  if  (  format.isEncapsulating(  ))  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if(  format.isEncapsulating  ()){  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
}  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUGGY]  printAndEscape(value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if  (format.isEscaping())  {    printAndEscape(value,  offset,  len);        }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
}  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if  (format.isEscaping())  {            }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[Delete]	[BUGGY]  if  (  format.isEncapsulating(  ))  {          printAndEncapsulate(  value,  offset,  len);  }else          if  (  format.isEscaping(  ))  {                  printAndEscape(  value,  offset,  len);          }else  {                  printSep(  );                  out.append(  value,  offset,  (  offset  +  len));          }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  println  ()  ;  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  printSep();    out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]    printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(    offset,  offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (offset,  offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  offset,  value,  offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  offset,  value,  offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,    offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  len,  offset  +  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  len,  offset  +  offset  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out  .append  ();  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(value,  offset,  offset  +  len);    }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  len,  offset,  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  len,  offset,  value  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(    offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (offset,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  value,  len,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  len,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  value,    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  value,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate  (  value,  offset,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(value,  offset,  len);    }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  offset,  value,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  offset,  value,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  value,  offset,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  offset,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  printSep();      }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printSep  (  )  ;	[BUGGY]  out.append(  value,  offset,  offset  +  len);  printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  offset,  offset    ==    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset==len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  offset,  offset  +  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset  +  offset  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  offset,  value,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  offset,  value,  len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(    offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (offset,  len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  value,  len,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,  len,  offset  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  value,    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  value,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,  offset  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape(  value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEscape  (  value,  offset,  len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(value,  offset,  len);    }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  offset,  offset    <<    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset<<len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  len,  offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  len,  offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  value,  offset,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,  offset,  offset  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate(  len,  offset,  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  len,  offset,  value  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  value,  offset,  offset    &    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset&len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
out.append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out.append(  len,  offset,  offset  +  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  len,  offset,  offset  +  value  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
if  (  newLine  )  {	[BUGGY]  if  (  !newLine)  {  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if(  !newLine  ){  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  newLine  )  {	[BUGGY]  if  (  !quote)  {  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if(  !quote  ){  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUGGY]  newLine  =  false;  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (newLine)  {    newLine  =  false;              [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUGGY]    [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (newLine)  {                  [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getDelimiter  (  )  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out  .append  ();  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getDelimiter  (  )  )  ;	[BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append  (  format.getEscape  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
out.append  (  format.getDelimiter  (  )  )  ;  }	[BUGGY]    [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(format.getDelimiter());            [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
newLine  =  false;	[BUGGY]  newLine  =  true;  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  [BUGGY]  newLine  =  true;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
int  start  =  offset;	[BUGGY]  long    start  =  offset;  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  longstart  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  start  =  pos;  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  int  start  =  pos;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  pos  =  offset;  int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  short    pos  =  offset;  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  shortpos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  pos  =  start;  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  int  pos  =  start;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  end  =  offset  +  len;  int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  start  =  offset;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  short    end  =  offset  +  len;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  shortend  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  start  +  len;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  offset  +  start;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  len  +  offset;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );  [CONTEXT]  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  println  ()  ;    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
printSep  (  )  ;	[BUGGY]    [CONTEXT]  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  printSep();      char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  int  delim  =  format.getDelimiter(  );  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  int  delim  =  format.getDelimiter  ()  ;  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  delim  =  format.getEscape(  );  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  char  delim  =  format.getEscape  ()  ;  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  escape  =  format.getEscape(  );  char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  encapsulator  =  format.getEncapsulator(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  this.format.validate(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  escape  =  format.getEscape  (  )  ;	[BUGGY]  int  escape  =  format.getEscape(  );  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  int  escape  =  format.getEscape  ()  ;    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  escape  =  format.getEscape  (  )  ;	[BUGGY]  char  escape  =  format.isEscaping(  );  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format.isEscaping  ()  ;    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  escape  =  format.getEscape  (  )  ;	[BUGGY]  char  escape  =  format  .getEncapsulator(  )  ;  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format  .getEncapsulator  ();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  pos  <=  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  start  <  end)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  start  <  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  pos  <  start  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'){  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  )  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (    c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (((c  ==  '\r')  ||(c  ==  '\n')  ||  c  ==  delim))  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\r')  ||  (c  ==  '\n')  ||  c  ==  delim)  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  ((c  ==  '\r'  ||  c  ==  '\n'))  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\r'  ||  c  ==  '\n')  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  pos  >  start)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  >  start  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  pos  +  1)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  +  1  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (    c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]  if(pos  >  start)  {        out.append(value,  start,  pos);};  if(c  ==  '\n')  {        c  =  'n';}else        if(c  ==  '\r')  {                c  =  'r';        };  out.append(escape);  out.append(c);  start  =  pos  +  1;  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {out.append(value,  start,  pos);};  if  (c  ==  '\n')  {c  =  'n';}elseif  (c  ==  '\r')  {c  =  'r';};  out.append(escape);  out.append(c);  start  =  pos  +  1;        if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]    [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {            if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  <  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  <  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  start  >  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  start  >  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >  offset)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >  offset  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  start  >  pos)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  start  >  pos  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]  out.append(value,  start,  pos);  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if  (pos  >  start)  {    out.append(value,  start,  pos);    if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]    [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if  (pos  >  start)  {        if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  ==  encapsulator)  {          out.append(  value,  start,  (  pos  +  1));          start  =  pos;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  pos,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(    start,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (start,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,    pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  offset  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]    [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append(value,  start,  pos);    }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  c  !=  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  !=  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  c  >=  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  >=  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  escape  ==  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  escape  ==  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  ==  '\r'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]  c  =  'n';  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (c  ==  '\n')  {    c  =  'n';          out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]    [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (c  ==  '\n')  {              out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  if  (  c  >=  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  >=  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  if  (  escape  ==  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  escape  ==  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]  c  =  'r';  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (c  ==  '\r')  {    c  =  'r';      out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]    [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (c  ==  '\r')  {          out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
c  =  'r';	[BUGGY]  c  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
c  =  'n';	[BUGGY]  c  ;  [CONTEXT]  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  ;  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  if  (  c  !=  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  !=  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]      if  (  escape  ==  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }if(  escape  ==  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
c  =  'r';	[BUGGY]  c    =    c  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c=c  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
c  =  'r';	[BUGGY]  c    =  null  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c=  null  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  end;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  end;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  start  +  1;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  start  +  1;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  1L;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  1L;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out  .append  ();  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  delim);  [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out.append  (  delim  )  ;  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]    [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out.append(escape);    out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  c);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  value);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  encapsulator);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;	[BUGGY]  out.append(  '  ');out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out.append(  escape);  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out.append  (  escape  )  ;    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  c  )  ;	[BUGGY]    [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out.append(c);      start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >=  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >=  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  offset  >  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  offset  >  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >  pos)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >  pos  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  offset,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  start,  value,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  start,  value,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  c  <  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  <  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
c  =  'n';	[BUGGY]  c    =    c  ;  [CONTEXT]  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c=c  ;  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  if  (  c  >  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  >  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  ;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  ;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);    if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  c);  out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  escape);  out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  escape);  out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  encapsulator);out.append(  escape);  out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  escape);  out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUGGY]  out.append(  escape);out.append(  escape);  out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  <  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  <  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (    c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  if  (  c  <  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  <  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  len;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  len;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  2;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  2;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  pos,  start,  value);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  pos,  start,  value  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out  .append(  value  ,  offset  ,  len)  ;  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out  .append  (  value  ,  offset  ,  len  );    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out  .append(  value  ,  offset  ,  end)  ;  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out  .append  (  value  ,  offset  ,  end  );    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  ;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  ;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
start  =  pos  +  1;	[BUGGY]  start  =  pos  +  3;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  3;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  c  )  ;	[BUGGY]  out  .append(  value  ,  offset  ,  pos)  ;  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out  .append  (  value  ,  offset  ,  pos  );    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >=  start)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  pos  >=  start  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  offset  >  start)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  offset  >  start  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >  offset)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  pos  >  offset  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  start  >  pos)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  start  >  pos  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {	[BUGGY]  if  (  start  >  start)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  start  >  start  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]  out.append(value,  start,  pos);  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if  (pos  >  start)  {    out.append(value,  start,  pos);    }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUGGY]    [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if  (pos  >  start)  {        }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  ==  encapsulator)  {          out.append(  value,  start,  (  pos  +  1));          start  =  pos;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  offset,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  offset  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  start,  value,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  start,  value,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(    start,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (start,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  start  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,    pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  pos,  start,  value);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  pos,  start,  value  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append(value,  start,  pos);    }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  pos,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
boolean  first  =  newLine;	[BUGGY]  boolean  first  =  quote;  [CONTEXT]  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  boolean  first  =  quote;  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
boolean  first  =  newLine;	[BUGGY]  boolean  quote  =  false;  boolean  first  =  newLine;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
boolean  quote  =  false;	[BUGGY]  boolean  quote  =  true;  [CONTEXT]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  [BUGGY]  boolean  quote  =  true;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
boolean  quote  =  false;	[BUGGY]  boolean  first  =  newLine;boolean  quote  =  false;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  short    start  =  offset;  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  shortstart  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  start  =  pos;  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  int  start  =  pos;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  pos  =  offset;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  start  =  offset;	[BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  long    pos  =  offset;  [CONTEXT]  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  longpos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  pos  =  start;  [CONTEXT]  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  int  pos  =  start;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  end  =  offset  +  len;  int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  pos  =  offset;	[BUGGY]  int  start  =  offset;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  short    end  =  offset  +  len;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  shortend  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  start  +  len;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  offset  +  start;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
int  end  =  offset  +  len;	[BUGGY]  int  end  =  len  +  offset;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );  [CONTEXT]  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  println  ()  ;    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
printSep  (  )  ;	[BUGGY]    [CONTEXT]  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  printSep();      char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  int  delim  =  format.getDelimiter(  );  [CONTEXT]      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  int  delim  =  format.getDelimiter  ()  ;  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  delim  =  format.getEscape(  );  [CONTEXT]      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  char  delim  =  format.getEscape  ()  ;  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  escape  =  format.getEscape(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  char  encapsulator  =  format.getEncapsulator(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  this.format.validate(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  delim  =  format.getDelimiter  (  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  String  encapsulator  =  format.getEncapsulator(  );  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  String  encapsulator  =  format.getEncapsulator  ()  ;    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUGGY]  char  encapsulator  =  format.isEncapsulating(  );  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  encapsulator  =  format.isEncapsulating  ()  ;    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <=  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  offset  <  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  offset  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  pos)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  end  <  pos)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  end  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  start)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  start  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r'))  ||  (  c  ==  encapsulator))  ||  (  c  ==  delim))  {          quote  =  true;          break;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'){  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  delim  ==  '\n'){  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]  quote  =  true;  break;  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    quote  =  true;  break;      pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]    [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {          pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]    quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  start);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =null.charAt  (  pos  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(pos);    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  len  <  0)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <  0  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  len  >  0)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  >  0  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  len  <=  end)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <=  end  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  start  <=  0)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  start  <=  0  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  first  &&(((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a')))  ||(c  >  'z'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  first  &&  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a')))  ||  (c  >  'z')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a'))  ||  c  >  'z')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A'))  ||  (c  >  'Z')  &&  (c  <  'a'))  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  <  '0'  ||  (c  >  '9')  &&  (c  <  'A'))  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  <  '0')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  '0'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  >  '9'  &&  c  <  'A')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  >  '9')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  '9'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  <  'A')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  'A'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  >  'Z'  &&  c  <  'a')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  >  'Z')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  'Z'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  <  'a')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  'a'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  >  'z')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  'z'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  <=  '#')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <=  '#'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  pos  <  end)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  pos  <  end  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  '\n'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  '\r'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  encapsulator  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  delim  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  end  -  1)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  end  -  1  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <=  '  '  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  len  <=  0  )  {	[BUGGY]  if  (  len  <=  0  >>  2)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <=  0  >>  2  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  ==  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  ==  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  start  <  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  start  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;  break;	[BUGGY]  break;  quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;  break;	[BUGGY]  quote  =  true;quote  =  true;  break;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  ||(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  &&  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  &&(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <=  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <=  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >=  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >=  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <=  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <=  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >=  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >=  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <=  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <=  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  quote  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  quote  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  delim  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  delim  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a'))  ||  c  >  'z')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a'))  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A'))  ||  (c  >  'Z')  &&  (c  <  'a'))  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A'))  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  <  '0'  ||  (c  >  '9')  &&  (c  <  'A'))  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  <  '0'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  '0'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  ((c  >  '9'  &&  c  <  'A')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  >  '9'  &&  c  <  'A')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  >  '9'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  '9'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  <  'A'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  'A'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  ((c  >  'Z'  &&  c  <  'a')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  >  'Z'  &&  c  <  'a')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  >  'Z'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  'Z'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  >  'z'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  'z'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  <=  '#'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <=  '#'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  pos  <  end  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  pos  <  end  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator)  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  ==  '\n'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  '\n'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  ==  '\r'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  '\r'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  ==  encapsulator  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  encapsulator  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  ==  delim  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  delim  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  end  -  1  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  end  -  1  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  c  <=  '  '  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <=  '  '  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  break;  quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  ==  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  <  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  <  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  delim  <=  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  delim  <=  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  pos  <  end)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  pos  <  end  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  ==  '\n')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '\n'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  ==  '\r')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '\r'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  ==  encapsulator)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  encapsulator  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  ==  delim)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  delim  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  end  -  1)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  end  -  1  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  c  <=  '  ')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  <=  '  '  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  ==  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  ==  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  offset  <  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  offset  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  start  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r'))  ||  (  c  ==  encapsulator))  ||  (  c  ==  delim))  {          quote  =  true;          break;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'){  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]  quote  =  true;  break;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    quote  =  true;  break;      pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {          pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  break;  quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  start);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =null.charAt  (  pos  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(pos);    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]    quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  !newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  !newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  c  <=  '  '  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  first)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  first  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  <  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  <  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  encapsulator  <=  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  len  <=  0)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  len  <=  0  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '\n'  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]  quote  =  true;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {    quote  =  true;    }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {        }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  first)  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    >    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end>1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  ;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  ;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  start  -  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  0;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  start);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  start  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt  (  value  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =null.charAt  (  pos  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(pos);                if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;  break;	[BUGGY]  break;  quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;  break;	[BUGGY]  quote  =  true;quote  =  true;  break;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    &&    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  2;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  2;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  offset  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              [BUGGY]  quote  =  false;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);                [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  !newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  !newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  c  <=  '  '  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  quote)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  quote  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  first)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  first  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  <  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  <  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  <=  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  encapsulator  <=  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  len  <=  0)  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  len  <=  0  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '\n'  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]  quote  =  true;  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {    quote  =  true;    }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]    [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {        }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  first)  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    <=    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<=1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  start;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  start;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  start  -  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  2;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  2;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  start);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  start  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt  (  value  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =null.charAt  (  pos  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(pos);                if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    &&    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  ;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  ;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  *  0;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  *  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]              if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  [BUGGY]  quote  =  false;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
}  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  if  (  encapsulator  <=  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  encapsulator  <=  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  start  <  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  start  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  end  <  pos)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  end  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  <  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  <  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  >  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  >  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    <    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  pos  -  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  +  3;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  +  3;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;  c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  pos);  pos  =  end  -  1;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;  c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  pos);pos  =  end  -  1;  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  <<  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  <<  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (    c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    &    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  pos  -  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  /  0;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  /  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    ==    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end==1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  0;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  String  c  =  value.charAt(  pos);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  String  c  =  value.charAt  (  pos  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt(pos);          if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  )  {	[BUGGY]  if  (  !quote)  {  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if(  !quote  ){  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  )  {  quote  =  true;  }	[BUGGY]  quote  =  true;  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if  (first)  {    quote  =  true;    }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  )  {  quote  =  true;  }	[BUGGY]    [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if  (first)  {        }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
quote  =  true;	[BUGGY]  quote  =  false;  [CONTEXT]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  [BUGGY]  quote  =  false;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {                [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  )  {	[BUGGY]  if  (  quote)  {  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if(  quote  ){  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  >  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  >  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  ==  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  ==  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  newLine  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  newLine  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  &&  (  encapsulator  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  encapsulator  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  quote)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  quote  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    >>    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end>>1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  ==  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    <<    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  len;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  len;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  *  3;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  *  3;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    >    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end>1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    |    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end|1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  +  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  +  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;  c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  pos);  pos  =  end  -  1;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;  c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  pos);pos  =  end  -  1;  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  -  4;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  -  4;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    &    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    <<    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  pos;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  pos;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  3;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  3;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
c  =  value.charAt  (  pos  )  ;	[BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  offset  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  ==  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end    ||    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end||1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
pos  =  end  -  1;	[BUGGY]  pos  =  end  -  1  <<  0;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  <<  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  !newLine)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  !newLine  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  newLine)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  newLine  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {	[BUGGY]  if  (  first)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  first  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUGGY]  out.append(value,  start,  end);  return  ;  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if  (!quote)  {    out.append(value,  start,  end);  return  ;              out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUGGY]    [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if  (!quote)  {                  out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  pos,  end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  pos,  end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  start,  pos);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  start,  pos  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(    start,  end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (start,  end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  end,  start);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  end,  start  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,    end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  start);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  start  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out  .append  ();  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;  return;	[BUGGY]    [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append(value,  start,  end);      }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  start,  start);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  start,  start  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  start,  value,  end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  start,  value,  end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  end,  start,  value);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  end,  start,  value  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]    [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append(value,  start,  end);    return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]    out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  print(  value,  true);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  encapsulator);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  printAndEscape(  value,  offset,  len);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  format.getDelimiter(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  '  ');out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  end  )  ;	[BUGGY]  out.append(  escape);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  delim);  [CONTEXT]      if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [BUGGY]  out.append  (  delim  )  ;            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]  out  .append(  value  ,  offset  ,  end)  ;  [CONTEXT]      if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [BUGGY]  out  .append  (  value  ,  offset  ,  end  );            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]    [CONTEXT]      if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [BUGGY]  out.append(encapsulator);              while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  >  end)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  >  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  start  <  end)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  start  <  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  <  start  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  end  <  pos)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  end  <  pos  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  <  pos)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  <  pos  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  c  !=  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  encapsulator  ==  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  encapsulator  ==  c)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  c  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  pos  +  1)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  +  1  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[Delete]	[BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
start  =  pos;	[BUGGY]  start  =  offset;  [CONTEXT]        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          [BUGGY]  start  =  offset;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
start  =  pos;	[BUGGY]  start  =    null;  [CONTEXT]        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          [BUGGY]  start  =null;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  pos    ||    1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos||1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  len);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  +  len  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  offset,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  offset,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(    start,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (start,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  pos,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  pos,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,    pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]    [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append(value,  start,  pos  +  1);            start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
start  =  pos;	[BUGGY]  start  =  start;  [CONTEXT]        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          [BUGGY]  start  =  start;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  String  c  =  value.charAt(  pos);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  String  c  =  value.charAt  (  pos  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]    [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);    if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  pos    >=    1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos>=1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  pos  );  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos)  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  start,  value,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  start,  value,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  pos,  start,  value  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  pos,  start,  value  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out  .append(  )  ;  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out  .append  ();          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  delim  ==  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  pos      instanceof      1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  instanceof  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
char  c  =  value.charAt  (  pos  )  ;	[BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  out.append(  value,  start,  offset  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  offset  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  offset,  pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  start,  offset  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(    start,  pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (start,  pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  pos,  start  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,    pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]  out.append(  value,  start);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  start  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;	[BUGGY]    [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append(value,  start,  pos);    out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;  out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  encapsulator);  out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;  out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  value,  start,  end);out.append(  value,  start,  pos);  out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;  out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  value,  start,  pos);out.append(  value,  start,  pos);  out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  value,  start,  pos  )  ;  out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  pos);  out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]  out.append(  delim);  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  [BUGGY]  out.append  (  delim  )  ;  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]    [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  [BUGGY]  out.append(encapsulator);    }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
out.append  (  encapsulator  )  ;	[BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
if  (  value  ==  null  )  {	[BUGGY]  if  (  value  !=  null)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if(  value  !=  null  ){      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
if  (  value  ==  null  )  {	[BUGGY]  if  (  value  ==  this)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if(  value  ==  this  ){      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
if  (  value  ==  null  )  {  value  =   " ";  }	[BUGGY]  value  =   " ";  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (value  ==  null)  {    value  =   " ";        if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
if  (  value  ==  null  )  {  value  =   " ";  }	[BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (value  ==  null)  {            if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[Delete]	[BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[Delete]	[BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
value  =   " ";	[BUGGY]  value    =    value  ;  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      [BUGGY]  value=value  ;  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
if  (  !checkForEscape  )  {	[BUGGY]  if  (  !quote)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    [BUGGY]  if(  !quote  ){      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  -4,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  -4,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  0,  value.length()  +  2  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  +  2)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  printAndEscape(  value,  0,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  printAndEscape  (  value,  0,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  0,  value.charAt(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.charAt  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print(value,  0,  value.length());    }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  0,  value.length()  -  3  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  -  3)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      [BUGGY]  println  ()  ;  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;	[BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      [BUGGY]  printSep();    out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;	[BUGGY]  out.append(  value);  printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;	[BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;	[BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
out.append  (  value  )  ;	[BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  [BUGGY]  out.append(value);    }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
printSep  (  )  ;  out.append  (  value  )  ;	[BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      [BUGGY]  printSep();      }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  9,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  9,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  0,  value.length()  -  8  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  -  8)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  0,  value.length  (  )  )  ;	[BUGGY]  print(  value,  0,  value.length()  -  1  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  -  1)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  true  )  ;	[BUGGY]  print(  value,  false);  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print  (  value,  false  )  ;  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  true  )  ;	[BUGGY]  CSVPrinter(  value,  true);  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  CSVPrinter  (  value,  true  )  ;  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
print  (  value,  true  )  ;	[BUGGY]    [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print(value,  true);          [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[-8];  [CONTEXT]              public  class  CSVRecord  implements  Serializable,  Iterable<String>  {    [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[-8];        private  final  String[]  values;              [CLASS]  CSVRecord      [VARIABLES]  
private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];  [CONTEXT]              public  class  CSVRecord  implements  Serializable,  Iterable<String>  {    [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];        private  final  String[]  values;              [CLASS]  CSVRecord      [VARIABLES]  
private  final  Map<String,  Integer>  mapping;	[BUGGY]  private    Map<String,  Integer>  mapping;  [CONTEXT]        private  final  String[]  values;        [BUGGY]  privateMap<String,  Integer>  mapping;    CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord      [VARIABLES]  
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this.values    =    EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values=EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this.values    =    values  ;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values=values  ;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this.values  =  values  !=  true  ?  values  :  EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  !=  true  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;	[BUGGY]  this.mapping  =  mapping;  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  [CONTEXT]        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;	[BUGGY]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  [CONTEXT]        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
this.mapping  =  mapping;	[BUGGY]  this.mapping  =    null;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =null;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  values[i];	[BUGGY]  return  EMPTY_STRING_ARRAY[i];  [CONTEXT]  public  String  get(int  i)  {  [BUGGY]  return  EMPTY_STRING_ARRAY[i];  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      int  i  [VARIABLES]  String[]    EMPTY_STRING_ARRAY    values    boolean    Map    mapping    int    i    
if  (  mapping  ==  null  )  {	[BUGGY]  if  (  mapping  !=  null)  {  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if(  mapping  !=  null  ){  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
if  (  mapping  ==  null  )  {	[BUGGY]  if  (  mapping  ==  true)  {  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if(  mapping  ==  true  ){  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUGGY]  throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (mapping  ==  null)  {    throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");      Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUGGY]    [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (mapping  ==  null)  {          Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[Delete]	[BUGGY]  if  (  (  mapping)  ==  null)  {          throw  new  IllegalStateException(   "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  [CONTEXT]        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  [BUGGY]  return  ;  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
Integer  index  =  mapping.get  (  name  )  ;	[BUGGY]  Integer  index  =  name.get(  mapping);  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    [BUGGY]  Integer  index  =  name.get  (  mapping  )  ;    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
Integer  index  =  mapping.get  (  name  )  ;	[BUGGY]    [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    [BUGGY]  Integer  index  =  mapping.get(name);      return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  index  ==  null  ?  values[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  ==  null  ?  values[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  values  !=  null  ?  index[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  values  !=  null  ?  index[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  index  !  =    null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !  =null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  index  !  =    values[index.intValue(  )]  ;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !  =values[index.intValue  ()  ]  ;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]  return  index  ;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  ;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUGGY]    [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !=  null  ?  values[index.intValue()]  :  null;          [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUGGY]  return  Arrays.asList(  EMPTY_STRING_ARRAY).iterator(  );  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList  (  EMPTY_STRING_ARRAY  )  .iterator  ()  ;  }        [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUGGY]  return  Arrays.asList(  values)  .iterator(  )  ;  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList  (  values  ).iterator  ();  }        [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUGGY]  return  Arrays  .toString(  EMPTY_STRING_ARRAY)  .iterator(  );  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays  .toString  (  EMPTY_STRING_ARRAY  ).iterator  ()  ;  }        [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUGGY]    [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList(values).iterator();          [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  values;	[BUGGY]  return  EMPTY_STRING_ARRAY;  [CONTEXT]  String[]  values()  {  [BUGGY]  return  EMPTY_STRING_ARRAY;  }        [CLASS]  CSVRecord    [METHOD]  values  [RETURN_TYPE]  String[]      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.toString  (  values  )  ;	[BUGGY]  return  Arrays.toString(  EMPTY_STRING_ARRAY);  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays.toString  (  EMPTY_STRING_ARRAY  )  ;  }        [CLASS]  CSVRecord    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.toString  (  values  )  ;	[BUGGY]  return  Arrays  .asList(  EMPTY_STRING_ARRAY)  ;  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays  .asList  (  EMPTY_STRING_ARRAY  );  }        [CLASS]  CSVRecord    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
return  Arrays.toString  (  values  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays.toString(values);          [CLASS]  CSVRecord    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
