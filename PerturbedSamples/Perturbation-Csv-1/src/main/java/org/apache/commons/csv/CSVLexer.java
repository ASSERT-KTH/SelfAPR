[REPLACE]^int c = in.read (  ) ;^28^^^^^27^29^[REPLACE] super ( format, in ) ;^[METHOD] <init> [TYPE] ExtendedBufferedReader) [PARAMETER] CSVFormat format ExtendedBufferedReader in [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  ExtendedBufferedReader in  [TYPE]  CSVFormat format 
[REPLACE]^int lastChar = in .readLine (  )  ;^44^^^^^41^118^[REPLACE] int lastChar = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^int c = in.readLine (  ) ;^51^^^^^41^118^[REPLACE] int c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^51^^^^^41^118^[ADD] int c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^boolean eol = isEndOfLine ( lastChar ) ;^52^^^^^41^118^[REPLACE] boolean eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.read (  ) ; ;^53^^^^^41^118^[REPLACE] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( eol  ^   ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED )  ^  !isEndOfFile ( lastChar )  )  {^57^58^59^^^41^118^[REPLACE] while  ( eol &&  ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED ) && !isEndOfFile ( lastChar )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEndOfFile ( lastChar )  )  {^66^^^^^57^71^[REPLACE] if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN; ;^67^^^^^57^71^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^lastChar =  null;^61^^^^^57^71^[REPLACE] lastChar = c;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^61^62^^^^57^71^[ADD] lastChar = c; c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.readAgain (  ) ; ;^62^^^^^57^71^[REPLACE] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( lastChar ) ;^63^^^^^57^71^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^63^^^^^57^71^[ADD] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.read (  ) ; ;^64^^^^^57^71^[REPLACE] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEscape ( c )  )  {^56^^^^^41^118^[REPLACE] if  ( emptyLinesIgnored )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( eol ;^57^58^59^^^41^118^[REPLACE] while  ( eol &&  ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED ) && !isEndOfFile ( lastChar )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEscape ( c )  )  {^66^^^^^57^71^[REPLACE] if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^62^63^^^^57^71^[ADD] c = in.read (  ) ; eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^64^^^^^57^71^[ADD] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^67^^^^^57^71^[ADD] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEscape ( c )  )  {^66^^^^^41^118^[REPLACE] if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN; ;^67^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^67^^^^^41^118^[ADD] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^lastChar =  null;^61^^^^^41^118^[REPLACE] lastChar = c;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.readAgain (  ) ; ;^62^^^^^41^118^[REPLACE] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( lastChar ) ;^63^^^^^41^118^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^63^64^^^^41^118^[ADD] eol = isEndOfLine ( c ) ; c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.read (  ) ; ;^64^^^^^41^118^[REPLACE] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEndOfFile ( lastChar )  )  {^66^^^^^41^118^[REPLACE] if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEndOfFile ( lastChar )  ||  ( isDelimiter ( lastChar )  && isEndOfFile ( c )  )  )  {^75^^^^^41^118^[REPLACE] if  ( isEndOfFile ( lastChar )  ||  ( !isDelimiter ( lastChar )  && isEndOfFile ( c )  )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     return tkn; }^75^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN; ;^76^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( tkn.type  &&  INVALID )  {^82^^^^^41^118^[REPLACE] while  ( tkn.type == INVALID )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^82^83^84^^^41^118^[ADD] while  ( tkn.type == INVALID )  {  if  ( surroundingSpacesIgnored )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( isWhitespace ( c )  ;^85^^^^^41^118^[REPLACE] while  ( isWhitespace ( c )  && !eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.readAgain (  ) ; ;^86^^^^^41^118^[REPLACE] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^86^^^^^41^118^[ADD] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( null ) ;^87^^^^^41^118^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEscape ( c )  )  {^84^^^^^41^118^[REPLACE] if  ( surroundingSpacesIgnored )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( isWhitespace ( c )   >=  false )  {^85^^^^^41^118^[REPLACE] while  ( isWhitespace ( c )  && !eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( lastChar ) ;^87^^^^^41^118^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isCommentStart ( lastChar )  )  {^92^^^^^41^118^[REPLACE] if  ( isCommentStart ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   tkn.type = TOKEN;^96^97^98^99^^41^118^[ADD] else if  ( isDelimiter ( c )  )  {  tkn.type = TOKEN; } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( eol )  {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEncapsulator ( c )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   encapsulatedTokenLexer ( tkn, c ) ;^103^104^105^106^^41^118^[ADD] else if  ( isEncapsulator ( c )  )  {  encapsulatedTokenLexer ( tkn, c ) ; } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;^106^107^^109^110^41^118^[ADD] else if  ( isEndOfFile ( c )  )  {  tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn = nextToken ( tkn.reset (  )  ) ;^114^^^^^106^115^[REPLACE] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^114^^^^^106^115^[ADD] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN; ;^109^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.isReady = false;^110^^^^^41^118^[REPLACE] tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^110^^^^^41^118^[ADD] tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^encapsulatedTokenLexer ( tkn, lastChar ) ;^105^^^^^41^118^[REPLACE] encapsulatedTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( isEncapsulator ( c )  )  {     encapsulatedTokenLexer ( tkn, c ) ; }else     if  ( isEndOfFile ( c )  )  {         tkn.type = EOF;         tkn.isReady = true;     }else {         simpleTokenLexer ( tkn, c ) ;     }^106^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^simpleTokenLexer ( tkn, lastChar ) ;^114^^^^^106^115^[REPLACE] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type  = null ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^109^^^^^41^118^[ADD] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEncapsulator ( in.lookAhead (  )  )  )  {^105^^^^^41^118^[REPLACE] encapsulatedTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^105^^^^^41^118^[ADD] encapsulatedTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEndOfFile ( lastChar )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^109^110^^^^41^118^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = EOF; ;^98^^^^^41^118^[REPLACE] tkn.type = TOKEN;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEncapsulator ( lastChar )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type  =  tkn.type ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^super ( format, in ) ;^114^^^^^106^115^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn =  nextToken ( null.reset (  )  ) ;^95^^^^^41^118^[REPLACE] tkn = nextToken ( tkn.reset (  )  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isDelimiter ( c )  )  {^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( false )  {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   tkn.type = EORECORD;^99^100^^102^^41^118^[ADD] else if  ( eol )  {  tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isEncapsulator ( lastChar )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isEndOfFile ( lastChar )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^tkn.isReady = true;^109^110^^^^41^118^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^86^87^^^^41^118^[ADD] c = in.read (  ) ; eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^87^^^^^41^118^[ADD] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( isWhitespace ( c )  || !eol )  {^85^^^^^41^118^[REPLACE] while  ( isWhitespace ( c )  && !eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^85^86^^^^41^118^[ADD] while  ( isWhitespace ( c )  && !eol )  { c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^84^85^86^87^88^41^118^[ADD] if  ( surroundingSpacesIgnored )  { while  ( isWhitespace ( c )  && !eol )  { c = in.read (  ) ; eol = isEndOfLine ( c ) ; }^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEscape ( c )  )  {^92^^^^^41^118^[REPLACE] if  ( isCommentStart ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isDelimiter ( lastChar )  )  {^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN; }else     if  ( eol )  {         tkn.type = EORECORD;     }else         if  ( isEncapsulator ( c )  )  {             encapsulatedTokenLexer ( tkn, c ) ;         }else             if  ( isEndOfFile ( c )  )  {                 tkn.type = EOF;                 tkn.isReady = true;             }else {                 simpleTokenLexer ( tkn, c ) ;             }^99^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^102^^^^^41^118^[ADD] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^95^^^^^41^118^[ADD] tkn = nextToken ( tkn.reset (  )  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isEndOfFile ( c )  )  {^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^96^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isEndOfFile ( c )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^while  ( false )  {^138^^^^^137^166^[REPLACE] while  ( true )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^if  ( isEscape ( c )  )  {^139^^^^^137^166^[REPLACE] if  ( isEndOfLine ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^143^^^^^137^166^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  if  ( isDelimiter ( c )  )  {^148^^^^^137^166^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^if  ( isEncapsulator ( c )  )  {     encapsulatedTokenLexer ( tkn, c ) ; }else     if  ( isEndOfFile ( c )  )  {         tkn.type = EOF;         tkn.isReady = true;     }else {         simpleTokenLexer ( tkn, c ) ;     }^148^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  if  ( isEscape ( c )  )  {^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.content.append (  ( char )  readEscape ( c )  ) ;^155^^^^^152^156^[REPLACE] tkn.content.append (  ( char )  c ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^155^^^^^152^156^[ADD] tkn.content.append (  ( char )  c ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.content.append (  ( char )  c ) ;^153^^^^^137^166^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type = EOF; ;^150^^^^^137^166^[REPLACE] tkn.type = TOKEN;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  else {^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^153^^^^^137^166^[ADD] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type = TOKEN; ;^145^^^^^137^166^[REPLACE] tkn.type = EOF;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.isReady = false;^146^^^^^137^166^[REPLACE] tkn.isReady = true;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type  = null ;^141^^^^^137^166^[REPLACE] tkn.type = EORECORD;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  else {^143^^^^^137^166^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;break;^143^144^145^146^147^137^166^[ADD] else if  ( isEndOfFile ( c )  )  {  tkn.type = EOF; tkn.isReady = true; break;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  else {^148^^^^^137^166^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^int c = in.read (  ) ;^153^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type  =  tkn.type ;^141^^^^^137^166^[REPLACE] tkn.type = EORECORD;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^141^^^^^137^166^[ADD] tkn.type = EORECORD;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^146^^^^^137^166^[ADD] tkn.isReady = true;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^c = in.readAgain (  ) ; ;^158^^^^^137^166^[REPLACE] c = in.read (  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^139^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^143^^^^^137^166^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^152^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^150^^^^^137^166^[ADD] tkn.type = TOKEN;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.content.append (  ( char )  c ) ;^152^153^154^155^156^137^166^[ADD] else if  ( isEscape ( c )  )  { tkn.content.append (  ( char )  readEscape ( c )  ) ; } else { tkn.content.append (  ( char )  c ) ; }^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.content.append (  ( char )  readEscape ( c )  ) ;tkn.content.append (  ( char )  c ) ;^152^153^154^155^156^137^166^[ADD] else if  ( isEscape ( c )  )  { tkn.content.append (  ( char )  readEscape ( c )  ) ; } else { tkn.content.append (  ( char )  c ) ; }^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.type = TOKEN;break;^148^149^150^151^^137^166^[ADD] else if  ( isDelimiter ( c )  )  {  tkn.type = TOKEN; break;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^tkn.isReady = true;^145^146^^^^137^166^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^if  ( isEscape ( c )  )  {^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^146^147^^^^137^166^[ADD] tkn.isReady = true; break;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^if  ( isEscape ( c )  )  {^161^^^^^137^166^[REPLACE] if  ( surroundingSpacesIgnored )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^simpleTokenLexer ( tkn, c ) ;^162^^^^^137^166^[REPLACE] trimTrailingSpaces ( tkn.content ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^162^^^^^137^166^[ADD] trimTrailingSpaces ( tkn.content ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^int lastChar = in.readAgain (  ) ;^183^^^^^181^225^[REPLACE] int startLineNumber = getLineNumber (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^183^^^^^181^225^[ADD] int startLineNumber = getLineNumber (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^186^187^^^^181^225^[ADD] while  ( true )  { c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^while  ( false )  {^198^^^^^181^225^[REPLACE] while  ( true )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if  ( isEscape ( c )  )  {^200^^^^^181^225^[REPLACE] if  ( isDelimiter ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.isReady = true;return tkn;^203^204^205^206^^181^225^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isWhitespace ( c )  )  {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}^211^212^213^214^^181^225^[ADD] else if  ( !isWhitespace ( c )  )  {  throw new IOException  (" ")  ; }^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^213^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^213^^^^^181^225^[ADD] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^eol = isEndOfLine ( c ) ;^213^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  =  tkn.type ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = TOKEN; ;^204^^^^^181^225^[REPLACE] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.isReady = false;^205^^^^^181^225^[REPLACE] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfLine ( c )  )  {^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  = null ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF; ;^201^^^^^181^225^[REPLACE] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^210^^^^181^225^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EORECORD;return tkn;^207^208^209^210^^181^225^[ADD] else if  ( isEndOfLine ( c )  )  {  tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  ) ; ;^199^^^^^181^225^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if  ( isDelimiter ( c )  )  {^189^^^^^181^225^[REPLACE] if  ( isEscape ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.content.append (  ( char )  readEscape ( c )  ) ;^189^190^191^192^^181^225^[ADD] if  ( isEscape ( c )  )  { tkn.content.append (  ( char )  readEscape ( c )  ) ; } else if  ( isEncapsulator ( c )  )  { if  ( isEncapsulator ( in.lookAhead (  )  )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.type = TOKEN;return tkn;tkn.type = EOF;^200^201^202^203^204^181^225^[ADD] if  ( isDelimiter ( c )  )  { tkn.type = TOKEN; return tkn; } else if  ( isEndOfFile ( c )  )  { tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;return tkn;^203^204^205^206^^181^225^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isWhitespace ( c )  )  {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^^^^^181^225^[ADD] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^201^202^^^^181^225^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^int c = in.read (  ) ;^213^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEncapsulator ( c )  )  {^191^^^^^181^225^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^217^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.content.append (  ( char )  readEscape ( c )  ) ;^222^^^^^217^223^[REPLACE] tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^219^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^209^210^^^^181^225^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^^^^^181^225^[ADD] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^^^^^181^225^[ADD] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^199^^^^^181^225^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^205^^^^181^225^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^206^^^^181^225^[ADD] tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if  ( isEscape ( c )  )  {^192^^^^^181^225^[REPLACE] if  ( isEncapsulator ( in.lookAhead (  )  )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^192^193^194^195^^181^225^[ADD] if  ( isEncapsulator ( in.lookAhead (  )  )  )  {  c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^while  ( false )  {^198^^^^^192^216^[REPLACE] while  ( true )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if  ( isEscape ( c )  )  {^200^^^^^192^216^[REPLACE] if  ( isDelimiter ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.type = TOKEN;return tkn;tkn.type = EOF;^200^201^202^203^204^192^216^[ADD] if  ( isDelimiter ( c )  )  { tkn.type = TOKEN; return tkn; } else if  ( isEndOfFile ( c )  )  { tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isWhitespace ( c )  )  {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^213^^^^^192^216^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^213^^^^^192^216^[ADD] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^eol = isEndOfLine ( c ) ;^213^^^^^192^216^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  =  tkn.type ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = TOKEN; ;^204^^^^^192^216^[REPLACE] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.isReady = false;^205^^^^^192^216^[REPLACE] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EORECORD;return tkn;^207^208^209^210^^192^216^[ADD] else if  ( isEndOfLine ( c )  )  {  tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^^^^^192^216^[ADD] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF; ;^201^^^^^192^216^[REPLACE] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^210^^^^192^216^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isWhitespace ( c )  )  {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}^211^212^213^214^^192^216^[ADD] else if  ( !isWhitespace ( c )  )  {  throw new IOException  (" ")  ; }^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  = null ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  ) ; ;^199^^^^^192^216^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^206^^^^192^216^[ADD] tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^^^^^192^216^[ADD] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfLine ( c )  )  {^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^^^^^192^216^[ADD] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  ) ; ;^194^^^^^181^225^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^^^^^181^225^[ADD] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^203^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     tkn.isReady = true;     return tkn; }else     if  ( isEndOfLine ( c )  )  {         tkn.type = EORECORD;         return tkn;     }else         if  ( ! ( isWhitespace ( c )  )  )  {             throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;         }^211^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^202^^^^192^216^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.isReady = true;return tkn;^203^204^205^206^^192^216^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^^^^^192^216^[ADD] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^200^201^202^203^204^192^216^[ADD] if  ( isDelimiter ( c )  )  { tkn.type = TOKEN; return tkn; } else if  ( isEndOfFile ( c )  )  { tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^207^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     tkn.isReady = true;     return tkn; }else     if  ( isEndOfLine ( c )  )  {         tkn.type = EORECORD;         return tkn;     }else         if  ( ! ( isWhitespace ( c )  )  )  {             throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;         }^211^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;return tkn;^203^204^205^206^^192^216^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^int c = in.read (  ) ;^213^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^205^^^^192^216^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.isReady = true;^204^205^^^^192^216^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.content.append (  ( char )  c ) ;^194^195^^^^181^225^[ADD] c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^217^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^222^^^^^217^223^[ADD] tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.content.append (  ( char )  c ) ;^190^^^^^181^225^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^191^^^^^181^225^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isDelimiter ( c )  )  {^217^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}^217^218^219^220^^181^225^[ADD] else if  ( isEndOfFile ( c )  )  {  throw new IOException  (" ")  ; } else {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^203^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^209^210^^^^192^216^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^194^^^^^181^225^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^207^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^194^195^^^^181^225^[ADD] c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^205^206^^^^192^216^[ADD] tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  ) ; ;^187^^^^^181^225^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^187^^^^^181^225^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^219^^^^^181^225^[ADD] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^200^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isEndOfFile ( c )  )  {^191^^^^^181^225^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^198^199^^^^181^225^[ADD] while  ( true )  { c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^198^199^^^^192^216^[ADD] while  ( true )  { c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^199^^^^^192^216^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^200^201^202^203^204^181^225^[ADD] if  ( isDelimiter ( c )  )  { tkn.type = TOKEN; return tkn; } else if  ( isEndOfFile ( c )  )  { tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^202^^^^181^225^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^201^202^^^^192^216^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.isReady = true;^204^205^^^^181^225^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
