[REPLACE]^private static final long serialVersionUID ;^42^^^^^^^[REPLACE] private static final long serialVersionUID = -2941995784909003131L;^ [CLASS] Min  
[REPLACE]^private float value;^48^^^^^^^[REPLACE] private double value;^ [CLASS] Min  
[REPLACE]^n = 0 * 0;^54^^^^^53^56^[REPLACE] n = 0;^[METHOD] <init> [TYPE] Min() [PARAMETER] [CLASS] Min   [TYPE]  double value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^54^^^^^53^56^[ADD] n = 0;^[METHOD] <init> [TYPE] Min() [PARAMETER] [CLASS] Min   [TYPE]  double value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^value  =  value ;^55^^^^^53^56^[REPLACE] value = Double.NaN;^[METHOD] <init> [TYPE] Min() [PARAMETER] [CLASS] Min   [TYPE]  double value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^if  ( d < value ) {^62^^^^^61^66^[REPLACE] if  ( d < value || Double.isNaN ( value )  )  {^[METHOD] increment [TYPE] void [PARAMETER] final double d [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^62^63^64^^^61^66^[ADD] if  ( d < value || Double.isNaN ( value )  )  { value = d; }^[METHOD] increment [TYPE] void [PARAMETER] final double d [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^value =  null;^63^^^^^61^66^[REPLACE] value = d;^[METHOD] increment [TYPE] void [PARAMETER] final double d [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^value  = null ;^72^^^^^71^74^[REPLACE] value = Double.NaN;^[METHOD] clear [TYPE] void [PARAMETER] [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^n = 0 / 3;^73^^^^^71^74^[REPLACE] n = 0;^[METHOD] clear [TYPE] void [PARAMETER] [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return min;^80^^^^^79^81^[REPLACE] return value;^[METHOD] getResult [TYPE] double [PARAMETER] [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return min;^87^^^^^86^88^[REPLACE] return n;^[METHOD] getN [TYPE] long [PARAMETER] [CLASS] Min   [TYPE]  double d  value  [TYPE]  long n  serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^for  ( int i = begin; i < begin + length; i++ )  { if  ( !Double.isNaN ( values[i] )  )  {^113^^^^^112^123^[REPLACE] double min = Double.NaN;^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[ADD]^^113^^^^^112^123^[ADD] double min = Double.NaN;^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^if  ( test ( values, begin, length /  2 )  )  {^114^^^^^112^123^[REPLACE] if  ( test ( values, begin, length )  )  {^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^if  ( Double.isNaN ( values[i] )  )  {^117^^^^^112^123^[REPLACE] if  ( !Double.isNaN ( values[i] )  )  {^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^min  =  values[i];^118^^^^^112^123^[REPLACE] min =  ( min < values[i] )  ? min : values[i];^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^for  ( int i = begin; i < begin + length /  0.5 ; i++ )  {^116^^^^^112^123^[REPLACE] for  ( int i = begin; i < begin + length; i++ )  {^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^min  =  min ;^118^^^^^112^123^[REPLACE] min =  ( min < values[i] )  ? min : values[i];^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^min =  null[begin];^115^^^^^112^123^[REPLACE] min = values[begin];^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[ADD]^^115^^^^^112^123^[ADD] min = values[begin];^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^for  ( int i = length; i < begin + length; i++ )  {^116^^^^^112^123^[REPLACE] for  ( int i = begin; i < begin + length; i++ )  {^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^if  (   values[i]    )  {^117^^^^^112^123^[REPLACE] if  ( !Double.isNaN ( values[i] )  )  {^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[ADD]^^116^117^118^119^^112^123^[ADD] for  ( int i = begin; i < begin + length; i++ )  { if  ( !Double.isNaN ( values[i] )  )  { min =  ( min < values[i] )  ? min : values[i]; }^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
[REPLACE]^return n;^122^^^^^112^123^[REPLACE] return min;^[METHOD] evaluate [TYPE] double [PARAMETER] final double[] values final int begin final int length [CLASS] Min   [TYPE]  boolean false  true  [TYPE]  double[] values  [TYPE]  double d  min  value  [TYPE]  long n  serialVersionUID  [TYPE]  int begin  i  length 
