[REPLACE]^final  short  serialVersionUID = 2619993603551148137;^37^^^^^^^[REPLACE] static final long serialVersionUID = 2619993603551148137L;^ [CLASS] MullerSolver  
[REPLACE]^super ( f, 98, 1E-6 ) ;^45^^^^^44^46^[REPLACE] super ( f, 100, 1E-6 ) ;^[METHOD] <init> [TYPE] UnivariateRealFunction) [PARAMETER] UnivariateRealFunction f [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  UnivariateRealFunction f  [TYPE]  boolean false  true 
[REPLACE]^if  ( f.value ( max )   ||  0.0 )  { return min; }^67^^^^^63^78^[REPLACE] if  ( f.value ( min )  == 0.0 )  { return min; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[ADD]^^67^68^^^^63^78^[ADD] if  ( f.value ( min )  == 0.0 )  { return min; } if  ( f.value ( max )  == 0.0 )  { return max; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^if  ( f.value ( max )  == 0.0 )  { return min; }^67^^^^^63^78^[REPLACE] if  ( f.value ( min )  == 0.0 )  { return min; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^if  ( f.value ( max )   &&  0.0 )  { return max; }^68^^^^^63^78^[REPLACE] if  ( f.value ( max )  == 0.0 )  { return max; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^if  ( f.value ( min )  == 0.0 )  { return max; }^68^^^^^63^78^[REPLACE] if  ( f.value ( max )  == 0.0 )  { return max; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^i  initial     &&  0.0 )  { return initial; }^69^^^^^63^78^[REPLACE] if  ( f.value ( initial )  == 0.0 )  { return initial; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[ADD]^^69^70^71^72^^63^78^[ADD] if  ( f.value ( initial )  == 0.0 )  { return initial; }  verifyBracketing ( min, max, f ) ; verifySequence ( min, initial, max ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^if  ( f.value ( min )  == 0.0 )  { return initial; }^69^^^^^63^78^[REPLACE] if  ( f.value ( initial )  == 0.0 )  { return initial; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^verifyBracketing ( initial, max, f ) ;^71^^^^^63^78^[REPLACE] verifyBracketing ( min, max, f ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^verifySequence ( min, initial, min ) ;^72^^^^^63^78^[REPLACE] verifySequence ( min, initial, max ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[ADD]^^72^73^74^75^76^63^78^[ADD] verifySequence ( min, initial, max ) ; if  ( isBracketing ( min, initial, f )  )  { return solve ( min, initial ) ; } else { return solve ( initial, max ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^if  ( isBracketing ( min, max, f )  )  {^73^^^^^63^78^[REPLACE] if  ( isBracketing ( min, initial, f )  )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^return solve ( initial, min ) ;^76^^^^^63^78^[REPLACE] return solve ( initial, max ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^return solve ( max, initial ) ;^74^^^^^63^78^[REPLACE] return solve ( min, initial ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^return solve ( min, max ) ;^74^^^^^63^78^[REPLACE] return solve ( min, initial ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max double initial [CLASS] MullerSolver   [TYPE]  long serialVersionUID  [TYPE]  double initial  max  min  [TYPE]  boolean false  true 
[REPLACE]^double d01, d12, d012, c1, delta, xplus, xminus, tolerance;^111^^^^^105^181^[REPLACE] double x0, x1, x2, x, oldx, y0, y1, y2, y;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^111^^^^^105^181^[ADD] double x0, x1, x2, x, oldx, y0, y1, y2, y;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^111^112^^^^105^181^[ADD] double x0, x1, x2, x, oldx, y0, y1, y2, y; double d01, d12, d012, c1, delta, xplus, xminus, tolerance;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double x0, x1, x2, x, oldx, y0, y1, y2, y;^112^^^^^105^181^[REPLACE] double d01, d12, d012, c1, delta, xplus, xminus, tolerance;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^112^^^^^105^181^[ADD] double d01, d12, d012, c1, delta, xplus, xminus, tolerance;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x2 = max; y2 = f.value ( x2 ) ; ;^114^^^^^105^181^[REPLACE] x0 = min; y0 = f.value ( x0 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x0 = min; y0 = f.value ( x0 ) ; ;^115^^^^^105^181^[REPLACE] x2 = max; y2 = f.value ( x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 1.0d  ;^116^^^^^105^181^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x2 = 0.5 *  ( x0 + x1 ) ; y2 = f.value ( x2 ) ; ;^116^^^^^105^181^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^116^^^^^105^181^[ADD] x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( ym  &&  0.0 )  { return min; }^119^^^^^105^181^[REPLACE] if  ( y0 == 0.0 )  { return min; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( y0 == 0.0 )  { return xminus; }^119^^^^^105^181^[REPLACE] if  ( y0 == 0.0 )  { return min; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( y2  ||  0.0 )  { return max; }^120^^^^^105^181^[REPLACE] if  ( y2 == 0.0 )  { return max; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( y2 == 0.0 )  { return xminus; }^120^^^^^105^181^[REPLACE] if  ( y2 == 0.0 )  { return max; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^verifyBracketing ( min, xminus, f ) ;^121^^^^^105^181^[REPLACE] verifyBracketing ( min, max, f ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^int i = 1 + 1;^123^^^^^105^181^[REPLACE] int i = 1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx ;^124^^^^^105^181^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^while  ( i  ==  maximalIterationCount )  {^125^^^^^105^181^[REPLACE] while  ( i <= maximalIterationCount )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  (   x - oldx     >  tolerance )  {^144^^^^^105^181^[REPLACE] if  ( Math.abs ( x - oldx )  <= tolerance )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^setResult ( x, i ) ;return result;^144^145^146^147^^105^181^[ADD] if  ( Math.abs ( x - oldx )  <= tolerance )  { setResult ( x, i ) ; return result; }^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^return solve ( initial, max ) ;^146^^^^^105^181^[REPLACE] return result;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( y )   ==  functionValueAccuracy )  {^148^^^^^105^181^[REPLACE] if  ( Math.abs ( y )  <= functionValueAccuracy )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^return solve ( initial, max ) ;^150^^^^^105^181^[REPLACE] return result;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( bisect )  {^159^^^^^105^181^[REPLACE] if  ( !bisect )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )   !=  0.0 )  {^169^^^^^159^177^[REPLACE] if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )  == 0.0 )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = x2; y1 = y2; ;^172^^^^^159^177^[REPLACE] x0 = xm; y0 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^172^^^^^159^177^[ADD] x0 = xm; y0 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^170^^^^^159^177^[REPLACE] x2 = xm; y2 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^170^^^^^159^177^[ADD] x2 = xm; y2 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 0.5  ;^174^^^^^159^177^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y = f.value ( x ) ; ;^175^^^^^159^177^[REPLACE] y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx  =  oldx ;^176^^^^^159^177^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double xm = 1.0d  ;^167^^^^^159^177^[REPLACE] double xm = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double ym = f.value ( ym ) ;^168^^^^^159^177^[REPLACE] double ym = f.value ( xm ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y2 = x > x1 ? y2 : y1; ;^160^^^^^105^181^[REPLACE] x0 = x < x1 ? x0 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^y0 = x < x1 ? y0 : y1;^160^161^^^^105^181^[ADD] x0 = x < x1 ? x0 : x1; y0 = x < x1 ? y0 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y0  =  y1;^161^^^^^105^181^[REPLACE] y0 = x < x1 ? y0 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^161^162^^^^105^181^[ADD] y0 = x < x1 ? y0 : y1; x2 = x > x1 ? x2 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x2  =  x1;^162^^^^^105^181^[REPLACE] x2 = x > x1 ? x2 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y0 = x < x1 ? y0 : y1; ;^163^^^^^105^181^[REPLACE] y2 = x > x1 ? y2 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^163^^^^^105^181^[ADD] y2 = x > x1 ? y2 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^164^^^^^105^181^[REPLACE] x1 = x; y1 = y;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^164^165^^^^105^181^[ADD] x1 = x; y1 = y; oldx = x;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx =  xplus;^165^^^^^105^181^[REPLACE] oldx = x;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^165^^^^^105^181^[ADD] oldx = x;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )   &&  0.0 )  {^169^^^^^105^181^[REPLACE] if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )  == 0.0 )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = x2; y1 = y2; ;^172^^^^^169^173^[REPLACE] x0 = xm; y0 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^170^^^^^105^181^[REPLACE] x2 = xm; y2 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^170^^^^^105^181^[ADD] x2 = xm; y2 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^d01 =  ( y1 - y0 )   ;^130^^^^^105^181^[REPLACE] d01 =  ( y1 - y0 )  /  ( x1 - x0 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^130^131^^^^105^181^[ADD] d01 =  ( y1 - y0 )  /  ( x1 - x0 ) ; d12 =  ( y2 - y1 )  /  ( x2 - x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^d12 =  (ym )   ;^131^^^^^105^181^[REPLACE] d12 =  ( y2 - y1 )  /  ( x2 - x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^d012 =  ( d12 - d01 )   ;^132^^^^^105^181^[REPLACE] d012 =  ( d12 - d01 )  /  ( x2 - x0 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^132^^^^^105^181^[ADD] d012 =  ( d12 - d01 )  /  ( x2 - x0 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^c1 =y1 +  ( x1 - x0 )  * d012;^133^^^^^105^181^[REPLACE] c1 = d01 +  ( x1 - x0 )  * d012;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ; ;^134^^^^^105^181^[REPLACE] delta = c1 * c1 - 4 * y1 * d012;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^134^135^^^^105^181^[ADD] delta = c1 * c1 - 4 * y1 * d012; xplus = x1 +  ( -2.0 * y1 )  /  ( c1 + Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xplus = x1  ||   ( -3.0d * y1 )  /  ( c1  ||  Math.sqrt ( delta )  ) ;^135^^^^^105^181^[REPLACE] xplus = x1 +  ( -2.0 * y1 )  /  ( c1 + Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^xminus = x1 +  ( -2.0 * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^135^136^^^^105^181^[ADD] xplus = x1 +  ( -2.0 * y1 )  /  ( c1 + Math.sqrt ( delta )  ) ; xminus = x1 +  ( -2.0 * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xminus =y1 +  ( -2.0 * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^136^^^^^105^181^[REPLACE] xminus = x1 +  ( -2.0 * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x =  isSequence ( y0, xplus, x2 )  ? xplus : xminus;^139^^^^^105^181^[REPLACE] x = isSequence ( x0, xplus, x2 )  ? xplus : xminus;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y1 = f.value ( x1 ) ; ;^140^^^^^105^181^[REPLACE] y = f.value ( x ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^tolerance = Math.max ( relativeAccuracy  &  Math.abs ( x ) , absoluteAccuracy ) ;^143^^^^^105^181^[REPLACE] tolerance = Math.max ( relativeAccuracy * Math.abs ( x ) , absoluteAccuracy ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x0  = xplus1;^160^^^^^105^181^[REPLACE] x0 = x < x1 ? x0 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^160^^^^^105^181^[ADD] x0 = x < x1 ? x0 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x2  = xplus2 ;^162^^^^^105^181^[REPLACE] x2 = x > x1 ? x2 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y2  =  y1;^163^^^^^105^181^[REPLACE] y2 = x > x1 ? y2 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx =  null;^165^^^^^105^181^[REPLACE] oldx = x;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = x2; y1 = y2; ;^172^^^^^105^181^[REPLACE] x0 = xm; y0 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 1.0d  ;^174^^^^^105^181^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^174^175^^^^105^181^[ADD] x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y = f.value ( x ) ; ;^175^^^^^105^181^[REPLACE] y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx  =  oldx ;^176^^^^^105^181^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^176^^^^^105^181^[ADD] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^boolean bisect =  ( x < x1 ;^155^156^157^^^105^181^[REPLACE] boolean bisect =  ( x < x1 &&  ( x1 - x0 )  > 0.95 *  ( x2 - x0 )  )  || ( x > x1 &&  ( x2 - x1 )  > 0.95 *  ( x2 - x0 )  )  || ( x == x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double xm = 0.5  ;^167^^^^^105^181^[REPLACE] double xm = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^167^^^^^105^181^[ADD] double xm = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double ym =   xm   ;^168^^^^^105^181^[REPLACE] double ym = f.value ( xm ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( x - oldx )   >= xplus )  {^144^^^^^105^181^[REPLACE] if  ( Math.abs ( x - oldx )  <= tolerance )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( y )   <  functionValueAccuracy )  {^148^^^^^105^181^[REPLACE] if  ( Math.abs ( y )  <= functionValueAccuracy )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )   ||  0.0 )  {^169^^^^^159^177^[REPLACE] if  ( MathUtils.sign ( y0 )  + MathUtils.sign ( ym )  == 0.0 )  {^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 4.0d  ;^174^^^^^159^177^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^176^^^^^159^177^[ADD] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double xm = 0.5  ;^167^^^^^159^177^[REPLACE] double xm = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^167^^^^^159^177^[ADD] double xm = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double ym =   ym   ;^168^^^^^159^177^[REPLACE] double ym = f.value ( xm ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xplus0  =  x0 ;^160^^^^^105^181^[REPLACE] x0 = x < x1 ? x0 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y0  =  y0 ;^161^^^^^105^181^[REPLACE] y0 = x < x1 ? y0 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^161^^^^^105^181^[ADD] y0 = x < x1 ? y0 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y2 = x > x1 ? y2 : y1; ;^162^^^^^105^181^[REPLACE] x2 = x > x1 ? x2 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^162^163^^^^105^181^[ADD] x2 = x > x1 ? x2 : x1; y2 = x > x1 ? y2 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y2  =  y2 ;^163^^^^^105^181^[REPLACE] y2 = x > x1 ? y2 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^d12 =  ( y2 - y1 )   ;^131^^^^^105^181^[REPLACE] d12 =  ( y2 - y1 )  /  ( x2 - x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^c1 = d01  ||   ( x1 - x0 )  * d012;^133^^^^^105^181^[REPLACE] c1 = d01 +  ( x1 - x0 )  * d012;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^delta = c1 * c1 -y1;^134^^^^^105^181^[REPLACE] delta = c1 * c1 - 4 * y1 * d012;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xplus = x1  <=   ( -2.0 * y1 )  /  ( c1  <=  Math.sqrt ( delta )  ) ;^135^^^^^105^181^[REPLACE] xplus = x1 +  ( -2.0 * y1 )  /  ( c1 + Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xminus =y1 +  ( -2.0D * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^136^^^^^105^181^[REPLACE] xminus = x1 +  ( -2.0 * y1 )  /  ( c1 - Math.sqrt ( delta )  ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x =  isSequence ( null, xplus, x2 )  ? xplus : xminus;^139^^^^^105^181^[REPLACE] x = isSequence ( x0, xplus, x2 )  ? xplus : xminus;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^139^140^^^^105^181^[ADD] x = isSequence ( x0, xplus, x2 )  ? xplus : xminus; y = f.value ( x ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^tolerance = Math.max ( relativeAccuracy  >=  Math.abs ( x ) , absoluteAccuracy ) ;^143^^^^^105^181^[REPLACE] tolerance = Math.max ( relativeAccuracy * Math.abs ( x ) , absoluteAccuracy ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^143^^^^^105^181^[ADD] tolerance = Math.max ( relativeAccuracy * Math.abs ( x ) , absoluteAccuracy ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^xplus0  =  y1;^160^^^^^105^181^[REPLACE] x0 = x < x1 ? x0 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^y0 = x  <=  x1 ? y0 : y1;^161^^^^^105^181^[REPLACE] y0 = x < x1 ? y0 : y1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x2  =  x2 ;^162^^^^^105^181^[REPLACE] x2 = x > x1 ? x2 : x1;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^172^^^^^105^181^[ADD] x0 = xm; y0 = ym;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^x1 = 0.5  ;^174^^^^^105^181^[REPLACE] x1 = 0.5 *  ( x0 + x2 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^175^^^^^105^181^[ADD] y1 = f.value ( x1 ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^oldx  = null ;^176^^^^^105^181^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double ym =   ym   ;^168^^^^^105^181^[REPLACE] double ym = f.value ( xm ) ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^return ;^180^^^^^105^181^[REPLACE] throw new ConvergenceException  (" ")  ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[ADD]^^180^^^^^105^181^[ADD] throw new ConvergenceException  (" ")  ;^[METHOD] solve [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean bisect  false  true  [TYPE]  long serialVersionUID  [TYPE]  double c1  d01  d012  d12  delta  max  min  oldx  tolerance  x  x0  x1  x2  xm  xminus  xplus  y  y0  y1  y2  ym  [TYPE]  int i 
[REPLACE]^double d01, d12, d012, c1, delta, xplus, xminus, tolerance;^214^^^^^209^276^[REPLACE] double x0, x1, x2, x, oldx, y0, y1, y2, y;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^214^^^^^209^276^[ADD] double x0, x1, x2, x, oldx, y0, y1, y2, y;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double x0, x1, x2, x, oldx, y0, y1, y2, y;^215^^^^^209^276^[REPLACE] double q, A, B, C, delta, denominator, tolerance;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^215^^^^^209^276^[ADD] double q, A, B, C, delta, denominator, tolerance;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x2 = max; y2 = f.value ( x2 ) ; ;^217^^^^^209^276^[REPLACE] x0 = min; y0 = f.value ( x0 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^217^^^^^209^276^[ADD] x0 = min; y0 = f.value ( x0 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x2 = max; y2 = f.value ( x2 ) ; ;^218^^^^^209^276^[REPLACE] x1 = max; y1 = f.value ( x1 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x2 = 0.5D  ;^219^^^^^209^276^[REPLACE] x2 = 0.5 *  ( x0 + x1 ) ; y2 = f.value ( x2 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^219^^^^^209^276^[ADD] x2 = 0.5 *  ( x0 + x1 ) ; y2 = f.value ( x2 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x1 = 0.5 *  ( x0 + x2 ) ; y1 = f.value ( x1 ) ; ;^219^^^^^209^276^[REPLACE] x2 = 0.5 *  ( x0 + x1 ) ; y2 = f.value ( x2 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( y0  || y2 )  { return min; }^222^^^^^209^276^[REPLACE] if  ( y0 == 0.0 )  { return min; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^222^223^^^^209^276^[ADD] if  ( y0 == 0.0 )  { return min; } if  ( y1 == 0.0 )  { return max; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( y0 == 0.0 )  { return tolerance; }^222^^^^^209^276^[REPLACE] if  ( y0 == 0.0 )  { return min; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( y1  && y2 )  { return max; }^223^^^^^209^276^[REPLACE] if  ( y1 == 0.0 )  { return max; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( y1 == 0.0 )  { return x; }^223^^^^^209^276^[REPLACE] if  ( y1 == 0.0 )  { return max; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^verifyBracketing ( tolerance, max, f ) ;^224^^^^^209^276^[REPLACE] verifyBracketing ( min, max, f ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^int i = 1 - 1;^226^^^^^209^276^[REPLACE] int i = 1;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^oldx ;^227^^^^^209^276^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^while  ( i  !=  maximalIterationCount )  {^228^^^^^209^276^[REPLACE] while  ( i <= maximalIterationCount )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^while  ( x == x1 ;^247^^^^^209^276^[REPLACE] while  ( x == x1 || x == x2 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x + =  x +;^248^^^^^209^276^[REPLACE] x += absoluteAccuracy;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( delta  !=  4.0d )  {^235^^^^^209^276^[REPLACE] if  ( delta >= 0.0 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator = Math.sqrt ( B * B  |  delta ) ;^242^^^^^235^243^[REPLACE] denominator = Math.sqrt ( B * B - delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^242^^^^^235^243^[ADD] denominator = Math.sqrt ( B * B - delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator  =  dminus;^239^^^^^209^276^[REPLACE] denominator = Math.abs ( dplus )  > Math.abs ( dminus )  ? dplus : dminus;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dplus = B  !=  Math.sqrt ( tolerance ) ;^237^^^^^209^276^[REPLACE] double dplus = B + Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dminus = B  &  Math.sqrt ( delta ) ;^238^^^^^209^276^[REPLACE] double dminus = B - Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( denominator  ==  0 )  {^244^^^^^209^276^[REPLACE] if  ( denominator != 0 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x = min  &  Math.random (  )  *  ( max - min ) ;^252^^^^^244^254^[REPLACE] x = min + Math.random (  )  *  ( max - min ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^oldx  =  oldx ;^253^^^^^244^254^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^253^^^^^244^254^[ADD] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^while  ( x == x1 && x == x2 )  {^247^^^^^209^276^[REPLACE] while  ( x == x1 || x == x2 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x + = null ;^248^^^^^209^276^[REPLACE] x += absoluteAccuracy;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x =y2 - 2.0 * C *  ( x2 - x1 )  / denominator;^245^^^^^209^276^[REPLACE] x = x2 - 2.0 * C *  ( x2 - x1 )  / denominator;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^248^^^^^209^276^[ADD] x += absoluteAccuracy;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( x - oldx )   >=  oldx )  {^259^^^^^209^276^[REPLACE] if  ( Math.abs ( x - oldx )  <= tolerance )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^setResult ( x, i ) ;return result;^259^260^261^262^^209^276^[ADD] if  ( Math.abs ( x - oldx )  <= tolerance )  { setResult ( x, i ) ; return result; }^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^return solve ( initial, max ) ;^261^^^^^209^276^[REPLACE] return result;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( Math .random (  )    ==  functionValueAccuracy )  {^263^^^^^209^276^[REPLACE] if  ( Math.abs ( y )  <= functionValueAccuracy )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^return solve ( initial, max ) ;^265^^^^^209^276^[REPLACE] return result;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^q =  ( x2 - x1 )   ;^230^^^^^209^276^[REPLACE] q =  ( x2 - x1 )  /  ( x1 - x0 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^230^231^^^^209^276^[ADD] q =  ( x2 - x1 )  /  ( x1 - x0 ) ; A = q *  ( y2 -  ( 1 + q )  * y1 + q * y0 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^A = q  ;^231^^^^^209^276^[REPLACE] A = q *  ( y2 -  ( 1 + q )  * y1 + q * y0 ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^B =  ( 2*q  ==  1 )  * y2 -  ( 1  ==  q )  *  ( 1  ==  q )  * y1  ==  q * q * y0;^232^^^^^209^276^[REPLACE] B =  ( 2*q + 1 )  * y2 -  ( 1 + q )  *  ( 1 + q )  * y1 + q * q * y0;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^232^233^^^^209^276^[ADD] B =  ( 2*q + 1 )  * y2 -  ( 1 + q )  *  ( 1 + q )  * y1 + q * q * y0; C =  ( 1 + q )  * y2;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^C =  ( 1 + q )   ;^233^^^^^209^276^[REPLACE] C =  ( 1 + q )  * y2;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^delta = B * B - 4 * A * C;^233^234^^^^209^276^[ADD] C =  ( 1 + q )  * y2; delta = B * B - 4 * A * C;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^delta = B * B  <=  4 % 0 * A * C;^234^^^^^209^276^[REPLACE] delta = B * B - 4 * A * C;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^239^^^^^209^276^[ADD] denominator = Math.abs ( dplus )  > Math.abs ( dminus )  ? dplus : dminus;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator = Math.sqrt ( B * B -B ) ;^242^^^^^209^276^[REPLACE] denominator = Math.sqrt ( B * B - delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x =tolerance + Math.random (  )  *  ( max - min ) ;^252^^^^^209^276^[REPLACE] x = min + Math.random (  )  *  ( max - min ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^oldx  = null ;^253^^^^^209^276^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^253^^^^^209^276^[ADD] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^y1 = f.value ( x1 ) ; ;^255^^^^^209^276^[REPLACE] y = f.value ( x ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^tolerance = Math.max (this * Math.abs ( x ) , absoluteAccuracy ) ;^258^^^^^209^276^[REPLACE] tolerance = Math.max ( relativeAccuracy * Math.abs ( x ) , absoluteAccuracy ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^269^^^^^209^276^[REPLACE] x0 = x1; y0 = y1;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^270^^^^^209^276^[REPLACE] x1 = x2; y1 = y2;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x0 = xm; y0 = ym; ;^271^^^^^209^276^[REPLACE] x2 = x; y2 = y;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^271^^^^^209^276^[ADD] x2 = x; y2 = y;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^oldx =  x2;^272^^^^^209^276^[REPLACE] oldx = x;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^272^^^^^209^276^[ADD] oldx = x;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dplus = B  |  Math.sqrt ( tolerance ) ;^237^^^^^209^276^[REPLACE] double dplus = B + Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dminus = B  ||    tolerance   ;^238^^^^^209^276^[REPLACE] double dminus = B - Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( delta  ==  0.0D )  {^235^^^^^209^276^[REPLACE] if  ( delta >= 0.0 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^235^236^237^238^239^209^276^[ADD] if  ( delta >= 0.0 )  {  double dplus = B + Math.sqrt ( delta ) ; double dminus = B - Math.sqrt ( delta ) ; denominator = Math.abs ( dplus )  > Math.abs ( dminus )  ? dplus : dminus;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator = Math.sqrt ( B * B  <  delta ) ;^242^^^^^235^243^[REPLACE] denominator = Math.sqrt ( B * B - delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dplus = B  ==    delta   ;^237^^^^^209^276^[REPLACE] double dplus = B + Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^237^^^^^209^276^[ADD] double dplus = B + Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dminus = B  ^    delta   ;^238^^^^^209^276^[REPLACE] double dminus = B - Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  (tolerance  ==  0 )  {^244^^^^^209^276^[REPLACE] if  ( denominator != 0 )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^244^245^^247^248^209^276^[ADD] if  ( denominator != 0 )  { x = x2 - 2.0 * C *  ( x2 - x1 )  / denominator; while  ( x == x1 || x == x2 )  { x += absoluteAccuracy;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x =tolerance + Math.random (  )  *  ( max - min ) ;^252^^^^^244^254^[REPLACE] x = min + Math.random (  )  *  ( max - min ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x = y2 - 3.0d * C *  ( x2 - x1 )  / denominator;^245^^^^^209^276^[REPLACE] x = x2 - 2.0 * C *  ( x2 - x1 )  / denominator;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( x - oldx )   <  tolerance )  {^259^^^^^209^276^[REPLACE] if  ( Math.abs ( x - oldx )  <= tolerance )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^if  ( Math.abs ( y )   ==  functionValueAccuracy )  {^263^^^^^209^276^[REPLACE] if  ( Math.abs ( y )  <= functionValueAccuracy )  {^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^B =  ( 2*q + 1 )  * y2 -  ( 1 + q )  *  ( 1 + q )  * y1 +y2;^232^^^^^209^276^[REPLACE] B =  ( 2*q + 1 )  * y2 -  ( 1 + q )  *  ( 1 + q )  * y1 + q * q * y0;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^delta = B * B -B;^234^^^^^209^276^[REPLACE] delta = B * B - 4 * A * C;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^234^^^^^209^276^[ADD] delta = B * B - 4 * A * C;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator  =  dplus ;^239^^^^^209^276^[REPLACE] denominator = Math.abs ( dplus )  > Math.abs ( dminus )  ? dplus : dminus;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^denominator = Math.sqrt ( B * B  !=  delta ) ;^242^^^^^209^276^[REPLACE] denominator = Math.sqrt ( B * B - delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x =y2 - 1.0d * C *  ( x2 - x1 )  / denominator;^245^^^^^209^276^[REPLACE] x = x2 - 2.0 * C *  ( x2 - x1 )  / denominator;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^x +;^248^^^^^209^276^[REPLACE] x += absoluteAccuracy;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^oldx  =  oldx ;^253^^^^^209^276^[REPLACE] oldx = Double.POSITIVE_INFINITY;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^tolerance = Math.max (true * Math.abs ( x ) , absoluteAccuracy ) ;^258^^^^^209^276^[REPLACE] tolerance = Math.max ( relativeAccuracy * Math.abs ( x ) , absoluteAccuracy ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^^270^^^^^209^276^[ADD] x1 = x2; y1 = y2;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dplus = B  >  Math.sqrt ( delta ) ;^237^^^^^209^276^[REPLACE] double dplus = B + Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[ADD]^double dminus = B - Math.sqrt ( delta ) ;^237^238^^^^209^276^[ADD] double dplus = B + Math.sqrt ( delta ) ; double dminus = B - Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^double dminus = B  &&  Math.abs ( delta ) ;^238^^^^^209^276^[REPLACE] double dminus = B - Math.sqrt ( delta ) ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
[REPLACE]^return ;^275^^^^^209^276^[REPLACE] throw new ConvergenceException  (" ")  ;^[METHOD] solve2 [TYPE] double [PARAMETER] double min double max [CLASS] MullerSolver   [TYPE]  boolean false  true  [TYPE]  long serialVersionUID  [TYPE]  double A  B  C  delta  denominator  dminus  dplus  max  min  oldx  q  tolerance  x  x0  x1  x2  y  y0  y1  y2  [TYPE]  int i 
