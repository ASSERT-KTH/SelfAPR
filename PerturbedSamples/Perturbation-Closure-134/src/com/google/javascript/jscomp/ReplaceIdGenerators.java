[REPLACE]^static final DiagnosticType NON_GLOBAL_ID_GENERATOR_CALL  = null ;^36^37^38^39^^36^39^[REPLACE] static final DiagnosticType NON_GLOBAL_ID_GENERATOR_CALL = DiagnosticType.error ( "JSC_NON_GLOBAL_ID_GENERATOR_CALL", "Id generator call must be in the global scope" ) ;^ [CLASS] ReplaceIdGenerators Callback  
[REPLACE]^static final DiagnosticType CONDITIONAL_ID_GENERATOR_CALL ;^41^42^43^44^^41^44^[REPLACE] static final DiagnosticType CONDITIONAL_ID_GENERATOR_CALL = DiagnosticType.error ( "JSC_CONDITIONAL_ID_GENERATOR_CALL", "Id generator call must be unconditional" ) ;^ [CLASS] ReplaceIdGenerators Callback  
[REPLACE]^private  AbstractCompiler compiler;^46^^^^^^^[REPLACE] private final AbstractCompiler compiler;^ [CLASS] ReplaceIdGenerators Callback  
[REPLACE]^this.compiler =  null;^51^^^^^49^58^[REPLACE] this.compiler = compiler;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> idGenerators [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  Set idGenerators  [TYPE]  String idGenerator  [TYPE]  boolean false  true  [TYPE]  Map nameGenerators  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL 
[REPLACE]^nameGenerators  =  nameGenerators ;^52^^^^^49^58^[REPLACE] nameGenerators = Maps.newHashMap (  ) ;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> idGenerators [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  Set idGenerators  [TYPE]  String idGenerator  [TYPE]  boolean false  true  [TYPE]  Map nameGenerators  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^53^^^^^49^58^[REPLACE] for  ( String idGenerator : idGenerators )  {^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> idGenerators [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  Set idGenerators  [TYPE]  String idGenerator  [TYPE]  boolean false  true  [TYPE]  Map nameGenerators  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL 
[ADD]^^53^54^55^56^57^49^58^[ADD] for  ( String idGenerator : idGenerators )  { nameGenerators.put ( idGenerator, new NameGenerator ( Collections.<String>emptySet (  ) , "", null )  ) ; }^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> idGenerators [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  Set idGenerators  [TYPE]  String idGenerator  [TYPE]  boolean false  true  [TYPE]  Map nameGenerators  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL 
[REPLACE]^nameGenerators = Maps.newHashMap (  ) ;^61^^^^^60^62^[REPLACE] NodeTraversal.traverse ( compiler, root, new Callback (  )  ) ;^[METHOD] process [TYPE] void [PARAMETER] Node externs Node root [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  Map nameGenerators  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node externs  root 
[REPLACE]^if  ( parent.getType (  )   ==  Token.CALL )  {^66^^^^^65^94^[REPLACE] if  ( n.getType (  )  != Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^String callName = parent.getFirstChild (  ) .getQualifiedName (  ) ;^70^^^^^65^94^[REPLACE] String callName = n.getFirstChild (  ) .getQualifiedName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( nextName ) ;^71^^^^^65^94^[REPLACE] NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( nameGenerator != null )  {^72^^^^^65^94^[REPLACE] if  ( nameGenerator == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( t.inGlobalScope (  )  )  {^76^^^^^65^94^[REPLACE] if  ( !t.inGlobalScope (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( !t.inGlobalScope (  )  )  {^83^^^^^65^94^[REPLACE] if  ( NodeUtil.isControlStructure ( ancestor )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^for  ( String idGenerator : idGenerators )  { nameGenerators.put (^82^^^^^65^94^[REPLACE] for  ( Node ancestor : n.getAncestors (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^82^83^^85^86^65^94^[ADD] for  ( Node ancestor : n.getAncestors (  )  )  { if  ( NodeUtil.isControlStructure ( ancestor )  )  { compiler.report ( JSError.make ( t, n, CONDITIONAL_ID_GENERATOR_CALL )  ) ; return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^90^^^^^65^94^[REPLACE] String nextName = nameGenerator.generateNextName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^parent.replaceChild ( parent, Node.newString ( nextName )  ) ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^parent.replaceChild ( n, Node.replaceChild ( callName )  ) ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^compiler.report (  ) ;^93^^^^^65^94^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( n.getType (  )   ==  Token.CALL )  {^66^^^^^65^94^[REPLACE] if  ( n.getType (  )  != Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^String callName = n.getType (  ) .getQualifiedName (  ) ;^70^^^^^65^94^[REPLACE] String callName = n.getFirstChild (  ) .getQualifiedName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( nextName ) ;^71^^^^^65^94^[REPLACE] NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^71^^^^^65^94^[ADD] NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( nameGenerator != null )  {^72^^^^^65^94^[REPLACE] if  ( nameGenerator == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( t.inGlobalScope (  )  )  {^76^^^^^65^94^[REPLACE] if  ( !t.inGlobalScope (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^76^77^78^79^80^65^94^[ADD] if  ( !t.inGlobalScope (  )  )  {  compiler.report ( JSError.make ( t, n, NON_GLOBAL_ID_GENERATOR_CALL )  ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( !t.inGlobalScope (  )  )  {^83^^^^^65^94^[REPLACE] if  ( NodeUtil.isControlStructure ( ancestor )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^for  ( Node ancestor : n.getAncestors (  )  )  { if  ( NodeUtil.isControlStructure ( ancestor )  )  {^82^^^^^65^94^[REPLACE] for  ( Node ancestor : n.getAncestors (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^90^^^^^65^94^[REPLACE] String nextName = nameGenerator.generateNextName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^90^^^^^65^94^[ADD] String nextName = nameGenerator.generateNextName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^parent.replaceChild ( n, Node.newString ( callName )  ) ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^91^^^^^65^94^[ADD] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^compiler .report (  )  ;^93^^^^^65^94^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REMOVE]^String callName = n.getFirstChild (  ) .getQualifiedName (  ) ;^93^^^^^65^94^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
