[REPLACE]^private  final Map<DiagnosticType, DiagnosticGroup> singletons = Maps.newHashMap (  ) ;^53^54^^^^53^54^[REPLACE] private static final Map<DiagnosticType, DiagnosticGroup> singletons = Maps.newHashMap (  ) ;^ [CLASS] DiagnosticGroup  
[REPLACE]^this.types =  ImmutableSet.copyOf ( Arrays.asList ( null )  ) ;^42^^^^^41^43^[REPLACE] this.types = ImmutableSet.copyOf ( Arrays.asList ( types )  ) ;^[METHOD] <init> [TYPE] DiagnosticType[]) [PARAMETER]  types [CLASS] DiagnosticGroup   [TYPE]  Set types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType[] types 
[REPLACE]^this.types = ImmutableSet.copyOf ( set ) ; ;^49^^^^^48^50^[REPLACE] this.types = ImmutableSet.of ( type ) ;^[METHOD] <init> [TYPE] DiagnosticType) [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[ADD]^^49^^^^^48^50^[ADD] this.types = ImmutableSet.of ( type ) ;^[METHOD] <init> [TYPE] DiagnosticType) [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REPLACE]^for  ( DiagnosticType type : group.types )  { if  ( !matches ( type )  )  {^68^^^^^67^75^[REPLACE] Set<DiagnosticType> set = Sets.newHashSet (  ) ;^[METHOD] <init> [TYPE] DiagnosticGroup[]) [PARAMETER]  groups [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticGroup[] groups 
[REPLACE]^for  ( DiagnosticType type : group.types )  { if  ( !matches ( type )  )  {^70^^^^^67^75^[REPLACE] for  ( DiagnosticGroup group : groups )  {^[METHOD] <init> [TYPE] DiagnosticGroup[]) [PARAMETER]  groups [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticGroup[] groups 
[REPLACE]^this.types = ImmutableSet.of ( type ) ; ;^74^^^^^67^75^[REPLACE] this.types = ImmutableSet.copyOf ( set ) ;^[METHOD] <init> [TYPE] DiagnosticGroup[]) [PARAMETER]  groups [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticGroup[] groups 
[REPLACE]^if  ( singletons.containsKey ( type )  )  {^58^^^^^57^62^[REPLACE] if  ( !singletons.containsKey ( type )  )  {^[METHOD] forType [TYPE] DiagnosticGroup [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REPLACE]^this.types = ImmutableSet.of ( type ) ;^59^^^^^57^62^[REPLACE] singletons.put ( type, new DiagnosticGroup ( type )  ) ;^[METHOD] forType [TYPE] DiagnosticGroup [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REMOVE]^Set<DiagnosticType> set = Sets.newHashSet (  ) ;^59^^^^^57^62^[REMOVE] ^[METHOD] forType [TYPE] DiagnosticGroup [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REPLACE]^return singletons.containsKey ( type ) ;^61^^^^^57^62^[REPLACE] return singletons.get ( type ) ;^[METHOD] forType [TYPE] DiagnosticGroup [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REPLACE]^return singletons.get ( type ) ;^82^^^^^81^83^[REPLACE] return matches ( error.getType (  )  ) ;^[METHOD] matches [TYPE] boolean [PARAMETER] JSError error [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  JSError error 
[REPLACE]^return types .addAll ( false )  ;^89^^^^^88^90^[REPLACE] return types.contains ( type ) ;^[METHOD] matches [TYPE] boolean [PARAMETER] DiagnosticType type [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticType type 
[REPLACE]^if  ( matches ( type )  )  {^97^^^^^95^102^[REPLACE] if  ( !matches ( type )  )  {^[METHOD] isSubGroup [TYPE] boolean [PARAMETER] DiagnosticGroup group [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticType type 
[REPLACE]^return true;^98^^^^^95^102^[REPLACE] return false;^[METHOD] isSubGroup [TYPE] boolean [PARAMETER] DiagnosticGroup group [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticType type 
[REPLACE]^Set<DiagnosticType> set = Sets.newHashSet (  ) ;^96^^^^^95^102^[REPLACE] for  ( DiagnosticType type : group.types )  {^[METHOD] isSubGroup [TYPE] boolean [PARAMETER] DiagnosticGroup group [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticType type 
[REPLACE]^return false;^101^^^^^95^102^[REPLACE] return true;^[METHOD] isSubGroup [TYPE] boolean [PARAMETER] DiagnosticGroup group [CLASS] DiagnosticGroup   [TYPE]  Set set  types  [TYPE]  boolean false  true  [TYPE]  Map singletons  [TYPE]  DiagnosticGroup group  [TYPE]  DiagnosticType type 
[REPLACE]^return singletons.get ( type ) ;^108^^^^^107^109^[REPLACE] return types;^[METHOD] getTypes [TYPE] Collection [PARAMETER] [CLASS] DiagnosticGroup   [TYPE]  Map singletons  [TYPE]  Set set  types  [TYPE]  boolean false  true 
